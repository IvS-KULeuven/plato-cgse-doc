== The GlobalState

* Why would we want a global state?
* They always tell me that we should not use global variables!
* What is in the `GlobalState`?
* What can we do with the `GlobalState`?


=== Singleton versus Shared State

From within several places in the code, we needed access to a certain state and act accordingly. One of these states is the `dry_run` which allows us to execute command sequences (test scripts) without actually sending instructions to the hardware, but just logging that the command would have been executed with its arguments. We could have gone with a singleton pattern, i.e. a class for which only one instance exists in your session, but a singleton is a difficult pattern to test and control. Another possible solution is to use a class for which all instances have a shared state. That means even if the class is instantiated multiple times, its state is the same for all those instances. This pattern is also known as the Borg pattern or the shared-state pattern.

The name `GlobalState` is maybe not such a good name as this class actually shares state between its instances, but this shared state is not global in the sense of a global variable. The objects can be instantiated from anywhere at anytime, which is what makes them globally available.


=== What is in the GlobalState?

==== The Setup

The complete configuration of the test setup. From the Setup you can access all devices that are known by the configuration manager, and you have access to calibration settings. The Setup is fully described in the API documentation of the class at `egse.setup`. The Setup that comes with the GlobalState is loaded from the Configuration Manager. Use the `GlobalState.load_setup()` to load the current Setup that is active on the Configuration Manager.

If you need to work with different Setups, `GlobalState` is not the right place to be. Load any Setup directly from the `Setup` class with the static methods `from_dict(my_dict)` or `from_yaml_file(filename)`.

==== Performing a Dry Run

At some point we need to check the test scripts that we write in order to see if the proper commands will be executed with their proper arguments. But we don't want the commands to be send to the mechanisms or controllers. We want to do a dry run where the script is executed as normal, but no instructions are sent to any device.

==== Retrieve the Command Sequence

Whenever a building block is executed, a command sequence is generated and stored in the `GlobalState`. There are two functions that access this command sequence: (1) the `execute()` function will copy the command sequence into the test dataset, and (2) the `generate_command_sequence()` will return the command sequence as a list (TODO: this will probably get its own class eventually).

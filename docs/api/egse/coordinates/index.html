<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.coordinates API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.coordinates</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import ast
import logging
import re
from math import atan
from math import atan2
from math import cos
from math import degrees
from math import pow
from math import radians
from math import sin
from math import sqrt
from math import tan
from typing import Dict
from typing import List
from typing import Optional
from typing import Union

import numpy as np
from numpy.polynomial import Polynomial

from egse.coordinates.referenceFrame import ReferenceFrame
from egse.settings import Settings
from egse.state import GlobalState
from egse.setup import NavigableDict, load_setup, Setup

logger = logging.getLogger(__name__)

FOV_SETTINGS = Settings.load(&#34;Field-Of-View&#34;)
CCD_SETTINGS = Settings.load(&#34;CCD&#34;)


def undistorted_to_distorted_focal_plane_coordinates(
    x_undistorted, y_undistorted, distortion_coefficients, focal_length
):
    &#34;&#34;&#34;
    Conversion from undistorted to distorted focal-plane coordinates.  The distortion is a
    radial effect and is defined as the difference in radial distance to the optical axis
    between the distorted and undistorted coordinates, and can be expressed in terms of the
    undistorted radial distance r as follows:

        Δr = r * [(k1 * r**2) + (k2 * r**4) + (k3 * r**6)],

    where the distortion and r are expressed in normalised focal-plane coordinates (i.e. divided
    by the focal length, expressed in the same unit), and (k1, k2, k3) are the distortion
    coefficients.

    Args:
        x_undistorted: Undistorted x-coordinate on the focal plane [mm].
        y_undistorted: Undistorted y-coordinate on the focal plane [mm].
        distortion_coefficients: List of polynomial coefficients for the field distortion.
        focal_length: Focal length [mm].
    Returns:
        x_distorted: Distorted x-coordinate on the focal plane [mm].
        y_distorted: Distorted y-coordinate on the focal plane [mm].
    &#34;&#34;&#34;

    # Distortion coefficients -&gt; (0, 0, 0, k1, 0, k2, 0, k3)

    coefficients = [
        0,
        0,
        0,
        distortion_coefficients[0],
        0,
        distortion_coefficients[1],
        0,
        distortion_coefficients[2],
    ]
    distortion_polynomial = Polynomial(coefficients)

    # Position on the focal plane:
    #   - field angle [radians]
    #   - radial distance from the optical axis [normalised pixels]

    angle = atan2(y_undistorted, x_undistorted)
    distance_undistorted = sqrt(pow(x_undistorted, 2) + pow(y_undistorted, 2)) / focal_length

    # Distortion [mm]
    # Source moves away from the optical axis (radially)

    distortion = distortion_polynomial(distance_undistorted) * focal_length

    # The field angle remains the same

    x_distorted = x_undistorted + cos(angle) * distortion
    y_distorted = y_undistorted + sin(angle) * distortion

    return x_distorted, y_distorted


def distorted_to_undistorted_focal_plane_coordinates(
    x_distorted, y_distorted, inverse_distortion_coefficients, focal_length
):
    &#34;&#34;&#34;
    Conversion from distorted to undistorted focal-plane coordinates.  The inverse distortion is a
    radial effect and is defined as the difference in radial distance to the optical axis
    between the distorted and undistorted coordinates, and can be expressed in terms of the
    undistorted radial distance r as follows:

        Δr = r * [(k1 * r**2) + (k2 * r**4) + (k3 * r**6)],

    where the inverse distortion and r are expressed in normalised focal-plane coordinates (i.e. divided
    by the focal length, expressed in the same unit), and (k1, k2, k3) are the inverse distortion
    coefficients.

    Args:
        x_distorted: Distorted x-coordinate on the focal plane [mm].
        y_distorted: Distorted y-coordinate on the focal plane [mm].
        inverse_distortion_coefficients: List of polynomial coefficients for the inverse field distortion.
        focal_length: Focal length [mm].
    Returns:
        x_undistorted: Undistorted x-coordinate on the focal plane [mm].
        y_undistorted: Undistorted y-coordinate on the focal plane [mm].
    &#34;&#34;&#34;

    # Inverse distortion coefficients -&gt; (0, 0, 0, k1, 0, k2, 0, k3)

    coefficients = [
        0,
        0,
        0,
        inverse_distortion_coefficients[0],
        0,
        inverse_distortion_coefficients[1],
        0,
        inverse_distortion_coefficients[2],
    ]
    inverse_distortion_polynomial = Polynomial(coefficients)

    # Position on the focal plane:
    #   - field angle [radians]
    #   - radial distance from the optical axis [normalised pixels]

    angle = atan2(y_distorted, x_distorted)
    distance_distorted = sqrt(pow(x_distorted, 2) + pow(y_distorted, 2)) / focal_length

    # Inverse distortion [mm]
    # Source moves towards the optical axis (radially) -&gt; negative!

    inverse_distortion = inverse_distortion_polynomial(distance_distorted) * focal_length

    # The field angle remains the same

    x_undistorted = x_distorted + cos(angle) * inverse_distortion
    y_undistorted = y_distorted + sin(angle) * inverse_distortion

    return x_undistorted, y_undistorted


def focal_plane_to_ccd_coordinates(x_fp, y_fp, setup: Setup = None):
    &#34;&#34;&#34;
    Conversion from focal-plane to pixel coordinates on the appropriate CCD.

    Args:
        x_fp: Focal-plane x-coordinate [mm].
        y_fp: Focal-plane y-coordinate [mm].
        setup: Setup
    Returns:
        Pixel coordinates (row, column) and the corresponding CCD.  If the given
        focal-plane coordinates do not fall on any CCD, (None, None, None) is
        returned.
    &#34;&#34;&#34;

    if setup is None:
        setup = load_setup()

    if setup is not None:
        num_rows = setup.camera.ccd.num_rows
        num_cols = setup.camera.ccd.num_column
    else:
        num_rows = CCD_SETTINGS.NUM_ROWS
        num_cols = CCD_SETTINGS.NUM_COLUMNS

    for ccd_code in range(1, 5):

        (row, column) = __focal_plane_to_ccd_coordinates__(x_fp, y_fp, ccd_code)

        if (row &lt; 0) or (column &lt; 0):
            continue

        if (row &gt;= num_rows) or (column &gt;= num_cols):
                continue

        return row, column, ccd_code

    return None, None, None


def __focal_plane_to_ccd_coordinates__(x_fp, y_fp, ccd_code):
    &#34;&#34;&#34;
    Conversion from focal-plane coordinates to pixel coordinates on the given CCD.

    Args:
        x_fp: Focal-plane x-coordinate [mm].
        y_fp: Focal-plane y-coordinate [mm].
        ccd_code: Code of the CCD for which to calculate the pixel coordinates [1, 2, 3, 4].
    Returns:
        Pixel coordinates (row, column) on the given CCD.
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        ccd_orientation = setup.camera.ccd.orientation[int(ccd_code) - 1]
        pixel_size      = setup.camera.ccd.pixel_size / 1000.0  # [mm]
        ccd_origin_x    = GlobalState.setup.camera.ccd.origin_offset_x[int(ccd_code) - 1]
        ccd_origin_y    = GlobalState.setup.camera.ccd.origin_offset_y[int(ccd_code) - 1]
    else:
        ccd_orientation = CCD_SETTINGS.ORIENTATION[int(ccd_code) - 1]
        pixel_size      = CCD_SETTINGS.PIXEL_SIZE / 1000  # Pixel size [mm]
        ccd_origin_x    = CCD_SETTINGS.ZEROPOINT[0]
        ccd_origin_y    = CCD_SETTINGS.ZEROPOINT[1]

    ccd_angle = radians(ccd_orientation)

    # CCD coordinates [mm]

    row    = ccd_origin_y - x_fp * sin(ccd_angle) + y_fp * cos(ccd_angle)
    column = ccd_origin_x + x_fp * cos(ccd_angle) + y_fp * sin(ccd_angle)

    row /= pixel_size
    column /= pixel_size

    return row, column


def focal_plane_coordinates_to_angles(x_fp, y_fp):
    &#34;&#34;&#34;
    Conversion from focal-plane coordinates to the gnomonic distance from the optical axis and
    the in-field angle.

    Args:
        x_fp: Focal-plane x-coordinate [mm].
        y_fp: Focal-plane y-coordinate [mm].
    Returns:
        Gnomonic distance from the optical axis and in-field angle [degrees].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        focal_length_mm = GlobalState.setup.camera.fov.focal_length_mm
    else:
        focal_length_mm = FOV_SETTINGS.FOCAL_LENGTH

    theta = degrees(atan(sqrt(pow(x_fp, 2) + pow(y_fp, 2)) / focal_length_mm))
    phi = degrees(atan2(y_fp, x_fp))

    return theta, phi


def ccd_to_focal_plane_coordinates(row, column, ccd_code):
    &#34;&#34;&#34;
    Conversion from pixel-coordinates on the given CCD to focal-plane coordinates.

    Args:
        row: Row coordinate [pixels].
        column: Column coordinate [pixels].
        ccd_code: Code of the CCD for which the pixel coordinates are given.
    Returns:
        Focal-plane coordinates (x, y) [mm].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        ccd_orientation = setup.camera.ccd.orientation[int(ccd_code) - 1]
        pixel_size_mm   = setup.camera.ccd.pixel_size / 1000.0  # [mm]
        ccd_origin_x    = GlobalState.setup.camera.ccd.origin_offset_x[int(ccd_code) - 1]
        ccd_origin_y    = GlobalState.setup.camera.ccd.origin_offset_y[int(ccd_code) - 1]
    else:
        ccd_orientation = CCD_SETTINGS.ORIENTATION[int(ccd_code) - 1]
        pixel_size_mm   = CCD_SETTINGS.PIXEL_SIZE / 1000  # Pixel size [mm]
        ccd_origin_x    = CCD_SETTINGS.ZEROPOINT[0]
        ccd_origin_y    = CCD_SETTINGS.ZEROPOINT[1]

    # Convert the pixel coordinates into [mm] coordinates

    row_mm = row * pixel_size_mm
    column_mm = column * pixel_size_mm

    # Convert the CCD coordinates into FP coordinates [mm]

    ccd_angle = radians(ccd_orientation)

    x_fp = (column_mm - ccd_origin_x) * cos(ccd_angle) - (row_mm - ccd_origin_y) * sin(ccd_angle)
    y_fp = (column_mm - ccd_origin_x) * sin(ccd_angle) + (row_mm - ccd_origin_y) * cos(ccd_angle)

    # That&#39;s it

    return x_fp, y_fp

def angles_to_focal_plane_coordinates(theta, phi):
    &#34;&#34;&#34;
    Conversion from the gnomonic distance from the optical axis and
    the in-field angle to focal-plane coordinates.

    Args:
        theta: Gnomonic distance from the optical axis [degrees].
        phi: In-field angle [degrees].
    Returns:
        Focal-plane coordinates (x, y) [mm].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        focal_length_mm = GlobalState.setup.camera.fov.focal_length_mm
    else:
        focal_length_mm = FOV_SETTINGS.FOCAL_LENGTH

    distance = focal_length_mm * tan(radians(theta))  # [mm]

    phi_radians = radians(phi)

    x_fp = distance * cos(phi_radians)
    y_fp = distance * sin(phi_radians)

    return x_fp, y_fp


def dict_to_ref_model(model_def: Union[Dict, List]) -&gt; NavigableDict:
    &#34;&#34;&#34;
    Creates a reference frames model from a dictionary or list of reference frame definitions.

    When a list is provided, the items in the list must be ReferenceFrames.

    The reference frame definitions are usually read from a YAML file or returned by a Setup,
    but can also be just ReferenceFrame objects.

    ReferenceFrame definitions have the following format:

    ```
    ReferenceFrame://(&lt;definition&gt;)
    ```
    where `&lt;definition&gt;` has the following elements, separated by &#39;` | `&#39;:
    * a translation matrix
    * a rotation matrix
    * the name of the reference frame
    * the name of the reference for this reference frame
    * a dictionary of links

    Args:
        model_def (dict or list): the definition of the reference model

    Returns:
        A dictionary representing the reference frames model.
    &#34;&#34;&#34;

    ref_model = NavigableDict({})
    ref_links = {}

    def create_ref_frame(name, data) -&gt; Union[ReferenceFrame, str]:

        # This is a recursive function that creates a reference frame based on the given data.
        # * When the data is already a ReferenceFrame, it just returns data
        # * When data starts with the special string `ReferenceFrame//`, the data string is parsed
        #   and a corresponding ReferenceFrame is returned
        # * When there is no match, the data is returned unaltered.
        #
        # SIDE EFFECT:
        # * In the process, the outer ref-model and ref_links are updated.

        if isinstance(data, ReferenceFrame):
            return data

        match = re.match(r&#34;ReferenceFrame//\((.*)\)$&#34;, data)
        if not match:
            return data

        translation, rotation, name, ref_name, links = match[1].split(&#34; | &#34;)

        # all links are processed later..

        ref_links[name] = ast.literal_eval(links)

        if ref_name == name == &#34;Master&#34;:
            ref_model.add(ref_name, ReferenceFrame.createMaster())
            return ref_model[&#34;Master&#34;]

        if ref_name not in ref_model:
            ref_model.add(ref_name, create_ref_frame(ref_name, model_def[ref_name]))

        ref_frame = ReferenceFrame.fromTranslationRotation(
            deserialize_array(translation),
            deserialize_array(rotation),
            name=name,
            ref=ref_model[ref_name],
        )

        return ref_frame

    # if the given model_def is a list, turn it into a dict

    if isinstance(model_def, list):
        model_def = {frame.name: frame for frame in model_def}

    for key, value in model_def.items():
        if key not in ref_model:
            ref_model.add(key, create_ref_frame(key, value))

    # Process all the links

    for ref_name, link_names in ref_links.items():
        ref = ref_model[ref_name]
        for link_name in link_names:
            if link_name not in ref.linkedTo:
                ref.addLink(ref_model[link_name])

    return ref_model


def ref_model_to_dict(ref_model) -&gt; NavigableDict:
    &#34;&#34;&#34;Creates a dictionary with reference frames definitions that define a reference model.

    Args:
        ref_model: A dictionary representing the reference frames model or a list of reference
            frames.
    Returns:
        A dictionary of reference frame definitions.
    &#34;&#34;&#34;

    if isinstance(ref_model, dict):
        ref_model = ref_model.values()

    # take each key (which is a reference frame) and serialize it

    model_def = {}

    for ref in ref_model:
        translation, rotation = ref.getTranslationRotationVectors()
        links = [ref.name for ref in ref.linkedTo]
        model_def[ref.name] = (
            f&#34;ReferenceFrame//(&#34;
            f&#34;{serialize_array(translation, precision=6)} | &#34;
            f&#34;{serialize_array(rotation, precision=6)} | &#34;
            f&#34;{ref.name} | &#34;
            f&#34;{ref.ref.name} | &#34;
            f&#34;{links})&#34;
        )

    return NavigableDict(model_def)


def serialize_array(arr: Union[np.ndarray, list], precision: int = 4) -&gt; str:
    &#34;&#34;&#34;Returns a string representation of a numpy array.

    &gt;&gt;&gt; serialize_array([1,2,3])
    &#39;[1, 2, 3]&#39;
    &gt;&gt;&gt; serialize_array([[1,2,3], [4,5,6]])
    &#39;[[1, 2, 3], [4, 5, 6]]&#39;
    &gt;&gt;&gt; serialize_array([[1,2.2,3], [4.3,5,6]])
    &#39;[[1.0000, 2.2000, 3.0000], [4.3000, 5.0000, 6.0000]]&#39;
    &gt;&gt;&gt; serialize_array([[1,2.2,3], [4.3,5,6]], precision=2)
    &#39;[[1.00, 2.20, 3.00], [4.30, 5.00, 6.00]]&#39;

    Args:
        arr: a one or two dimensional numpy array or list.
        precision (int): number of digits of precision
    Returns:
        A string representing the input array.
    &#34;&#34;&#34;
    if isinstance(arr, list):
        arr = np.array(arr)
    msg = np.array2string(
        arr,
        separator=&#34;, &#34;,
        suppress_small=True,
        formatter={&#34;float_kind&#34;: lambda x: f&#34;{x:.{precision}f}&#34;},
    ).replace(&#34;\n&#34;, &#34;&#34;)
    return msg


def deserialize_array(arr_str: str) -&gt; Optional[np.ndarray]:
    &#34;&#34;&#34;Returns a numpy array from the given string.

    The input string is interpreted as a one or two-dimensional array, with commas or spaces
    separating the columns, and semi-colons separating the rows.

    &gt;&gt;&gt; deserialize_array(&#39;1,2,3&#39;)
    array([1, 2, 3])
    &gt;&gt;&gt; deserialize_array(&#39;1 2 3&#39;)
    array([1, 2, 3])
    &gt;&gt;&gt; deserialize_array(&#39;1,2,3;4,5,6&#39;)
    array([[1, 2, 3],
           [4, 5, 6]])
    &gt;&gt;&gt; deserialize_array(&#34;[[1,2,3], [4,5,6]]&#34;)
    array([[1, 2, 3],
           [4, 5, 6]])

    Args:
        arr_str: string representation of a numpy array
    Returns:
        A one or two-dimensional numpy array or `None` when input string cannot be parsed into a
        numpy array.
    &#34;&#34;&#34;

    import re

    arr_str = re.sub(r&#34;\],\s*\[&#34;, &#34;];[&#34;, arr_str)
    try:
        arr = np.array(_convert_from_string(arr_str))
        return arr if &#34;;&#34; in arr_str else arr.flatten()
    except ValueError as exc:
        logger.error(f&#34;Input string could not be parsed into a numpy array: {exc}&#34;)
    return None


def _convert_from_string(data):

    # This function was copied from:
    #   https://github.com/numpy/numpy/blob/v1.19.0/numpy/matrixlib/defmatrix.py#L14
    # We include the function here because the np.matrix class is deprecated and will be removed.
    # This function is what we actually needed from np.matrix.

    for char in &#34;[]&#34;:
        data = data.replace(char, &#34;&#34;)

    rows = data.split(&#34;;&#34;)
    new_data = []
    count = 0
    for row in rows:
        trow = row.split(&#34;,&#34;)
        new_row = []
        for col in trow:
            temp = col.split()
            new_row.extend(map(ast.literal_eval, temp))
        if count == 0:
            n_cols = len(new_row)
        elif len(new_row) != n_cols:
            raise ValueError(&#34;Rows not the same size.&#34;)
        count += 1
        new_data.append(new_row)
    return new_data</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="egse.coordinates.avoidance" href="avoidance.html">egse.coordinates.avoidance</a></code></dt>
<dd>
<div class="desc"><p>Created on Wed Sep
9 17:19:47 2020 …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.cslmodel" href="cslmodel.html">egse.coordinates.cslmodel</a></code></dt>
<dd>
<div class="desc"><p>A CSL reference frame model which has knowledge about the CSL Setup, and the PUNA Hexapod model …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.laser_tracker_to_dict" href="laser_tracker_to_dict.html">egse.coordinates.laser_tracker_to_dict</a></code></dt>
<dd>
<div class="desc"><p>Created on Sat Oct
3 11:53:23 2020 …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.point" href="point.html">egse.coordinates.point</a></code></dt>
<dd>
<div class="desc"><p>The point module provides two classes, a <code>Point</code> class which simply represents a point
in the 3D space, and a <code>Points</code> class which is a collection of …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.pyplot" href="pyplot.html">egse.coordinates.pyplot</a></code></dt>
<dd>
<div class="desc"><p>This module defines some plotting functions for Reference Frames …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.referenceFrame" href="referenceFrame.html">egse.coordinates.referenceFrame</a></code></dt>
<dd>
<div class="desc"><p>The referenceFrames module provides the class :code:<code>ReferenceFrames</code> which defines the affine transformation
for bringing one reference frame to …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.refmodel" href="refmodel.html">egse.coordinates.refmodel</a></code></dt>
<dd>
<div class="desc"><p>The Reference Frame Model is a self-consistent graph of reference frames that are connected by
reference and/or by explicit links …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.rotationMatrix" href="rotationMatrix.html">egse.coordinates.rotationMatrix</a></code></dt>
<dd>
<div class="desc"><p>The RotationMatrix provides a number of convenience methods to define and apply rotations …</p></div>
</dd>
<dt><code class="name"><a title="egse.coordinates.transform3d_addon" href="transform3d_addon.html">egse.coordinates.transform3d_addon</a></code></dt>
<dd>
<div class="desc"><p>Created on Mon Jun 25 16:25:33 2018 …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.coordinates.angles_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">angles_to_focal_plane_coordinates</span></span>(<span>theta, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion from the gnomonic distance from the optical axis and
the in-field angle to focal-plane coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta</code></strong></dt>
<dd>Gnomonic distance from the optical axis [degrees].</dd>
<dt><strong><code>phi</code></strong></dt>
<dd>In-field angle [degrees].</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Focal-plane coordinates (x, y) [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angles_to_focal_plane_coordinates(theta, phi):
    &#34;&#34;&#34;
    Conversion from the gnomonic distance from the optical axis and
    the in-field angle to focal-plane coordinates.

    Args:
        theta: Gnomonic distance from the optical axis [degrees].
        phi: In-field angle [degrees].
    Returns:
        Focal-plane coordinates (x, y) [mm].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        focal_length_mm = GlobalState.setup.camera.fov.focal_length_mm
    else:
        focal_length_mm = FOV_SETTINGS.FOCAL_LENGTH

    distance = focal_length_mm * tan(radians(theta))  # [mm]

    phi_radians = radians(phi)

    x_fp = distance * cos(phi_radians)
    y_fp = distance * sin(phi_radians)

    return x_fp, y_fp</code></pre>
</details>
</dd>
<dt id="egse.coordinates.ccd_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">ccd_to_focal_plane_coordinates</span></span>(<span>row, column, ccd_code)</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion from pixel-coordinates on the given CCD to focal-plane coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row</code></strong></dt>
<dd>Row coordinate [pixels].</dd>
<dt><strong><code>column</code></strong></dt>
<dd>Column coordinate [pixels].</dd>
<dt><strong><code>ccd_code</code></strong></dt>
<dd>Code of the CCD for which the pixel coordinates are given.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Focal-plane coordinates (x, y) [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ccd_to_focal_plane_coordinates(row, column, ccd_code):
    &#34;&#34;&#34;
    Conversion from pixel-coordinates on the given CCD to focal-plane coordinates.

    Args:
        row: Row coordinate [pixels].
        column: Column coordinate [pixels].
        ccd_code: Code of the CCD for which the pixel coordinates are given.
    Returns:
        Focal-plane coordinates (x, y) [mm].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        ccd_orientation = setup.camera.ccd.orientation[int(ccd_code) - 1]
        pixel_size_mm   = setup.camera.ccd.pixel_size / 1000.0  # [mm]
        ccd_origin_x    = GlobalState.setup.camera.ccd.origin_offset_x[int(ccd_code) - 1]
        ccd_origin_y    = GlobalState.setup.camera.ccd.origin_offset_y[int(ccd_code) - 1]
    else:
        ccd_orientation = CCD_SETTINGS.ORIENTATION[int(ccd_code) - 1]
        pixel_size_mm   = CCD_SETTINGS.PIXEL_SIZE / 1000  # Pixel size [mm]
        ccd_origin_x    = CCD_SETTINGS.ZEROPOINT[0]
        ccd_origin_y    = CCD_SETTINGS.ZEROPOINT[1]

    # Convert the pixel coordinates into [mm] coordinates

    row_mm = row * pixel_size_mm
    column_mm = column * pixel_size_mm

    # Convert the CCD coordinates into FP coordinates [mm]

    ccd_angle = radians(ccd_orientation)

    x_fp = (column_mm - ccd_origin_x) * cos(ccd_angle) - (row_mm - ccd_origin_y) * sin(ccd_angle)
    y_fp = (column_mm - ccd_origin_x) * sin(ccd_angle) + (row_mm - ccd_origin_y) * cos(ccd_angle)

    # That&#39;s it

    return x_fp, y_fp</code></pre>
</details>
</dd>
<dt id="egse.coordinates.deserialize_array"><code class="name flex">
<span>def <span class="ident">deserialize_array</span></span>(<span>arr_str: str) ‑> Optional[numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a numpy array from the given string.</p>
<p>The input string is interpreted as a one or two-dimensional array, with commas or spaces
separating the columns, and semi-colons separating the rows.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; deserialize_array('1,2,3')
array([1, 2, 3])
&gt;&gt;&gt; deserialize_array('1 2 3')
array([1, 2, 3])
&gt;&gt;&gt; deserialize_array('1,2,3;4,5,6')
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; deserialize_array(&quot;[[1,2,3], [4,5,6]]&quot;)
array([[1, 2, 3],
       [4, 5, 6]])
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr_str</code></strong></dt>
<dd>string representation of a numpy array</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A one or two-dimensional numpy array or <code>None</code> when input string cannot be parsed into a
numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize_array(arr_str: str) -&gt; Optional[np.ndarray]:
    &#34;&#34;&#34;Returns a numpy array from the given string.

    The input string is interpreted as a one or two-dimensional array, with commas or spaces
    separating the columns, and semi-colons separating the rows.

    &gt;&gt;&gt; deserialize_array(&#39;1,2,3&#39;)
    array([1, 2, 3])
    &gt;&gt;&gt; deserialize_array(&#39;1 2 3&#39;)
    array([1, 2, 3])
    &gt;&gt;&gt; deserialize_array(&#39;1,2,3;4,5,6&#39;)
    array([[1, 2, 3],
           [4, 5, 6]])
    &gt;&gt;&gt; deserialize_array(&#34;[[1,2,3], [4,5,6]]&#34;)
    array([[1, 2, 3],
           [4, 5, 6]])

    Args:
        arr_str: string representation of a numpy array
    Returns:
        A one or two-dimensional numpy array or `None` when input string cannot be parsed into a
        numpy array.
    &#34;&#34;&#34;

    import re

    arr_str = re.sub(r&#34;\],\s*\[&#34;, &#34;];[&#34;, arr_str)
    try:
        arr = np.array(_convert_from_string(arr_str))
        return arr if &#34;;&#34; in arr_str else arr.flatten()
    except ValueError as exc:
        logger.error(f&#34;Input string could not be parsed into a numpy array: {exc}&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="egse.coordinates.dict_to_ref_model"><code class="name flex">
<span>def <span class="ident">dict_to_ref_model</span></span>(<span>model_def: Union[Dict[~KT, ~VT], List[~T]]) ‑> egse.setup.NavigableDict</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a reference frames model from a dictionary or list of reference frame definitions.</p>
<p>When a list is provided, the items in the list must be ReferenceFrames.</p>
<p>The reference frame definitions are usually read from a YAML file or returned by a Setup,
but can also be just ReferenceFrame objects.</p>
<p>ReferenceFrame definitions have the following format:</p>
<pre><code>ReferenceFrame://(&lt;definition&gt;)
</code></pre>
<p>where <code>&lt;definition&gt;</code> has the following elements, separated by '<code>|</code>':
* a translation matrix
* a rotation matrix
* the name of the reference frame
* the name of the reference for this reference frame
* a dictionary of links</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_def</code></strong> :&ensp;<code>dict</code> or <code>list</code></dt>
<dd>the definition of the reference model</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary representing the reference frames model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict_to_ref_model(model_def: Union[Dict, List]) -&gt; NavigableDict:
    &#34;&#34;&#34;
    Creates a reference frames model from a dictionary or list of reference frame definitions.

    When a list is provided, the items in the list must be ReferenceFrames.

    The reference frame definitions are usually read from a YAML file or returned by a Setup,
    but can also be just ReferenceFrame objects.

    ReferenceFrame definitions have the following format:

    ```
    ReferenceFrame://(&lt;definition&gt;)
    ```
    where `&lt;definition&gt;` has the following elements, separated by &#39;` | `&#39;:
    * a translation matrix
    * a rotation matrix
    * the name of the reference frame
    * the name of the reference for this reference frame
    * a dictionary of links

    Args:
        model_def (dict or list): the definition of the reference model

    Returns:
        A dictionary representing the reference frames model.
    &#34;&#34;&#34;

    ref_model = NavigableDict({})
    ref_links = {}

    def create_ref_frame(name, data) -&gt; Union[ReferenceFrame, str]:

        # This is a recursive function that creates a reference frame based on the given data.
        # * When the data is already a ReferenceFrame, it just returns data
        # * When data starts with the special string `ReferenceFrame//`, the data string is parsed
        #   and a corresponding ReferenceFrame is returned
        # * When there is no match, the data is returned unaltered.
        #
        # SIDE EFFECT:
        # * In the process, the outer ref-model and ref_links are updated.

        if isinstance(data, ReferenceFrame):
            return data

        match = re.match(r&#34;ReferenceFrame//\((.*)\)$&#34;, data)
        if not match:
            return data

        translation, rotation, name, ref_name, links = match[1].split(&#34; | &#34;)

        # all links are processed later..

        ref_links[name] = ast.literal_eval(links)

        if ref_name == name == &#34;Master&#34;:
            ref_model.add(ref_name, ReferenceFrame.createMaster())
            return ref_model[&#34;Master&#34;]

        if ref_name not in ref_model:
            ref_model.add(ref_name, create_ref_frame(ref_name, model_def[ref_name]))

        ref_frame = ReferenceFrame.fromTranslationRotation(
            deserialize_array(translation),
            deserialize_array(rotation),
            name=name,
            ref=ref_model[ref_name],
        )

        return ref_frame

    # if the given model_def is a list, turn it into a dict

    if isinstance(model_def, list):
        model_def = {frame.name: frame for frame in model_def}

    for key, value in model_def.items():
        if key not in ref_model:
            ref_model.add(key, create_ref_frame(key, value))

    # Process all the links

    for ref_name, link_names in ref_links.items():
        ref = ref_model[ref_name]
        for link_name in link_names:
            if link_name not in ref.linkedTo:
                ref.addLink(ref_model[link_name])

    return ref_model</code></pre>
</details>
</dd>
<dt id="egse.coordinates.distorted_to_undistorted_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">distorted_to_undistorted_focal_plane_coordinates</span></span>(<span>x_distorted, y_distorted, inverse_distortion_coefficients, focal_length)</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion from distorted to undistorted focal-plane coordinates.
The inverse distortion is a
radial effect and is defined as the difference in radial distance to the optical axis
between the distorted and undistorted coordinates, and can be expressed in terms of the
undistorted radial distance r as follows:</p>
<pre><code>Δr = r * [(k1 * r**2) + (k2 * r**4) + (k3 * r**6)],
</code></pre>
<p>where the inverse distortion and r are expressed in normalised focal-plane coordinates (i.e. divided
by the focal length, expressed in the same unit), and (k1, k2, k3) are the inverse distortion
coefficients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_distorted</code></strong></dt>
<dd>Distorted x-coordinate on the focal plane [mm].</dd>
<dt><strong><code>y_distorted</code></strong></dt>
<dd>Distorted y-coordinate on the focal plane [mm].</dd>
<dt><strong><code>inverse_distortion_coefficients</code></strong></dt>
<dd>List of polynomial coefficients for the inverse field distortion.</dd>
<dt><strong><code>focal_length</code></strong></dt>
<dd>Focal length [mm].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x_undistorted</code></dt>
<dd>Undistorted x-coordinate on the focal plane [mm].</dd>
<dt><code>y_undistorted</code></dt>
<dd>Undistorted y-coordinate on the focal plane [mm].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distorted_to_undistorted_focal_plane_coordinates(
    x_distorted, y_distorted, inverse_distortion_coefficients, focal_length
):
    &#34;&#34;&#34;
    Conversion from distorted to undistorted focal-plane coordinates.  The inverse distortion is a
    radial effect and is defined as the difference in radial distance to the optical axis
    between the distorted and undistorted coordinates, and can be expressed in terms of the
    undistorted radial distance r as follows:

        Δr = r * [(k1 * r**2) + (k2 * r**4) + (k3 * r**6)],

    where the inverse distortion and r are expressed in normalised focal-plane coordinates (i.e. divided
    by the focal length, expressed in the same unit), and (k1, k2, k3) are the inverse distortion
    coefficients.

    Args:
        x_distorted: Distorted x-coordinate on the focal plane [mm].
        y_distorted: Distorted y-coordinate on the focal plane [mm].
        inverse_distortion_coefficients: List of polynomial coefficients for the inverse field distortion.
        focal_length: Focal length [mm].
    Returns:
        x_undistorted: Undistorted x-coordinate on the focal plane [mm].
        y_undistorted: Undistorted y-coordinate on the focal plane [mm].
    &#34;&#34;&#34;

    # Inverse distortion coefficients -&gt; (0, 0, 0, k1, 0, k2, 0, k3)

    coefficients = [
        0,
        0,
        0,
        inverse_distortion_coefficients[0],
        0,
        inverse_distortion_coefficients[1],
        0,
        inverse_distortion_coefficients[2],
    ]
    inverse_distortion_polynomial = Polynomial(coefficients)

    # Position on the focal plane:
    #   - field angle [radians]
    #   - radial distance from the optical axis [normalised pixels]

    angle = atan2(y_distorted, x_distorted)
    distance_distorted = sqrt(pow(x_distorted, 2) + pow(y_distorted, 2)) / focal_length

    # Inverse distortion [mm]
    # Source moves towards the optical axis (radially) -&gt; negative!

    inverse_distortion = inverse_distortion_polynomial(distance_distorted) * focal_length

    # The field angle remains the same

    x_undistorted = x_distorted + cos(angle) * inverse_distortion
    y_undistorted = y_distorted + sin(angle) * inverse_distortion

    return x_undistorted, y_undistorted</code></pre>
</details>
</dd>
<dt id="egse.coordinates.focal_plane_coordinates_to_angles"><code class="name flex">
<span>def <span class="ident">focal_plane_coordinates_to_angles</span></span>(<span>x_fp, y_fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion from focal-plane coordinates to the gnomonic distance from the optical axis and
the in-field angle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_fp</code></strong></dt>
<dd>Focal-plane x-coordinate [mm].</dd>
<dt><strong><code>y_fp</code></strong></dt>
<dd>Focal-plane y-coordinate [mm].</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Gnomonic distance from the optical axis and in-field angle [degrees].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focal_plane_coordinates_to_angles(x_fp, y_fp):
    &#34;&#34;&#34;
    Conversion from focal-plane coordinates to the gnomonic distance from the optical axis and
    the in-field angle.

    Args:
        x_fp: Focal-plane x-coordinate [mm].
        y_fp: Focal-plane y-coordinate [mm].
    Returns:
        Gnomonic distance from the optical axis and in-field angle [degrees].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    if setup is not None:
        focal_length_mm = GlobalState.setup.camera.fov.focal_length_mm
    else:
        focal_length_mm = FOV_SETTINGS.FOCAL_LENGTH

    theta = degrees(atan(sqrt(pow(x_fp, 2) + pow(y_fp, 2)) / focal_length_mm))
    phi = degrees(atan2(y_fp, x_fp))

    return theta, phi</code></pre>
</details>
</dd>
<dt id="egse.coordinates.focal_plane_to_ccd_coordinates"><code class="name flex">
<span>def <span class="ident">focal_plane_to_ccd_coordinates</span></span>(<span>x_fp, y_fp, setup: <a title="egse.setup.Setup" href="../setup.html#egse.setup.Setup">Setup</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion from focal-plane to pixel coordinates on the appropriate CCD.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_fp</code></strong></dt>
<dd>Focal-plane x-coordinate [mm].</dd>
<dt><strong><code>y_fp</code></strong></dt>
<dd>Focal-plane y-coordinate [mm].</dd>
<dt><strong><code>setup</code></strong></dt>
<dd>Setup</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Pixel coordinates (row, column) and the corresponding CCD.
If the given
focal-plane coordinates do not fall on any CCD, (None, None, None) is
returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focal_plane_to_ccd_coordinates(x_fp, y_fp, setup: Setup = None):
    &#34;&#34;&#34;
    Conversion from focal-plane to pixel coordinates on the appropriate CCD.

    Args:
        x_fp: Focal-plane x-coordinate [mm].
        y_fp: Focal-plane y-coordinate [mm].
        setup: Setup
    Returns:
        Pixel coordinates (row, column) and the corresponding CCD.  If the given
        focal-plane coordinates do not fall on any CCD, (None, None, None) is
        returned.
    &#34;&#34;&#34;

    if setup is None:
        setup = load_setup()

    if setup is not None:
        num_rows = setup.camera.ccd.num_rows
        num_cols = setup.camera.ccd.num_column
    else:
        num_rows = CCD_SETTINGS.NUM_ROWS
        num_cols = CCD_SETTINGS.NUM_COLUMNS

    for ccd_code in range(1, 5):

        (row, column) = __focal_plane_to_ccd_coordinates__(x_fp, y_fp, ccd_code)

        if (row &lt; 0) or (column &lt; 0):
            continue

        if (row &gt;= num_rows) or (column &gt;= num_cols):
                continue

        return row, column, ccd_code

    return None, None, None</code></pre>
</details>
</dd>
<dt id="egse.coordinates.ref_model_to_dict"><code class="name flex">
<span>def <span class="ident">ref_model_to_dict</span></span>(<span>ref_model) ‑> egse.setup.NavigableDict</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dictionary with reference frames definitions that define a reference model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ref_model</code></strong></dt>
<dd>A dictionary representing the reference frames model or a list of reference
frames.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary of reference frame definitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ref_model_to_dict(ref_model) -&gt; NavigableDict:
    &#34;&#34;&#34;Creates a dictionary with reference frames definitions that define a reference model.

    Args:
        ref_model: A dictionary representing the reference frames model or a list of reference
            frames.
    Returns:
        A dictionary of reference frame definitions.
    &#34;&#34;&#34;

    if isinstance(ref_model, dict):
        ref_model = ref_model.values()

    # take each key (which is a reference frame) and serialize it

    model_def = {}

    for ref in ref_model:
        translation, rotation = ref.getTranslationRotationVectors()
        links = [ref.name for ref in ref.linkedTo]
        model_def[ref.name] = (
            f&#34;ReferenceFrame//(&#34;
            f&#34;{serialize_array(translation, precision=6)} | &#34;
            f&#34;{serialize_array(rotation, precision=6)} | &#34;
            f&#34;{ref.name} | &#34;
            f&#34;{ref.ref.name} | &#34;
            f&#34;{links})&#34;
        )

    return NavigableDict(model_def)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.serialize_array"><code class="name flex">
<span>def <span class="ident">serialize_array</span></span>(<span>arr: Union[numpy.ndarray, list], precision: int = 4) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string representation of a numpy array.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; serialize_array([1,2,3])
'[1, 2, 3]'
&gt;&gt;&gt; serialize_array([[1,2,3], [4,5,6]])
'[[1, 2, 3], [4, 5, 6]]'
&gt;&gt;&gt; serialize_array([[1,2.2,3], [4.3,5,6]])
'[[1.0000, 2.2000, 3.0000], [4.3000, 5.0000, 6.0000]]'
&gt;&gt;&gt; serialize_array([[1,2.2,3], [4.3,5,6]], precision=2)
'[[1.00, 2.20, 3.00], [4.30, 5.00, 6.00]]'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong></dt>
<dd>a one or two dimensional numpy array or list.</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code></dt>
<dd>number of digits of precision</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string representing the input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_array(arr: Union[np.ndarray, list], precision: int = 4) -&gt; str:
    &#34;&#34;&#34;Returns a string representation of a numpy array.

    &gt;&gt;&gt; serialize_array([1,2,3])
    &#39;[1, 2, 3]&#39;
    &gt;&gt;&gt; serialize_array([[1,2,3], [4,5,6]])
    &#39;[[1, 2, 3], [4, 5, 6]]&#39;
    &gt;&gt;&gt; serialize_array([[1,2.2,3], [4.3,5,6]])
    &#39;[[1.0000, 2.2000, 3.0000], [4.3000, 5.0000, 6.0000]]&#39;
    &gt;&gt;&gt; serialize_array([[1,2.2,3], [4.3,5,6]], precision=2)
    &#39;[[1.00, 2.20, 3.00], [4.30, 5.00, 6.00]]&#39;

    Args:
        arr: a one or two dimensional numpy array or list.
        precision (int): number of digits of precision
    Returns:
        A string representing the input array.
    &#34;&#34;&#34;
    if isinstance(arr, list):
        arr = np.array(arr)
    msg = np.array2string(
        arr,
        separator=&#34;, &#34;,
        suppress_small=True,
        formatter={&#34;float_kind&#34;: lambda x: f&#34;{x:.{precision}f}&#34;},
    ).replace(&#34;\n&#34;, &#34;&#34;)
    return msg</code></pre>
</details>
</dd>
<dt id="egse.coordinates.undistorted_to_distorted_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">undistorted_to_distorted_focal_plane_coordinates</span></span>(<span>x_undistorted, y_undistorted, distortion_coefficients, focal_length)</span>
</code></dt>
<dd>
<div class="desc"><p>Conversion from undistorted to distorted focal-plane coordinates.
The distortion is a
radial effect and is defined as the difference in radial distance to the optical axis
between the distorted and undistorted coordinates, and can be expressed in terms of the
undistorted radial distance r as follows:</p>
<pre><code>Δr = r * [(k1 * r**2) + (k2 * r**4) + (k3 * r**6)],
</code></pre>
<p>where the distortion and r are expressed in normalised focal-plane coordinates (i.e. divided
by the focal length, expressed in the same unit), and (k1, k2, k3) are the distortion
coefficients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x_undistorted</code></strong></dt>
<dd>Undistorted x-coordinate on the focal plane [mm].</dd>
<dt><strong><code>y_undistorted</code></strong></dt>
<dd>Undistorted y-coordinate on the focal plane [mm].</dd>
<dt><strong><code>distortion_coefficients</code></strong></dt>
<dd>List of polynomial coefficients for the field distortion.</dd>
<dt><strong><code>focal_length</code></strong></dt>
<dd>Focal length [mm].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x_distorted</code></dt>
<dd>Distorted x-coordinate on the focal plane [mm].</dd>
<dt><code>y_distorted</code></dt>
<dd>Distorted y-coordinate on the focal plane [mm].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undistorted_to_distorted_focal_plane_coordinates(
    x_undistorted, y_undistorted, distortion_coefficients, focal_length
):
    &#34;&#34;&#34;
    Conversion from undistorted to distorted focal-plane coordinates.  The distortion is a
    radial effect and is defined as the difference in radial distance to the optical axis
    between the distorted and undistorted coordinates, and can be expressed in terms of the
    undistorted radial distance r as follows:

        Δr = r * [(k1 * r**2) + (k2 * r**4) + (k3 * r**6)],

    where the distortion and r are expressed in normalised focal-plane coordinates (i.e. divided
    by the focal length, expressed in the same unit), and (k1, k2, k3) are the distortion
    coefficients.

    Args:
        x_undistorted: Undistorted x-coordinate on the focal plane [mm].
        y_undistorted: Undistorted y-coordinate on the focal plane [mm].
        distortion_coefficients: List of polynomial coefficients for the field distortion.
        focal_length: Focal length [mm].
    Returns:
        x_distorted: Distorted x-coordinate on the focal plane [mm].
        y_distorted: Distorted y-coordinate on the focal plane [mm].
    &#34;&#34;&#34;

    # Distortion coefficients -&gt; (0, 0, 0, k1, 0, k2, 0, k3)

    coefficients = [
        0,
        0,
        0,
        distortion_coefficients[0],
        0,
        distortion_coefficients[1],
        0,
        distortion_coefficients[2],
    ]
    distortion_polynomial = Polynomial(coefficients)

    # Position on the focal plane:
    #   - field angle [radians]
    #   - radial distance from the optical axis [normalised pixels]

    angle = atan2(y_undistorted, x_undistorted)
    distance_undistorted = sqrt(pow(x_undistorted, 2) + pow(y_undistorted, 2)) / focal_length

    # Distortion [mm]
    # Source moves away from the optical axis (radially)

    distortion = distortion_polynomial(distance_undistorted) * focal_length

    # The field angle remains the same

    x_distorted = x_undistorted + cos(angle) * distortion
    y_distorted = y_undistorted + sin(angle) * distortion

    return x_distorted, y_distorted</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="../index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="egse.coordinates.avoidance" href="avoidance.html">egse.coordinates.avoidance</a></code></li>
<li><code><a title="egse.coordinates.cslmodel" href="cslmodel.html">egse.coordinates.cslmodel</a></code></li>
<li><code><a title="egse.coordinates.laser_tracker_to_dict" href="laser_tracker_to_dict.html">egse.coordinates.laser_tracker_to_dict</a></code></li>
<li><code><a title="egse.coordinates.point" href="point.html">egse.coordinates.point</a></code></li>
<li><code><a title="egse.coordinates.pyplot" href="pyplot.html">egse.coordinates.pyplot</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame" href="referenceFrame.html">egse.coordinates.referenceFrame</a></code></li>
<li><code><a title="egse.coordinates.refmodel" href="refmodel.html">egse.coordinates.refmodel</a></code></li>
<li><code><a title="egse.coordinates.rotationMatrix" href="rotationMatrix.html">egse.coordinates.rotationMatrix</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon" href="transform3d_addon.html">egse.coordinates.transform3d_addon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.coordinates.angles_to_focal_plane_coordinates" href="#egse.coordinates.angles_to_focal_plane_coordinates">angles_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.coordinates.ccd_to_focal_plane_coordinates" href="#egse.coordinates.ccd_to_focal_plane_coordinates">ccd_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.coordinates.deserialize_array" href="#egse.coordinates.deserialize_array">deserialize_array</a></code></li>
<li><code><a title="egse.coordinates.dict_to_ref_model" href="#egse.coordinates.dict_to_ref_model">dict_to_ref_model</a></code></li>
<li><code><a title="egse.coordinates.distorted_to_undistorted_focal_plane_coordinates" href="#egse.coordinates.distorted_to_undistorted_focal_plane_coordinates">distorted_to_undistorted_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.coordinates.focal_plane_coordinates_to_angles" href="#egse.coordinates.focal_plane_coordinates_to_angles">focal_plane_coordinates_to_angles</a></code></li>
<li><code><a title="egse.coordinates.focal_plane_to_ccd_coordinates" href="#egse.coordinates.focal_plane_to_ccd_coordinates">focal_plane_to_ccd_coordinates</a></code></li>
<li><code><a title="egse.coordinates.ref_model_to_dict" href="#egse.coordinates.ref_model_to_dict">ref_model_to_dict</a></code></li>
<li><code><a title="egse.coordinates.serialize_array" href="#egse.coordinates.serialize_array">serialize_array</a></code></li>
<li><code><a title="egse.coordinates.undistorted_to_distorted_focal_plane_coordinates" href="#egse.coordinates.undistorted_to_distorted_focal_plane_coordinates">undistorted_to_distorted_focal_plane_coordinates</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
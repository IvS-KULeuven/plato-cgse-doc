<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.coordinates.transform3d_addon API documentation</title>
<meta name="description" content="Created on Mon Jun 25 16:25:33 2018 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.coordinates.transform3d_addon</code></h1>
</header>
<section id="section-intro">
<p>Created on Mon Jun 25 16:25:33 2018</p>
<p>@author: pierre</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Mon Jun 25 16:25:33 2018

@author: pierre
&#34;&#34;&#34;
import numpy
import numpy as np
import math
import transforms3d as t3

from egse.coordinates.rotationMatrix import RotationMatrix

def affine_isEuclidian(matrix):
    &#34;&#34;&#34;
    Tests if a matrix is a pure solid-body euclidian rotation + translation (no shear or scaling)
    
    We only need to check that 
    . the rotation part is orthogonal : R @ R.T = I
    . the det(R) = 1  (=&gt; this is not a reflexion) 
    &#34;&#34;&#34;
    rotation = matrix[:3,:3]
    return np.allclose((rotation @ rotation.T),np.identity(3)) &amp; np.allclose(np.linalg.det(matrix),1)

def affine_inverse(matrix):
    &#34;&#34;&#34;
    affine_inverse(matrix)
    
    WARNING: 
    This is NOT a generic inversion of an affine transformation matrix
    
    This returns the affine transformation inverting that produced by the input matrix, 
    
    ASSSUMING that only rotation and translation were involved 
    in the affine transformation, no zoom, no shear!
    
    That preserves the fact that the orthogonal property of the part of the input matrix
    corresponding to rotation =&gt; the inverse is simply the transpose.
    
    Pierre Royer
    &#34;&#34;&#34;
    #import numpy as np

    # Extract Rotation matrix and translation vector from input affine transformation
    R = matrix[:3,:3]
    t = matrix[:3,3]
    #
    # Invert the rotation and the translation
    Rinv = R.T
    tinv = -t
    #
    # The inverse affine is composed from R^-1 for the rotation and -(R^-1 . t) for the translation
    result = np.identity(4)
    result[:3,:3] = Rinv
    result[:3,3]  = np.dot(Rinv,tinv)
    
    if affine_isEuclidian(result):
        return result
    else:
        print(&#34;WARNING: This is not a rigid-body transformation matrix&#34;)
        #print(f&#34;R.T-based  (.6f) = \n {np.round(result,6)}&#34;)
        #print(f&#34;np.inverse (.6f) = \n {np.round(np.linalg.inv(matrix),6)}&#34;)
        return np.linalg.inv(matrix)

def affine_matrix_from_points(v0, v1, shear=False, scale=False, usesvd=True):
    &#34;&#34;&#34;affine_matrix_from_points(v0, v1, shear=False, scale=False, usesvd=True)
    Return affine transform matrix to register two point sets.

    v0 and v1 are shape (ndims, \*) arrays of at least ndims non-homogeneous
    coordinates, where ndims is the dimensionality of the coordinate space.

    If shear is False, a similarity transformation matrix is returned.
    If also scale is False, a rigid/Euclidean transformation matrix
    is returned.

    By default the algorithm by Hartley and Zissermann [15] is used.
    If usesvd is True, similarity and Euclidean transformation matrices
    are calculated by minimizing the weighted sum of squared deviations
    (RMSD) according to the algorithm by Kabsch [8].
    Otherwise, and if ndims is 3, the quaternion based algorithm by Horn [9]
    is used, which is slower when using this Python implementation.

    The returned matrix performs rotation, translation and uniform scaling
    (if specified).

    &gt;&gt;&gt; v0 = [[0, 1031, 1031, 0], [0, 0, 1600, 1600]]
    &gt;&gt;&gt; v1 = [[675, 826, 826, 677], [55, 52, 281, 277]]
    &gt;&gt;&gt; affine_matrix_from_points(v0, v1)
    array([[   0.14549,    0.00062,  675.50008],
           [   0.00048,    0.14094,   53.24971],
           [   0.     ,    0.     ,    1.     ]])
    &gt;&gt;&gt; T = translation_matrix(numpy.random.random(3)-0.5)
    &gt;&gt;&gt; R = random_rotation_matrix(numpy.random.random(3))
    &gt;&gt;&gt; S = scale_matrix(random.random())
    &gt;&gt;&gt; M = concatenate_matrices(T, R, S)
    &gt;&gt;&gt; v0 = (numpy.random.rand(4, 100) - 0.5) * 20
    &gt;&gt;&gt; v0[3] = 1
    &gt;&gt;&gt; v1 = numpy.dot(M, v0)
    &gt;&gt;&gt; v0[:3] += numpy.random.normal(0, 1e-8, 300).reshape(3, -1)
    &gt;&gt;&gt; M = affine_matrix_from_points(v0[:3], v1[:3])
    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))
    True

    More examples in superimposition_matrix()

    Author: this function was extracted from the original transformations.py 
            written by Christoph Golke:
            https://www.lfd.uci.edu/~gohlke/code/transformations.py.html
            
    usesvd controls the use of a method based on Singular Value Decomposition (SVD)
    --&gt; when True, it is equivalent to rigid_transform_3D (see below)

    &#34;&#34;&#34;
    import numpy
    v0 = numpy.array(v0, dtype=numpy.float64, copy=True)
    v1 = numpy.array(v1, dtype=numpy.float64, copy=True)

    ndims = v0.shape[0]
    if ndims &lt; 2 or v0.shape[1] &lt; ndims or v0.shape != v1.shape:
        print(f&#34;ndims {ndims} v0/1.shape {v0.shape} {v1.shape} v0/1 class {v0.__class__} {v1.__class__}&#34;)
        raise ValueError(&#39;input arrays are of wrong shape or type&#39;)

    # move centroids to origin
    t0 = -numpy.mean(v0, axis=1)
    M0 = numpy.identity(ndims+1)
    M0[:ndims, ndims] = t0
    v0 += t0.reshape(ndims, 1)
    t1 = -numpy.mean(v1, axis=1)
    M1 = numpy.identity(ndims+1)
    M1[:ndims, ndims] = t1
    v1 += t1.reshape(ndims, 1)

    if shear:
        # Affine transformation
        A = numpy.concatenate((v0, v1), axis=0)
        u, s, vh = numpy.linalg.svd(A.T)
        vh = vh[:ndims].T
        B = vh[:ndims]
        C = vh[ndims:2*ndims]
        t = numpy.dot(C, numpy.linalg.pinv(B))
        t = numpy.concatenate((t, numpy.zeros((ndims, 1))), axis=1)
        M = numpy.vstack((t, ((0.0,)*ndims) + (1.0,)))
    elif usesvd or ndims != 3:
        # Rigid transformation via SVD of covariance matrix
        u, s, vh = numpy.linalg.svd(numpy.dot(v1, v0.T))
        # rotation matrix from SVD orthonormal bases
        R = numpy.dot(u, vh)
        if numpy.linalg.det(R) &lt; 0.0:
            # R does not constitute right handed system
            R -= numpy.outer(u[:, ndims-1], vh[ndims-1, :]*2.0)
            s[-1] *= -1.0
        # homogeneous transformation matrix
        M = numpy.identity(ndims+1)
        M[:ndims, :ndims] = R
    else:
        # Rigid transformation matrix via quaternion
        # compute symmetric matrix N
        xx, yy, zz = numpy.sum(v0 * v1, axis=1)
        xy, yz, zx = numpy.sum(v0 * numpy.roll(v1, -1, axis=0), axis=1)
        xz, yx, zy = numpy.sum(v0 * numpy.roll(v1, -2, axis=0), axis=1)
        N = [[xx+yy+zz, 0.0,      0.0,      0.0],
             [yz-zy,    xx-yy-zz, 0.0,      0.0],
             [zx-xz,    xy+yx,    yy-xx-zz, 0.0],
             [xy-yx,    zx+xz,    yz+zy,    zz-xx-yy]]
        # quaternion: eigenvector corresponding to most positive eigenvalue
        w, V = numpy.linalg.eigh(N)
        q = V[:, numpy.argmax(w)]
        q /= _vector_norm(q)  # unit quaternion
        # homogeneous transformation matrix
        M = _quaternion_matrix(q)

    if scale and not shear:
        # Affine transformation; scale is ratio of RMS deviations from centroid
        v0 *= v0
        v1 *= v1
        M[:ndims, :ndims] *= math.sqrt(numpy.sum(v1) / numpy.sum(v0))

    # move centroids back
    M = numpy.dot(numpy.linalg.inv(M1), numpy.dot(M, M0))
    M /= M[ndims, ndims]
    return M


def _vector_norm(data, axis=None, out=None):
    &#34;&#34;&#34;Return length, i.e. Euclidean norm, of ndarray along axis.

    &gt;&gt;&gt; v = numpy.random.random(3)
    &gt;&gt;&gt; n = vector_norm(v)
    &gt;&gt;&gt; numpy.allclose(n, numpy.linalg.norm(v))
    True
    &gt;&gt;&gt; v = numpy.random.rand(6, 5, 3)
    &gt;&gt;&gt; n = vector_norm(v, axis=-1)
    &gt;&gt;&gt; numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2)))
    True
    &gt;&gt;&gt; n = vector_norm(v, axis=1)
    &gt;&gt;&gt; numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))
    True
    &gt;&gt;&gt; v = numpy.random.rand(5, 4, 3)
    &gt;&gt;&gt; n = numpy.empty((5, 3))
    &gt;&gt;&gt; vector_norm(v, axis=1, out=n)
    &gt;&gt;&gt; numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))
    True
    &gt;&gt;&gt; vector_norm([])
    0.0
    &gt;&gt;&gt; vector_norm([1])
    1.0
    
    This function is called by affine_matrix_from_points when usesvd=False

    Author: this function was extracted from the original transformations.py 
            written by Christoph Golke:
            https://www.lfd.uci.edu/~gohlke/code/transformations.py.html

    &#34;&#34;&#34;
    data = numpy.array(data, dtype=numpy.float64, copy=True)
    if out is None:
        if data.ndim == 1:
            return math.sqrt(numpy.dot(data, data))
        data *= data
        out = numpy.atleast_1d(numpy.sum(data, axis=axis))
        numpy.sqrt(out, out)
        return out
    else:
        data *= data
        numpy.sum(data, axis=axis, out=out)
        numpy.sqrt(out, out)


def _quaternion_matrix(quaternion):
    &#34;&#34;&#34;Return homogeneous rotation matrix from quaternion.

    &gt;&gt;&gt; M = quaternion_matrix([0.99810947, 0.06146124, 0, 0])
    &gt;&gt;&gt; numpy.allclose(M, rotation_matrix(0.123, [1, 0, 0]))
    True
    &gt;&gt;&gt; M = quaternion_matrix([1, 0, 0, 0])
    &gt;&gt;&gt; numpy.allclose(M, numpy.identity(4))
    True
    &gt;&gt;&gt; M = quaternion_matrix([0, 1, 0, 0])
    &gt;&gt;&gt; numpy.allclose(M, numpy.diag([1, -1, -1, 1]))
    True

    This function is called by affine_matrix_from_points when usesvd=False

    Author: this function was extracted from the original transformations.py 
            written by Christoph Golke:
            https://www.lfd.uci.edu/~gohlke/code/transformations.py.html
    &#34;&#34;&#34;
    _EPS = np.finfo(float).eps * 5
    
    q = numpy.array(quaternion, dtype=numpy.float64, copy=True)
    n = numpy.dot(q, q)
    if n &lt; _EPS:
        return numpy.identity(4)
    q *= math.sqrt(2.0 / n)
    q = numpy.outer(q, q)
    return numpy.array([
        [1.0-q[2, 2]-q[3, 3],     q[1, 2]-q[3, 0],     q[1, 3]+q[2, 0], 0.0],
        [    q[1, 2]+q[3, 0], 1.0-q[1, 1]-q[3, 3],     q[2, 3]-q[1, 0], 0.0],
        [    q[1, 3]-q[2, 0],     q[2, 3]+q[1, 0], 1.0-q[1, 1]-q[2, 2], 0.0],
        [                0.0,                 0.0,                 0.0, 1.0]])


def rigid_transform_3D(fromA, toB, verbose=True):
    &#34;&#34;&#34;rigid_transform_3D(fromA, toB, verbose=True)
    
    INPUT
    Afrom, Bto 3xn arrays = xyz coords of n points to be registered
    
    OUTPUT
    Rotation + translation transformation matrix registering fromA into toB
    
    Author : Nghia Ho - 2013 - http://nghiaho.com/?page_id=671
            &#34;Finding optimal rotation and translation between corresponding 3D points&#34;
             Based on &#34;A Method for Registration of 3-D Shapes&#34;, by Besl and McKay, 1992.
             
    This is based on Singular Value Decomposition (SVD) 
    --&gt; it is equivalent to affine_matrix_from_points with parameter usesvd=True
    &#34;&#34;&#34;
    A = fromA.T
    B = toB.T
    
    assert len(A) == len(B)
    
    N = A.shape[0]; # total points

    centroid_A = np.mean(A, axis=0)
    centroid_B = np.mean(B, axis=0)
    
    # centre the points
    AA = A - np.tile(centroid_A, (N, 1))
    BB = B - np.tile(centroid_B, (N, 1))
    
    # @ is matrix multiplication for array
    H = np.transpose(AA) @ BB
    
    U, S, Vt = np.linalg.svd(H)
    
    R = Vt.T @ U.T
    
    # special reflection case
    if np.linalg.det(R) &lt; 0:
       print (&#34;Reflection detected&#34;)
       Vt[2,:] *= -1
       R = Vt.T @ U.T
       
    t = -R @ centroid_A.T + centroid_B.T
    
    result = np.identity(4)
    result[:3,:3] = R
    result[:3,3]  = t
    
    return result


def translationRotationToTransformation(translation,rotation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False):
    &#34;&#34;&#34;
    translationRotationToTransformation(translation,rotation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False)
    
    translationFirst : translation first
             False first 3 rows of transformation matrix = (R   t) [usual convention and default here]
             True  first 3 rows of transformation matrix = (R  Rt) [used in the hexapod]
    &#34;&#34;&#34;
    import transforms3d as t3
    import numpy as np
    # Zoom - unit
    zdef = np.array([1,1,1])
    # Shear
    sdef = np.array([0,0,0])
    translation = np.array(translation)
    #if degrees: rotation = np.deg2rad(np.array(rotation))
    if degrees: rotation = np.array([np.deg2rad(item) for item in rotation])
    rotx,roty,rotz = rotation
    rmat = RotationMatrix(rotx,roty,rotz,rot_config=rot_config,active=active)
    #
    if translationFirst:
        result = np.identity(4)
        result[:3,:3] = rmat.R
        result[:3,3]  = rmat.R @ translation
    else:
        result = t3.affines.compose(translation,rmat.R,Z=zdef,S=sdef)
    return result

def translationRotationFromTransformation(transformation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False):
    &#34;&#34;&#34;
    translationRotationFromTransformation(transformation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False)
    
    translationFirst : translation first
             False first 3 rows of transformation matrix = (R   t) [usual convention and default here]
             True  first 3 rows of transformation matrix = (R  Rt) [used in the hexapod]
    &#34;&#34;&#34;
    translation = transformation[:3,3]
    rotation = t3.euler.mat2euler(transformation,axes=rot_config)
    if degrees: rotation = np.array([np.rad2deg(item) for item in rotation])
    if translationFirst:
        translation = transformation[:3,:3].T @ translation
    return translation,rotation

tr2T = translationRotationToTransformation
T2tr = translationRotationFromTransformation


def vectorPlaneIntersection(pt, frame, epsilon=1.e-6):
    &#34;&#34;&#34;
    return the coordinates of the intersection of a vector with a plane.

    pt = input vector. Point object, expressing the vector
         vector origin = pt.ref.getOrigin().coordinates[:3]
         vector direction = pt.coordinates[:3]
    frame = input plane. ReferenceFrame object whose x-y plane is the target plane for intersection

    If the vector&#39;s own reference frame is &#39;frame&#39;, the problem is trivial

    In all cases, the coordinates of the interesection point are provided as a Point object, in &#34;frame&#34; coordinates

    Ref:
    https://stackoverflow.com/questions/5666222/3d-line-plane-intersection
    &#34;&#34;&#34;

    from egse.coordinates.point import Point

    if pt.ref == frame:
        # The point is defined in frame =&gt; the origin of the vector is the origin of the target plane.
        return np.array([0,0,0])
    else:
        # Express all inputs in &#39;frame&#39;

        # Vector Origin (p0)
        vec_orig = Point(pt.ref.getOrigin().coordinates[:3],ref=pt.ref, name=&#39;ptorig&#39;).expressIn(frame)[:3]
        # Vector End (p1)
        vec_end  = pt.expressIn(frame)[:3]
        # Vector (u)
        vec = vec_end - vec_orig

        # A point in Plane (pco)
        #plane_orig = np.array([0,0,0],dtype=float)
        plane_orig = frame.getOrigin().coordinates[:3]
        # Normal to the plane (pno)
        plane_normal = frame.getAxis(&#39;z&#39;).coordinates[:3]

        # Vector to normal &#39;angle&#39;
        vec_x_normal = np.dot(vec, plane_normal)

        # Test if there is an intersection (and if it&#39;s unique)
        # --&gt; input vector and normal mustn&#39;t be perpendicular, else the vector is // to the plane or inside it
        #
        if (np.allclose(vec_x_normal, 0., atol=epsilon)):
            print(&#39;The input vector is // to the plane normal (or inside the plane)&#39;)
            print(&#39;--&gt; there exists no intersection (or an infinity of them)&#39;)
            return None
        else:
            # Vector from the point in the plane to the origin of the vector (w)
            plane_to_vec = vec_orig - plane_orig

            # Solution  (&#34;how many &#39;vectors&#39; away is the interesection ?&#34;)
            vec_multiplicator = - np.dot(plane_normal, plane_to_vec) / vec_x_normal

            return Point(vec_orig + (vec * vec_multiplicator), ref=frame)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.coordinates.transform3d_addon.T2tr"><code class="name flex">
<span>def <span class="ident">T2tr</span></span>(<span>transformation, rot_config='sxyz', active=True, degrees=True, translationFirst=False)</span>
</code></dt>
<dd>
<div class="desc"><p>translationRotationFromTransformation(transformation,rot_config="sxyz",active=True,degrees=True,translationFirst=False)</p>
<p>translationFirst : translation first
False first 3 rows of transformation matrix = (R
t) [usual convention and default here]
True
first 3 rows of transformation matrix = (R
Rt) [used in the hexapod]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translationRotationFromTransformation(transformation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False):
    &#34;&#34;&#34;
    translationRotationFromTransformation(transformation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False)
    
    translationFirst : translation first
             False first 3 rows of transformation matrix = (R   t) [usual convention and default here]
             True  first 3 rows of transformation matrix = (R  Rt) [used in the hexapod]
    &#34;&#34;&#34;
    translation = transformation[:3,3]
    rotation = t3.euler.mat2euler(transformation,axes=rot_config)
    if degrees: rotation = np.array([np.rad2deg(item) for item in rotation])
    if translationFirst:
        translation = transformation[:3,:3].T @ translation
    return translation,rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.affine_inverse"><code class="name flex">
<span>def <span class="ident">affine_inverse</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>affine_inverse(matrix)</p>
<p>WARNING:
This is NOT a generic inversion of an affine transformation matrix</p>
<p>This returns the affine transformation inverting that produced by the input matrix, </p>
<p>ASSSUMING that only rotation and translation were involved
in the affine transformation, no zoom, no shear!</p>
<p>That preserves the fact that the orthogonal property of the part of the input matrix
corresponding to rotation =&gt; the inverse is simply the transpose.</p>
<p>Pierre Royer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_inverse(matrix):
    &#34;&#34;&#34;
    affine_inverse(matrix)
    
    WARNING: 
    This is NOT a generic inversion of an affine transformation matrix
    
    This returns the affine transformation inverting that produced by the input matrix, 
    
    ASSSUMING that only rotation and translation were involved 
    in the affine transformation, no zoom, no shear!
    
    That preserves the fact that the orthogonal property of the part of the input matrix
    corresponding to rotation =&gt; the inverse is simply the transpose.
    
    Pierre Royer
    &#34;&#34;&#34;
    #import numpy as np

    # Extract Rotation matrix and translation vector from input affine transformation
    R = matrix[:3,:3]
    t = matrix[:3,3]
    #
    # Invert the rotation and the translation
    Rinv = R.T
    tinv = -t
    #
    # The inverse affine is composed from R^-1 for the rotation and -(R^-1 . t) for the translation
    result = np.identity(4)
    result[:3,:3] = Rinv
    result[:3,3]  = np.dot(Rinv,tinv)
    
    if affine_isEuclidian(result):
        return result
    else:
        print(&#34;WARNING: This is not a rigid-body transformation matrix&#34;)
        #print(f&#34;R.T-based  (.6f) = \n {np.round(result,6)}&#34;)
        #print(f&#34;np.inverse (.6f) = \n {np.round(np.linalg.inv(matrix),6)}&#34;)
        return np.linalg.inv(matrix)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.affine_isEuclidian"><code class="name flex">
<span>def <span class="ident">affine_isEuclidian</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if a matrix is a pure solid-body euclidian rotation + translation (no shear or scaling)</p>
<p>We only need to check that
. the rotation part is orthogonal : R @ R.T = I
. the det(R) = 1
(=&gt; this is not a reflexion)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_isEuclidian(matrix):
    &#34;&#34;&#34;
    Tests if a matrix is a pure solid-body euclidian rotation + translation (no shear or scaling)
    
    We only need to check that 
    . the rotation part is orthogonal : R @ R.T = I
    . the det(R) = 1  (=&gt; this is not a reflexion) 
    &#34;&#34;&#34;
    rotation = matrix[:3,:3]
    return np.allclose((rotation @ rotation.T),np.identity(3)) &amp; np.allclose(np.linalg.det(matrix),1)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.affine_matrix_from_points"><code class="name flex">
<span>def <span class="ident">affine_matrix_from_points</span></span>(<span>v0, v1, shear=False, scale=False, usesvd=True)</span>
</code></dt>
<dd>
<div class="desc"><p>affine_matrix_from_points(v0, v1, shear=False, scale=False, usesvd=True)
Return affine transform matrix to register two point sets.</p>
<p>v0 and v1 are shape (ndims, *) arrays of at least ndims non-homogeneous
coordinates, where ndims is the dimensionality of the coordinate space.</p>
<p>If shear is False, a similarity transformation matrix is returned.
If also scale is False, a rigid/Euclidean transformation matrix
is returned.</p>
<p>By default the algorithm by Hartley and Zissermann [15] is used.
If usesvd is True, similarity and Euclidean transformation matrices
are calculated by minimizing the weighted sum of squared deviations
(RMSD) according to the algorithm by Kabsch [8].
Otherwise, and if ndims is 3, the quaternion based algorithm by Horn [9]
is used, which is slower when using this Python implementation.</p>
<p>The returned matrix performs rotation, translation and uniform scaling
(if specified).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; v0 = [[0, 1031, 1031, 0], [0, 0, 1600, 1600]]
&gt;&gt;&gt; v1 = [[675, 826, 826, 677], [55, 52, 281, 277]]
&gt;&gt;&gt; affine_matrix_from_points(v0, v1)
array([[   0.14549,    0.00062,  675.50008],
       [   0.00048,    0.14094,   53.24971],
       [   0.     ,    0.     ,    1.     ]])
&gt;&gt;&gt; T = translation_matrix(numpy.random.random(3)-0.5)
&gt;&gt;&gt; R = random_rotation_matrix(numpy.random.random(3))
&gt;&gt;&gt; S = scale_matrix(random.random())
&gt;&gt;&gt; M = concatenate_matrices(T, R, S)
&gt;&gt;&gt; v0 = (numpy.random.rand(4, 100) - 0.5) * 20
&gt;&gt;&gt; v0[3] = 1
&gt;&gt;&gt; v1 = numpy.dot(M, v0)
&gt;&gt;&gt; v0[:3] += numpy.random.normal(0, 1e-8, 300).reshape(3, -1)
&gt;&gt;&gt; M = affine_matrix_from_points(v0[:3], v1[:3])
&gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))
True
</code></pre>
<p>More examples in superimposition_matrix()</p>
<p>Author: this function was extracted from the original transformations.py
written by Christoph Golke:
<a href="https://www.lfd.uci.edu/~gohlke/code/transformations.py.html">https://www.lfd.uci.edu/~gohlke/code/transformations.py.html</a></p>
<p>usesvd controls the use of a method based on Singular Value Decomposition (SVD)
&ndash;&gt; when True, it is equivalent to rigid_transform_3D (see below)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_matrix_from_points(v0, v1, shear=False, scale=False, usesvd=True):
    &#34;&#34;&#34;affine_matrix_from_points(v0, v1, shear=False, scale=False, usesvd=True)
    Return affine transform matrix to register two point sets.

    v0 and v1 are shape (ndims, \*) arrays of at least ndims non-homogeneous
    coordinates, where ndims is the dimensionality of the coordinate space.

    If shear is False, a similarity transformation matrix is returned.
    If also scale is False, a rigid/Euclidean transformation matrix
    is returned.

    By default the algorithm by Hartley and Zissermann [15] is used.
    If usesvd is True, similarity and Euclidean transformation matrices
    are calculated by minimizing the weighted sum of squared deviations
    (RMSD) according to the algorithm by Kabsch [8].
    Otherwise, and if ndims is 3, the quaternion based algorithm by Horn [9]
    is used, which is slower when using this Python implementation.

    The returned matrix performs rotation, translation and uniform scaling
    (if specified).

    &gt;&gt;&gt; v0 = [[0, 1031, 1031, 0], [0, 0, 1600, 1600]]
    &gt;&gt;&gt; v1 = [[675, 826, 826, 677], [55, 52, 281, 277]]
    &gt;&gt;&gt; affine_matrix_from_points(v0, v1)
    array([[   0.14549,    0.00062,  675.50008],
           [   0.00048,    0.14094,   53.24971],
           [   0.     ,    0.     ,    1.     ]])
    &gt;&gt;&gt; T = translation_matrix(numpy.random.random(3)-0.5)
    &gt;&gt;&gt; R = random_rotation_matrix(numpy.random.random(3))
    &gt;&gt;&gt; S = scale_matrix(random.random())
    &gt;&gt;&gt; M = concatenate_matrices(T, R, S)
    &gt;&gt;&gt; v0 = (numpy.random.rand(4, 100) - 0.5) * 20
    &gt;&gt;&gt; v0[3] = 1
    &gt;&gt;&gt; v1 = numpy.dot(M, v0)
    &gt;&gt;&gt; v0[:3] += numpy.random.normal(0, 1e-8, 300).reshape(3, -1)
    &gt;&gt;&gt; M = affine_matrix_from_points(v0[:3], v1[:3])
    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))
    True

    More examples in superimposition_matrix()

    Author: this function was extracted from the original transformations.py 
            written by Christoph Golke:
            https://www.lfd.uci.edu/~gohlke/code/transformations.py.html
            
    usesvd controls the use of a method based on Singular Value Decomposition (SVD)
    --&gt; when True, it is equivalent to rigid_transform_3D (see below)

    &#34;&#34;&#34;
    import numpy
    v0 = numpy.array(v0, dtype=numpy.float64, copy=True)
    v1 = numpy.array(v1, dtype=numpy.float64, copy=True)

    ndims = v0.shape[0]
    if ndims &lt; 2 or v0.shape[1] &lt; ndims or v0.shape != v1.shape:
        print(f&#34;ndims {ndims} v0/1.shape {v0.shape} {v1.shape} v0/1 class {v0.__class__} {v1.__class__}&#34;)
        raise ValueError(&#39;input arrays are of wrong shape or type&#39;)

    # move centroids to origin
    t0 = -numpy.mean(v0, axis=1)
    M0 = numpy.identity(ndims+1)
    M0[:ndims, ndims] = t0
    v0 += t0.reshape(ndims, 1)
    t1 = -numpy.mean(v1, axis=1)
    M1 = numpy.identity(ndims+1)
    M1[:ndims, ndims] = t1
    v1 += t1.reshape(ndims, 1)

    if shear:
        # Affine transformation
        A = numpy.concatenate((v0, v1), axis=0)
        u, s, vh = numpy.linalg.svd(A.T)
        vh = vh[:ndims].T
        B = vh[:ndims]
        C = vh[ndims:2*ndims]
        t = numpy.dot(C, numpy.linalg.pinv(B))
        t = numpy.concatenate((t, numpy.zeros((ndims, 1))), axis=1)
        M = numpy.vstack((t, ((0.0,)*ndims) + (1.0,)))
    elif usesvd or ndims != 3:
        # Rigid transformation via SVD of covariance matrix
        u, s, vh = numpy.linalg.svd(numpy.dot(v1, v0.T))
        # rotation matrix from SVD orthonormal bases
        R = numpy.dot(u, vh)
        if numpy.linalg.det(R) &lt; 0.0:
            # R does not constitute right handed system
            R -= numpy.outer(u[:, ndims-1], vh[ndims-1, :]*2.0)
            s[-1] *= -1.0
        # homogeneous transformation matrix
        M = numpy.identity(ndims+1)
        M[:ndims, :ndims] = R
    else:
        # Rigid transformation matrix via quaternion
        # compute symmetric matrix N
        xx, yy, zz = numpy.sum(v0 * v1, axis=1)
        xy, yz, zx = numpy.sum(v0 * numpy.roll(v1, -1, axis=0), axis=1)
        xz, yx, zy = numpy.sum(v0 * numpy.roll(v1, -2, axis=0), axis=1)
        N = [[xx+yy+zz, 0.0,      0.0,      0.0],
             [yz-zy,    xx-yy-zz, 0.0,      0.0],
             [zx-xz,    xy+yx,    yy-xx-zz, 0.0],
             [xy-yx,    zx+xz,    yz+zy,    zz-xx-yy]]
        # quaternion: eigenvector corresponding to most positive eigenvalue
        w, V = numpy.linalg.eigh(N)
        q = V[:, numpy.argmax(w)]
        q /= _vector_norm(q)  # unit quaternion
        # homogeneous transformation matrix
        M = _quaternion_matrix(q)

    if scale and not shear:
        # Affine transformation; scale is ratio of RMS deviations from centroid
        v0 *= v0
        v1 *= v1
        M[:ndims, :ndims] *= math.sqrt(numpy.sum(v1) / numpy.sum(v0))

    # move centroids back
    M = numpy.dot(numpy.linalg.inv(M1), numpy.dot(M, M0))
    M /= M[ndims, ndims]
    return M</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.rigid_transform_3D"><code class="name flex">
<span>def <span class="ident">rigid_transform_3D</span></span>(<span>fromA, toB, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>rigid_transform_3D(fromA, toB, verbose=True)</p>
<p>INPUT
Afrom, Bto 3xn arrays = xyz coords of n points to be registered</p>
<p>OUTPUT
Rotation + translation transformation matrix registering fromA into toB</p>
<p>Author : Nghia Ho - 2013 - <a href="http://nghiaho.com/?page_id=671">http://nghiaho.com/?page_id=671</a>
"Finding optimal rotation and translation between corresponding 3D points"
Based on "A Method for Registration of 3-D Shapes", by Besl and McKay, 1992.</p>
<p>This is based on Singular Value Decomposition (SVD)
&ndash;&gt; it is equivalent to affine_matrix_from_points with parameter usesvd=True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rigid_transform_3D(fromA, toB, verbose=True):
    &#34;&#34;&#34;rigid_transform_3D(fromA, toB, verbose=True)
    
    INPUT
    Afrom, Bto 3xn arrays = xyz coords of n points to be registered
    
    OUTPUT
    Rotation + translation transformation matrix registering fromA into toB
    
    Author : Nghia Ho - 2013 - http://nghiaho.com/?page_id=671
            &#34;Finding optimal rotation and translation between corresponding 3D points&#34;
             Based on &#34;A Method for Registration of 3-D Shapes&#34;, by Besl and McKay, 1992.
             
    This is based on Singular Value Decomposition (SVD) 
    --&gt; it is equivalent to affine_matrix_from_points with parameter usesvd=True
    &#34;&#34;&#34;
    A = fromA.T
    B = toB.T
    
    assert len(A) == len(B)
    
    N = A.shape[0]; # total points

    centroid_A = np.mean(A, axis=0)
    centroid_B = np.mean(B, axis=0)
    
    # centre the points
    AA = A - np.tile(centroid_A, (N, 1))
    BB = B - np.tile(centroid_B, (N, 1))
    
    # @ is matrix multiplication for array
    H = np.transpose(AA) @ BB
    
    U, S, Vt = np.linalg.svd(H)
    
    R = Vt.T @ U.T
    
    # special reflection case
    if np.linalg.det(R) &lt; 0:
       print (&#34;Reflection detected&#34;)
       Vt[2,:] *= -1
       R = Vt.T @ U.T
       
    t = -R @ centroid_A.T + centroid_B.T
    
    result = np.identity(4)
    result[:3,:3] = R
    result[:3,3]  = t
    
    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.tr2T"><code class="name flex">
<span>def <span class="ident">tr2T</span></span>(<span>translation, rotation, rot_config='sxyz', active=True, degrees=True, translationFirst=False)</span>
</code></dt>
<dd>
<div class="desc"><p>translationRotationToTransformation(translation,rotation,rot_config="sxyz",active=True,degrees=True,translationFirst=False)</p>
<p>translationFirst : translation first
False first 3 rows of transformation matrix = (R
t) [usual convention and default here]
True
first 3 rows of transformation matrix = (R
Rt) [used in the hexapod]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translationRotationToTransformation(translation,rotation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False):
    &#34;&#34;&#34;
    translationRotationToTransformation(translation,rotation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False)
    
    translationFirst : translation first
             False first 3 rows of transformation matrix = (R   t) [usual convention and default here]
             True  first 3 rows of transformation matrix = (R  Rt) [used in the hexapod]
    &#34;&#34;&#34;
    import transforms3d as t3
    import numpy as np
    # Zoom - unit
    zdef = np.array([1,1,1])
    # Shear
    sdef = np.array([0,0,0])
    translation = np.array(translation)
    #if degrees: rotation = np.deg2rad(np.array(rotation))
    if degrees: rotation = np.array([np.deg2rad(item) for item in rotation])
    rotx,roty,rotz = rotation
    rmat = RotationMatrix(rotx,roty,rotz,rot_config=rot_config,active=active)
    #
    if translationFirst:
        result = np.identity(4)
        result[:3,:3] = rmat.R
        result[:3,3]  = rmat.R @ translation
    else:
        result = t3.affines.compose(translation,rmat.R,Z=zdef,S=sdef)
    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.translationRotationFromTransformation"><code class="name flex">
<span>def <span class="ident">translationRotationFromTransformation</span></span>(<span>transformation, rot_config='sxyz', active=True, degrees=True, translationFirst=False)</span>
</code></dt>
<dd>
<div class="desc"><p>translationRotationFromTransformation(transformation,rot_config="sxyz",active=True,degrees=True,translationFirst=False)</p>
<p>translationFirst : translation first
False first 3 rows of transformation matrix = (R
t) [usual convention and default here]
True
first 3 rows of transformation matrix = (R
Rt) [used in the hexapod]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translationRotationFromTransformation(transformation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False):
    &#34;&#34;&#34;
    translationRotationFromTransformation(transformation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False)
    
    translationFirst : translation first
             False first 3 rows of transformation matrix = (R   t) [usual convention and default here]
             True  first 3 rows of transformation matrix = (R  Rt) [used in the hexapod]
    &#34;&#34;&#34;
    translation = transformation[:3,3]
    rotation = t3.euler.mat2euler(transformation,axes=rot_config)
    if degrees: rotation = np.array([np.rad2deg(item) for item in rotation])
    if translationFirst:
        translation = transformation[:3,:3].T @ translation
    return translation,rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.translationRotationToTransformation"><code class="name flex">
<span>def <span class="ident">translationRotationToTransformation</span></span>(<span>translation, rotation, rot_config='sxyz', active=True, degrees=True, translationFirst=False)</span>
</code></dt>
<dd>
<div class="desc"><p>translationRotationToTransformation(translation,rotation,rot_config="sxyz",active=True,degrees=True,translationFirst=False)</p>
<p>translationFirst : translation first
False first 3 rows of transformation matrix = (R
t) [usual convention and default here]
True
first 3 rows of transformation matrix = (R
Rt) [used in the hexapod]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translationRotationToTransformation(translation,rotation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False):
    &#34;&#34;&#34;
    translationRotationToTransformation(translation,rotation,rot_config=&#34;sxyz&#34;,active=True,degrees=True,translationFirst=False)
    
    translationFirst : translation first
             False first 3 rows of transformation matrix = (R   t) [usual convention and default here]
             True  first 3 rows of transformation matrix = (R  Rt) [used in the hexapod]
    &#34;&#34;&#34;
    import transforms3d as t3
    import numpy as np
    # Zoom - unit
    zdef = np.array([1,1,1])
    # Shear
    sdef = np.array([0,0,0])
    translation = np.array(translation)
    #if degrees: rotation = np.deg2rad(np.array(rotation))
    if degrees: rotation = np.array([np.deg2rad(item) for item in rotation])
    rotx,roty,rotz = rotation
    rmat = RotationMatrix(rotx,roty,rotz,rot_config=rot_config,active=active)
    #
    if translationFirst:
        result = np.identity(4)
        result[:3,:3] = rmat.R
        result[:3,3]  = rmat.R @ translation
    else:
        result = t3.affines.compose(translation,rmat.R,Z=zdef,S=sdef)
    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.transform3d_addon.vectorPlaneIntersection"><code class="name flex">
<span>def <span class="ident">vectorPlaneIntersection</span></span>(<span>pt, frame, epsilon=1e-06)</span>
</code></dt>
<dd>
<div class="desc"><p>return the coordinates of the intersection of a vector with a plane.</p>
<p>pt = input vector. Point object, expressing the vector
vector origin = pt.ref.getOrigin().coordinates[:3]
vector direction = pt.coordinates[:3]
frame = input plane. ReferenceFrame object whose x-y plane is the target plane for intersection</p>
<p>If the vector's own reference frame is 'frame', the problem is trivial</p>
<p>In all cases, the coordinates of the interesection point are provided as a Point object, in "frame" coordinates</p>
<p>Ref:
<a href="https://stackoverflow.com/questions/5666222/3d-line-plane-intersection">https://stackoverflow.com/questions/5666222/3d-line-plane-intersection</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vectorPlaneIntersection(pt, frame, epsilon=1.e-6):
    &#34;&#34;&#34;
    return the coordinates of the intersection of a vector with a plane.

    pt = input vector. Point object, expressing the vector
         vector origin = pt.ref.getOrigin().coordinates[:3]
         vector direction = pt.coordinates[:3]
    frame = input plane. ReferenceFrame object whose x-y plane is the target plane for intersection

    If the vector&#39;s own reference frame is &#39;frame&#39;, the problem is trivial

    In all cases, the coordinates of the interesection point are provided as a Point object, in &#34;frame&#34; coordinates

    Ref:
    https://stackoverflow.com/questions/5666222/3d-line-plane-intersection
    &#34;&#34;&#34;

    from egse.coordinates.point import Point

    if pt.ref == frame:
        # The point is defined in frame =&gt; the origin of the vector is the origin of the target plane.
        return np.array([0,0,0])
    else:
        # Express all inputs in &#39;frame&#39;

        # Vector Origin (p0)
        vec_orig = Point(pt.ref.getOrigin().coordinates[:3],ref=pt.ref, name=&#39;ptorig&#39;).expressIn(frame)[:3]
        # Vector End (p1)
        vec_end  = pt.expressIn(frame)[:3]
        # Vector (u)
        vec = vec_end - vec_orig

        # A point in Plane (pco)
        #plane_orig = np.array([0,0,0],dtype=float)
        plane_orig = frame.getOrigin().coordinates[:3]
        # Normal to the plane (pno)
        plane_normal = frame.getAxis(&#39;z&#39;).coordinates[:3]

        # Vector to normal &#39;angle&#39;
        vec_x_normal = np.dot(vec, plane_normal)

        # Test if there is an intersection (and if it&#39;s unique)
        # --&gt; input vector and normal mustn&#39;t be perpendicular, else the vector is // to the plane or inside it
        #
        if (np.allclose(vec_x_normal, 0., atol=epsilon)):
            print(&#39;The input vector is // to the plane normal (or inside the plane)&#39;)
            print(&#39;--&gt; there exists no intersection (or an infinity of them)&#39;)
            return None
        else:
            # Vector from the point in the plane to the origin of the vector (w)
            plane_to_vec = vec_orig - plane_orig

            # Solution  (&#34;how many &#39;vectors&#39; away is the interesection ?&#34;)
            vec_multiplicator = - np.dot(plane_normal, plane_to_vec) / vec_x_normal

            return Point(vec_orig + (vec * vec_multiplicator), ref=frame)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.coordinates" href="index.html">egse.coordinates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.coordinates.transform3d_addon.T2tr" href="#egse.coordinates.transform3d_addon.T2tr">T2tr</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.affine_inverse" href="#egse.coordinates.transform3d_addon.affine_inverse">affine_inverse</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.affine_isEuclidian" href="#egse.coordinates.transform3d_addon.affine_isEuclidian">affine_isEuclidian</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.affine_matrix_from_points" href="#egse.coordinates.transform3d_addon.affine_matrix_from_points">affine_matrix_from_points</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.rigid_transform_3D" href="#egse.coordinates.transform3d_addon.rigid_transform_3D">rigid_transform_3D</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.tr2T" href="#egse.coordinates.transform3d_addon.tr2T">tr2T</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.translationRotationFromTransformation" href="#egse.coordinates.transform3d_addon.translationRotationFromTransformation">translationRotationFromTransformation</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.translationRotationToTransformation" href="#egse.coordinates.transform3d_addon.translationRotationToTransformation">translationRotationToTransformation</a></code></li>
<li><code><a title="egse.coordinates.transform3d_addon.vectorPlaneIntersection" href="#egse.coordinates.transform3d_addon.vectorPlaneIntersection">vectorPlaneIntersection</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
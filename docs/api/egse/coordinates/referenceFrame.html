<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.coordinates.referenceFrame API documentation</title>
<meta name="description" content="The referenceFrames module provides the class :code:`ReferenceFrames` which defines the affine transformation
for bringing one reference frame to â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.coordinates.referenceFrame</code></h1>
</header>
<section id="section-intro">
<p>The referenceFrames module provides the class :code:<code>ReferenceFrames</code> which defines the affine transformation
for bringing one reference frame to another.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>The tests in methods like getPassiveTransformationTo using '==' should be looked at again and maybe
changed into using the 'is' operator. This because we now have <strong>eq</strong> implemented.</p>
</div>
<p>@author: Pierre Royer</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The referenceFrames module provides the class :code:`ReferenceFrames` which defines the affine transformation
for bringing one reference frame to another.

.. todo:: The tests in methods like getPassiveTransformationTo using &#39;==&#39; should be looked at again and maybe
          changed into using the &#39;is&#39; operator. This because we now have __eq__ implemented.

@author: Pierre Royer
&#34;&#34;&#34;
import logging
import random
import string
import textwrap

import numpy as np
import transforms3d as t3

import egse.coordinates.transform3d_addon as t3add
from egse.coordinates.point import Point
from egse.coordinates.rotationMatrix import RotationMatrix
from egse.decorators import deprecate
from egse.exceptions import InvalidOperationError

LOGGER = logging.getLogger(__name__)


def transformationToString(transformation):
    &#34;&#34;&#34;Helper function: prints out a transformation (numpy ndarray) in a condensed form on one line.&#34;&#34;&#34;

    if isinstance(transformation, np.ndarray):
        if np.allclose(transformation, ReferenceFrame._I):
            return &#34;Identity&#34;
        msg = np.array2string(
            transformation,
            separator=&#34;,&#34;,
            suppress_small=True,
            formatter={&#34;float_kind&#34;: lambda x: &#34;%.2f&#34; % x},
        ).replace(&#34;\n&#34;, &#34;&#34;)
        return msg

    # We do not want to raise an Exception here since this is mainly used in logging messages
    # and doesn&#39;t really harm the execution of the program.
    return f&#34;ERROR: expected transformation to be an ndarray, type={type(transformation)}&#34;


class ReferenceFrame(object):
    &#34;&#34;&#34;
    A Reference Frame defined in reference frame &#34;ref&#34;, i.e.
    defined by the affine transformation bringing the reference frame &#34;ref&#34; onto &#34;self&#34;.

    By default, &#34;ref&#34; is the master refence frame, defined as the identity matrix.

    :param transformation: 4x4 affine transformation matrix defining this system in &#34;ref&#34; system
    :type transformation: numpy array

    :param ref: reference system in which this new reference frame is defined
    :type ref: ReferenceFrame

    :param name: name the reference frame so it can be referenced, set to &#39;master&#39; when None
    :type name: str

    :param rot_config:
            * Is set when using creator ReferenceFrame.fromTranslationRotation()
            * In other cases, is set to a default &#34;szyx&#34;
              (rotations around static axes z, y and x in this order)
              In these other cases, it has no real direct influence,
              except for methods returning the rotation vector (e.g. getRotationVector)
              It is therefore always recommended to pass it to the constructor, even when
              constructing the ReferenceFrame directly from a transformation matrix
    :type rot_config: str

    Both the ``transformation`` and the ``ref`` parameters are mandatory.

    If the reference frame is None, the master reference frame is created.

    The master reference frame:

        * is defined by the identity transformation matrix
        * has itself as a reference

    For convenience we provide the following factory methods:

    createMaster()
        Create a Master Reference Frame

    createRotation(..)
        Create a new Reference Frame that is rotated with respect to the given reference frame

    createTranslation(..)
        Create a new Reference Frame that is a translation with respect to the given reference frame
    &#34;&#34;&#34;

    _I = np.identity(4)
    _MASTER = None
    _ROT_CONFIG_DEFAULT = &#34;sxyz&#34;
    _names_used = [None, &#34;Master&#34;]
    _strict_naming = False
    _ACTIVE_DEFAULT = True

    def __new__(cls, transformation, ref, name=None, rot_config=_ROT_CONFIG_DEFAULT):
        &#34;&#34;&#34;Create a new ReferenceFrame class.&#34;&#34;&#34;

        LOGGER.debug(
            f&#34;transformation={transformationToString(transformation)}, ref={ref!r}, name={name}, rot_config={rot_config}&#34;
        )

        if ref is None:
            msg = (
                &#34;No reference frame was given, if you planned to create a Master Reference Frame, &#34;
                &#34;use ReferenceFrame.createMaster(). &#34;
            )
            LOGGER.error(msg)
            raise ValueError(msg, &#34;REF_IS_NONE&#34;)

        if not isinstance(ref, cls):
            msg = f&#34;The &#39;ref&#39; keyword argument is not a ReferenceFrame object, but {type(ref)}&#34;
            LOGGER.error(msg)
            raise ValueError(msg, &#34;REF_IS_NOT_CLS&#34;)

        if name == &#34;Master&#34;:
            msg = (
                &#34;The &#39;name&#39; argument cannot be &#39;Master&#39; unless a Master instance should be created, &#34;
                &#34;in that case, use ReferenceFrame.createMaster()&#34;
            )
            LOGGER.error(msg)
            raise ValueError(msg, &#34;MASTER_NAME_USED&#34;)

        if transformation is None:
            msg = &#34;The &#39;transformation&#39; argument can not be None, please provide a proper transformation for this reference frame.&#34;
            LOGGER.error(msg)
            raise ValueError(msg, &#34;TRANSFORMATION_IS_NONE&#34;)

        if not isinstance(transformation, np.ndarray):
            msg = f&#34;The &#39;transformation&#39; argument shall be a Numpy ndarray [not a {type(transformation)}], please provide a proper transformation for this reference frame.&#34;
            LOGGER.error(msg)
            raise ValueError(msg, &#34;TRANSFORMATION_IS_NOT_NDARRAY&#34;)

        if rot_config is None:
            msg = &#34;The &#39;rot_config&#39; keyword argument can not be None, do not specify it when you want to use the default value.&#34;
            LOGGER.error(msg)
            raise ValueError(msg)

        _instance = super(ReferenceFrame, cls).__new__(cls)

        return _instance

    def __init__(self, transformation, ref, name=None, rot_config=_ROT_CONFIG_DEFAULT):
        &#34;&#34;&#34;Initialize the ReferenceFrame object &#34;&#34;&#34;

        self.debug = False

        LOGGER.debug(
            f&#34;transformation={transformationToString(transformation)}, ref={ref!r}, name={name}, rot_config={rot_config}&#34;
        )

        # All argument testing is done in the __new__() method and we should be save here.

        self.ref = ref
        self.name = self.__createName(name)
        self.transformation = transformation
        self.rot_config = rot_config

        self.definition = [self.transformation, self.ref, self.name]

        self.x = self.getAxis(&#34;x&#34;)
        self.y = self.getAxis(&#34;y&#34;)
        self.z = self.getAxis(&#34;z&#34;)

        self.linkedTo = {}
        self.referenceFor = []

        ref.referenceFor.append(self)

        return

    def find_master(self):
        return self.findMaster()

    def findMaster(self):
        &#34;&#34;&#34;
        Returns the Master frame for this reference frame. The Master frame is always at the end
        of the path following the references.

        Returns:
            The master frame.
        &#34;&#34;&#34;

        frame = self
        while not frame.isMaster():
            frame = frame.ref
        return frame

    @classmethod
    def createMaster(cls):
        &#34;&#34;&#34;
        Create a master reference frame.

        A master reference frame is defined with respect to itself and is initialised with the
        identity matrix.

        The master frame is automatically given the name &#34;Master&#34;.
        &#34;&#34;&#34;
        ref_master = super(ReferenceFrame, cls).__new__(cls)
        ref_master.name = &#34;Master&#34;
        ref_master.ref = ref_master
        ref_master.transformation = cls._I
        ref_master.rot_config = cls._ROT_CONFIG_DEFAULT
        ref_master.initialized = True
        ref_master.debug = False
        ref_master.linkedTo = {}
        ref_master.referenceFor = []

        LOGGER.debug(
            f&#34;NEW MASTER CREATED: {id(ref_master)}, ref = {id(ref_master.ref)}, &#34;
            f&#34;name = {ref_master.name}&#34;
        )

        return ref_master

    @classmethod
    def __createName(cls, name: str = None):

        if name is None:
            while name in cls._names_used:
                name = &#34;F&#34; + &#34;&#34;.join(random.choices(string.ascii_uppercase, k=3))
            return name

        if cls._strict_naming:

            # generate a unique name

            old_name = name

            while name in cls._names_used:
                name = &#34;F&#34; + &#34;&#34;.join(random.choices(string.ascii_uppercase, k=3))

            LOGGER.warning(
                f&#34;name (&#39;{old_name}&#39;) is already defined, since strict naming is applied, &#34;
                f&#34;a new unique name was created: {name}&#34;
            )

        else:

            if name in cls._names_used:
                LOGGER.log(
                    0,
                    f&#34;name (&#39;{name}&#39;) is already defined, now you have more than one &#34;
                    f&#34;ReferenceFrame with the same name.&#34;,
                )

        cls._names_used.append(name)
        return name

    @classmethod
    def fromTranslation(cls, transx, transy, transz, ref, name=None):
        &#34;&#34;&#34;
        Create a ReferenceFrame from a translation with respect to the given reference frame.

        :param transx: translation along the x-axis
        :type transx: float

        :param transy: translation along the y-axis
        :type transy: float

        :param transz: translation along the z-axis
        :type transz: float

        :param ref: reference frame with respect to which the translation is performed. If no ref is given
            the rotation is with respect to the master reference frame
        :type ref: ReferenceFrame

        :param name: a simple convenient name to identify the reference frame. If no name is provided
                     a random name of four characters starting with &#39;F&#39; will be generated.
        :type name: str

        :return: a reference frame
        &#34;&#34;&#34;
        adef = np.identity(4)
        adef[:3, 3] = [transx, transy, transz]

        if ref is None:
            raise ValueError(
                &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
            )

        return cls(transformation=adef, ref=ref, name=name)

    @classmethod
    def fromRotation(
        cls,
        rotx,
        roty,
        rotz,
        ref,
        name=None,
        rot_config=_ROT_CONFIG_DEFAULT,
        active=_ACTIVE_DEFAULT,
        degrees=True,
    ):
        &#34;&#34;&#34;
        Create a ReferenceFrame from a rotation with respect to the given reference frame.

        :param rotx: rotation around the x-axis
        :type rotx: float

        :param roty: rotation around the y-axis
        :type roty: float

        :param rotz: rotation around the z-axis
        :type rotz: float

        :param ref: reference frame with respect to which the rotation is performed. If no ref is given
            the rotation is with respect to the master reference frame
        :type ref: ReferenceFrame

        :param name: a simple convenient name to identify the reference frame. If no name is provided
                     a random name of four characters starting with &#39;F&#39; will be generated.
        :type name: str

        :return: a reference frame
        &#34;&#34;&#34;
        # Convention (rotating axes, in order xyz)

        # rot_config = cls._ROT_CONFIG_DEFAULT

        # Rotation amplitude

        # Rotation
        if degrees:
            rotx = np.deg2rad(rotx)
            roty = np.deg2rad(roty)
            rotz = np.deg2rad(rotz)

        rotation = RotationMatrix(rotx, roty, rotz, rot_config, active=active)

        # Defaults for zoom &amp; shear

        zdef = np.array([1, 1, 1])
        sdef = np.array([0, 0, 0])

        translation = [0, 0, 0]

        TT = t3.affines.compose(T=translation, R=rotation.R, Z=zdef, S=sdef)

        if ref is None:
            raise ValueError(
                &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
            )

        return cls(transformation=TT, ref=ref, name=name, rot_config=rot_config)

    @staticmethod
    def fromPoints(points, plane=&#34;xy&#34;, name=None, usesvd=True, verbose=True):
        &#34;&#34;&#34;
        fromPoints(points, plane=&#34;xy&#34;, name=None, usesvd=True,verbose=True)

        Finds the best fitting &#34;plane&#34; plane to all points in &#34;points&#34; and builds a ReferenceFrame
        considering the fitted plane as the &#39;xy&#39; plane of the new system

        fitPlane must be in [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;]
        &#34;&#34;&#34;
        return points.bestFittingPlane(fitPlane=plane, usesvd=usesvd, verbose=verbose)

    @classmethod
    def fromTranslationRotation(
        cls,
        translation,
        rotation,
        ref,
        name=None,
        rot_config=_ROT_CONFIG_DEFAULT,
        active=_ACTIVE_DEFAULT,
        degrees=True,
    ):
        &#34;&#34;&#34;fromTranslationRotation(cls,translation,rotation, ref=None,name=None, rot_config=_ROT_CONFIG_DEFAULT,active=_ACTIVE_DEFAULT, degrees=True)

        Construct a ReferenceFrame from a translation and a rotation (vectors!)

        translation : translation vector : 3 x 1 = tx, ty, tz
        rotation    : rotation vector    : 3 x 1 = rx, ry, rz

        rot_config : convention for the rotation, see rotationMatrix.__doc__

        degrees : if True, input values are assumed in degrees, otherwise radians
        &#34;&#34;&#34;
        # Translation
        translation = np.array(translation)
        # Zoom - unit
        zdef = np.array([1, 1, 1])
        # Shear
        sdef = np.array([0, 0, 0])
        # Rotation
        if degrees:
            rotation = np.array([np.deg2rad(item) for item in rotation])
        rotx, roty, rotz = rotation
        #
        rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)
        #
        # transformation = t3.affines.compose(translation,rmat.R,Z=zdef,S=sdef)

        if ref is None:
            raise ValueError(
                &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
            )

        return cls(
            transformation=t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef),
            ref=ref,
            name=name,
            rot_config=rot_config,
        )

    def getTranslationVector(self):
        &#34;&#34;&#34;
        getTranslationVector()

        Returns the translation defining this reference frame (from self.ref to self)
        &#34;&#34;&#34;
        return self.transformation[:3, 3]

    def getRotationVector(self, degrees=True, active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getRotationVector()

        Returns the rotation (vector) defining this reference frame (from self.ref to self)
        degrees : if true, rotation angles are expressed in degrees
        &#34;&#34;&#34;
        rotation = t3.euler.mat2euler(self.transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        return rotation

    def getTranslationRotationVectors(self, degrees=True, active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;getTranslationRotationVectors()
        Returns the translation and rotation (vectors) defining this reference frame (from self.ref to self)
        degrees : if true, rotation angles are expressed in degrees
        &#34;&#34;&#34;
        translation = self.getTranslationVector()
        rotation = self.getRotationVector(degrees=degrees, active=active)
        return translation, rotation

    def getRotationMatrix(self):
        &#34;&#34;&#34;
        getRotationMatrix()

        Returns the rotation (matrix) defining this reference frame (from self.ref to self)
        &#34;&#34;&#34;
        result = self.transformation.copy()
        result[:3, 3] = [0.0, 0.0, 0.0]
        return result

    def __repr__(self):
        return f&#34;ReferenceFrame(transformation={transformationToString(self.transformation)}, ref={self.ref.name}, name={self.name}, rot_config={self.rot_config})&#34;

    def __str__(self):
        msg = textwrap.dedent(
            f&#34;&#34;&#34;\
                ReferenceFrame
                name          : {self.name}
                reference     : {self.ref.name}
                rot_config    : {self.rot_config}
                links         : {[key.name for key in self.linkedTo.keys()]}
                transformation:
                  [{np.round(self.transformation[0], 3)}
                   {np.round(self.transformation[1], 3)}
                   {np.round(self.transformation[2], 3)}
                   {np.round(self.transformation[3], 3)}]
                translation   : {np.round(self.getTranslationVector(),3)}
                rotation      : {np.round(self.getRotationVector(),3)}&#34;&#34;&#34;
        )
        return msg

    @deprecate(
        reason=(
            &#34;I do not see the added value of changing the name and &#34;
            &#34;the current method has the side effect to change the name &#34;
            &#34;to a random string when the name argument is already used.&#34;
        ),
        alternative=&#34;the constructor argument to set the name already of the object.&#34;,
    )
    def setName(self, name=None):
        &#34;&#34;&#34;
        Set or change the name of a reference frame.

        ..note: this method is deprecated

        :param str name: the new name for the reference frame, if None, a random name will be generated.

        :raises InvalidOperationError: when you try to change the name of the Master reference frame
        &#34;&#34;&#34;
        if self.isMaster():
            raise InvalidOperationError(
                &#34;You try to change the name of the Master reference frame, which is not allowed.&#34;
            )
        self.name = self.__createName(name)

    def addLink(self, ref, transformation=None, _stop=False):
        &#34;&#34;&#34;
        adds a link between self and ref in self.linkedTo and ref.linkedTo
        &#34;&#34;&#34;

        # DONE: set the inverse transformation in the ref to this
        #   ref.linkedTo[self] = t3add.affine_inverse(transformation)
        # TODO:
        #   remove the _stop keyword

        # TODO: deprecate transformation as an input variable
        #       linkedTo can become a list of reference frames, with no transformation
        #       associated to the link. The tfo associated to a link is already
        #       checked in real time whenever the link is addressed
        if transformation is None:
            transformation = self.getActiveTransformationTo(ref)
        else:
            LOGGER.info(&#34;Deprecation warning: transformation will be automatically set to &#34;
                        &#34;the current relation between {self.name} and {ref.name}&#34;)
            LOGGER.flash_flood(&#34;Requested:&#34;)
            LOGGER.flash_flood(np.round(transformation, decimals=3))
            LOGGER.flash_flood(&#34;Auto (enforced):&#34;)

            transformation = self.getActiveTransformationTo(ref)

            LOGGER.flash_flood(np.round(transformation, decimals=3))

        self.linkedTo[ref] = transformation

        # TODO simplify this when transformation is deprecated
        #      it becomes ref.linkedTo[self] = ref.getActiveTransformationTo(self)
        ref.linkedTo[self] = t3add.affine_inverse(transformation)

    def removeLink(self, ref):
        &#34;&#34;&#34;
        Remove the link between self and ref, both ways.
        &#34;&#34;&#34;

        # First remove the entry in ref to this

        if self in ref.linkedTo:
            del ref.linkedTo[self]

        # Then remove the entry in this to ref

        if ref in self.linkedTo:
            del self.linkedTo[ref]

    def getPassiveTransformationTo(self, targetFrame):
        &#34;&#34;&#34;
        getPassiveTransformationTo(self,targetFrame)
        == getPointTransformationTo(self,targetFrame)

        returns the transformation to apply to a Point (defined in self) to express it in targetFrame

        Passive transformation : the point is static, we change the reference frame around it
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;PASSIVE TO self {self.name} target {targetFrame.name}&#34;)
        if targetFrame is self:
            &#34;&#34;&#34;
            Nothing to do here, we already have the right coordinates
            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;case 1&#34;)
            result = np.identity(4)

        elif targetFrame.ref is self:
            &#34;&#34;&#34;
            The target frame is defined in self =&gt; the requested transformation is the targetFrame definition
            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;=== 2 start ===&#34;)
            result = t3add.affine_inverse(targetFrame.transformation)
            LOGGER.flash_flood(&#34;=== 2 end   ===&#34;)
        elif targetFrame.ref is self.ref:
            &#34;&#34;&#34;
            targetFrame and self are defined wrt the same reference frame
            We want
            self --&gt; targetFrame
            We know
            targetFrame.ref --&gt; targetFrame (= targetFrame.transformation)
            self.ref   --&gt; self   (= self.transformation)
            That is
            self --&gt; self.ref is targetFrame.ref --&gt; targetFrame
            inverse(definition)    targetFrame definition

            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;=== 3 start ===&#34;)
            LOGGER.flash_flood(&#34; ref   \n{0}&#34;.format(self.ref))
            LOGGER.flash_flood(&#34;===&#34;)
            LOGGER.flash_flood(&#34;self   \n{0}&#34;.format(self))
            LOGGER.flash_flood(&#34;===&#34;)
            LOGGER.flash_flood(&#34;targetFrame \n{0}&#34;.format(targetFrame))
            LOGGER.flash_flood(&#34;===&#34;)

            selfToRef = self.transformation
            LOGGER.flash_flood(&#34;selfToRef \n{0}&#34;.format(selfToRef))

            # refToRef = I

            refToTarget = t3add.affine_inverse(targetFrame.transformation)
            LOGGER.flash_flood(&#34;refToTarget \n{0}&#34;.format(refToTarget))

            result = np.dot(refToTarget, selfToRef)
            LOGGER.flash_flood(&#34;result \n{0}&#34;.format(result))
            LOGGER.flash_flood(&#34;=== 3 end   ===&#34;)
        else:
            &#34;&#34;&#34;
            We are after the transformation from
            self --&gt; targetFrame
            ==
            self --&gt; self.ref --&gt; targetFrame.ref --&gt; targetFrame

            We know
            targetFrame.ref --&gt; targetFrame (targetFrame.transformation)
            self.ref        --&gt; self (self.transformation)
            but
            targetFrame.ref != self.ref
            so we need
            self.ref --&gt; targetFrame.ref
            then we can compose
            self --&gt; self.ref --&gt; targetFrame.ref --&gt; targetFrame

            Note: the transformation self.ref --&gt; targetFrame.ref is acquired recursively
                  This relies on the underlying assumption that there exists
                  one unique reference frame that source and self can be linked to
                  (without constraints on the number of links necessary), i.e.
                  that, from a frame to its reference or the opposite, there exists
                  a path between self and targetFrame. That is equivalent to
                  the assumption that the entire set of reference frames is connex,
                  i.e. defined upon a unique master reference frame.
            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;=== 4 start ===&#34;)
            selfToRef = self.transformation
            selfRefToTargetRef = self.ref.getPassiveTransformationTo(targetFrame.ref)
            refToTarget = t3add.affine_inverse(targetFrame.transformation)
            result = np.dot(refToTarget, np.dot(selfRefToTargetRef, selfToRef))
            LOGGER.flash_flood(&#34;=== 4 end   ===&#34;)

        return result

    def getPassiveTranslationRotationVectorsTo(
        self, targetFrame, degrees=True
    ):  # , active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts rotation vector from the result of getPassiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getPassiveTransformationTo(targetFrame)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getPassiveTranslationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts translation vector from the result of getPassiveTransformationTo(target)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[0]

    def getPassiveRotationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)

        extracts rotation vector from the result of getPassiveTransformationTo(targetFrame)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[1]

    def getPassiveTransformationFrom(self, source):
        &#34;&#34;&#34;
        getPassiveTransformationFrom(self,source)
        ==  getPointTransformationTo(self,source)

        INPUT
        source : is a ReferenceFrame object

        OUTPUT
        returns the transformation matrix  that, applied to a point defined
        in source returns its coordinates in self
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;PASSIVE FROM self {self.name} source {source.name}&#34;)
        return source.getPassiveTransformationTo(self)

    def getPassiveTranslationRotationVectorsFrom(
        self, source, degrees=True
    ):  # , active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsFrom(self,source, degrees=True)

        extracts rotation vector from the result of getPassiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getPassiveTransformationFrom(source)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getPassiveTranslationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationVectorFrom(self,source, degrees=True)

        extracts translation vector from the result of getPassiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsFrom(source, degrees=degrees)[0]

    def getPassiveRotationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsFrom(self,source,degrees=True)

        extracts rotation vector from the result of getPassiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsFrom(source, degrees=degrees)[1]

    def getActiveTransformationTo(self, target):
        &#34;&#34;&#34;
        Return the transformation matrix from this reference frame (``self``) to
        the target reference frame.

        Applying this transformation to the ``self`` ReferenceFrame would render it
        identical to target.

        Applying this transformation to a point defined in ``self`` would move it to
        the same coordinates in target.

        :param target: is a ReferenceFrame object

        :return: the transformation matrix that defines the reference frame ``target``
            in ``self``, the current reference frame. The transformation from self
            to target

        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;ACTIVE TO self {self.name} target {target.name}&#34;)
        return target.getPassiveTransformationTo(self)

    def getActiveTranslationRotationVectorsTo(
        self, targetFrame, degrees=True
    ):  # ,active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts rotation vector from the result of getActiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getActiveTransformationTo(targetFrame)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getActiveTranslationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts translation vector from the result of getActiveTransformationTo(target)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[0]

    def getActiveRotationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)

        extracts rotation vector from the result of getActiveTransformationTo(targetFrame)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[1]

    def getActiveTransformationFrom(self, source):
        &#34;&#34;&#34;
        Applying this transformation to the ``source`` ReferenceFrame
        would render it identical to self.

        Applying this transformation to a point defined in source
        would move it to the same coordinates in self.

        :param source: is a ReferenceFrame object

        :return: the transformation matrix that defines this reference frame in ``source``,
            i.e. the transformation from ``source`` to ``self``

        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;ACTIVE FROM self {self.name} source {source.name}&#34;)
        return self.getPassiveTransformationTo(source)

    def getActiveTranslationRotationVectorsFrom(
        self, source, degrees=True
    ):  # ,active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsFrom(self,source, degrees=True)

        extracts rotation vector from the result of getActiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getActiveTransformationFrom(source)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getActiveTranslationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationVectorFrom(self,source, degrees=True)

        extracts translation vector from the result of getActiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsFrom(source, degrees=degrees)[0]

    def getActiveRotationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsFrom(self,source,degrees=True)

        extracts rotation vector from the result of getActiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsFrom(source, degrees=degrees)[1]

    def _findEnds(self, frame, visited=[], ends=[], verbose=True, level=1):
        &#34;&#34;&#34;
        PURPOSE
        Identify the &#39;linked_frames&#39;:
            frames that are linked, either directly or indirectly (via mult. links) to &#34;frame&#34;
            --&gt; returned as visited
        Identify subset of &#39;linked_frames of which the reference does not belong to linked_frames
            --&gt; returned as &#39;finalEnds&#39;
        &#34;&#34;&#34;
        LOGGER.flash_flood(
            f&#34;{level:-2d}{2*level*&#39; &#39;} Current: {frame.name} --  ends: {[f.name for f in ends]} -- visited {[f.name for f in visited]}&#34;
        )
        # if verbose: print (f&#34;{level:-2d}{2*level*&#39; &#39;} Current: {frame.name} --  ends: {[f.name for f in ends]} -- visited {[f.name for f in visited]}&#34;)

        # Establish the set of &#39;linked_frames&#39; (variable &#39;visited&#39;)
        # The recursive process below keeps unwanted (non-endFrames), namely the
        # frames that are not directly, but well indirectly linked to their reference
        # This case is solved further down
        if frame not in visited:
            visited.append(frame)
            if verbose and level:
                level += 1
            if frame.ref not in frame.linkedTo:
                ends.append(frame)
                LOGGER.flash_flood(f&#34;{(10+2*level)*&#39; &#39;}{frame.name}: new end&#34;)
                # if verbose: LOGGER.info(f&#34;{(10+2*level)*&#39; &#39;}{frame.name}: new end&#34;)
            for linkedFrame in frame.linkedTo:
                ends, visited = self._findEnds(
                    linkedFrame, visited=visited, ends=ends, verbose=verbose, level=level
                )

        # If frame.ref was linked to frame via an indirect route, reject it
        finalEnds = []
        for aframe in ends:
            if aframe.ref not in ends:
                finalEnds.append(aframe)
        return finalEnds, visited

    def setTransformation(
        self, transformation, updated=None, preserveLinks=True, _relative=False, verbose=True
    ):
        &#34;&#34;&#34;
        setTransformation(self,transformation, updated=None, preserveLinks=True,_relative=False, verbose=True)

        Alter the definition of this coordinate system

        If other systems are linked to this one, their definition must be updated accordingly
          The link set between two ref. Frames A &amp; B is the active transformation matrix from A to B
          A.addLink(B, matrix)
          A.getActiveTransformationTo(B) --&gt; matrix

        The way to update the definition of the present system, and of those linked to it
        depends on the structure of those links.

        We define
        - the target frame as the one we want to move / redefine
        - &#39;linkedFrames&#39; as those directly, or indirectly (i.e. via multiple links)
           linked to the target frame
        - endFrames as the subset of linkedFrames which are not linked to their reference (directly or indirectly)
        - sideFrames as the set of frames whose reference is a linkedFrame, but not themselves belonging to the linkedFrames

        We can demonstrate that updating the endFrames (Block A below) is sufficient to represent
        the movement of the target frame and all frames directly or indirectly linked to it.

        This may nevertheless have perverse effects for sideFrames. Indeed,
        their reference will (directly or implicitely) be redefined, but they shouldn&#39;t:
        they are not linked to their reference --&gt; their location in space (e.g. wrt the master frame)
        should not be affected by the movement of the target frame. This is the aim of block B.

        For a completely robust solution, 2 steps must be taken
        BLOCK A. apply the rigt transformation to all &#34;endFrames&#34;
        BLOCK B. Check for frames
                       using any of the &#34;visited&#34; frames as a reference
                       not linked to its reference
            Correct its so that it doesn&#39;t move (it shouldn&#39;t be affected by the requested movement)
            This demands a &#34;referenceFor&#34; array property

        &#34;&#34;&#34;
        # Ruthless, enforced redefinition of one system. Know what you do, or stay away.
        # Semi-unpredictible side effets if the impacted frame has links!
        if preserveLinks == False:
            self.transformation = transformation
            return

        if updated is None:
            updated = []

        # visitedFrames = all frames which can be reached from self via invariant links
        # endFrames = subset of visitedFrames that are at the end of a chain, and must be updated
        #             in order to properly represent the requested movement
        endFrames, visitedFrames = self._findEnds(frame=self, visited=[], ends=[], verbose=verbose)
        if verbose:
            LOGGER.info(
                f&#34;Visited sub-system                      {[f.name for f in visitedFrames]}&#34;
            )
            LOGGER.info(f&#34;End-frames (movement necessary)         {[f.name for f in endFrames]}&#34;)

        # All updates are done by relative movements
        # so we must first compute the relative movement corresponding to the requested absolute movement
        if _relative == False:
            ## virtual = what self should become after the (absolute) movement
            ## it allows to compute the relative transformation to be applied and work in relative further down
            virtual = ReferenceFrame(
                transformation, ref=self.ref, name=&#34;virtual&#34;, rot_config=self.rot_config
            )
            request = self.getActiveTransformationTo(virtual)
            del virtual
        else:
            # If this method is called by applyTransformation,
            # we are facing a request for a relative movement
            # In that case the input is directly what we want
            request = transformation

        # BLOCK B. Check for frames that were impacted but shouldn&#39;t have been and correct them
        # B1. List of frames demanding a correction
        #     &#39;impacted&#39; are frames having their reference inside the rigid structure moving, but not linked to it
        #     If nothing is done, the movement will implicitely displace them, which is not intended

        ### Impacted shall not contain frames that are linked to self (== to any frame in visitedFrames) via any route...
        ### We check if the impacted frames are in visitedFrames:
        ### it is enough to know it&#39;s connected to the entire &#39;solid body&#39; in which self belongs
        impacted = []
        for frame in visitedFrames:
            for child in frame.referenceFor:
                # Version 1 : too simple (restores too many frames)
                #if child not in frame.linkedTo:

                # Version 2 : overkill
                #child_ends, child_visited = child._findEnds(frame=child,visited=[],ends=[],verbose=verbose)
                #if frame not in child_visited:

                # Version 3 : just check if the child belongs to the rigid structure...
                if child not in visitedFrames:
                    impacted.append(child)

        LOGGER.debug(f&#34;Impacted (not moving, defined in moving) {[f.name for f in impacted]}&#34;)

        # B2. save the location of all impacted frames
        # tempReference has the only purpose of avoiding that every frame must know the master
        # It could be any frame without links and defined wrt the master, but the master isn&#39;t known here...
        # TODO : confirm that the master isn&#39;t known (e.g. via cls._MASTER)
        tempMaster = self.findMaster()
        toRestore = {}
        for frame in impacted:
            toRestore[frame] = ReferenceFrame(
                frame.getActiveTransformationFrom(tempMaster),
                ref=tempMaster,
                name=frame.name + &#34;toRestore&#34;,
                rot_config=frame.rot_config,
            )

        # BLOCK A. apply the rigt transformation to all &#34;endFrames&#34;
        &#34;&#34;&#34;
        ### Ensure that &#34;Untouched&#34; remains unaffected regardless of the update order of the endFrames
        selfUntouched = ReferenceFrame(
            transformation = self.getActiveTransformationFrom(tempMaster),
            ref=tempMaster,
            name=self.name + &#34;_fixed&#34;,
            rot_config=self.rot_config,
        )
        &#34;&#34;&#34;

        selfUntouched = ReferenceFrame(
            transformation=self.transformation,
            ref=self.ref,
            name=self.name + &#34;_fixed&#34;,
            rot_config=self.rot_config,
        )

        for bottom in endFrames:

            up = bottom.getActiveTransformationTo(selfUntouched)
            down = selfUntouched.getActiveTransformationTo(bottom)

            relativeTransformation = up @ request @ down

            LOGGER.flash_flood(
                f&#34;\nAdjusting {bottom.name} to {self.name}\nUpdated {[i.name for i in updated]}&#34;
            )
            LOGGER.flash_flood(f&#34;\ninput transformation \n{np.round(transformation,3)}&#34;)
            LOGGER.flash_flood(
                f&#34;\nup \n{np.round(up,3)}\ntransformation\n{np.round(request,3)}\ndown\n{np.round(down,3)}&#34;
            )
            LOGGER.flash_flood(f&#34;\nrelativeTransformation \n{np.round(relativeTransformation,3)}&#34;)

            bottom.transformation = bottom.transformation @ relativeTransformation

            updated.append(bottom)

        for frame in visitedFrames:
            if frame not in updated:
                updated.append(frame)

        # Block B
        # B3. Correction
        # we must set preserveLinks to False to prevent cascading impact from this update
        # if X1 is impacted with
        #    X1.ref = E1     X1 --&gt; X2 (simple link)    E2.ref = X2
        # where X1 and X2 are &#34;external frames&#34; and E1 and E2 are &#34;endFrames&#34; that will hence move
        # X1 was impacted by the move of E1, but X2 wasn&#39;t
        # ==&gt; wrt master, neither X1 nor X2 should have moved, but X1 did (via its ref)
        # and hence its link with X2 is now corrupt
        # We need to move X1 back to its original location wrt master
        # if we preserved the links while doing that,
        # we will move X2, which shouldn&#39;t move
        # (it didn&#39;t have to, it didn&#39;t and the goal is to restore the validity of the links)
        #
        # Direct restoration or the impacted frames at their original location

        for frame in toRestore:
            frame.transformation = frame.ref.getActiveTransformationTo(toRestore[frame])

        del toRestore

        return

    def setTranslationRotation(
        self,
        translation,
        rotation,
        rot_config=_ROT_CONFIG_DEFAULT,
        active=_ACTIVE_DEFAULT,
        degrees=True,
        preserveLinks=True,
    ):
        &#34;&#34;&#34;
        setTranslationRotation(self,translation,rotation,rot_config=_ROT_CONFIG_DEFAULT, active=_ACTIVE_DEFAULT, degrees=True, preserveLinks=True)

        Same as setTransformation, but input = translation and rotation vectors rather than affine transformation matrix
        &#34;&#34;&#34;
        # Translation
        translation = np.array(translation)
        # Zoom - unit
        zdef = np.array([1, 1, 1])
        # Shear
        sdef = np.array([0, 0, 0])
        # Rotation
        if degrees:
            rotation = np.array([np.deg2rad(item) for item in rotation])

        rotx, roty, rotz = rotation

        rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)

        LOGGER.flash_flood(t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef))

        transformation = t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef)

        self.setTransformation(transformation, preserveLinks=preserveLinks, _relative=False)
        return

    def applyTransformation(self, transformation, updated=None, preserveLinks=True):
        &#34;&#34;&#34;
        applyTransformation(self,transformation)

        Applies the transformation to the current reference frame&#39;s definition

        self.transformation := transformation @ self.transformation
        &#34;&#34;&#34;
        if updated is None:
            updated = []

        self.setTransformation(
            transformation=transformation,
            updated=updated,
            preserveLinks=preserveLinks,
            _relative=True,
        )

    def applyTranslationRotation(
        self,
        translation,
        rotation,
        rot_config=None,
        active=_ACTIVE_DEFAULT,
        degrees=True,
        preserveLinks=True,
    ):
        &#34;&#34;&#34;
        applyTranslationRotation(self,translation,rotation,rot_config=None,active=_ACTIVE_DEFAULT,degrees=True, preserveLinks=True)

        Builds transformation from input translation and rotation, then applies this transformation
        &#34;&#34;&#34;
        if rot_config is None:
            rot_config = self.rot_config

        # Translation
        translation = np.array(translation)
        # Zoom - unit
        zdef = np.array([1, 1, 1])
        # Shear
        sdef = np.array([0, 0, 0])
        # Rotation
        if degrees:
            rotation = np.array([np.deg2rad(item) for item in rotation])
        rotx, roty, rotz = rotation
        #
        rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)
        #
        transformation = t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef)
        #
        self.applyTransformation(transformation, preserveLinks=preserveLinks)
        return

    def getAxis(self, axis, name=None):
        &#34;&#34;&#34;
        INPUT
        axis : in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]

        OUTPUT
        Returns an object of class Point, corresponding to the vector defining
        the axis of choice in self.
        The output can be used with the Point methods to express that axis in any reference frame
        &#34;&#34;&#34;
        haxis = {}
        haxis[&#34;x&#34;] = [1, 0, 0]
        haxis[&#34;y&#34;] = [0, 1, 0]
        haxis[&#34;z&#34;] = [0, 0, 1]
        if name is None:
            name = self.name + axis
        return Point(haxis[axis], ref=self, name=name)

    def getNormal(self, name=None):
        &#34;&#34;&#34;
        getNormal(self,name=None)

        Returns a unit vector normal to the X-Y plane (= [0,0,1] = getAxis(&#39;z&#39;))
        &#34;&#34;&#34;
        return Point([0, 0, 1], ref=self, name=name)

    def getOrigin(self, name=None):
        &#34;&#34;&#34;
        OUTPUT
        Returns an object of class Point, corresponding to the vector defining the origin in &#39;self&#39;, i.e. [0,0,0]
        The output can be used with the Point methods to express that axis in any reference frame
        &#34;&#34;&#34;
        return Point([0, 0, 0], ref=self, name=name)

    def is_master(self):
        return self.isMaster()

    def isMaster(self):
        &#34;&#34;&#34;
        A Master reference frame is a reference frame that refers to itself, and the
        transformation is the Identity matrix.
        &#34;&#34;&#34;
        tr = self.transformation

        if (
            (self.name == self.ref.name)
            and (tr.shape[0] == tr.shape[1])
            and np.allclose(tr, np.eye(tr.shape[0]))
        ):
            return True
        return False

    def isSame(self, other):
        &#34;&#34;&#34;
        Returns True if the two reference frames are the same except for their name.

        Two Reference Frames are considered the same when:

        * their transformation matrices are equal
        * the reference frame is equal
        * the rot_config is equal
        * the name may be different

        .. todo:: This needs further work and testing!
        &#34;&#34;&#34;

        if other is self:
            LOGGER.debug(
                &#34;self and other are the same object (beware: this message might occur with recursion from self.ref != self.other)&#34;
            )
            return True

        if isinstance(other, ReferenceFrame):
            LOGGER.flash_flood(f&#34;comparing {self.name} and {other.name}&#34;)
            if not np.array_equal(self.transformation, other.transformation):
                LOGGER.flash_flood(&#34;self.transformation not equals other.transformation&#34;)
                return False
            if self.rot_config != other.rot_config:
                LOGGER.flash_flood(&#34;self.rot_config not equals other.rot_config&#34;)
                return False
            # The following tests are here to prevent recursion to go infinite when self and other
            # point to itself
            if self.ref is self and other.ref is other:
                LOGGER.flash_flood(&#34;both self.ref and other.ref point to themselves&#34;)
                pass
            else:
                LOGGER.flash_flood(&#34;one of self.ref or other.ref doesn&#39;t points to itself&#34;)
                if self.ref != other.ref:
                    LOGGER.flash_flood(&#34;self.ref not equals other.ref&#34;)
                    return False
            if self.name is not other.name:
                LOGGER.flash_flood(
                    f&#34;When checking two reference frames for equality, only their names differ: &#39;{self.name}&#39; not equals &#39;{other.name}&#39;&#34;
                )
                pass
            return True
        return NotImplemented

    def __eq__(self, other):
        &#34;&#34;&#34;
        Overrides the default implementation, which basically checks for id(self) == id(other).

        Two Reference Frames are considered equal when:

        * their transformation matrices are equal
        * the reference frame is equal
        * the rot_config is equal
        * do we want to insist on the name being equal?
          YES - for strict testing
          NO  - this might need a new method like isSame(self, other) where the criteria are relaxed


        .. todo:: This needs further work and testing!
        &#34;&#34;&#34;

        if other is self:
            LOGGER.debug(
                &#34;self and other are the same object (beware: this message might occur with recursion from self.ref != self.other)&#34;
            )
            return True

        if isinstance(other, ReferenceFrame):
            LOGGER.flash_flood(f&#34;comparing {self.name} and {other.name}&#34;)
            if not np.array_equal(self.transformation, other.transformation):
                LOGGER.flash_flood(&#34;self.transformation not equals other.transformation&#34;)
                return False
            if self.rot_config != other.rot_config:
                LOGGER.flash_flood(&#34;self.rot_config not equals other.rot_config&#34;)
                return False
            # The following tests are here to prevent recursion to go infinite when self and other
            # point to itself
            if self.ref is self and other.ref is other:
                LOGGER.flash_flood(&#34;both self.ref and other.ref point to themselves&#34;)
                pass
            else:
                LOGGER.flash_flood(&#34;one of self.ref or other.ref doesn&#39;t points to itself&#34;)
                if self.ref != other.ref:
                    LOGGER.flash_flood(&#34;self.ref not equals other.ref&#34;)
                    return False
            if self.name is not other.name:
                LOGGER.flash_flood(
                    f&#34;When checking two reference frames for equality, only their names differ: &#39;{self.name}&#39; not equals &#39;{other.name}&#39;&#34;
                )
                return False
            return True
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        hash_number = (id(self.rot_config) + id(self.ref) + id(self.name)) // 16
        return hash_number

    def __copy__(self):

        LOGGER.debug(
            f&#39;Copying {self!r} unless {self.name} is &#34;Master&#34; in which case the Master itself is returned.&#39;
        )

        if self.isMaster():
            LOGGER.debug(f&#34;Returning Master itself instead of a copy.&#34;)
            return self

        return ReferenceFrame(self.transformation, self.ref, self.name, self.rot_config)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.coordinates.referenceFrame.transformationToString"><code class="name flex">
<span>def <span class="ident">transformationToString</span></span>(<span>transformation)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function: prints out a transformation (numpy ndarray) in a condensed form on one line.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transformationToString(transformation):
    &#34;&#34;&#34;Helper function: prints out a transformation (numpy ndarray) in a condensed form on one line.&#34;&#34;&#34;

    if isinstance(transformation, np.ndarray):
        if np.allclose(transformation, ReferenceFrame._I):
            return &#34;Identity&#34;
        msg = np.array2string(
            transformation,
            separator=&#34;,&#34;,
            suppress_small=True,
            formatter={&#34;float_kind&#34;: lambda x: &#34;%.2f&#34; % x},
        ).replace(&#34;\n&#34;, &#34;&#34;)
        return msg

    # We do not want to raise an Exception here since this is mainly used in logging messages
    # and doesn&#39;t really harm the execution of the program.
    return f&#34;ERROR: expected transformation to be an ndarray, type={type(transformation)}&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame"><code class="flex name class">
<span>class <span class="ident">ReferenceFrame</span></span>
<span>(</span><span>transformation, ref, name=None, rot_config='sxyz')</span>
</code></dt>
<dd>
<div class="desc"><p>A Reference Frame defined in reference frame "ref", i.e.
defined by the affine transformation bringing the reference frame "ref" onto "self".</p>
<p>By default, "ref" is the master refence frame, defined as the identity matrix.</p>
<p>:param transformation: 4x4 affine transformation matrix defining this system in "ref" system
:type transformation: numpy array</p>
<p>:param ref: reference system in which this new reference frame is defined
:type ref: ReferenceFrame</p>
<p>:param name: name the reference frame so it can be referenced, set to 'master' when None
:type name: str</p>
<p>:param rot_config:
* Is set when using creator ReferenceFrame.fromTranslationRotation()
* In other cases, is set to a default "szyx"
(rotations around static axes z, y and x in this order)
In these other cases, it has no real direct influence,
except for methods returning the rotation vector (e.g. getRotationVector)
It is therefore always recommended to pass it to the constructor, even when
constructing the ReferenceFrame directly from a transformation matrix
:type rot_config: str</p>
<p>Both the <code>transformation</code> and the <code>ref</code> parameters are mandatory.</p>
<p>If the reference frame is None, the master reference frame is created.</p>
<p>The master reference frame:</p>
<pre><code>* is defined by the identity transformation matrix
* has itself as a reference
</code></pre>
<p>For convenience we provide the following factory methods:</p>
<p>createMaster()
Create a Master Reference Frame</p>
<p>createRotation(..)
Create a new Reference Frame that is rotated with respect to the given reference frame</p>
<p>createTranslation(..)
Create a new Reference Frame that is a translation with respect to the given reference frame</p>
<p>Initialize the ReferenceFrame object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenceFrame(object):
    &#34;&#34;&#34;
    A Reference Frame defined in reference frame &#34;ref&#34;, i.e.
    defined by the affine transformation bringing the reference frame &#34;ref&#34; onto &#34;self&#34;.

    By default, &#34;ref&#34; is the master refence frame, defined as the identity matrix.

    :param transformation: 4x4 affine transformation matrix defining this system in &#34;ref&#34; system
    :type transformation: numpy array

    :param ref: reference system in which this new reference frame is defined
    :type ref: ReferenceFrame

    :param name: name the reference frame so it can be referenced, set to &#39;master&#39; when None
    :type name: str

    :param rot_config:
            * Is set when using creator ReferenceFrame.fromTranslationRotation()
            * In other cases, is set to a default &#34;szyx&#34;
              (rotations around static axes z, y and x in this order)
              In these other cases, it has no real direct influence,
              except for methods returning the rotation vector (e.g. getRotationVector)
              It is therefore always recommended to pass it to the constructor, even when
              constructing the ReferenceFrame directly from a transformation matrix
    :type rot_config: str

    Both the ``transformation`` and the ``ref`` parameters are mandatory.

    If the reference frame is None, the master reference frame is created.

    The master reference frame:

        * is defined by the identity transformation matrix
        * has itself as a reference

    For convenience we provide the following factory methods:

    createMaster()
        Create a Master Reference Frame

    createRotation(..)
        Create a new Reference Frame that is rotated with respect to the given reference frame

    createTranslation(..)
        Create a new Reference Frame that is a translation with respect to the given reference frame
    &#34;&#34;&#34;

    _I = np.identity(4)
    _MASTER = None
    _ROT_CONFIG_DEFAULT = &#34;sxyz&#34;
    _names_used = [None, &#34;Master&#34;]
    _strict_naming = False
    _ACTIVE_DEFAULT = True

    def __new__(cls, transformation, ref, name=None, rot_config=_ROT_CONFIG_DEFAULT):
        &#34;&#34;&#34;Create a new ReferenceFrame class.&#34;&#34;&#34;

        LOGGER.debug(
            f&#34;transformation={transformationToString(transformation)}, ref={ref!r}, name={name}, rot_config={rot_config}&#34;
        )

        if ref is None:
            msg = (
                &#34;No reference frame was given, if you planned to create a Master Reference Frame, &#34;
                &#34;use ReferenceFrame.createMaster(). &#34;
            )
            LOGGER.error(msg)
            raise ValueError(msg, &#34;REF_IS_NONE&#34;)

        if not isinstance(ref, cls):
            msg = f&#34;The &#39;ref&#39; keyword argument is not a ReferenceFrame object, but {type(ref)}&#34;
            LOGGER.error(msg)
            raise ValueError(msg, &#34;REF_IS_NOT_CLS&#34;)

        if name == &#34;Master&#34;:
            msg = (
                &#34;The &#39;name&#39; argument cannot be &#39;Master&#39; unless a Master instance should be created, &#34;
                &#34;in that case, use ReferenceFrame.createMaster()&#34;
            )
            LOGGER.error(msg)
            raise ValueError(msg, &#34;MASTER_NAME_USED&#34;)

        if transformation is None:
            msg = &#34;The &#39;transformation&#39; argument can not be None, please provide a proper transformation for this reference frame.&#34;
            LOGGER.error(msg)
            raise ValueError(msg, &#34;TRANSFORMATION_IS_NONE&#34;)

        if not isinstance(transformation, np.ndarray):
            msg = f&#34;The &#39;transformation&#39; argument shall be a Numpy ndarray [not a {type(transformation)}], please provide a proper transformation for this reference frame.&#34;
            LOGGER.error(msg)
            raise ValueError(msg, &#34;TRANSFORMATION_IS_NOT_NDARRAY&#34;)

        if rot_config is None:
            msg = &#34;The &#39;rot_config&#39; keyword argument can not be None, do not specify it when you want to use the default value.&#34;
            LOGGER.error(msg)
            raise ValueError(msg)

        _instance = super(ReferenceFrame, cls).__new__(cls)

        return _instance

    def __init__(self, transformation, ref, name=None, rot_config=_ROT_CONFIG_DEFAULT):
        &#34;&#34;&#34;Initialize the ReferenceFrame object &#34;&#34;&#34;

        self.debug = False

        LOGGER.debug(
            f&#34;transformation={transformationToString(transformation)}, ref={ref!r}, name={name}, rot_config={rot_config}&#34;
        )

        # All argument testing is done in the __new__() method and we should be save here.

        self.ref = ref
        self.name = self.__createName(name)
        self.transformation = transformation
        self.rot_config = rot_config

        self.definition = [self.transformation, self.ref, self.name]

        self.x = self.getAxis(&#34;x&#34;)
        self.y = self.getAxis(&#34;y&#34;)
        self.z = self.getAxis(&#34;z&#34;)

        self.linkedTo = {}
        self.referenceFor = []

        ref.referenceFor.append(self)

        return

    def find_master(self):
        return self.findMaster()

    def findMaster(self):
        &#34;&#34;&#34;
        Returns the Master frame for this reference frame. The Master frame is always at the end
        of the path following the references.

        Returns:
            The master frame.
        &#34;&#34;&#34;

        frame = self
        while not frame.isMaster():
            frame = frame.ref
        return frame

    @classmethod
    def createMaster(cls):
        &#34;&#34;&#34;
        Create a master reference frame.

        A master reference frame is defined with respect to itself and is initialised with the
        identity matrix.

        The master frame is automatically given the name &#34;Master&#34;.
        &#34;&#34;&#34;
        ref_master = super(ReferenceFrame, cls).__new__(cls)
        ref_master.name = &#34;Master&#34;
        ref_master.ref = ref_master
        ref_master.transformation = cls._I
        ref_master.rot_config = cls._ROT_CONFIG_DEFAULT
        ref_master.initialized = True
        ref_master.debug = False
        ref_master.linkedTo = {}
        ref_master.referenceFor = []

        LOGGER.debug(
            f&#34;NEW MASTER CREATED: {id(ref_master)}, ref = {id(ref_master.ref)}, &#34;
            f&#34;name = {ref_master.name}&#34;
        )

        return ref_master

    @classmethod
    def __createName(cls, name: str = None):

        if name is None:
            while name in cls._names_used:
                name = &#34;F&#34; + &#34;&#34;.join(random.choices(string.ascii_uppercase, k=3))
            return name

        if cls._strict_naming:

            # generate a unique name

            old_name = name

            while name in cls._names_used:
                name = &#34;F&#34; + &#34;&#34;.join(random.choices(string.ascii_uppercase, k=3))

            LOGGER.warning(
                f&#34;name (&#39;{old_name}&#39;) is already defined, since strict naming is applied, &#34;
                f&#34;a new unique name was created: {name}&#34;
            )

        else:

            if name in cls._names_used:
                LOGGER.log(
                    0,
                    f&#34;name (&#39;{name}&#39;) is already defined, now you have more than one &#34;
                    f&#34;ReferenceFrame with the same name.&#34;,
                )

        cls._names_used.append(name)
        return name

    @classmethod
    def fromTranslation(cls, transx, transy, transz, ref, name=None):
        &#34;&#34;&#34;
        Create a ReferenceFrame from a translation with respect to the given reference frame.

        :param transx: translation along the x-axis
        :type transx: float

        :param transy: translation along the y-axis
        :type transy: float

        :param transz: translation along the z-axis
        :type transz: float

        :param ref: reference frame with respect to which the translation is performed. If no ref is given
            the rotation is with respect to the master reference frame
        :type ref: ReferenceFrame

        :param name: a simple convenient name to identify the reference frame. If no name is provided
                     a random name of four characters starting with &#39;F&#39; will be generated.
        :type name: str

        :return: a reference frame
        &#34;&#34;&#34;
        adef = np.identity(4)
        adef[:3, 3] = [transx, transy, transz]

        if ref is None:
            raise ValueError(
                &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
            )

        return cls(transformation=adef, ref=ref, name=name)

    @classmethod
    def fromRotation(
        cls,
        rotx,
        roty,
        rotz,
        ref,
        name=None,
        rot_config=_ROT_CONFIG_DEFAULT,
        active=_ACTIVE_DEFAULT,
        degrees=True,
    ):
        &#34;&#34;&#34;
        Create a ReferenceFrame from a rotation with respect to the given reference frame.

        :param rotx: rotation around the x-axis
        :type rotx: float

        :param roty: rotation around the y-axis
        :type roty: float

        :param rotz: rotation around the z-axis
        :type rotz: float

        :param ref: reference frame with respect to which the rotation is performed. If no ref is given
            the rotation is with respect to the master reference frame
        :type ref: ReferenceFrame

        :param name: a simple convenient name to identify the reference frame. If no name is provided
                     a random name of four characters starting with &#39;F&#39; will be generated.
        :type name: str

        :return: a reference frame
        &#34;&#34;&#34;
        # Convention (rotating axes, in order xyz)

        # rot_config = cls._ROT_CONFIG_DEFAULT

        # Rotation amplitude

        # Rotation
        if degrees:
            rotx = np.deg2rad(rotx)
            roty = np.deg2rad(roty)
            rotz = np.deg2rad(rotz)

        rotation = RotationMatrix(rotx, roty, rotz, rot_config, active=active)

        # Defaults for zoom &amp; shear

        zdef = np.array([1, 1, 1])
        sdef = np.array([0, 0, 0])

        translation = [0, 0, 0]

        TT = t3.affines.compose(T=translation, R=rotation.R, Z=zdef, S=sdef)

        if ref is None:
            raise ValueError(
                &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
            )

        return cls(transformation=TT, ref=ref, name=name, rot_config=rot_config)

    @staticmethod
    def fromPoints(points, plane=&#34;xy&#34;, name=None, usesvd=True, verbose=True):
        &#34;&#34;&#34;
        fromPoints(points, plane=&#34;xy&#34;, name=None, usesvd=True,verbose=True)

        Finds the best fitting &#34;plane&#34; plane to all points in &#34;points&#34; and builds a ReferenceFrame
        considering the fitted plane as the &#39;xy&#39; plane of the new system

        fitPlane must be in [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;]
        &#34;&#34;&#34;
        return points.bestFittingPlane(fitPlane=plane, usesvd=usesvd, verbose=verbose)

    @classmethod
    def fromTranslationRotation(
        cls,
        translation,
        rotation,
        ref,
        name=None,
        rot_config=_ROT_CONFIG_DEFAULT,
        active=_ACTIVE_DEFAULT,
        degrees=True,
    ):
        &#34;&#34;&#34;fromTranslationRotation(cls,translation,rotation, ref=None,name=None, rot_config=_ROT_CONFIG_DEFAULT,active=_ACTIVE_DEFAULT, degrees=True)

        Construct a ReferenceFrame from a translation and a rotation (vectors!)

        translation : translation vector : 3 x 1 = tx, ty, tz
        rotation    : rotation vector    : 3 x 1 = rx, ry, rz

        rot_config : convention for the rotation, see rotationMatrix.__doc__

        degrees : if True, input values are assumed in degrees, otherwise radians
        &#34;&#34;&#34;
        # Translation
        translation = np.array(translation)
        # Zoom - unit
        zdef = np.array([1, 1, 1])
        # Shear
        sdef = np.array([0, 0, 0])
        # Rotation
        if degrees:
            rotation = np.array([np.deg2rad(item) for item in rotation])
        rotx, roty, rotz = rotation
        #
        rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)
        #
        # transformation = t3.affines.compose(translation,rmat.R,Z=zdef,S=sdef)

        if ref is None:
            raise ValueError(
                &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
            )

        return cls(
            transformation=t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef),
            ref=ref,
            name=name,
            rot_config=rot_config,
        )

    def getTranslationVector(self):
        &#34;&#34;&#34;
        getTranslationVector()

        Returns the translation defining this reference frame (from self.ref to self)
        &#34;&#34;&#34;
        return self.transformation[:3, 3]

    def getRotationVector(self, degrees=True, active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getRotationVector()

        Returns the rotation (vector) defining this reference frame (from self.ref to self)
        degrees : if true, rotation angles are expressed in degrees
        &#34;&#34;&#34;
        rotation = t3.euler.mat2euler(self.transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        return rotation

    def getTranslationRotationVectors(self, degrees=True, active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;getTranslationRotationVectors()
        Returns the translation and rotation (vectors) defining this reference frame (from self.ref to self)
        degrees : if true, rotation angles are expressed in degrees
        &#34;&#34;&#34;
        translation = self.getTranslationVector()
        rotation = self.getRotationVector(degrees=degrees, active=active)
        return translation, rotation

    def getRotationMatrix(self):
        &#34;&#34;&#34;
        getRotationMatrix()

        Returns the rotation (matrix) defining this reference frame (from self.ref to self)
        &#34;&#34;&#34;
        result = self.transformation.copy()
        result[:3, 3] = [0.0, 0.0, 0.0]
        return result

    def __repr__(self):
        return f&#34;ReferenceFrame(transformation={transformationToString(self.transformation)}, ref={self.ref.name}, name={self.name}, rot_config={self.rot_config})&#34;

    def __str__(self):
        msg = textwrap.dedent(
            f&#34;&#34;&#34;\
                ReferenceFrame
                name          : {self.name}
                reference     : {self.ref.name}
                rot_config    : {self.rot_config}
                links         : {[key.name for key in self.linkedTo.keys()]}
                transformation:
                  [{np.round(self.transformation[0], 3)}
                   {np.round(self.transformation[1], 3)}
                   {np.round(self.transformation[2], 3)}
                   {np.round(self.transformation[3], 3)}]
                translation   : {np.round(self.getTranslationVector(),3)}
                rotation      : {np.round(self.getRotationVector(),3)}&#34;&#34;&#34;
        )
        return msg

    @deprecate(
        reason=(
            &#34;I do not see the added value of changing the name and &#34;
            &#34;the current method has the side effect to change the name &#34;
            &#34;to a random string when the name argument is already used.&#34;
        ),
        alternative=&#34;the constructor argument to set the name already of the object.&#34;,
    )
    def setName(self, name=None):
        &#34;&#34;&#34;
        Set or change the name of a reference frame.

        ..note: this method is deprecated

        :param str name: the new name for the reference frame, if None, a random name will be generated.

        :raises InvalidOperationError: when you try to change the name of the Master reference frame
        &#34;&#34;&#34;
        if self.isMaster():
            raise InvalidOperationError(
                &#34;You try to change the name of the Master reference frame, which is not allowed.&#34;
            )
        self.name = self.__createName(name)

    def addLink(self, ref, transformation=None, _stop=False):
        &#34;&#34;&#34;
        adds a link between self and ref in self.linkedTo and ref.linkedTo
        &#34;&#34;&#34;

        # DONE: set the inverse transformation in the ref to this
        #   ref.linkedTo[self] = t3add.affine_inverse(transformation)
        # TODO:
        #   remove the _stop keyword

        # TODO: deprecate transformation as an input variable
        #       linkedTo can become a list of reference frames, with no transformation
        #       associated to the link. The tfo associated to a link is already
        #       checked in real time whenever the link is addressed
        if transformation is None:
            transformation = self.getActiveTransformationTo(ref)
        else:
            LOGGER.info(&#34;Deprecation warning: transformation will be automatically set to &#34;
                        &#34;the current relation between {self.name} and {ref.name}&#34;)
            LOGGER.flash_flood(&#34;Requested:&#34;)
            LOGGER.flash_flood(np.round(transformation, decimals=3))
            LOGGER.flash_flood(&#34;Auto (enforced):&#34;)

            transformation = self.getActiveTransformationTo(ref)

            LOGGER.flash_flood(np.round(transformation, decimals=3))

        self.linkedTo[ref] = transformation

        # TODO simplify this when transformation is deprecated
        #      it becomes ref.linkedTo[self] = ref.getActiveTransformationTo(self)
        ref.linkedTo[self] = t3add.affine_inverse(transformation)

    def removeLink(self, ref):
        &#34;&#34;&#34;
        Remove the link between self and ref, both ways.
        &#34;&#34;&#34;

        # First remove the entry in ref to this

        if self in ref.linkedTo:
            del ref.linkedTo[self]

        # Then remove the entry in this to ref

        if ref in self.linkedTo:
            del self.linkedTo[ref]

    def getPassiveTransformationTo(self, targetFrame):
        &#34;&#34;&#34;
        getPassiveTransformationTo(self,targetFrame)
        == getPointTransformationTo(self,targetFrame)

        returns the transformation to apply to a Point (defined in self) to express it in targetFrame

        Passive transformation : the point is static, we change the reference frame around it
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;PASSIVE TO self {self.name} target {targetFrame.name}&#34;)
        if targetFrame is self:
            &#34;&#34;&#34;
            Nothing to do here, we already have the right coordinates
            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;case 1&#34;)
            result = np.identity(4)

        elif targetFrame.ref is self:
            &#34;&#34;&#34;
            The target frame is defined in self =&gt; the requested transformation is the targetFrame definition
            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;=== 2 start ===&#34;)
            result = t3add.affine_inverse(targetFrame.transformation)
            LOGGER.flash_flood(&#34;=== 2 end   ===&#34;)
        elif targetFrame.ref is self.ref:
            &#34;&#34;&#34;
            targetFrame and self are defined wrt the same reference frame
            We want
            self --&gt; targetFrame
            We know
            targetFrame.ref --&gt; targetFrame (= targetFrame.transformation)
            self.ref   --&gt; self   (= self.transformation)
            That is
            self --&gt; self.ref is targetFrame.ref --&gt; targetFrame
            inverse(definition)    targetFrame definition

            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;=== 3 start ===&#34;)
            LOGGER.flash_flood(&#34; ref   \n{0}&#34;.format(self.ref))
            LOGGER.flash_flood(&#34;===&#34;)
            LOGGER.flash_flood(&#34;self   \n{0}&#34;.format(self))
            LOGGER.flash_flood(&#34;===&#34;)
            LOGGER.flash_flood(&#34;targetFrame \n{0}&#34;.format(targetFrame))
            LOGGER.flash_flood(&#34;===&#34;)

            selfToRef = self.transformation
            LOGGER.flash_flood(&#34;selfToRef \n{0}&#34;.format(selfToRef))

            # refToRef = I

            refToTarget = t3add.affine_inverse(targetFrame.transformation)
            LOGGER.flash_flood(&#34;refToTarget \n{0}&#34;.format(refToTarget))

            result = np.dot(refToTarget, selfToRef)
            LOGGER.flash_flood(&#34;result \n{0}&#34;.format(result))
            LOGGER.flash_flood(&#34;=== 3 end   ===&#34;)
        else:
            &#34;&#34;&#34;
            We are after the transformation from
            self --&gt; targetFrame
            ==
            self --&gt; self.ref --&gt; targetFrame.ref --&gt; targetFrame

            We know
            targetFrame.ref --&gt; targetFrame (targetFrame.transformation)
            self.ref        --&gt; self (self.transformation)
            but
            targetFrame.ref != self.ref
            so we need
            self.ref --&gt; targetFrame.ref
            then we can compose
            self --&gt; self.ref --&gt; targetFrame.ref --&gt; targetFrame

            Note: the transformation self.ref --&gt; targetFrame.ref is acquired recursively
                  This relies on the underlying assumption that there exists
                  one unique reference frame that source and self can be linked to
                  (without constraints on the number of links necessary), i.e.
                  that, from a frame to its reference or the opposite, there exists
                  a path between self and targetFrame. That is equivalent to
                  the assumption that the entire set of reference frames is connex,
                  i.e. defined upon a unique master reference frame.
            &#34;&#34;&#34;
            LOGGER.flash_flood(&#34;=== 4 start ===&#34;)
            selfToRef = self.transformation
            selfRefToTargetRef = self.ref.getPassiveTransformationTo(targetFrame.ref)
            refToTarget = t3add.affine_inverse(targetFrame.transformation)
            result = np.dot(refToTarget, np.dot(selfRefToTargetRef, selfToRef))
            LOGGER.flash_flood(&#34;=== 4 end   ===&#34;)

        return result

    def getPassiveTranslationRotationVectorsTo(
        self, targetFrame, degrees=True
    ):  # , active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts rotation vector from the result of getPassiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getPassiveTransformationTo(targetFrame)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getPassiveTranslationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts translation vector from the result of getPassiveTransformationTo(target)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[0]

    def getPassiveRotationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)

        extracts rotation vector from the result of getPassiveTransformationTo(targetFrame)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[1]

    def getPassiveTransformationFrom(self, source):
        &#34;&#34;&#34;
        getPassiveTransformationFrom(self,source)
        ==  getPointTransformationTo(self,source)

        INPUT
        source : is a ReferenceFrame object

        OUTPUT
        returns the transformation matrix  that, applied to a point defined
        in source returns its coordinates in self
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;PASSIVE FROM self {self.name} source {source.name}&#34;)
        return source.getPassiveTransformationTo(self)

    def getPassiveTranslationRotationVectorsFrom(
        self, source, degrees=True
    ):  # , active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsFrom(self,source, degrees=True)

        extracts rotation vector from the result of getPassiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getPassiveTransformationFrom(source)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getPassiveTranslationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationVectorFrom(self,source, degrees=True)

        extracts translation vector from the result of getPassiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsFrom(source, degrees=degrees)[0]

    def getPassiveRotationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getPassiveTranslationRotationVectorsFrom(self,source,degrees=True)

        extracts rotation vector from the result of getPassiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getPassiveTranslationRotationVectorsFrom(source, degrees=degrees)[1]

    def getActiveTransformationTo(self, target):
        &#34;&#34;&#34;
        Return the transformation matrix from this reference frame (``self``) to
        the target reference frame.

        Applying this transformation to the ``self`` ReferenceFrame would render it
        identical to target.

        Applying this transformation to a point defined in ``self`` would move it to
        the same coordinates in target.

        :param target: is a ReferenceFrame object

        :return: the transformation matrix that defines the reference frame ``target``
            in ``self``, the current reference frame. The transformation from self
            to target

        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;ACTIVE TO self {self.name} target {target.name}&#34;)
        return target.getPassiveTransformationTo(self)

    def getActiveTranslationRotationVectorsTo(
        self, targetFrame, degrees=True
    ):  # ,active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts rotation vector from the result of getActiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getActiveTransformationTo(targetFrame)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getActiveTranslationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsTo(self,ref,degrees=True)

        extracts translation vector from the result of getActiveTransformationTo(target)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[0]

    def getActiveRotationVectorTo(self, targetFrame, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)

        extracts rotation vector from the result of getActiveTransformationTo(targetFrame)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[1]

    def getActiveTransformationFrom(self, source):
        &#34;&#34;&#34;
        Applying this transformation to the ``source`` ReferenceFrame
        would render it identical to self.

        Applying this transformation to a point defined in source
        would move it to the same coordinates in self.

        :param source: is a ReferenceFrame object

        :return: the transformation matrix that defines this reference frame in ``source``,
            i.e. the transformation from ``source`` to ``self``

        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;ACTIVE FROM self {self.name} source {source.name}&#34;)
        return self.getPassiveTransformationTo(source)

    def getActiveTranslationRotationVectorsFrom(
        self, source, degrees=True
    ):  # ,active=_ACTIVE_DEFAULT):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsFrom(self,source, degrees=True)

        extracts rotation vector from the result of getActiveTransformationTo(target)
        &#34;&#34;&#34;
        transformation = self.getActiveTransformationFrom(source)
        rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
        if degrees:
            rotation = np.array([np.rad2deg(item) for item in rotation])
        translation = transformation[:3, 3]
        return translation, rotation

    def getActiveTranslationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationVectorFrom(self,source, degrees=True)

        extracts translation vector from the result of getActiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsFrom(source, degrees=degrees)[0]

    def getActiveRotationVectorFrom(self, source, degrees=True):
        &#34;&#34;&#34;
        getActiveTranslationRotationVectorsFrom(self,source,degrees=True)

        extracts rotation vector from the result of getActiveTransformationFrom(source)
        &#34;&#34;&#34;
        return self.getActiveTranslationRotationVectorsFrom(source, degrees=degrees)[1]

    def _findEnds(self, frame, visited=[], ends=[], verbose=True, level=1):
        &#34;&#34;&#34;
        PURPOSE
        Identify the &#39;linked_frames&#39;:
            frames that are linked, either directly or indirectly (via mult. links) to &#34;frame&#34;
            --&gt; returned as visited
        Identify subset of &#39;linked_frames of which the reference does not belong to linked_frames
            --&gt; returned as &#39;finalEnds&#39;
        &#34;&#34;&#34;
        LOGGER.flash_flood(
            f&#34;{level:-2d}{2*level*&#39; &#39;} Current: {frame.name} --  ends: {[f.name for f in ends]} -- visited {[f.name for f in visited]}&#34;
        )
        # if verbose: print (f&#34;{level:-2d}{2*level*&#39; &#39;} Current: {frame.name} --  ends: {[f.name for f in ends]} -- visited {[f.name for f in visited]}&#34;)

        # Establish the set of &#39;linked_frames&#39; (variable &#39;visited&#39;)
        # The recursive process below keeps unwanted (non-endFrames), namely the
        # frames that are not directly, but well indirectly linked to their reference
        # This case is solved further down
        if frame not in visited:
            visited.append(frame)
            if verbose and level:
                level += 1
            if frame.ref not in frame.linkedTo:
                ends.append(frame)
                LOGGER.flash_flood(f&#34;{(10+2*level)*&#39; &#39;}{frame.name}: new end&#34;)
                # if verbose: LOGGER.info(f&#34;{(10+2*level)*&#39; &#39;}{frame.name}: new end&#34;)
            for linkedFrame in frame.linkedTo:
                ends, visited = self._findEnds(
                    linkedFrame, visited=visited, ends=ends, verbose=verbose, level=level
                )

        # If frame.ref was linked to frame via an indirect route, reject it
        finalEnds = []
        for aframe in ends:
            if aframe.ref not in ends:
                finalEnds.append(aframe)
        return finalEnds, visited

    def setTransformation(
        self, transformation, updated=None, preserveLinks=True, _relative=False, verbose=True
    ):
        &#34;&#34;&#34;
        setTransformation(self,transformation, updated=None, preserveLinks=True,_relative=False, verbose=True)

        Alter the definition of this coordinate system

        If other systems are linked to this one, their definition must be updated accordingly
          The link set between two ref. Frames A &amp; B is the active transformation matrix from A to B
          A.addLink(B, matrix)
          A.getActiveTransformationTo(B) --&gt; matrix

        The way to update the definition of the present system, and of those linked to it
        depends on the structure of those links.

        We define
        - the target frame as the one we want to move / redefine
        - &#39;linkedFrames&#39; as those directly, or indirectly (i.e. via multiple links)
           linked to the target frame
        - endFrames as the subset of linkedFrames which are not linked to their reference (directly or indirectly)
        - sideFrames as the set of frames whose reference is a linkedFrame, but not themselves belonging to the linkedFrames

        We can demonstrate that updating the endFrames (Block A below) is sufficient to represent
        the movement of the target frame and all frames directly or indirectly linked to it.

        This may nevertheless have perverse effects for sideFrames. Indeed,
        their reference will (directly or implicitely) be redefined, but they shouldn&#39;t:
        they are not linked to their reference --&gt; their location in space (e.g. wrt the master frame)
        should not be affected by the movement of the target frame. This is the aim of block B.

        For a completely robust solution, 2 steps must be taken
        BLOCK A. apply the rigt transformation to all &#34;endFrames&#34;
        BLOCK B. Check for frames
                       using any of the &#34;visited&#34; frames as a reference
                       not linked to its reference
            Correct its so that it doesn&#39;t move (it shouldn&#39;t be affected by the requested movement)
            This demands a &#34;referenceFor&#34; array property

        &#34;&#34;&#34;
        # Ruthless, enforced redefinition of one system. Know what you do, or stay away.
        # Semi-unpredictible side effets if the impacted frame has links!
        if preserveLinks == False:
            self.transformation = transformation
            return

        if updated is None:
            updated = []

        # visitedFrames = all frames which can be reached from self via invariant links
        # endFrames = subset of visitedFrames that are at the end of a chain, and must be updated
        #             in order to properly represent the requested movement
        endFrames, visitedFrames = self._findEnds(frame=self, visited=[], ends=[], verbose=verbose)
        if verbose:
            LOGGER.info(
                f&#34;Visited sub-system                      {[f.name for f in visitedFrames]}&#34;
            )
            LOGGER.info(f&#34;End-frames (movement necessary)         {[f.name for f in endFrames]}&#34;)

        # All updates are done by relative movements
        # so we must first compute the relative movement corresponding to the requested absolute movement
        if _relative == False:
            ## virtual = what self should become after the (absolute) movement
            ## it allows to compute the relative transformation to be applied and work in relative further down
            virtual = ReferenceFrame(
                transformation, ref=self.ref, name=&#34;virtual&#34;, rot_config=self.rot_config
            )
            request = self.getActiveTransformationTo(virtual)
            del virtual
        else:
            # If this method is called by applyTransformation,
            # we are facing a request for a relative movement
            # In that case the input is directly what we want
            request = transformation

        # BLOCK B. Check for frames that were impacted but shouldn&#39;t have been and correct them
        # B1. List of frames demanding a correction
        #     &#39;impacted&#39; are frames having their reference inside the rigid structure moving, but not linked to it
        #     If nothing is done, the movement will implicitely displace them, which is not intended

        ### Impacted shall not contain frames that are linked to self (== to any frame in visitedFrames) via any route...
        ### We check if the impacted frames are in visitedFrames:
        ### it is enough to know it&#39;s connected to the entire &#39;solid body&#39; in which self belongs
        impacted = []
        for frame in visitedFrames:
            for child in frame.referenceFor:
                # Version 1 : too simple (restores too many frames)
                #if child not in frame.linkedTo:

                # Version 2 : overkill
                #child_ends, child_visited = child._findEnds(frame=child,visited=[],ends=[],verbose=verbose)
                #if frame not in child_visited:

                # Version 3 : just check if the child belongs to the rigid structure...
                if child not in visitedFrames:
                    impacted.append(child)

        LOGGER.debug(f&#34;Impacted (not moving, defined in moving) {[f.name for f in impacted]}&#34;)

        # B2. save the location of all impacted frames
        # tempReference has the only purpose of avoiding that every frame must know the master
        # It could be any frame without links and defined wrt the master, but the master isn&#39;t known here...
        # TODO : confirm that the master isn&#39;t known (e.g. via cls._MASTER)
        tempMaster = self.findMaster()
        toRestore = {}
        for frame in impacted:
            toRestore[frame] = ReferenceFrame(
                frame.getActiveTransformationFrom(tempMaster),
                ref=tempMaster,
                name=frame.name + &#34;toRestore&#34;,
                rot_config=frame.rot_config,
            )

        # BLOCK A. apply the rigt transformation to all &#34;endFrames&#34;
        &#34;&#34;&#34;
        ### Ensure that &#34;Untouched&#34; remains unaffected regardless of the update order of the endFrames
        selfUntouched = ReferenceFrame(
            transformation = self.getActiveTransformationFrom(tempMaster),
            ref=tempMaster,
            name=self.name + &#34;_fixed&#34;,
            rot_config=self.rot_config,
        )
        &#34;&#34;&#34;

        selfUntouched = ReferenceFrame(
            transformation=self.transformation,
            ref=self.ref,
            name=self.name + &#34;_fixed&#34;,
            rot_config=self.rot_config,
        )

        for bottom in endFrames:

            up = bottom.getActiveTransformationTo(selfUntouched)
            down = selfUntouched.getActiveTransformationTo(bottom)

            relativeTransformation = up @ request @ down

            LOGGER.flash_flood(
                f&#34;\nAdjusting {bottom.name} to {self.name}\nUpdated {[i.name for i in updated]}&#34;
            )
            LOGGER.flash_flood(f&#34;\ninput transformation \n{np.round(transformation,3)}&#34;)
            LOGGER.flash_flood(
                f&#34;\nup \n{np.round(up,3)}\ntransformation\n{np.round(request,3)}\ndown\n{np.round(down,3)}&#34;
            )
            LOGGER.flash_flood(f&#34;\nrelativeTransformation \n{np.round(relativeTransformation,3)}&#34;)

            bottom.transformation = bottom.transformation @ relativeTransformation

            updated.append(bottom)

        for frame in visitedFrames:
            if frame not in updated:
                updated.append(frame)

        # Block B
        # B3. Correction
        # we must set preserveLinks to False to prevent cascading impact from this update
        # if X1 is impacted with
        #    X1.ref = E1     X1 --&gt; X2 (simple link)    E2.ref = X2
        # where X1 and X2 are &#34;external frames&#34; and E1 and E2 are &#34;endFrames&#34; that will hence move
        # X1 was impacted by the move of E1, but X2 wasn&#39;t
        # ==&gt; wrt master, neither X1 nor X2 should have moved, but X1 did (via its ref)
        # and hence its link with X2 is now corrupt
        # We need to move X1 back to its original location wrt master
        # if we preserved the links while doing that,
        # we will move X2, which shouldn&#39;t move
        # (it didn&#39;t have to, it didn&#39;t and the goal is to restore the validity of the links)
        #
        # Direct restoration or the impacted frames at their original location

        for frame in toRestore:
            frame.transformation = frame.ref.getActiveTransformationTo(toRestore[frame])

        del toRestore

        return

    def setTranslationRotation(
        self,
        translation,
        rotation,
        rot_config=_ROT_CONFIG_DEFAULT,
        active=_ACTIVE_DEFAULT,
        degrees=True,
        preserveLinks=True,
    ):
        &#34;&#34;&#34;
        setTranslationRotation(self,translation,rotation,rot_config=_ROT_CONFIG_DEFAULT, active=_ACTIVE_DEFAULT, degrees=True, preserveLinks=True)

        Same as setTransformation, but input = translation and rotation vectors rather than affine transformation matrix
        &#34;&#34;&#34;
        # Translation
        translation = np.array(translation)
        # Zoom - unit
        zdef = np.array([1, 1, 1])
        # Shear
        sdef = np.array([0, 0, 0])
        # Rotation
        if degrees:
            rotation = np.array([np.deg2rad(item) for item in rotation])

        rotx, roty, rotz = rotation

        rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)

        LOGGER.flash_flood(t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef))

        transformation = t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef)

        self.setTransformation(transformation, preserveLinks=preserveLinks, _relative=False)
        return

    def applyTransformation(self, transformation, updated=None, preserveLinks=True):
        &#34;&#34;&#34;
        applyTransformation(self,transformation)

        Applies the transformation to the current reference frame&#39;s definition

        self.transformation := transformation @ self.transformation
        &#34;&#34;&#34;
        if updated is None:
            updated = []

        self.setTransformation(
            transformation=transformation,
            updated=updated,
            preserveLinks=preserveLinks,
            _relative=True,
        )

    def applyTranslationRotation(
        self,
        translation,
        rotation,
        rot_config=None,
        active=_ACTIVE_DEFAULT,
        degrees=True,
        preserveLinks=True,
    ):
        &#34;&#34;&#34;
        applyTranslationRotation(self,translation,rotation,rot_config=None,active=_ACTIVE_DEFAULT,degrees=True, preserveLinks=True)

        Builds transformation from input translation and rotation, then applies this transformation
        &#34;&#34;&#34;
        if rot_config is None:
            rot_config = self.rot_config

        # Translation
        translation = np.array(translation)
        # Zoom - unit
        zdef = np.array([1, 1, 1])
        # Shear
        sdef = np.array([0, 0, 0])
        # Rotation
        if degrees:
            rotation = np.array([np.deg2rad(item) for item in rotation])
        rotx, roty, rotz = rotation
        #
        rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)
        #
        transformation = t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef)
        #
        self.applyTransformation(transformation, preserveLinks=preserveLinks)
        return

    def getAxis(self, axis, name=None):
        &#34;&#34;&#34;
        INPUT
        axis : in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]

        OUTPUT
        Returns an object of class Point, corresponding to the vector defining
        the axis of choice in self.
        The output can be used with the Point methods to express that axis in any reference frame
        &#34;&#34;&#34;
        haxis = {}
        haxis[&#34;x&#34;] = [1, 0, 0]
        haxis[&#34;y&#34;] = [0, 1, 0]
        haxis[&#34;z&#34;] = [0, 0, 1]
        if name is None:
            name = self.name + axis
        return Point(haxis[axis], ref=self, name=name)

    def getNormal(self, name=None):
        &#34;&#34;&#34;
        getNormal(self,name=None)

        Returns a unit vector normal to the X-Y plane (= [0,0,1] = getAxis(&#39;z&#39;))
        &#34;&#34;&#34;
        return Point([0, 0, 1], ref=self, name=name)

    def getOrigin(self, name=None):
        &#34;&#34;&#34;
        OUTPUT
        Returns an object of class Point, corresponding to the vector defining the origin in &#39;self&#39;, i.e. [0,0,0]
        The output can be used with the Point methods to express that axis in any reference frame
        &#34;&#34;&#34;
        return Point([0, 0, 0], ref=self, name=name)

    def is_master(self):
        return self.isMaster()

    def isMaster(self):
        &#34;&#34;&#34;
        A Master reference frame is a reference frame that refers to itself, and the
        transformation is the Identity matrix.
        &#34;&#34;&#34;
        tr = self.transformation

        if (
            (self.name == self.ref.name)
            and (tr.shape[0] == tr.shape[1])
            and np.allclose(tr, np.eye(tr.shape[0]))
        ):
            return True
        return False

    def isSame(self, other):
        &#34;&#34;&#34;
        Returns True if the two reference frames are the same except for their name.

        Two Reference Frames are considered the same when:

        * their transformation matrices are equal
        * the reference frame is equal
        * the rot_config is equal
        * the name may be different

        .. todo:: This needs further work and testing!
        &#34;&#34;&#34;

        if other is self:
            LOGGER.debug(
                &#34;self and other are the same object (beware: this message might occur with recursion from self.ref != self.other)&#34;
            )
            return True

        if isinstance(other, ReferenceFrame):
            LOGGER.flash_flood(f&#34;comparing {self.name} and {other.name}&#34;)
            if not np.array_equal(self.transformation, other.transformation):
                LOGGER.flash_flood(&#34;self.transformation not equals other.transformation&#34;)
                return False
            if self.rot_config != other.rot_config:
                LOGGER.flash_flood(&#34;self.rot_config not equals other.rot_config&#34;)
                return False
            # The following tests are here to prevent recursion to go infinite when self and other
            # point to itself
            if self.ref is self and other.ref is other:
                LOGGER.flash_flood(&#34;both self.ref and other.ref point to themselves&#34;)
                pass
            else:
                LOGGER.flash_flood(&#34;one of self.ref or other.ref doesn&#39;t points to itself&#34;)
                if self.ref != other.ref:
                    LOGGER.flash_flood(&#34;self.ref not equals other.ref&#34;)
                    return False
            if self.name is not other.name:
                LOGGER.flash_flood(
                    f&#34;When checking two reference frames for equality, only their names differ: &#39;{self.name}&#39; not equals &#39;{other.name}&#39;&#34;
                )
                pass
            return True
        return NotImplemented

    def __eq__(self, other):
        &#34;&#34;&#34;
        Overrides the default implementation, which basically checks for id(self) == id(other).

        Two Reference Frames are considered equal when:

        * their transformation matrices are equal
        * the reference frame is equal
        * the rot_config is equal
        * do we want to insist on the name being equal?
          YES - for strict testing
          NO  - this might need a new method like isSame(self, other) where the criteria are relaxed


        .. todo:: This needs further work and testing!
        &#34;&#34;&#34;

        if other is self:
            LOGGER.debug(
                &#34;self and other are the same object (beware: this message might occur with recursion from self.ref != self.other)&#34;
            )
            return True

        if isinstance(other, ReferenceFrame):
            LOGGER.flash_flood(f&#34;comparing {self.name} and {other.name}&#34;)
            if not np.array_equal(self.transformation, other.transformation):
                LOGGER.flash_flood(&#34;self.transformation not equals other.transformation&#34;)
                return False
            if self.rot_config != other.rot_config:
                LOGGER.flash_flood(&#34;self.rot_config not equals other.rot_config&#34;)
                return False
            # The following tests are here to prevent recursion to go infinite when self and other
            # point to itself
            if self.ref is self and other.ref is other:
                LOGGER.flash_flood(&#34;both self.ref and other.ref point to themselves&#34;)
                pass
            else:
                LOGGER.flash_flood(&#34;one of self.ref or other.ref doesn&#39;t points to itself&#34;)
                if self.ref != other.ref:
                    LOGGER.flash_flood(&#34;self.ref not equals other.ref&#34;)
                    return False
            if self.name is not other.name:
                LOGGER.flash_flood(
                    f&#34;When checking two reference frames for equality, only their names differ: &#39;{self.name}&#39; not equals &#39;{other.name}&#39;&#34;
                )
                return False
            return True
        return NotImplemented

    def __hash__(self):
        &#34;&#34;&#34;Overrides the default implementation&#34;&#34;&#34;
        hash_number = (id(self.rot_config) + id(self.ref) + id(self.name)) // 16
        return hash_number

    def __copy__(self):

        LOGGER.debug(
            f&#39;Copying {self!r} unless {self.name} is &#34;Master&#34; in which case the Master itself is returned.&#39;
        )

        if self.isMaster():
            LOGGER.debug(f&#34;Returning Master itself instead of a copy.&#34;)
            return self

        return ReferenceFrame(self.transformation, self.ref, self.name, self.rot_config)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.createMaster"><code class="name flex">
<span>def <span class="ident">createMaster</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a master reference frame.</p>
<p>A master reference frame is defined with respect to itself and is initialised with the
identity matrix.</p>
<p>The master frame is automatically given the name "Master".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def createMaster(cls):
    &#34;&#34;&#34;
    Create a master reference frame.

    A master reference frame is defined with respect to itself and is initialised with the
    identity matrix.

    The master frame is automatically given the name &#34;Master&#34;.
    &#34;&#34;&#34;
    ref_master = super(ReferenceFrame, cls).__new__(cls)
    ref_master.name = &#34;Master&#34;
    ref_master.ref = ref_master
    ref_master.transformation = cls._I
    ref_master.rot_config = cls._ROT_CONFIG_DEFAULT
    ref_master.initialized = True
    ref_master.debug = False
    ref_master.linkedTo = {}
    ref_master.referenceFor = []

    LOGGER.debug(
        f&#34;NEW MASTER CREATED: {id(ref_master)}, ref = {id(ref_master.ref)}, &#34;
        f&#34;name = {ref_master.name}&#34;
    )

    return ref_master</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.fromPoints"><code class="name flex">
<span>def <span class="ident">fromPoints</span></span>(<span>points, plane='xy', name=None, usesvd=True, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>fromPoints(points, plane="xy", name=None, usesvd=True,verbose=True)</p>
<p>Finds the best fitting "plane" plane to all points in "points" and builds a ReferenceFrame
considering the fitted plane as the 'xy' plane of the new system</p>
<p>fitPlane must be in ['xy','yz','zx']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromPoints(points, plane=&#34;xy&#34;, name=None, usesvd=True, verbose=True):
    &#34;&#34;&#34;
    fromPoints(points, plane=&#34;xy&#34;, name=None, usesvd=True,verbose=True)

    Finds the best fitting &#34;plane&#34; plane to all points in &#34;points&#34; and builds a ReferenceFrame
    considering the fitted plane as the &#39;xy&#39; plane of the new system

    fitPlane must be in [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;]
    &#34;&#34;&#34;
    return points.bestFittingPlane(fitPlane=plane, usesvd=usesvd, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.fromRotation"><code class="name flex">
<span>def <span class="ident">fromRotation</span></span>(<span>rotx, roty, rotz, ref, name=None, rot_config='sxyz', active=True, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a ReferenceFrame from a rotation with respect to the given reference frame.</p>
<p>:param rotx: rotation around the x-axis
:type rotx: float</p>
<p>:param roty: rotation around the y-axis
:type roty: float</p>
<p>:param rotz: rotation around the z-axis
:type rotz: float</p>
<p>:param ref: reference frame with respect to which the rotation is performed. If no ref is given
the rotation is with respect to the master reference frame
:type ref: ReferenceFrame</p>
<p>:param name: a simple convenient name to identify the reference frame. If no name is provided
a random name of four characters starting with 'F' will be generated.
:type name: str</p>
<p>:return: a reference frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromRotation(
    cls,
    rotx,
    roty,
    rotz,
    ref,
    name=None,
    rot_config=_ROT_CONFIG_DEFAULT,
    active=_ACTIVE_DEFAULT,
    degrees=True,
):
    &#34;&#34;&#34;
    Create a ReferenceFrame from a rotation with respect to the given reference frame.

    :param rotx: rotation around the x-axis
    :type rotx: float

    :param roty: rotation around the y-axis
    :type roty: float

    :param rotz: rotation around the z-axis
    :type rotz: float

    :param ref: reference frame with respect to which the rotation is performed. If no ref is given
        the rotation is with respect to the master reference frame
    :type ref: ReferenceFrame

    :param name: a simple convenient name to identify the reference frame. If no name is provided
                 a random name of four characters starting with &#39;F&#39; will be generated.
    :type name: str

    :return: a reference frame
    &#34;&#34;&#34;
    # Convention (rotating axes, in order xyz)

    # rot_config = cls._ROT_CONFIG_DEFAULT

    # Rotation amplitude

    # Rotation
    if degrees:
        rotx = np.deg2rad(rotx)
        roty = np.deg2rad(roty)
        rotz = np.deg2rad(rotz)

    rotation = RotationMatrix(rotx, roty, rotz, rot_config, active=active)

    # Defaults for zoom &amp; shear

    zdef = np.array([1, 1, 1])
    sdef = np.array([0, 0, 0])

    translation = [0, 0, 0]

    TT = t3.affines.compose(T=translation, R=rotation.R, Z=zdef, S=sdef)

    if ref is None:
        raise ValueError(
            &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
        )

    return cls(transformation=TT, ref=ref, name=name, rot_config=rot_config)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.fromTranslation"><code class="name flex">
<span>def <span class="ident">fromTranslation</span></span>(<span>transx, transy, transz, ref, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a ReferenceFrame from a translation with respect to the given reference frame.</p>
<p>:param transx: translation along the x-axis
:type transx: float</p>
<p>:param transy: translation along the y-axis
:type transy: float</p>
<p>:param transz: translation along the z-axis
:type transz: float</p>
<p>:param ref: reference frame with respect to which the translation is performed. If no ref is given
the rotation is with respect to the master reference frame
:type ref: ReferenceFrame</p>
<p>:param name: a simple convenient name to identify the reference frame. If no name is provided
a random name of four characters starting with 'F' will be generated.
:type name: str</p>
<p>:return: a reference frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromTranslation(cls, transx, transy, transz, ref, name=None):
    &#34;&#34;&#34;
    Create a ReferenceFrame from a translation with respect to the given reference frame.

    :param transx: translation along the x-axis
    :type transx: float

    :param transy: translation along the y-axis
    :type transy: float

    :param transz: translation along the z-axis
    :type transz: float

    :param ref: reference frame with respect to which the translation is performed. If no ref is given
        the rotation is with respect to the master reference frame
    :type ref: ReferenceFrame

    :param name: a simple convenient name to identify the reference frame. If no name is provided
                 a random name of four characters starting with &#39;F&#39; will be generated.
    :type name: str

    :return: a reference frame
    &#34;&#34;&#34;
    adef = np.identity(4)
    adef[:3, 3] = [transx, transy, transz]

    if ref is None:
        raise ValueError(
            &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
        )

    return cls(transformation=adef, ref=ref, name=name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.fromTranslationRotation"><code class="name flex">
<span>def <span class="ident">fromTranslationRotation</span></span>(<span>translation, rotation, ref, name=None, rot_config='sxyz', active=True, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>fromTranslationRotation(cls,translation,rotation, ref=None,name=None, rot_config=_ROT_CONFIG_DEFAULT,active=_ACTIVE_DEFAULT, degrees=True)</p>
<p>Construct a ReferenceFrame from a translation and a rotation (vectors!)</p>
<p>translation : translation vector : 3 x 1 = tx, ty, tz
rotation
: rotation vector
: 3 x 1 = rx, ry, rz</p>
<p>rot_config : convention for the rotation, see rotationMatrix.<strong>doc</strong></p>
<p>degrees : if True, input values are assumed in degrees, otherwise radians</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromTranslationRotation(
    cls,
    translation,
    rotation,
    ref,
    name=None,
    rot_config=_ROT_CONFIG_DEFAULT,
    active=_ACTIVE_DEFAULT,
    degrees=True,
):
    &#34;&#34;&#34;fromTranslationRotation(cls,translation,rotation, ref=None,name=None, rot_config=_ROT_CONFIG_DEFAULT,active=_ACTIVE_DEFAULT, degrees=True)

    Construct a ReferenceFrame from a translation and a rotation (vectors!)

    translation : translation vector : 3 x 1 = tx, ty, tz
    rotation    : rotation vector    : 3 x 1 = rx, ry, rz

    rot_config : convention for the rotation, see rotationMatrix.__doc__

    degrees : if True, input values are assumed in degrees, otherwise radians
    &#34;&#34;&#34;
    # Translation
    translation = np.array(translation)
    # Zoom - unit
    zdef = np.array([1, 1, 1])
    # Shear
    sdef = np.array([0, 0, 0])
    # Rotation
    if degrees:
        rotation = np.array([np.deg2rad(item) for item in rotation])
    rotx, roty, rotz = rotation
    #
    rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)
    #
    # transformation = t3.affines.compose(translation,rmat.R,Z=zdef,S=sdef)

    if ref is None:
        raise ValueError(
            &#34;The ref argument can not be None, provide a master or another reference frame.&#34;
        )

    return cls(
        transformation=t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef),
        ref=ref,
        name=name,
        rot_config=rot_config,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.addLink"><code class="name flex">
<span>def <span class="ident">addLink</span></span>(<span>self, ref, transformation=None)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a link between self and ref in self.linkedTo and ref.linkedTo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addLink(self, ref, transformation=None, _stop=False):
    &#34;&#34;&#34;
    adds a link between self and ref in self.linkedTo and ref.linkedTo
    &#34;&#34;&#34;

    # DONE: set the inverse transformation in the ref to this
    #   ref.linkedTo[self] = t3add.affine_inverse(transformation)
    # TODO:
    #   remove the _stop keyword

    # TODO: deprecate transformation as an input variable
    #       linkedTo can become a list of reference frames, with no transformation
    #       associated to the link. The tfo associated to a link is already
    #       checked in real time whenever the link is addressed
    if transformation is None:
        transformation = self.getActiveTransformationTo(ref)
    else:
        LOGGER.info(&#34;Deprecation warning: transformation will be automatically set to &#34;
                    &#34;the current relation between {self.name} and {ref.name}&#34;)
        LOGGER.flash_flood(&#34;Requested:&#34;)
        LOGGER.flash_flood(np.round(transformation, decimals=3))
        LOGGER.flash_flood(&#34;Auto (enforced):&#34;)

        transformation = self.getActiveTransformationTo(ref)

        LOGGER.flash_flood(np.round(transformation, decimals=3))

    self.linkedTo[ref] = transformation

    # TODO simplify this when transformation is deprecated
    #      it becomes ref.linkedTo[self] = ref.getActiveTransformationTo(self)
    ref.linkedTo[self] = t3add.affine_inverse(transformation)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.applyTransformation"><code class="name flex">
<span>def <span class="ident">applyTransformation</span></span>(<span>self, transformation, updated=None, preserveLinks=True)</span>
</code></dt>
<dd>
<div class="desc"><p>applyTransformation(self,transformation)</p>
<p>Applies the transformation to the current reference frame's definition</p>
<p>self.transformation := transformation @ self.transformation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def applyTransformation(self, transformation, updated=None, preserveLinks=True):
    &#34;&#34;&#34;
    applyTransformation(self,transformation)

    Applies the transformation to the current reference frame&#39;s definition

    self.transformation := transformation @ self.transformation
    &#34;&#34;&#34;
    if updated is None:
        updated = []

    self.setTransformation(
        transformation=transformation,
        updated=updated,
        preserveLinks=preserveLinks,
        _relative=True,
    )</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.applyTranslationRotation"><code class="name flex">
<span>def <span class="ident">applyTranslationRotation</span></span>(<span>self, translation, rotation, rot_config=None, active=True, degrees=True, preserveLinks=True)</span>
</code></dt>
<dd>
<div class="desc"><p>applyTranslationRotation(self,translation,rotation,rot_config=None,active=_ACTIVE_DEFAULT,degrees=True, preserveLinks=True)</p>
<p>Builds transformation from input translation and rotation, then applies this transformation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def applyTranslationRotation(
    self,
    translation,
    rotation,
    rot_config=None,
    active=_ACTIVE_DEFAULT,
    degrees=True,
    preserveLinks=True,
):
    &#34;&#34;&#34;
    applyTranslationRotation(self,translation,rotation,rot_config=None,active=_ACTIVE_DEFAULT,degrees=True, preserveLinks=True)

    Builds transformation from input translation and rotation, then applies this transformation
    &#34;&#34;&#34;
    if rot_config is None:
        rot_config = self.rot_config

    # Translation
    translation = np.array(translation)
    # Zoom - unit
    zdef = np.array([1, 1, 1])
    # Shear
    sdef = np.array([0, 0, 0])
    # Rotation
    if degrees:
        rotation = np.array([np.deg2rad(item) for item in rotation])
    rotx, roty, rotz = rotation
    #
    rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)
    #
    transformation = t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef)
    #
    self.applyTransformation(transformation, preserveLinks=preserveLinks)
    return</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.findMaster"><code class="name flex">
<span>def <span class="ident">findMaster</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Master frame for this reference frame. The Master frame is always at the end
of the path following the references.</p>
<h2 id="returns">Returns</h2>
<p>The master frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findMaster(self):
    &#34;&#34;&#34;
    Returns the Master frame for this reference frame. The Master frame is always at the end
    of the path following the references.

    Returns:
        The master frame.
    &#34;&#34;&#34;

    frame = self
    while not frame.isMaster():
        frame = frame.ref
    return frame</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.find_master"><code class="name flex">
<span>def <span class="ident">find_master</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_master(self):
    return self.findMaster()</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveRotationVectorFrom"><code class="name flex">
<span>def <span class="ident">getActiveRotationVectorFrom</span></span>(<span>self, source, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getActiveTranslationRotationVectorsFrom(self,source,degrees=True)</p>
<p>extracts rotation vector from the result of getActiveTransformationFrom(source)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveRotationVectorFrom(self, source, degrees=True):
    &#34;&#34;&#34;
    getActiveTranslationRotationVectorsFrom(self,source,degrees=True)

    extracts rotation vector from the result of getActiveTransformationFrom(source)
    &#34;&#34;&#34;
    return self.getActiveTranslationRotationVectorsFrom(source, degrees=degrees)[1]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveRotationVectorTo"><code class="name flex">
<span>def <span class="ident">getActiveRotationVectorTo</span></span>(<span>self, targetFrame, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getActiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)</p>
<p>extracts rotation vector from the result of getActiveTransformationTo(targetFrame)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveRotationVectorTo(self, targetFrame, degrees=True):
    &#34;&#34;&#34;
    getActiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)

    extracts rotation vector from the result of getActiveTransformationTo(targetFrame)
    &#34;&#34;&#34;
    return self.getActiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[1]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTransformationFrom"><code class="name flex">
<span>def <span class="ident">getActiveTransformationFrom</span></span>(<span>self, source)</span>
</code></dt>
<dd>
<div class="desc"><p>Applying this transformation to the <code>source</code> ReferenceFrame
would render it identical to self.</p>
<p>Applying this transformation to a point defined in source
would move it to the same coordinates in self.</p>
<p>:param source: is a ReferenceFrame object</p>
<p>:return: the transformation matrix that defines this reference frame in <code>source</code>,
i.e. the transformation from <code>source</code> to <code>self</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveTransformationFrom(self, source):
    &#34;&#34;&#34;
    Applying this transformation to the ``source`` ReferenceFrame
    would render it identical to self.

    Applying this transformation to a point defined in source
    would move it to the same coordinates in self.

    :param source: is a ReferenceFrame object

    :return: the transformation matrix that defines this reference frame in ``source``,
        i.e. the transformation from ``source`` to ``self``

    &#34;&#34;&#34;
    LOGGER.flash_flood(&#34;ACTIVE FROM self {self.name} source {source.name}&#34;)
    return self.getPassiveTransformationTo(source)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTransformationTo"><code class="name flex">
<span>def <span class="ident">getActiveTransformationTo</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the transformation matrix from this reference frame (<code>self</code>) to
the target reference frame.</p>
<p>Applying this transformation to the <code>self</code> ReferenceFrame would render it
identical to target.</p>
<p>Applying this transformation to a point defined in <code>self</code> would move it to
the same coordinates in target.</p>
<p>:param target: is a ReferenceFrame object</p>
<p>:return: the transformation matrix that defines the reference frame <code>target</code>
in <code>self</code>, the current reference frame. The transformation from self
to target</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveTransformationTo(self, target):
    &#34;&#34;&#34;
    Return the transformation matrix from this reference frame (``self``) to
    the target reference frame.

    Applying this transformation to the ``self`` ReferenceFrame would render it
    identical to target.

    Applying this transformation to a point defined in ``self`` would move it to
    the same coordinates in target.

    :param target: is a ReferenceFrame object

    :return: the transformation matrix that defines the reference frame ``target``
        in ``self``, the current reference frame. The transformation from self
        to target

    &#34;&#34;&#34;
    LOGGER.flash_flood(&#34;ACTIVE TO self {self.name} target {target.name}&#34;)
    return target.getPassiveTransformationTo(self)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationRotationVectorsFrom"><code class="name flex">
<span>def <span class="ident">getActiveTranslationRotationVectorsFrom</span></span>(<span>self, source, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getActiveTranslationRotationVectorsFrom(self,source, degrees=True)</p>
<p>extracts rotation vector from the result of getActiveTransformationTo(target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveTranslationRotationVectorsFrom(
    self, source, degrees=True
):  # ,active=_ACTIVE_DEFAULT):
    &#34;&#34;&#34;
    getActiveTranslationRotationVectorsFrom(self,source, degrees=True)

    extracts rotation vector from the result of getActiveTransformationTo(target)
    &#34;&#34;&#34;
    transformation = self.getActiveTransformationFrom(source)
    rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
    if degrees:
        rotation = np.array([np.rad2deg(item) for item in rotation])
    translation = transformation[:3, 3]
    return translation, rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationRotationVectorsTo"><code class="name flex">
<span>def <span class="ident">getActiveTranslationRotationVectorsTo</span></span>(<span>self, targetFrame, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getActiveTranslationRotationVectorsTo(self,ref,degrees=True)</p>
<p>extracts rotation vector from the result of getActiveTransformationTo(target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveTranslationRotationVectorsTo(
    self, targetFrame, degrees=True
):  # ,active=_ACTIVE_DEFAULT):
    &#34;&#34;&#34;
    getActiveTranslationRotationVectorsTo(self,ref,degrees=True)

    extracts rotation vector from the result of getActiveTransformationTo(target)
    &#34;&#34;&#34;
    transformation = self.getActiveTransformationTo(targetFrame)
    rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
    if degrees:
        rotation = np.array([np.rad2deg(item) for item in rotation])
    translation = transformation[:3, 3]
    return translation, rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationVectorFrom"><code class="name flex">
<span>def <span class="ident">getActiveTranslationVectorFrom</span></span>(<span>self, source, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getActiveTranslationVectorFrom(self,source, degrees=True)</p>
<p>extracts translation vector from the result of getActiveTransformationFrom(source)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveTranslationVectorFrom(self, source, degrees=True):
    &#34;&#34;&#34;
    getActiveTranslationVectorFrom(self,source, degrees=True)

    extracts translation vector from the result of getActiveTransformationFrom(source)
    &#34;&#34;&#34;
    return self.getActiveTranslationRotationVectorsFrom(source, degrees=degrees)[0]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationVectorTo"><code class="name flex">
<span>def <span class="ident">getActiveTranslationVectorTo</span></span>(<span>self, targetFrame, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getActiveTranslationRotationVectorsTo(self,ref,degrees=True)</p>
<p>extracts translation vector from the result of getActiveTransformationTo(target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveTranslationVectorTo(self, targetFrame, degrees=True):
    &#34;&#34;&#34;
    getActiveTranslationRotationVectorsTo(self,ref,degrees=True)

    extracts translation vector from the result of getActiveTransformationTo(target)
    &#34;&#34;&#34;
    return self.getActiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[0]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getAxis"><code class="name flex">
<span>def <span class="ident">getAxis</span></span>(<span>self, axis, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>INPUT
axis : in ['x','y','z']</p>
<p>OUTPUT
Returns an object of class Point, corresponding to the vector defining
the axis of choice in self.
The output can be used with the Point methods to express that axis in any reference frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAxis(self, axis, name=None):
    &#34;&#34;&#34;
    INPUT
    axis : in [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]

    OUTPUT
    Returns an object of class Point, corresponding to the vector defining
    the axis of choice in self.
    The output can be used with the Point methods to express that axis in any reference frame
    &#34;&#34;&#34;
    haxis = {}
    haxis[&#34;x&#34;] = [1, 0, 0]
    haxis[&#34;y&#34;] = [0, 1, 0]
    haxis[&#34;z&#34;] = [0, 0, 1]
    if name is None:
        name = self.name + axis
    return Point(haxis[axis], ref=self, name=name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getNormal"><code class="name flex">
<span>def <span class="ident">getNormal</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>getNormal(self,name=None)</p>
<p>Returns a unit vector normal to the X-Y plane (= [0,0,1] = getAxis('z'))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNormal(self, name=None):
    &#34;&#34;&#34;
    getNormal(self,name=None)

    Returns a unit vector normal to the X-Y plane (= [0,0,1] = getAxis(&#39;z&#39;))
    &#34;&#34;&#34;
    return Point([0, 0, 1], ref=self, name=name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getOrigin"><code class="name flex">
<span>def <span class="ident">getOrigin</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>OUTPUT
Returns an object of class Point, corresponding to the vector defining the origin in 'self', i.e. [0,0,0]
The output can be used with the Point methods to express that axis in any reference frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOrigin(self, name=None):
    &#34;&#34;&#34;
    OUTPUT
    Returns an object of class Point, corresponding to the vector defining the origin in &#39;self&#39;, i.e. [0,0,0]
    The output can be used with the Point methods to express that axis in any reference frame
    &#34;&#34;&#34;
    return Point([0, 0, 0], ref=self, name=name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveRotationVectorFrom"><code class="name flex">
<span>def <span class="ident">getPassiveRotationVectorFrom</span></span>(<span>self, source, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTranslationRotationVectorsFrom(self,source,degrees=True)</p>
<p>extracts rotation vector from the result of getPassiveTransformationFrom(source)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveRotationVectorFrom(self, source, degrees=True):
    &#34;&#34;&#34;
    getPassiveTranslationRotationVectorsFrom(self,source,degrees=True)

    extracts rotation vector from the result of getPassiveTransformationFrom(source)
    &#34;&#34;&#34;
    return self.getPassiveTranslationRotationVectorsFrom(source, degrees=degrees)[1]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveRotationVectorTo"><code class="name flex">
<span>def <span class="ident">getPassiveRotationVectorTo</span></span>(<span>self, targetFrame, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)</p>
<p>extracts rotation vector from the result of getPassiveTransformationTo(targetFrame)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveRotationVectorTo(self, targetFrame, degrees=True):
    &#34;&#34;&#34;
    getPassiveTranslationRotationVectorsTo(self,targetFrame,degrees=True)

    extracts rotation vector from the result of getPassiveTransformationTo(targetFrame)
    &#34;&#34;&#34;
    return self.getPassiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[1]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTransformationFrom"><code class="name flex">
<span>def <span class="ident">getPassiveTransformationFrom</span></span>(<span>self, source)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTransformationFrom(self,source)
==
getPointTransformationTo(self,source)</p>
<p>INPUT
source : is a ReferenceFrame object</p>
<p>OUTPUT
returns the transformation matrix
that, applied to a point defined
in source returns its coordinates in self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveTransformationFrom(self, source):
    &#34;&#34;&#34;
    getPassiveTransformationFrom(self,source)
    ==  getPointTransformationTo(self,source)

    INPUT
    source : is a ReferenceFrame object

    OUTPUT
    returns the transformation matrix  that, applied to a point defined
    in source returns its coordinates in self
    &#34;&#34;&#34;
    LOGGER.flash_flood(&#34;PASSIVE FROM self {self.name} source {source.name}&#34;)
    return source.getPassiveTransformationTo(self)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTransformationTo"><code class="name flex">
<span>def <span class="ident">getPassiveTransformationTo</span></span>(<span>self, targetFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTransformationTo(self,targetFrame)
== getPointTransformationTo(self,targetFrame)</p>
<p>returns the transformation to apply to a Point (defined in self) to express it in targetFrame</p>
<p>Passive transformation : the point is static, we change the reference frame around it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveTransformationTo(self, targetFrame):
    &#34;&#34;&#34;
    getPassiveTransformationTo(self,targetFrame)
    == getPointTransformationTo(self,targetFrame)

    returns the transformation to apply to a Point (defined in self) to express it in targetFrame

    Passive transformation : the point is static, we change the reference frame around it
    &#34;&#34;&#34;
    LOGGER.flash_flood(&#34;PASSIVE TO self {self.name} target {targetFrame.name}&#34;)
    if targetFrame is self:
        &#34;&#34;&#34;
        Nothing to do here, we already have the right coordinates
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;case 1&#34;)
        result = np.identity(4)

    elif targetFrame.ref is self:
        &#34;&#34;&#34;
        The target frame is defined in self =&gt; the requested transformation is the targetFrame definition
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;=== 2 start ===&#34;)
        result = t3add.affine_inverse(targetFrame.transformation)
        LOGGER.flash_flood(&#34;=== 2 end   ===&#34;)
    elif targetFrame.ref is self.ref:
        &#34;&#34;&#34;
        targetFrame and self are defined wrt the same reference frame
        We want
        self --&gt; targetFrame
        We know
        targetFrame.ref --&gt; targetFrame (= targetFrame.transformation)
        self.ref   --&gt; self   (= self.transformation)
        That is
        self --&gt; self.ref is targetFrame.ref --&gt; targetFrame
        inverse(definition)    targetFrame definition

        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;=== 3 start ===&#34;)
        LOGGER.flash_flood(&#34; ref   \n{0}&#34;.format(self.ref))
        LOGGER.flash_flood(&#34;===&#34;)
        LOGGER.flash_flood(&#34;self   \n{0}&#34;.format(self))
        LOGGER.flash_flood(&#34;===&#34;)
        LOGGER.flash_flood(&#34;targetFrame \n{0}&#34;.format(targetFrame))
        LOGGER.flash_flood(&#34;===&#34;)

        selfToRef = self.transformation
        LOGGER.flash_flood(&#34;selfToRef \n{0}&#34;.format(selfToRef))

        # refToRef = I

        refToTarget = t3add.affine_inverse(targetFrame.transformation)
        LOGGER.flash_flood(&#34;refToTarget \n{0}&#34;.format(refToTarget))

        result = np.dot(refToTarget, selfToRef)
        LOGGER.flash_flood(&#34;result \n{0}&#34;.format(result))
        LOGGER.flash_flood(&#34;=== 3 end   ===&#34;)
    else:
        &#34;&#34;&#34;
        We are after the transformation from
        self --&gt; targetFrame
        ==
        self --&gt; self.ref --&gt; targetFrame.ref --&gt; targetFrame

        We know
        targetFrame.ref --&gt; targetFrame (targetFrame.transformation)
        self.ref        --&gt; self (self.transformation)
        but
        targetFrame.ref != self.ref
        so we need
        self.ref --&gt; targetFrame.ref
        then we can compose
        self --&gt; self.ref --&gt; targetFrame.ref --&gt; targetFrame

        Note: the transformation self.ref --&gt; targetFrame.ref is acquired recursively
              This relies on the underlying assumption that there exists
              one unique reference frame that source and self can be linked to
              (without constraints on the number of links necessary), i.e.
              that, from a frame to its reference or the opposite, there exists
              a path between self and targetFrame. That is equivalent to
              the assumption that the entire set of reference frames is connex,
              i.e. defined upon a unique master reference frame.
        &#34;&#34;&#34;
        LOGGER.flash_flood(&#34;=== 4 start ===&#34;)
        selfToRef = self.transformation
        selfRefToTargetRef = self.ref.getPassiveTransformationTo(targetFrame.ref)
        refToTarget = t3add.affine_inverse(targetFrame.transformation)
        result = np.dot(refToTarget, np.dot(selfRefToTargetRef, selfToRef))
        LOGGER.flash_flood(&#34;=== 4 end   ===&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationRotationVectorsFrom"><code class="name flex">
<span>def <span class="ident">getPassiveTranslationRotationVectorsFrom</span></span>(<span>self, source, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTranslationRotationVectorsFrom(self,source, degrees=True)</p>
<p>extracts rotation vector from the result of getPassiveTransformationTo(target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveTranslationRotationVectorsFrom(
    self, source, degrees=True
):  # , active=_ACTIVE_DEFAULT):
    &#34;&#34;&#34;
    getPassiveTranslationRotationVectorsFrom(self,source, degrees=True)

    extracts rotation vector from the result of getPassiveTransformationTo(target)
    &#34;&#34;&#34;
    transformation = self.getPassiveTransformationFrom(source)
    rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
    if degrees:
        rotation = np.array([np.rad2deg(item) for item in rotation])
    translation = transformation[:3, 3]
    return translation, rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationRotationVectorsTo"><code class="name flex">
<span>def <span class="ident">getPassiveTranslationRotationVectorsTo</span></span>(<span>self, targetFrame, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)</p>
<p>extracts rotation vector from the result of getPassiveTransformationTo(target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveTranslationRotationVectorsTo(
    self, targetFrame, degrees=True
):  # , active=_ACTIVE_DEFAULT):
    &#34;&#34;&#34;
    getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)

    extracts rotation vector from the result of getPassiveTransformationTo(target)
    &#34;&#34;&#34;
    transformation = self.getPassiveTransformationTo(targetFrame)
    rotation = t3.euler.mat2euler(transformation, axes=self.rot_config)
    if degrees:
        rotation = np.array([np.rad2deg(item) for item in rotation])
    translation = transformation[:3, 3]
    return translation, rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationVectorFrom"><code class="name flex">
<span>def <span class="ident">getPassiveTranslationVectorFrom</span></span>(<span>self, source, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTranslationVectorFrom(self,source, degrees=True)</p>
<p>extracts translation vector from the result of getPassiveTransformationFrom(source)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveTranslationVectorFrom(self, source, degrees=True):
    &#34;&#34;&#34;
    getPassiveTranslationVectorFrom(self,source, degrees=True)

    extracts translation vector from the result of getPassiveTransformationFrom(source)
    &#34;&#34;&#34;
    return self.getPassiveTranslationRotationVectorsFrom(source, degrees=degrees)[0]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationVectorTo"><code class="name flex">
<span>def <span class="ident">getPassiveTranslationVectorTo</span></span>(<span>self, targetFrame, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)</p>
<p>extracts translation vector from the result of getPassiveTransformationTo(target)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPassiveTranslationVectorTo(self, targetFrame, degrees=True):
    &#34;&#34;&#34;
    getPassiveTranslationRotationVectorsTo(self,ref,degrees=True)

    extracts translation vector from the result of getPassiveTransformationTo(target)
    &#34;&#34;&#34;
    return self.getPassiveTranslationRotationVectorsTo(targetFrame, degrees=degrees)[0]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getRotationMatrix"><code class="name flex">
<span>def <span class="ident">getRotationMatrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getRotationMatrix()</p>
<p>Returns the rotation (matrix) defining this reference frame (from self.ref to self)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRotationMatrix(self):
    &#34;&#34;&#34;
    getRotationMatrix()

    Returns the rotation (matrix) defining this reference frame (from self.ref to self)
    &#34;&#34;&#34;
    result = self.transformation.copy()
    result[:3, 3] = [0.0, 0.0, 0.0]
    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getRotationVector"><code class="name flex">
<span>def <span class="ident">getRotationVector</span></span>(<span>self, degrees=True, active=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getRotationVector()</p>
<p>Returns the rotation (vector) defining this reference frame (from self.ref to self)
degrees : if true, rotation angles are expressed in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRotationVector(self, degrees=True, active=_ACTIVE_DEFAULT):
    &#34;&#34;&#34;
    getRotationVector()

    Returns the rotation (vector) defining this reference frame (from self.ref to self)
    degrees : if true, rotation angles are expressed in degrees
    &#34;&#34;&#34;
    rotation = t3.euler.mat2euler(self.transformation, axes=self.rot_config)
    if degrees:
        rotation = np.array([np.rad2deg(item) for item in rotation])
    return rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getTranslationRotationVectors"><code class="name flex">
<span>def <span class="ident">getTranslationRotationVectors</span></span>(<span>self, degrees=True, active=True)</span>
</code></dt>
<dd>
<div class="desc"><p>getTranslationRotationVectors()
Returns the translation and rotation (vectors) defining this reference frame (from self.ref to self)
degrees : if true, rotation angles are expressed in degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTranslationRotationVectors(self, degrees=True, active=_ACTIVE_DEFAULT):
    &#34;&#34;&#34;getTranslationRotationVectors()
    Returns the translation and rotation (vectors) defining this reference frame (from self.ref to self)
    degrees : if true, rotation angles are expressed in degrees
    &#34;&#34;&#34;
    translation = self.getTranslationVector()
    rotation = self.getRotationVector(degrees=degrees, active=active)
    return translation, rotation</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.getTranslationVector"><code class="name flex">
<span>def <span class="ident">getTranslationVector</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>getTranslationVector()</p>
<p>Returns the translation defining this reference frame (from self.ref to self)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTranslationVector(self):
    &#34;&#34;&#34;
    getTranslationVector()

    Returns the translation defining this reference frame (from self.ref to self)
    &#34;&#34;&#34;
    return self.transformation[:3, 3]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.isMaster"><code class="name flex">
<span>def <span class="ident">isMaster</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A Master reference frame is a reference frame that refers to itself, and the
transformation is the Identity matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isMaster(self):
    &#34;&#34;&#34;
    A Master reference frame is a reference frame that refers to itself, and the
    transformation is the Identity matrix.
    &#34;&#34;&#34;
    tr = self.transformation

    if (
        (self.name == self.ref.name)
        and (tr.shape[0] == tr.shape[1])
        and np.allclose(tr, np.eye(tr.shape[0]))
    ):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.isSame"><code class="name flex">
<span>def <span class="ident">isSame</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the two reference frames are the same except for their name.</p>
<p>Two Reference Frames are considered the same when:</p>
<ul>
<li>their transformation matrices are equal</li>
<li>the reference frame is equal</li>
<li>the rot_config is equal</li>
<li>the name may be different</li>
</ul>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>This needs further work and testing!</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isSame(self, other):
    &#34;&#34;&#34;
    Returns True if the two reference frames are the same except for their name.

    Two Reference Frames are considered the same when:

    * their transformation matrices are equal
    * the reference frame is equal
    * the rot_config is equal
    * the name may be different

    .. todo:: This needs further work and testing!
    &#34;&#34;&#34;

    if other is self:
        LOGGER.debug(
            &#34;self and other are the same object (beware: this message might occur with recursion from self.ref != self.other)&#34;
        )
        return True

    if isinstance(other, ReferenceFrame):
        LOGGER.flash_flood(f&#34;comparing {self.name} and {other.name}&#34;)
        if not np.array_equal(self.transformation, other.transformation):
            LOGGER.flash_flood(&#34;self.transformation not equals other.transformation&#34;)
            return False
        if self.rot_config != other.rot_config:
            LOGGER.flash_flood(&#34;self.rot_config not equals other.rot_config&#34;)
            return False
        # The following tests are here to prevent recursion to go infinite when self and other
        # point to itself
        if self.ref is self and other.ref is other:
            LOGGER.flash_flood(&#34;both self.ref and other.ref point to themselves&#34;)
            pass
        else:
            LOGGER.flash_flood(&#34;one of self.ref or other.ref doesn&#39;t points to itself&#34;)
            if self.ref != other.ref:
                LOGGER.flash_flood(&#34;self.ref not equals other.ref&#34;)
                return False
        if self.name is not other.name:
            LOGGER.flash_flood(
                f&#34;When checking two reference frames for equality, only their names differ: &#39;{self.name}&#39; not equals &#39;{other.name}&#39;&#34;
            )
            pass
        return True
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.is_master"><code class="name flex">
<span>def <span class="ident">is_master</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_master(self):
    return self.isMaster()</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.removeLink"><code class="name flex">
<span>def <span class="ident">removeLink</span></span>(<span>self, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the link between self and ref, both ways.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeLink(self, ref):
    &#34;&#34;&#34;
    Remove the link between self and ref, both ways.
    &#34;&#34;&#34;

    # First remove the entry in ref to this

    if self in ref.linkedTo:
        del ref.linkedTo[self]

    # Then remove the entry in this to ref

    if ref in self.linkedTo:
        del self.linkedTo[ref]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.setName"><code class="name flex">
<span>def <span class="ident">setName</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set or change the name of a reference frame.</p>
<p>..note: this method is deprecated</p>
<p>:param str name: the new name for the reference frame, if None, a random name will be generated.</p>
<p>:raises InvalidOperationError: when you try to change the name of the Master reference frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@deprecate(
    reason=(
        &#34;I do not see the added value of changing the name and &#34;
        &#34;the current method has the side effect to change the name &#34;
        &#34;to a random string when the name argument is already used.&#34;
    ),
    alternative=&#34;the constructor argument to set the name already of the object.&#34;,
)
def setName(self, name=None):
    &#34;&#34;&#34;
    Set or change the name of a reference frame.

    ..note: this method is deprecated

    :param str name: the new name for the reference frame, if None, a random name will be generated.

    :raises InvalidOperationError: when you try to change the name of the Master reference frame
    &#34;&#34;&#34;
    if self.isMaster():
        raise InvalidOperationError(
            &#34;You try to change the name of the Master reference frame, which is not allowed.&#34;
        )
    self.name = self.__createName(name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.setTransformation"><code class="name flex">
<span>def <span class="ident">setTransformation</span></span>(<span>self, transformation, updated=None, preserveLinks=True, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>setTransformation(self,transformation, updated=None, preserveLinks=True,_relative=False, verbose=True)</p>
<p>Alter the definition of this coordinate system</p>
<p>If other systems are linked to this one, their definition must be updated accordingly
The link set between two ref. Frames A &amp; B is the active transformation matrix from A to B
A.addLink(B, matrix)
A.getActiveTransformationTo(B) &ndash;&gt; matrix</p>
<p>The way to update the definition of the present system, and of those linked to it
depends on the structure of those links.</p>
<p>We define
- the target frame as the one we want to move / redefine
- 'linkedFrames' as those directly, or indirectly (i.e. via multiple links)
linked to the target frame
- endFrames as the subset of linkedFrames which are not linked to their reference (directly or indirectly)
- sideFrames as the set of frames whose reference is a linkedFrame, but not themselves belonging to the linkedFrames</p>
<p>We can demonstrate that updating the endFrames (Block A below) is sufficient to represent
the movement of the target frame and all frames directly or indirectly linked to it.</p>
<p>This may nevertheless have perverse effects for sideFrames. Indeed,
their reference will (directly or implicitely) be redefined, but they shouldn't:
they are not linked to their reference &ndash;&gt; their location in space (e.g. wrt the master frame)
should not be affected by the movement of the target frame. This is the aim of block B.</p>
<p>For a completely robust solution, 2 steps must be taken
BLOCK A. apply the rigt transformation to all "endFrames"
BLOCK B. Check for frames
using any of the "visited" frames as a reference
not linked to its reference
Correct its so that it doesn't move (it shouldn't be affected by the requested movement)
This demands a "referenceFor" array property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTransformation(
    self, transformation, updated=None, preserveLinks=True, _relative=False, verbose=True
):
    &#34;&#34;&#34;
    setTransformation(self,transformation, updated=None, preserveLinks=True,_relative=False, verbose=True)

    Alter the definition of this coordinate system

    If other systems are linked to this one, their definition must be updated accordingly
      The link set between two ref. Frames A &amp; B is the active transformation matrix from A to B
      A.addLink(B, matrix)
      A.getActiveTransformationTo(B) --&gt; matrix

    The way to update the definition of the present system, and of those linked to it
    depends on the structure of those links.

    We define
    - the target frame as the one we want to move / redefine
    - &#39;linkedFrames&#39; as those directly, or indirectly (i.e. via multiple links)
       linked to the target frame
    - endFrames as the subset of linkedFrames which are not linked to their reference (directly or indirectly)
    - sideFrames as the set of frames whose reference is a linkedFrame, but not themselves belonging to the linkedFrames

    We can demonstrate that updating the endFrames (Block A below) is sufficient to represent
    the movement of the target frame and all frames directly or indirectly linked to it.

    This may nevertheless have perverse effects for sideFrames. Indeed,
    their reference will (directly or implicitely) be redefined, but they shouldn&#39;t:
    they are not linked to their reference --&gt; their location in space (e.g. wrt the master frame)
    should not be affected by the movement of the target frame. This is the aim of block B.

    For a completely robust solution, 2 steps must be taken
    BLOCK A. apply the rigt transformation to all &#34;endFrames&#34;
    BLOCK B. Check for frames
                   using any of the &#34;visited&#34; frames as a reference
                   not linked to its reference
        Correct its so that it doesn&#39;t move (it shouldn&#39;t be affected by the requested movement)
        This demands a &#34;referenceFor&#34; array property

    &#34;&#34;&#34;
    # Ruthless, enforced redefinition of one system. Know what you do, or stay away.
    # Semi-unpredictible side effets if the impacted frame has links!
    if preserveLinks == False:
        self.transformation = transformation
        return

    if updated is None:
        updated = []

    # visitedFrames = all frames which can be reached from self via invariant links
    # endFrames = subset of visitedFrames that are at the end of a chain, and must be updated
    #             in order to properly represent the requested movement
    endFrames, visitedFrames = self._findEnds(frame=self, visited=[], ends=[], verbose=verbose)
    if verbose:
        LOGGER.info(
            f&#34;Visited sub-system                      {[f.name for f in visitedFrames]}&#34;
        )
        LOGGER.info(f&#34;End-frames (movement necessary)         {[f.name for f in endFrames]}&#34;)

    # All updates are done by relative movements
    # so we must first compute the relative movement corresponding to the requested absolute movement
    if _relative == False:
        ## virtual = what self should become after the (absolute) movement
        ## it allows to compute the relative transformation to be applied and work in relative further down
        virtual = ReferenceFrame(
            transformation, ref=self.ref, name=&#34;virtual&#34;, rot_config=self.rot_config
        )
        request = self.getActiveTransformationTo(virtual)
        del virtual
    else:
        # If this method is called by applyTransformation,
        # we are facing a request for a relative movement
        # In that case the input is directly what we want
        request = transformation

    # BLOCK B. Check for frames that were impacted but shouldn&#39;t have been and correct them
    # B1. List of frames demanding a correction
    #     &#39;impacted&#39; are frames having their reference inside the rigid structure moving, but not linked to it
    #     If nothing is done, the movement will implicitely displace them, which is not intended

    ### Impacted shall not contain frames that are linked to self (== to any frame in visitedFrames) via any route...
    ### We check if the impacted frames are in visitedFrames:
    ### it is enough to know it&#39;s connected to the entire &#39;solid body&#39; in which self belongs
    impacted = []
    for frame in visitedFrames:
        for child in frame.referenceFor:
            # Version 1 : too simple (restores too many frames)
            #if child not in frame.linkedTo:

            # Version 2 : overkill
            #child_ends, child_visited = child._findEnds(frame=child,visited=[],ends=[],verbose=verbose)
            #if frame not in child_visited:

            # Version 3 : just check if the child belongs to the rigid structure...
            if child not in visitedFrames:
                impacted.append(child)

    LOGGER.debug(f&#34;Impacted (not moving, defined in moving) {[f.name for f in impacted]}&#34;)

    # B2. save the location of all impacted frames
    # tempReference has the only purpose of avoiding that every frame must know the master
    # It could be any frame without links and defined wrt the master, but the master isn&#39;t known here...
    # TODO : confirm that the master isn&#39;t known (e.g. via cls._MASTER)
    tempMaster = self.findMaster()
    toRestore = {}
    for frame in impacted:
        toRestore[frame] = ReferenceFrame(
            frame.getActiveTransformationFrom(tempMaster),
            ref=tempMaster,
            name=frame.name + &#34;toRestore&#34;,
            rot_config=frame.rot_config,
        )

    # BLOCK A. apply the rigt transformation to all &#34;endFrames&#34;
    &#34;&#34;&#34;
    ### Ensure that &#34;Untouched&#34; remains unaffected regardless of the update order of the endFrames
    selfUntouched = ReferenceFrame(
        transformation = self.getActiveTransformationFrom(tempMaster),
        ref=tempMaster,
        name=self.name + &#34;_fixed&#34;,
        rot_config=self.rot_config,
    )
    &#34;&#34;&#34;

    selfUntouched = ReferenceFrame(
        transformation=self.transformation,
        ref=self.ref,
        name=self.name + &#34;_fixed&#34;,
        rot_config=self.rot_config,
    )

    for bottom in endFrames:

        up = bottom.getActiveTransformationTo(selfUntouched)
        down = selfUntouched.getActiveTransformationTo(bottom)

        relativeTransformation = up @ request @ down

        LOGGER.flash_flood(
            f&#34;\nAdjusting {bottom.name} to {self.name}\nUpdated {[i.name for i in updated]}&#34;
        )
        LOGGER.flash_flood(f&#34;\ninput transformation \n{np.round(transformation,3)}&#34;)
        LOGGER.flash_flood(
            f&#34;\nup \n{np.round(up,3)}\ntransformation\n{np.round(request,3)}\ndown\n{np.round(down,3)}&#34;
        )
        LOGGER.flash_flood(f&#34;\nrelativeTransformation \n{np.round(relativeTransformation,3)}&#34;)

        bottom.transformation = bottom.transformation @ relativeTransformation

        updated.append(bottom)

    for frame in visitedFrames:
        if frame not in updated:
            updated.append(frame)

    # Block B
    # B3. Correction
    # we must set preserveLinks to False to prevent cascading impact from this update
    # if X1 is impacted with
    #    X1.ref = E1     X1 --&gt; X2 (simple link)    E2.ref = X2
    # where X1 and X2 are &#34;external frames&#34; and E1 and E2 are &#34;endFrames&#34; that will hence move
    # X1 was impacted by the move of E1, but X2 wasn&#39;t
    # ==&gt; wrt master, neither X1 nor X2 should have moved, but X1 did (via its ref)
    # and hence its link with X2 is now corrupt
    # We need to move X1 back to its original location wrt master
    # if we preserved the links while doing that,
    # we will move X2, which shouldn&#39;t move
    # (it didn&#39;t have to, it didn&#39;t and the goal is to restore the validity of the links)
    #
    # Direct restoration or the impacted frames at their original location

    for frame in toRestore:
        frame.transformation = frame.ref.getActiveTransformationTo(toRestore[frame])

    del toRestore

    return</code></pre>
</details>
</dd>
<dt id="egse.coordinates.referenceFrame.ReferenceFrame.setTranslationRotation"><code class="name flex">
<span>def <span class="ident">setTranslationRotation</span></span>(<span>self, translation, rotation, rot_config='sxyz', active=True, degrees=True, preserveLinks=True)</span>
</code></dt>
<dd>
<div class="desc"><p>setTranslationRotation(self,translation,rotation,rot_config=_ROT_CONFIG_DEFAULT, active=_ACTIVE_DEFAULT, degrees=True, preserveLinks=True)</p>
<p>Same as setTransformation, but input = translation and rotation vectors rather than affine transformation matrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setTranslationRotation(
    self,
    translation,
    rotation,
    rot_config=_ROT_CONFIG_DEFAULT,
    active=_ACTIVE_DEFAULT,
    degrees=True,
    preserveLinks=True,
):
    &#34;&#34;&#34;
    setTranslationRotation(self,translation,rotation,rot_config=_ROT_CONFIG_DEFAULT, active=_ACTIVE_DEFAULT, degrees=True, preserveLinks=True)

    Same as setTransformation, but input = translation and rotation vectors rather than affine transformation matrix
    &#34;&#34;&#34;
    # Translation
    translation = np.array(translation)
    # Zoom - unit
    zdef = np.array([1, 1, 1])
    # Shear
    sdef = np.array([0, 0, 0])
    # Rotation
    if degrees:
        rotation = np.array([np.deg2rad(item) for item in rotation])

    rotx, roty, rotz = rotation

    rmat = RotationMatrix(rotx, roty, rotz, rot_config=rot_config, active=active)

    LOGGER.flash_flood(t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef))

    transformation = t3.affines.compose(translation, rmat.R, Z=zdef, S=sdef)

    self.setTransformation(transformation, preserveLinks=preserveLinks, _relative=False)
    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.coordinates" href="index.html">egse.coordinates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.coordinates.referenceFrame.transformationToString" href="#egse.coordinates.referenceFrame.transformationToString">transformationToString</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.coordinates.referenceFrame.ReferenceFrame" href="#egse.coordinates.referenceFrame.ReferenceFrame">ReferenceFrame</a></code></h4>
<ul class="">
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.addLink" href="#egse.coordinates.referenceFrame.ReferenceFrame.addLink">addLink</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.applyTransformation" href="#egse.coordinates.referenceFrame.ReferenceFrame.applyTransformation">applyTransformation</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.applyTranslationRotation" href="#egse.coordinates.referenceFrame.ReferenceFrame.applyTranslationRotation">applyTranslationRotation</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.createMaster" href="#egse.coordinates.referenceFrame.ReferenceFrame.createMaster">createMaster</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.findMaster" href="#egse.coordinates.referenceFrame.ReferenceFrame.findMaster">findMaster</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.find_master" href="#egse.coordinates.referenceFrame.ReferenceFrame.find_master">find_master</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.fromPoints" href="#egse.coordinates.referenceFrame.ReferenceFrame.fromPoints">fromPoints</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.fromRotation" href="#egse.coordinates.referenceFrame.ReferenceFrame.fromRotation">fromRotation</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.fromTranslation" href="#egse.coordinates.referenceFrame.ReferenceFrame.fromTranslation">fromTranslation</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.fromTranslationRotation" href="#egse.coordinates.referenceFrame.ReferenceFrame.fromTranslationRotation">fromTranslationRotation</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveRotationVectorFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveRotationVectorFrom">getActiveRotationVectorFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveRotationVectorTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveRotationVectorTo">getActiveRotationVectorTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTransformationFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveTransformationFrom">getActiveTransformationFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTransformationTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveTransformationTo">getActiveTransformationTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationRotationVectorsFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationRotationVectorsFrom">getActiveTranslationRotationVectorsFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationRotationVectorsTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationRotationVectorsTo">getActiveTranslationRotationVectorsTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationVectorFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationVectorFrom">getActiveTranslationVectorFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationVectorTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getActiveTranslationVectorTo">getActiveTranslationVectorTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getAxis" href="#egse.coordinates.referenceFrame.ReferenceFrame.getAxis">getAxis</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getNormal" href="#egse.coordinates.referenceFrame.ReferenceFrame.getNormal">getNormal</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getOrigin" href="#egse.coordinates.referenceFrame.ReferenceFrame.getOrigin">getOrigin</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveRotationVectorFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveRotationVectorFrom">getPassiveRotationVectorFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveRotationVectorTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveRotationVectorTo">getPassiveRotationVectorTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTransformationFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTransformationFrom">getPassiveTransformationFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTransformationTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTransformationTo">getPassiveTransformationTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationRotationVectorsFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationRotationVectorsFrom">getPassiveTranslationRotationVectorsFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationRotationVectorsTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationRotationVectorsTo">getPassiveTranslationRotationVectorsTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationVectorFrom" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationVectorFrom">getPassiveTranslationVectorFrom</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationVectorTo" href="#egse.coordinates.referenceFrame.ReferenceFrame.getPassiveTranslationVectorTo">getPassiveTranslationVectorTo</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getRotationMatrix" href="#egse.coordinates.referenceFrame.ReferenceFrame.getRotationMatrix">getRotationMatrix</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getRotationVector" href="#egse.coordinates.referenceFrame.ReferenceFrame.getRotationVector">getRotationVector</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getTranslationRotationVectors" href="#egse.coordinates.referenceFrame.ReferenceFrame.getTranslationRotationVectors">getTranslationRotationVectors</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.getTranslationVector" href="#egse.coordinates.referenceFrame.ReferenceFrame.getTranslationVector">getTranslationVector</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.isMaster" href="#egse.coordinates.referenceFrame.ReferenceFrame.isMaster">isMaster</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.isSame" href="#egse.coordinates.referenceFrame.ReferenceFrame.isSame">isSame</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.is_master" href="#egse.coordinates.referenceFrame.ReferenceFrame.is_master">is_master</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.removeLink" href="#egse.coordinates.referenceFrame.ReferenceFrame.removeLink">removeLink</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.setName" href="#egse.coordinates.referenceFrame.ReferenceFrame.setName">setName</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.setTransformation" href="#egse.coordinates.referenceFrame.ReferenceFrame.setTransformation">setTransformation</a></code></li>
<li><code><a title="egse.coordinates.referenceFrame.ReferenceFrame.setTranslationRotation" href="#egse.coordinates.referenceFrame.ReferenceFrame.setTranslationRotation">setTranslationRotation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
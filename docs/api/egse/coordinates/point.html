<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.coordinates.point API documentation</title>
<meta name="description" content="The point module provides two classes, a `Point` class which simply represents a point
in the 3D space, and a `Points` class which is a collection of â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.coordinates.point</code></h1>
</header>
<section id="section-intro">
<p>The point module provides two classes, a <code><a title="egse.coordinates.point.Point" href="#egse.coordinates.point.Point">Point</a></code> class which simply represents a point
in the 3D space, and a <code><a title="egse.coordinates.point.Points" href="#egse.coordinates.point.Points">Points</a></code> class which is a collection of Point objects.</p>
<p>A Point is defined with respect to a given reference frame and is given a name.</p>
<p>Point objects defined in the same reference frame can be combined with the
natural <code>+</code>, <code>-</code> , <code>+=</code> and <code>-=</code> operations.</p>
<p>In order to work with 4x4 transformation matrices, the 3D [x,y,z] coordinates are
automatically converted to a [x,y,z,1] coordinates array attribute.</p>
<p>@author: Pierre Royer</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The point module provides two classes, a `Point` class which simply represents a point
in the 3D space, and a `Points` class which is a collection of Point objects.

A Point is defined with respect to a given reference frame and is given a name.

Point objects defined in the same reference frame can be combined with the
natural `+`, `-` , `+=` and `-=` operations.

In order to work with 4x4 transformation matrices, the 3D [x,y,z] coordinates are
automatically converted to a [x,y,z,1] coordinates array attribute.

@author: Pierre Royer
&#34;&#34;&#34;
import logging
import random
import string

import numpy as np

import egse.coordinates.transform3d_addon as t3add

LOGGER = logging.getLogger(__name__)


class Point:
    &#34;&#34;&#34;
    A Point object represents a point in 3D space and is defined with respect to
    a given reference frame.

    .. note::
        There is no check that the randomly generated name is unique, so two Point
        objects can be different but have the same name.

    &#34;&#34;&#34;
    debug = 0

    def __init__(self, coordinates, ref, name=None):
        &#34;&#34;&#34;
        This initializes a Point object in a given reference frame.

        Args:
            coordinates (numpy.ndarray, list): 1x3 or 1x4 matrix defining this system in &#34;ref&#34; system
                (1x3 being x,y,z + an additional 1 for the affine operations)

            ref (ReferenceFrame): the reference system in which this Point object will be defined,
                if not given or None the master reference frame will be used

        &#34;&#34;&#34;

        # Makes sure of format [x,y,z,1] and sets coordinates
        self.setCoordinates(coordinates)

        # set the reference frame of reference
        if ref is None:
            raise ValueError(&#34;A Point shall be defined with a reference frame, ref can not be None.&#34;)
        else:
            self.ref = ref

        self.setName(name)

        self.definition = [self.coordinates[:-1], self.ref, self.name]

    def __repr__(self):
        return f&#34;{self.coordinates[:-1]} (ref {self.ref.name})&#34;

    def __str__(self):
        return f&#34;{self.coordinates[:-1]} (ref {self.ref.name}), name {self.name}&#34;

    def __eq__(self, other):
        &#34;&#34;&#34;
        Re-implements the == operator which by default checks if id(self) == id(other).

        Two Point objects are equal when:

        * their coordinates are equal
        * the reference system in which they are defined is equal
        * the name must not be equal
        &#34;&#34;&#34;
        if self is other:
            return True

        if isinstance(other, Point):
            if not np.array_equal(self.coordinates, other.coordinates):
                return False
            if self.ref != other.ref:
                return False
            return True
        return NotImplemented

    def __hash__(self):
        return id(self.definition) // 16

    def isSame(self, other):
        &#34;&#34;&#34;
        This checks if a Point is the same as another Point in a different reference frame.

        Two Point objects are the same when their position, i.e. coordinates, are equal
        after they have been expressed in the same reference frame.

        :param other: a Point object that you want to check
        :type other: Point

        :returns: True when the two Point objects are the same, False otherwise

        :raises TypeError: when other is not a compatible type, NotImplemented will returned
                           which will result in a ```TypeError: unsupported operand type(s) for +:```.
        &#34;&#34;&#34;

        if isinstance(other, Point):
            if self == other:
                return True
            else:
                if np.array_equal(self.coordinates, other.expressIn(self.ref)):
                    return True
            return False
        return NotImplemented

    @staticmethod
    def __coords__(coordinates):
        &#34;&#34;&#34;
        Formats 1x3 or 1x4 input lists or np.arrays into 1x4 np.array coordinates
        Static --&gt; can be called &#39;from outside&#39;, without passing a Point object
        &#34;&#34;&#34;
        if isinstance(coordinates, Point):
            return coordinates.coordinates
        elif isinstance(coordinates, (np.ndarray, list)):
            coordinates = list(coordinates)
            if len(coordinates) == 3:
                coordinates.append(1)
            return coordinates
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray or Point&#34;)

    def setName(self, name=None):
        &#34;&#34;&#34;
        Set or change the name of a Point object.

        :param str name: the new name for the Point, if None, a random name will be generated.

        .. todo:: Should we care about the possibility the the generation of random names does not
                  necessarily create a unique name for the Point?
        &#34;&#34;&#34;
        if name is None:
            self.name = &#39;p&#39;+&#39;&#39;.join(random.choices(string.ascii_lowercase, k=3))
        else:
            self.name = name

    def setCoordinates(self, coordinates):
        &#34;&#34;&#34;
        Set the coordinates of this Point object.
        &#34;&#34;&#34;
        coordinates = Point.__coords__(coordinates)
        self.coordinates = np.array(coordinates)

        self.x = self.coordinates[0]
        self.y = self.coordinates[1]
        self.z = self.coordinates[2]

    def getCoordinates(self, ref=None):
        &#34;&#34;&#34;
        Returns the coordinates of this Points object.

        If no reference frame is given, the coordinates of the Point will just be returned,
        other wise this method behaves the same as the ``expressIn(ref)`` method.

        :param ref: the Reference Frame in which the Point shall be defined
        :type ref: ReferenceFrame
        &#34;&#34;&#34;
        if ref is None:
            return self.coordinates
        else:
            return self.expressIn(ref)

    def distanceTo(self, target):
        &#34;&#34;&#34;
        Returns the distance of this Point object to the target. Target can be another Point,
        a ReferenceFrame object or a Numpy dnarray or list with coordinates.
        &#34;&#34;&#34;
        from egse.coordinates.referenceFrame import ReferenceFrame

        if isinstance(target, Point):
            targetCoords = target.expressIn(self.ref)[:3]
        elif isinstance(target, ReferenceFrame):
            return np.linalg.norm(self.expressIn(target)[:3])
        elif isinstance(target, (np.ndarray, list)):
            if len(target) &gt; 3:
                target = target[:3]
            targetCoords = target
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray, Point or ReferenceFrame&#34;)

        LOGGER.info(f&#34;self={self.coordinates[:-1]}, target={targetCoords}&#34;)

        return np.linalg.norm(self.coordinates[:3]-targetCoords)

    def inPlaneDistanceTo(self,target,plane=&#39;xy&#39;):
        &#34;&#34;&#34;
        Returns the distance of this Point object to the target, considering 2 coordinates only!

        target: can be another Point, a ReferenceFrame object or a Numpy dnarray or list with coordinates.

        plane : must be in [&#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;]

        NB: The xy, yz or xz plane used to project the points coordinates before
            computing the distances is taken from the coordinate system of &#34;self&#34;
            ==&gt; pointA.inPlaneDistanceTo(pointB) != pointB.inPlaneDistanceTo(pointA)
            The first projects on the xy plane of pointA.ref, the second on the xy plane of pointB.ref
        &#34;&#34;&#34;
        from egse.coordinates.referenceFrame import ReferenceFrame

        if isinstance(target, Point):
            targetCoords = target.expressIn(self.ref)
        elif isinstance(target, ReferenceFrame):
            targetCoords = target.getOrigin().expressIn(self)
        elif isinstance(target, (np.ndarray, list)):
            targetCoords = target
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray, Point or ReferenceFrame&#34;)

        LOGGER.info(f&#34;self={self.coordinates[:-1]}, target={targetCoords}&#34;)

        planeSelect = {&#39;xy&#39;:[0,1], &#39;xz&#39;:[0,2], &#39;yz&#39;:[1,2]}

        LOGGER.info(f&#34;self.coordinates[planeSelect[plane]]  {self.coordinates[planeSelect[plane]]}&#34;)
        LOGGER.info(f&#34;targetCoords[planeSelect[plane]]      {targetCoords[planeSelect[plane]]}&#34;)
        LOGGER.info(f&#34;Difference                            {self.coordinates[planeSelect[plane]]-targetCoords[planeSelect[plane]]}&#34;)

        return np.linalg.norm(self.coordinates[planeSelect[plane]]-targetCoords[planeSelect[plane]])

    def distanceToPlane(self,plane=&#34;xy&#34;,ref=None):
        &#34;&#34;&#34;
        distanceToPlane(self,plane=&#34;xy&#34;,ref=None)

        The target plane is defined by one of it coordinate planes: [&#34;xy&#34;, &#34;yz&#34;, &#34;xz&#34;]

        :param ref: reference frame
        :type ref: ReferenceFrame

        :param plane: in [&#34;xy&#34;, &#34;xz&#34;, &#34;yz&#34;]
        :type plane: str

        :returns: the distance from self to plane
        &#34;&#34;&#34;
        if (ref is None) or (self.ref == ref):
            coordinates = self.coordinates[:-1]
        elif self.ref != ref:
            coordinates = self.expressIn(ref)

        outOfPlaneIndex = {&#39;xy&#39;:2,&#39;xz&#39;:1,&#39;yz&#39;:0}

        return coordinates[outOfPlaneIndex[plane]]

    def __sub__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        newPoint = self + point
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates - apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates - Point.__coords__(apoint)

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        return Point(coordinates=newCoordinates,ref=self.ref)

    def __isub__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        self += coordinates (modifies self in place)
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates - apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates - Point.__coords__(apoint)

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        self.coordinates = newCoordinates

        return self

    def __add__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        newPoint = self + point
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    print(f&#34;DEBUG: {apoint} = {apoint.expressIn(self.ref)}&#34;)
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates + apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates + Point.__coords__(apoint)

        else:
            return NotImplemented

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        return Point(coordinates=newCoordinates,ref=self.ref)

    def __iadd__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        self += coordinates (modifies self in place)
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates + apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates + Point.__coords__(apoint)

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        self.coordinates = newCoordinates

        return self

    def expressIn(self,targetFrame):
        &#34;&#34;&#34;
        expressIn(self,targetFrame)
        &#34;&#34;&#34;
        if targetFrame == self.ref:
            &#34;&#34;&#34;
            targetFrame == self.ref
            We&#39;re after the definition of self
            &#34;&#34;&#34;
            result = self.coordinates
        else:
            &#34;&#34;&#34;
            We&#39;re after the coordinates of self, i.e. the definition of self in targetFrame

            We know the coordinates in self.ref
            #We need to apply the transformation from targetFrame to self.ref
            self.ref        --&gt; self (self.transformation)
            &#34;&#34;&#34;
            #transform = targetFrame.getTransformationFrom(self.ref)
            transform = self.ref.getPassiveTransformationTo(targetFrame)
            if self.debug: print(&#34;transform \n{0}&#34;.format(transform))
            result    = np.dot(transform,self.coordinates)
        return result

    def changeRef(self,targetFrame):
        &#34;&#34;&#34;
        We redefine self as attached to another reference frame
        . calculate self&#39;s coordinates in the new reference frame
        . update the definition
        &#34;&#34;&#34;
        newCoordinates = self.expressIn(targetFrame)
        self.setCoordinates(newCoordinates)
        self.ref = targetFrame
        return




class Points():
    &#34;&#34;&#34;
    A Points object is a collection of Point objects.

    Points can be constructed from either a numpy.ndarray of shape 3 x n or 4 x n, or
    a list of Point objects. The coordinates of the Point objects are transferred to
    the desired ReferenceFrame and concatenated in the list order.

    When automatically generated a Points object name consists in a capital &#39;P&#39; followed by
    three lower case letters. A Point can be extracted from a Points object by its
    position in the coordinates array (see below).

    &#34;&#34;&#34;
    debug=0
    def __init__(self, coordinates, ref,name=None):
        &#34;&#34;&#34;
        Points.__init__(self, coordinates, ref, name=None)

        Constructor

        coordinates : must be of one of the following type:
            * numpy.ndarray:
              4xn matrix defining this system in &#34;ref&#34; system
              (3 being x,y,z + an additional 1 for the affine operations)
            * list of Point objects:
              the coordinates of the Point objects are extracted in the order of the list
              and concatenated in a numpy.ndarray

        ref         : reference system in which self is defined

        Both parameters are mandatory.
        &#34;&#34;&#34;

        # TODO: accept a list made of Point and Points rather than strictly Point

        if isinstance(coordinates, list):
            coordinateList = []
            for apoint in coordinates:
                if not isinstance(apoint, Point):
                    raise ValueError(&#34;If the input is a list, all items in it must be Point(s) objects&#34;)
                coordinateList.append(apoint.expressIn(ref))
            self.setCoordinates(np.array(coordinateList).T)
        elif isinstance(coordinates, np.ndarray):
            self.setCoordinates(coordinates)
        else:
            raise ValueError(&#34;The input must be either a numpy.ndarray or a list of Point objects&#34;)

        self.ref = ref

        self.setName(name)

        return

    def __repr__(self):
        return &#34;{0} (ref {1})&#34;.format(self.coordinates[:-1], self.ref.name)

    def __str__(self):
        return &#34;{1} (ref {2}), name {0}&#34;.format(self.name, self.coordinates[:-1], self.ref.name)

    @staticmethod
    def __coords__(coordinates):
        &#34;&#34;&#34;
        Formats 3xn or 4xn input lists or np.arrays into 4xn np.array coordinates
        Static --&gt; can be called &#39;from outside&#39;, without passing a Points object
        &#34;&#34;&#34;
        if isinstance(coordinates, Point):
            return coordinates.coordinates
        elif isinstance(coordinates, np.ndarray):

            if coordinates.shape[0] not in [3,4]:
                raise ValueError(&#34;Input coordinates array must be 3 x n or 4 x n&#34;)

            if coordinates.shape[0]==3:
                newCoords = np.ones([4,coordinates.shape[1]])
                newCoords[:3,:] = coordinates
                coordinates = newCoords
            return coordinates
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray or Point&#34;)

    def setName(self,name=None):
        if name is None:
            self.name = &#39;P&#39;+ &#39;&#39;.join(random.choices(string.ascii_lowercase, k=2))+\
                             &#39;&#39;.join(random.choices(string.ascii_uppercase, k=1))
        else:
            self.name = name

    def setCoordinates(self,coordinates):
        #coordinates = list(coordinates)
        #if len(coordinates)==3: coordinates.append(1)
        coordinates = Points.__coords__(coordinates)
        self.coordinates = coordinates

        self.x = self.coordinates[0,:]
        self.y = self.coordinates[1,:]
        self.z = self.coordinates[2,:]

        return

    def getCoordinates(self,ref=None):
        if ref is None:
            return self.coordinates
        else:
            return self.expressIn(ref)

    def expressIn(self,targetFrame):
        &#34;&#34;&#34;
        expressIn(self,targetFrame)
        &#34;&#34;&#34;
        if targetFrame == self.ref:
            &#34;&#34;&#34;
            targetFrame == self.ref
            We&#39;re after the definition of self
            &#34;&#34;&#34;
            result = self.coordinates
        else:
            &#34;&#34;&#34;
            We&#39;re after the coordinates of self, i.e. the definition of self in targetFrame

            We know the coordinates in self.ref
            #We need to apply the transformation from targetFrame to self.ref
            self.ref        --&gt; self (self.transformation)
            &#34;&#34;&#34;
            #transform = targetFrame.getTransformationFrom(self.ref)
            transform = self.ref.getPassiveTransformationTo(targetFrame)
            if self.debug: print(&#34;transform \n{0}&#34;.format(transform))
            result    = np.dot(transform,self.coordinates)
        return result

    def changeRef(self,targetFrame):
        &#34;&#34;&#34;
        We redefine self as attached to another reference frame
        . calculate self&#39;s coordinates in the new reference frame
        . update the definition
        &#34;&#34;&#34;
        newCoordinates = self.expressIn(targetFrame)
        self.setCoordinates(newCoordinates)
        self.ref = targetFrame
        return

    def getPoint(self,index,name=None):
        &#34;&#34;&#34;
        Returns the point with coordinates self.coordinates[:,index], in reference frame pts.ref
        &#34;&#34;&#34;
        return Point(self.coordinates[:,index],ref=self.ref,name=name)

    get = getPoint

    def bestFittingPlane(self,fitPlane=&#34;xy&#34;, usesvd=False,verbose=True):
        &#34;&#34;&#34;
        bestFittingPlane(self,fitPlane=&#34;xy&#34;, usesvd=False,verbose=True)

        fitPlane in [&#39;xy,&#39;yz&#39;,&#39;zx&#39;]
        usesvd   see transform3d_addon.affine_matrix_from_points.__doc__

        OUTPUT
        returns the reference Frame having as X-Y plane the plane best fitting all points in self
        &#34;&#34;&#34;
        # Import necessary due to a circular dependency between Point and ReferenceFrame
        from egse.coordinates.referenceFrame import ReferenceFrame

        debug=True

        a,b,c = self.fitPlane(fitPlane=fitPlane,verbose=verbose)
        #print (f&#34;a {a}, b {b}, c {c}&#34;)
        #print()

        unitaxes = Points.fromPlaneParameters(a,b,c,ref=self.ref,plane=fitPlane)
        #print(f&#34;Unitaxes coordinates \n{np.round(unitaxes.coordinates,3)}&#34;)
        #print()


        # unitaxes contain 3 unit axes and an origin
        # =&gt; the unit vectors do NOT belong to the target plane
        # =&gt; they must be translated before
        unitcoords = unitaxes.coordinates
        for ax in range(3):
            unitcoords[:3,ax] += unitcoords[:3,3]

        newaxes = Points(unitcoords, ref=self.ref)

        #print(f&#34;newaxes {np.round(newaxes.coordinates,3)}&#34;)

        selfaxes = Points(np.identity(4),ref=self.ref)

        transform  = t3add.affine_matrix_from_points(selfaxes.coordinates[:3,:], newaxes.coordinates[:3,:], shear=False, scale=False, usesvd=usesvd)


        if debug:
            transform2 =        t3add.rigid_transform_3D(selfaxes.coordinates[:3,:], newaxes.coordinates[:3,:], verbose=verbose)

        if verbose:
            print()
            print(f&#34;Transform  \n{np.round(transform,3)}&#34;)
            if debug:
                print()
                print(f&#34;Transform2 \n{np.round(transform2,3)}&#34;)
                print()
                print(f&#34;Both methods consistent ? {np.allclose(transform, transform2)}&#34;)

        return ReferenceFrame(transformation=transform, ref=self.ref)



    def fitPlane(self,fitPlane=&#34;xy&#34;,verbose=True):
        &#34;&#34;&#34;
        fitPlane(self,fitPlane=&#34;xy&#34;,verbose=True)

        :returns: the best fitting parameters a, b, c corresponding to the fitted plane

        :param fitPlane: defines the expression of the fitted plane in [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;]:
                         &#39;xy&#39; : z = ax + by + c
                         &#39;yz&#39; : x = ay + bz + c
                         &#39;zx&#39; : y = az + bx + c

        :param verbose: default = True
        &#34;&#34;&#34;
        xyz = [self.x,self.y,self.z]

        ndata = len(xyz[0])

        # Account for cases
        startingIndex={&#39;xy&#39;:0,&#39;yz&#39;:1,&#39;zx&#39;:2}[fitPlane]

        # System matrix
        A = np.vstack([xyz[startingIndex],xyz[(startingIndex+1)%3], np.ones(ndata)]).T

        # Solve linear equations
        a, b, c = np.linalg.lstsq(A, xyz[(startingIndex+2)%3],rcond=None)[0]

        # Print results on screen
        if verbose:
            hprint = {&#39;xy&#39;:&#39;z = ax + by + c&#39;,&#39;yz&#39;:&#39;x = ay + bz + c&#39;,&#39;zx&#39;:&#39;y = az + bx + c&#39;}
            print(f&#39;{hprint[fitPlane]} : \n    a = {a:7.3e}  \n    b = {b:7.3e} \n    c = {c:7.3e}&#39;)

        return a,b,c

    @classmethod
    def fromPlaneParameters(cls,a,b,c,ref,plane=&#39;xy&#39;,verbose=False):
        &#34;&#34;&#34;fromPlaneParameters(cls,a,b,c,ref,plane=&#39;xy&#39;,verbose=False)

        Returns a Points object describing the unit axes and the origin of the reference frame defined by
        the input parameters.

        :param plane: The plane definition depends on the &#34;plane&#34; parameter plane must be in [&#34;xy&#34;,&#34;yz&#34;,&#34;zx&#34;]
                      &#39;xy&#39; : z = ax + by + c (origin defined at x = y = 0)
                      &#39;yz&#39; : x = ay + bz + c  --&gt; NOT IMPLEMENTED
                      &#39;zx&#39; : y = az + bx + c  --&gt; NOT IMPLEMENTED

        :returns:  A Points with 4 Point objects corresponding to
                   - the 3 unit axes defining a coordinate system with this plane as &#34;plane&#34; plane
                   - the origin
                   in this order (origin last)
        &#34;&#34;&#34;
        if plane != &#39;xy&#39;:
            print(f&#34;WARNING: plane = {plane} NOT IMPLEMENTED&#34;)
        # p0 : on the Z-axis
        # x = y = 0
        p0 = np.array([0,0,c])

        # pxy : on the intersection between target plane and plane // to xy passing through z=c
        if np.abs(b)&gt;1.e-5:
            # z = c, x = 1
            pxy = np.array([1,-a/float(b),c])
        else:
            # z = c, y = 1
            pxy = np.array([-b/float(a),1,c])

        # pyz : intersection of target plane and Y-Z plane
        # x = 0, y = 1
        pyz = np.array([0,1,b+c])

        &#34;&#34;&#34;
        # pzx : intersection of target plane and Z-X plane
        if np.abs(a)&gt;1.e-3:
            # y = 0, z = 1
            pzx = np.array([(1-c)/float(a),0,1])
        else:
            # y = 0, x = 1
            pzx = np.array([1,0,a+c])
        &#34;&#34;&#34;
        #
        # xunit = unit vector from [0,0,0] along the intersection between target plane and plane // to xy passing through z=c
        xunit = (pxy - p0)/np.linalg.norm(pxy-p0)
        # ytemp = unit vector from [0,0,0] along the intersection between target plane and Y-Z plane
        # ytemp is in the target plane, but not perpendicular to xunit
        # its norm doesn&#39;t matter
        ytemp = (pyz - p0)#/np.linalg.norm(pyz-p0)

        # xunit and ytemp are both in the plane
        # =&gt; zunit is perpendicular to both
        zunit = np.cross(xunit,ytemp)
        zunit /= np.linalg.norm(zunit)

        # yunit completes the right handed reference frame
        # The renormalisation shouldn&#39;t be necessary...
        yunit = np.cross(zunit,xunit)
        yunit /= np.linalg.norm(yunit)

        xu = Point(xunit,ref=ref)
        yu = Point(yunit,ref=ref)
        zu = Point(zunit,ref=ref)
        origin = Point(p0,ref=ref)

        if verbose:
            print(f&#39;xunit  {xunit}&#39;)
            print(f&#39;yunit  {yunit}&#39;)
            print(f&#39;zunit  {zunit}&#39;)
            print(f&#39;origin {p0}&#39;)
            print()

        return cls([xu,yu,zu,origin],ref=ref)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.coordinates.point.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>coordinates, ref, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Point object represents a point in 3D space and is defined with respect to
a given reference frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is no check that the randomly generated name is unique, so two Point
objects can be different but have the same name.</p>
</div>
<p>This initializes a Point object in a given reference frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>numpy.ndarray, list</code></dt>
<dd>1x3 or 1x4 matrix defining this system in "ref" system
(1x3 being x,y,z + an additional 1 for the affine operations)</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>ReferenceFrame</code></dt>
<dd>the reference system in which this Point object will be defined,
if not given or None the master reference frame will be used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point:
    &#34;&#34;&#34;
    A Point object represents a point in 3D space and is defined with respect to
    a given reference frame.

    .. note::
        There is no check that the randomly generated name is unique, so two Point
        objects can be different but have the same name.

    &#34;&#34;&#34;
    debug = 0

    def __init__(self, coordinates, ref, name=None):
        &#34;&#34;&#34;
        This initializes a Point object in a given reference frame.

        Args:
            coordinates (numpy.ndarray, list): 1x3 or 1x4 matrix defining this system in &#34;ref&#34; system
                (1x3 being x,y,z + an additional 1 for the affine operations)

            ref (ReferenceFrame): the reference system in which this Point object will be defined,
                if not given or None the master reference frame will be used

        &#34;&#34;&#34;

        # Makes sure of format [x,y,z,1] and sets coordinates
        self.setCoordinates(coordinates)

        # set the reference frame of reference
        if ref is None:
            raise ValueError(&#34;A Point shall be defined with a reference frame, ref can not be None.&#34;)
        else:
            self.ref = ref

        self.setName(name)

        self.definition = [self.coordinates[:-1], self.ref, self.name]

    def __repr__(self):
        return f&#34;{self.coordinates[:-1]} (ref {self.ref.name})&#34;

    def __str__(self):
        return f&#34;{self.coordinates[:-1]} (ref {self.ref.name}), name {self.name}&#34;

    def __eq__(self, other):
        &#34;&#34;&#34;
        Re-implements the == operator which by default checks if id(self) == id(other).

        Two Point objects are equal when:

        * their coordinates are equal
        * the reference system in which they are defined is equal
        * the name must not be equal
        &#34;&#34;&#34;
        if self is other:
            return True

        if isinstance(other, Point):
            if not np.array_equal(self.coordinates, other.coordinates):
                return False
            if self.ref != other.ref:
                return False
            return True
        return NotImplemented

    def __hash__(self):
        return id(self.definition) // 16

    def isSame(self, other):
        &#34;&#34;&#34;
        This checks if a Point is the same as another Point in a different reference frame.

        Two Point objects are the same when their position, i.e. coordinates, are equal
        after they have been expressed in the same reference frame.

        :param other: a Point object that you want to check
        :type other: Point

        :returns: True when the two Point objects are the same, False otherwise

        :raises TypeError: when other is not a compatible type, NotImplemented will returned
                           which will result in a ```TypeError: unsupported operand type(s) for +:```.
        &#34;&#34;&#34;

        if isinstance(other, Point):
            if self == other:
                return True
            else:
                if np.array_equal(self.coordinates, other.expressIn(self.ref)):
                    return True
            return False
        return NotImplemented

    @staticmethod
    def __coords__(coordinates):
        &#34;&#34;&#34;
        Formats 1x3 or 1x4 input lists or np.arrays into 1x4 np.array coordinates
        Static --&gt; can be called &#39;from outside&#39;, without passing a Point object
        &#34;&#34;&#34;
        if isinstance(coordinates, Point):
            return coordinates.coordinates
        elif isinstance(coordinates, (np.ndarray, list)):
            coordinates = list(coordinates)
            if len(coordinates) == 3:
                coordinates.append(1)
            return coordinates
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray or Point&#34;)

    def setName(self, name=None):
        &#34;&#34;&#34;
        Set or change the name of a Point object.

        :param str name: the new name for the Point, if None, a random name will be generated.

        .. todo:: Should we care about the possibility the the generation of random names does not
                  necessarily create a unique name for the Point?
        &#34;&#34;&#34;
        if name is None:
            self.name = &#39;p&#39;+&#39;&#39;.join(random.choices(string.ascii_lowercase, k=3))
        else:
            self.name = name

    def setCoordinates(self, coordinates):
        &#34;&#34;&#34;
        Set the coordinates of this Point object.
        &#34;&#34;&#34;
        coordinates = Point.__coords__(coordinates)
        self.coordinates = np.array(coordinates)

        self.x = self.coordinates[0]
        self.y = self.coordinates[1]
        self.z = self.coordinates[2]

    def getCoordinates(self, ref=None):
        &#34;&#34;&#34;
        Returns the coordinates of this Points object.

        If no reference frame is given, the coordinates of the Point will just be returned,
        other wise this method behaves the same as the ``expressIn(ref)`` method.

        :param ref: the Reference Frame in which the Point shall be defined
        :type ref: ReferenceFrame
        &#34;&#34;&#34;
        if ref is None:
            return self.coordinates
        else:
            return self.expressIn(ref)

    def distanceTo(self, target):
        &#34;&#34;&#34;
        Returns the distance of this Point object to the target. Target can be another Point,
        a ReferenceFrame object or a Numpy dnarray or list with coordinates.
        &#34;&#34;&#34;
        from egse.coordinates.referenceFrame import ReferenceFrame

        if isinstance(target, Point):
            targetCoords = target.expressIn(self.ref)[:3]
        elif isinstance(target, ReferenceFrame):
            return np.linalg.norm(self.expressIn(target)[:3])
        elif isinstance(target, (np.ndarray, list)):
            if len(target) &gt; 3:
                target = target[:3]
            targetCoords = target
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray, Point or ReferenceFrame&#34;)

        LOGGER.info(f&#34;self={self.coordinates[:-1]}, target={targetCoords}&#34;)

        return np.linalg.norm(self.coordinates[:3]-targetCoords)

    def inPlaneDistanceTo(self,target,plane=&#39;xy&#39;):
        &#34;&#34;&#34;
        Returns the distance of this Point object to the target, considering 2 coordinates only!

        target: can be another Point, a ReferenceFrame object or a Numpy dnarray or list with coordinates.

        plane : must be in [&#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;]

        NB: The xy, yz or xz plane used to project the points coordinates before
            computing the distances is taken from the coordinate system of &#34;self&#34;
            ==&gt; pointA.inPlaneDistanceTo(pointB) != pointB.inPlaneDistanceTo(pointA)
            The first projects on the xy plane of pointA.ref, the second on the xy plane of pointB.ref
        &#34;&#34;&#34;
        from egse.coordinates.referenceFrame import ReferenceFrame

        if isinstance(target, Point):
            targetCoords = target.expressIn(self.ref)
        elif isinstance(target, ReferenceFrame):
            targetCoords = target.getOrigin().expressIn(self)
        elif isinstance(target, (np.ndarray, list)):
            targetCoords = target
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray, Point or ReferenceFrame&#34;)

        LOGGER.info(f&#34;self={self.coordinates[:-1]}, target={targetCoords}&#34;)

        planeSelect = {&#39;xy&#39;:[0,1], &#39;xz&#39;:[0,2], &#39;yz&#39;:[1,2]}

        LOGGER.info(f&#34;self.coordinates[planeSelect[plane]]  {self.coordinates[planeSelect[plane]]}&#34;)
        LOGGER.info(f&#34;targetCoords[planeSelect[plane]]      {targetCoords[planeSelect[plane]]}&#34;)
        LOGGER.info(f&#34;Difference                            {self.coordinates[planeSelect[plane]]-targetCoords[planeSelect[plane]]}&#34;)

        return np.linalg.norm(self.coordinates[planeSelect[plane]]-targetCoords[planeSelect[plane]])

    def distanceToPlane(self,plane=&#34;xy&#34;,ref=None):
        &#34;&#34;&#34;
        distanceToPlane(self,plane=&#34;xy&#34;,ref=None)

        The target plane is defined by one of it coordinate planes: [&#34;xy&#34;, &#34;yz&#34;, &#34;xz&#34;]

        :param ref: reference frame
        :type ref: ReferenceFrame

        :param plane: in [&#34;xy&#34;, &#34;xz&#34;, &#34;yz&#34;]
        :type plane: str

        :returns: the distance from self to plane
        &#34;&#34;&#34;
        if (ref is None) or (self.ref == ref):
            coordinates = self.coordinates[:-1]
        elif self.ref != ref:
            coordinates = self.expressIn(ref)

        outOfPlaneIndex = {&#39;xy&#39;:2,&#39;xz&#39;:1,&#39;yz&#39;:0}

        return coordinates[outOfPlaneIndex[plane]]

    def __sub__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        newPoint = self + point
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates - apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates - Point.__coords__(apoint)

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        return Point(coordinates=newCoordinates,ref=self.ref)

    def __isub__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        self += coordinates (modifies self in place)
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates - apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates - Point.__coords__(apoint)

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        self.coordinates = newCoordinates

        return self

    def __add__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        newPoint = self + point
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    print(f&#34;DEBUG: {apoint} = {apoint.expressIn(self.ref)}&#34;)
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates + apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates + Point.__coords__(apoint)

        else:
            return NotImplemented

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        return Point(coordinates=newCoordinates,ref=self.ref)

    def __iadd__(self,apoint):
        &#34;&#34;&#34;
        Takes care for
        self += coordinates (modifies self in place)
        &#34;&#34;&#34;
        if isinstance(apoint, Point):

            try:
                if apoint.ref != self.ref:
                    raise ValueError
            except ValueError:
                print(&#34;WARNING: The points have different reference frames, returning NotImplemented&#34;)
                return NotImplemented
            newCoordinates = self.coordinates + apoint.coordinates

        elif isinstance(apoint, (np.ndarray, list)):

            newCoordinates = self.coordinates + Point.__coords__(apoint)

        # For the affine transforms, the 4th digit must be set to 1 (it has been modified above)
        newCoordinates[-1] = 1

        self.coordinates = newCoordinates

        return self

    def expressIn(self,targetFrame):
        &#34;&#34;&#34;
        expressIn(self,targetFrame)
        &#34;&#34;&#34;
        if targetFrame == self.ref:
            &#34;&#34;&#34;
            targetFrame == self.ref
            We&#39;re after the definition of self
            &#34;&#34;&#34;
            result = self.coordinates
        else:
            &#34;&#34;&#34;
            We&#39;re after the coordinates of self, i.e. the definition of self in targetFrame

            We know the coordinates in self.ref
            #We need to apply the transformation from targetFrame to self.ref
            self.ref        --&gt; self (self.transformation)
            &#34;&#34;&#34;
            #transform = targetFrame.getTransformationFrom(self.ref)
            transform = self.ref.getPassiveTransformationTo(targetFrame)
            if self.debug: print(&#34;transform \n{0}&#34;.format(transform))
            result    = np.dot(transform,self.coordinates)
        return result

    def changeRef(self,targetFrame):
        &#34;&#34;&#34;
        We redefine self as attached to another reference frame
        . calculate self&#39;s coordinates in the new reference frame
        . update the definition
        &#34;&#34;&#34;
        newCoordinates = self.expressIn(targetFrame)
        self.setCoordinates(newCoordinates)
        self.ref = targetFrame
        return</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="egse.coordinates.point.Point.debug"><code class="name">var <span class="ident">debug</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.coordinates.point.Point.changeRef"><code class="name flex">
<span>def <span class="ident">changeRef</span></span>(<span>self, targetFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>We redefine self as attached to another reference frame
. calculate self's coordinates in the new reference frame
. update the definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeRef(self,targetFrame):
    &#34;&#34;&#34;
    We redefine self as attached to another reference frame
    . calculate self&#39;s coordinates in the new reference frame
    . update the definition
    &#34;&#34;&#34;
    newCoordinates = self.expressIn(targetFrame)
    self.setCoordinates(newCoordinates)
    self.ref = targetFrame
    return</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.distanceTo"><code class="name flex">
<span>def <span class="ident">distanceTo</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the distance of this Point object to the target. Target can be another Point,
a ReferenceFrame object or a Numpy dnarray or list with coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distanceTo(self, target):
    &#34;&#34;&#34;
    Returns the distance of this Point object to the target. Target can be another Point,
    a ReferenceFrame object or a Numpy dnarray or list with coordinates.
    &#34;&#34;&#34;
    from egse.coordinates.referenceFrame import ReferenceFrame

    if isinstance(target, Point):
        targetCoords = target.expressIn(self.ref)[:3]
    elif isinstance(target, ReferenceFrame):
        return np.linalg.norm(self.expressIn(target)[:3])
    elif isinstance(target, (np.ndarray, list)):
        if len(target) &gt; 3:
            target = target[:3]
        targetCoords = target
    else:
        raise ValueError(&#34;input must be a list, numpy.ndarray, Point or ReferenceFrame&#34;)

    LOGGER.info(f&#34;self={self.coordinates[:-1]}, target={targetCoords}&#34;)

    return np.linalg.norm(self.coordinates[:3]-targetCoords)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.distanceToPlane"><code class="name flex">
<span>def <span class="ident">distanceToPlane</span></span>(<span>self, plane='xy', ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>distanceToPlane(self,plane="xy",ref=None)</p>
<p>The target plane is defined by one of it coordinate planes: ["xy", "yz", "xz"]</p>
<p>:param ref: reference frame
:type ref: ReferenceFrame</p>
<p>:param plane: in ["xy", "xz", "yz"]
:type plane: str</p>
<p>:returns: the distance from self to plane</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distanceToPlane(self,plane=&#34;xy&#34;,ref=None):
    &#34;&#34;&#34;
    distanceToPlane(self,plane=&#34;xy&#34;,ref=None)

    The target plane is defined by one of it coordinate planes: [&#34;xy&#34;, &#34;yz&#34;, &#34;xz&#34;]

    :param ref: reference frame
    :type ref: ReferenceFrame

    :param plane: in [&#34;xy&#34;, &#34;xz&#34;, &#34;yz&#34;]
    :type plane: str

    :returns: the distance from self to plane
    &#34;&#34;&#34;
    if (ref is None) or (self.ref == ref):
        coordinates = self.coordinates[:-1]
    elif self.ref != ref:
        coordinates = self.expressIn(ref)

    outOfPlaneIndex = {&#39;xy&#39;:2,&#39;xz&#39;:1,&#39;yz&#39;:0}

    return coordinates[outOfPlaneIndex[plane]]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.expressIn"><code class="name flex">
<span>def <span class="ident">expressIn</span></span>(<span>self, targetFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>expressIn(self,targetFrame)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expressIn(self,targetFrame):
    &#34;&#34;&#34;
    expressIn(self,targetFrame)
    &#34;&#34;&#34;
    if targetFrame == self.ref:
        &#34;&#34;&#34;
        targetFrame == self.ref
        We&#39;re after the definition of self
        &#34;&#34;&#34;
        result = self.coordinates
    else:
        &#34;&#34;&#34;
        We&#39;re after the coordinates of self, i.e. the definition of self in targetFrame

        We know the coordinates in self.ref
        #We need to apply the transformation from targetFrame to self.ref
        self.ref        --&gt; self (self.transformation)
        &#34;&#34;&#34;
        #transform = targetFrame.getTransformationFrom(self.ref)
        transform = self.ref.getPassiveTransformationTo(targetFrame)
        if self.debug: print(&#34;transform \n{0}&#34;.format(transform))
        result    = np.dot(transform,self.coordinates)
    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.getCoordinates"><code class="name flex">
<span>def <span class="ident">getCoordinates</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coordinates of this Points object.</p>
<p>If no reference frame is given, the coordinates of the Point will just be returned,
other wise this method behaves the same as the <code>expressIn(ref)</code> method.</p>
<p>:param ref: the Reference Frame in which the Point shall be defined
:type ref: ReferenceFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCoordinates(self, ref=None):
    &#34;&#34;&#34;
    Returns the coordinates of this Points object.

    If no reference frame is given, the coordinates of the Point will just be returned,
    other wise this method behaves the same as the ``expressIn(ref)`` method.

    :param ref: the Reference Frame in which the Point shall be defined
    :type ref: ReferenceFrame
    &#34;&#34;&#34;
    if ref is None:
        return self.coordinates
    else:
        return self.expressIn(ref)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.inPlaneDistanceTo"><code class="name flex">
<span>def <span class="ident">inPlaneDistanceTo</span></span>(<span>self, target, plane='xy')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the distance of this Point object to the target, considering 2 coordinates only!</p>
<p>target: can be another Point, a ReferenceFrame object or a Numpy dnarray or list with coordinates.</p>
<p>plane : must be in ['xy', 'xz', 'yz']</p>
<p>NB: The xy, yz or xz plane used to project the points coordinates before
computing the distances is taken from the coordinate system of "self"
==&gt; pointA.inPlaneDistanceTo(pointB) != pointB.inPlaneDistanceTo(pointA)
The first projects on the xy plane of pointA.ref, the second on the xy plane of pointB.ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inPlaneDistanceTo(self,target,plane=&#39;xy&#39;):
    &#34;&#34;&#34;
    Returns the distance of this Point object to the target, considering 2 coordinates only!

    target: can be another Point, a ReferenceFrame object or a Numpy dnarray or list with coordinates.

    plane : must be in [&#39;xy&#39;, &#39;xz&#39;, &#39;yz&#39;]

    NB: The xy, yz or xz plane used to project the points coordinates before
        computing the distances is taken from the coordinate system of &#34;self&#34;
        ==&gt; pointA.inPlaneDistanceTo(pointB) != pointB.inPlaneDistanceTo(pointA)
        The first projects on the xy plane of pointA.ref, the second on the xy plane of pointB.ref
    &#34;&#34;&#34;
    from egse.coordinates.referenceFrame import ReferenceFrame

    if isinstance(target, Point):
        targetCoords = target.expressIn(self.ref)
    elif isinstance(target, ReferenceFrame):
        targetCoords = target.getOrigin().expressIn(self)
    elif isinstance(target, (np.ndarray, list)):
        targetCoords = target
    else:
        raise ValueError(&#34;input must be a list, numpy.ndarray, Point or ReferenceFrame&#34;)

    LOGGER.info(f&#34;self={self.coordinates[:-1]}, target={targetCoords}&#34;)

    planeSelect = {&#39;xy&#39;:[0,1], &#39;xz&#39;:[0,2], &#39;yz&#39;:[1,2]}

    LOGGER.info(f&#34;self.coordinates[planeSelect[plane]]  {self.coordinates[planeSelect[plane]]}&#34;)
    LOGGER.info(f&#34;targetCoords[planeSelect[plane]]      {targetCoords[planeSelect[plane]]}&#34;)
    LOGGER.info(f&#34;Difference                            {self.coordinates[planeSelect[plane]]-targetCoords[planeSelect[plane]]}&#34;)

    return np.linalg.norm(self.coordinates[planeSelect[plane]]-targetCoords[planeSelect[plane]])</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.isSame"><code class="name flex">
<span>def <span class="ident">isSame</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>This checks if a Point is the same as another Point in a different reference frame.</p>
<p>Two Point objects are the same when their position, i.e. coordinates, are equal
after they have been expressed in the same reference frame.</p>
<p>:param other: a Point object that you want to check
:type other: Point</p>
<p>:returns: True when the two Point objects are the same, False otherwise</p>
<p>:raises TypeError: when other is not a compatible type, NotImplemented will returned
which will result in a <code>TypeError: unsupported operand type(s) for +:</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isSame(self, other):
    &#34;&#34;&#34;
    This checks if a Point is the same as another Point in a different reference frame.

    Two Point objects are the same when their position, i.e. coordinates, are equal
    after they have been expressed in the same reference frame.

    :param other: a Point object that you want to check
    :type other: Point

    :returns: True when the two Point objects are the same, False otherwise

    :raises TypeError: when other is not a compatible type, NotImplemented will returned
                       which will result in a ```TypeError: unsupported operand type(s) for +:```.
    &#34;&#34;&#34;

    if isinstance(other, Point):
        if self == other:
            return True
        else:
            if np.array_equal(self.coordinates, other.expressIn(self.ref)):
                return True
        return False
    return NotImplemented</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.setCoordinates"><code class="name flex">
<span>def <span class="ident">setCoordinates</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the coordinates of this Point object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCoordinates(self, coordinates):
    &#34;&#34;&#34;
    Set the coordinates of this Point object.
    &#34;&#34;&#34;
    coordinates = Point.__coords__(coordinates)
    self.coordinates = np.array(coordinates)

    self.x = self.coordinates[0]
    self.y = self.coordinates[1]
    self.z = self.coordinates[2]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Point.setName"><code class="name flex">
<span>def <span class="ident">setName</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set or change the name of a Point object.</p>
<p>:param str name: the new name for the Point, if None, a random name will be generated.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Should we care about the possibility the the generation of random names does not
necessarily create a unique name for the Point?</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setName(self, name=None):
    &#34;&#34;&#34;
    Set or change the name of a Point object.

    :param str name: the new name for the Point, if None, a random name will be generated.

    .. todo:: Should we care about the possibility the the generation of random names does not
              necessarily create a unique name for the Point?
    &#34;&#34;&#34;
    if name is None:
        self.name = &#39;p&#39;+&#39;&#39;.join(random.choices(string.ascii_lowercase, k=3))
    else:
        self.name = name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.coordinates.point.Points"><code class="flex name class">
<span>class <span class="ident">Points</span></span>
<span>(</span><span>coordinates, ref, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Points object is a collection of Point objects.</p>
<p>Points can be constructed from either a numpy.ndarray of shape 3 x n or 4 x n, or
a list of Point objects. The coordinates of the Point objects are transferred to
the desired ReferenceFrame and concatenated in the list order.</p>
<p>When automatically generated a Points object name consists in a capital 'P' followed by
three lower case letters. A Point can be extracted from a Points object by its
position in the coordinates array (see below).</p>
<p>Points.<strong>init</strong>(self, coordinates, ref, name=None)</p>
<p>Constructor</p>
<p>coordinates : must be of one of the following type:
* numpy.ndarray:
4xn matrix defining this system in "ref" system
(3 being x,y,z + an additional 1 for the affine operations)
* list of Point objects:
the coordinates of the Point objects are extracted in the order of the list
and concatenated in a numpy.ndarray</p>
<p>ref
: reference system in which self is defined</p>
<p>Both parameters are mandatory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Points():
    &#34;&#34;&#34;
    A Points object is a collection of Point objects.

    Points can be constructed from either a numpy.ndarray of shape 3 x n or 4 x n, or
    a list of Point objects. The coordinates of the Point objects are transferred to
    the desired ReferenceFrame and concatenated in the list order.

    When automatically generated a Points object name consists in a capital &#39;P&#39; followed by
    three lower case letters. A Point can be extracted from a Points object by its
    position in the coordinates array (see below).

    &#34;&#34;&#34;
    debug=0
    def __init__(self, coordinates, ref,name=None):
        &#34;&#34;&#34;
        Points.__init__(self, coordinates, ref, name=None)

        Constructor

        coordinates : must be of one of the following type:
            * numpy.ndarray:
              4xn matrix defining this system in &#34;ref&#34; system
              (3 being x,y,z + an additional 1 for the affine operations)
            * list of Point objects:
              the coordinates of the Point objects are extracted in the order of the list
              and concatenated in a numpy.ndarray

        ref         : reference system in which self is defined

        Both parameters are mandatory.
        &#34;&#34;&#34;

        # TODO: accept a list made of Point and Points rather than strictly Point

        if isinstance(coordinates, list):
            coordinateList = []
            for apoint in coordinates:
                if not isinstance(apoint, Point):
                    raise ValueError(&#34;If the input is a list, all items in it must be Point(s) objects&#34;)
                coordinateList.append(apoint.expressIn(ref))
            self.setCoordinates(np.array(coordinateList).T)
        elif isinstance(coordinates, np.ndarray):
            self.setCoordinates(coordinates)
        else:
            raise ValueError(&#34;The input must be either a numpy.ndarray or a list of Point objects&#34;)

        self.ref = ref

        self.setName(name)

        return

    def __repr__(self):
        return &#34;{0} (ref {1})&#34;.format(self.coordinates[:-1], self.ref.name)

    def __str__(self):
        return &#34;{1} (ref {2}), name {0}&#34;.format(self.name, self.coordinates[:-1], self.ref.name)

    @staticmethod
    def __coords__(coordinates):
        &#34;&#34;&#34;
        Formats 3xn or 4xn input lists or np.arrays into 4xn np.array coordinates
        Static --&gt; can be called &#39;from outside&#39;, without passing a Points object
        &#34;&#34;&#34;
        if isinstance(coordinates, Point):
            return coordinates.coordinates
        elif isinstance(coordinates, np.ndarray):

            if coordinates.shape[0] not in [3,4]:
                raise ValueError(&#34;Input coordinates array must be 3 x n or 4 x n&#34;)

            if coordinates.shape[0]==3:
                newCoords = np.ones([4,coordinates.shape[1]])
                newCoords[:3,:] = coordinates
                coordinates = newCoords
            return coordinates
        else:
            raise ValueError(&#34;input must be a list, numpy.ndarray or Point&#34;)

    def setName(self,name=None):
        if name is None:
            self.name = &#39;P&#39;+ &#39;&#39;.join(random.choices(string.ascii_lowercase, k=2))+\
                             &#39;&#39;.join(random.choices(string.ascii_uppercase, k=1))
        else:
            self.name = name

    def setCoordinates(self,coordinates):
        #coordinates = list(coordinates)
        #if len(coordinates)==3: coordinates.append(1)
        coordinates = Points.__coords__(coordinates)
        self.coordinates = coordinates

        self.x = self.coordinates[0,:]
        self.y = self.coordinates[1,:]
        self.z = self.coordinates[2,:]

        return

    def getCoordinates(self,ref=None):
        if ref is None:
            return self.coordinates
        else:
            return self.expressIn(ref)

    def expressIn(self,targetFrame):
        &#34;&#34;&#34;
        expressIn(self,targetFrame)
        &#34;&#34;&#34;
        if targetFrame == self.ref:
            &#34;&#34;&#34;
            targetFrame == self.ref
            We&#39;re after the definition of self
            &#34;&#34;&#34;
            result = self.coordinates
        else:
            &#34;&#34;&#34;
            We&#39;re after the coordinates of self, i.e. the definition of self in targetFrame

            We know the coordinates in self.ref
            #We need to apply the transformation from targetFrame to self.ref
            self.ref        --&gt; self (self.transformation)
            &#34;&#34;&#34;
            #transform = targetFrame.getTransformationFrom(self.ref)
            transform = self.ref.getPassiveTransformationTo(targetFrame)
            if self.debug: print(&#34;transform \n{0}&#34;.format(transform))
            result    = np.dot(transform,self.coordinates)
        return result

    def changeRef(self,targetFrame):
        &#34;&#34;&#34;
        We redefine self as attached to another reference frame
        . calculate self&#39;s coordinates in the new reference frame
        . update the definition
        &#34;&#34;&#34;
        newCoordinates = self.expressIn(targetFrame)
        self.setCoordinates(newCoordinates)
        self.ref = targetFrame
        return

    def getPoint(self,index,name=None):
        &#34;&#34;&#34;
        Returns the point with coordinates self.coordinates[:,index], in reference frame pts.ref
        &#34;&#34;&#34;
        return Point(self.coordinates[:,index],ref=self.ref,name=name)

    get = getPoint

    def bestFittingPlane(self,fitPlane=&#34;xy&#34;, usesvd=False,verbose=True):
        &#34;&#34;&#34;
        bestFittingPlane(self,fitPlane=&#34;xy&#34;, usesvd=False,verbose=True)

        fitPlane in [&#39;xy,&#39;yz&#39;,&#39;zx&#39;]
        usesvd   see transform3d_addon.affine_matrix_from_points.__doc__

        OUTPUT
        returns the reference Frame having as X-Y plane the plane best fitting all points in self
        &#34;&#34;&#34;
        # Import necessary due to a circular dependency between Point and ReferenceFrame
        from egse.coordinates.referenceFrame import ReferenceFrame

        debug=True

        a,b,c = self.fitPlane(fitPlane=fitPlane,verbose=verbose)
        #print (f&#34;a {a}, b {b}, c {c}&#34;)
        #print()

        unitaxes = Points.fromPlaneParameters(a,b,c,ref=self.ref,plane=fitPlane)
        #print(f&#34;Unitaxes coordinates \n{np.round(unitaxes.coordinates,3)}&#34;)
        #print()


        # unitaxes contain 3 unit axes and an origin
        # =&gt; the unit vectors do NOT belong to the target plane
        # =&gt; they must be translated before
        unitcoords = unitaxes.coordinates
        for ax in range(3):
            unitcoords[:3,ax] += unitcoords[:3,3]

        newaxes = Points(unitcoords, ref=self.ref)

        #print(f&#34;newaxes {np.round(newaxes.coordinates,3)}&#34;)

        selfaxes = Points(np.identity(4),ref=self.ref)

        transform  = t3add.affine_matrix_from_points(selfaxes.coordinates[:3,:], newaxes.coordinates[:3,:], shear=False, scale=False, usesvd=usesvd)


        if debug:
            transform2 =        t3add.rigid_transform_3D(selfaxes.coordinates[:3,:], newaxes.coordinates[:3,:], verbose=verbose)

        if verbose:
            print()
            print(f&#34;Transform  \n{np.round(transform,3)}&#34;)
            if debug:
                print()
                print(f&#34;Transform2 \n{np.round(transform2,3)}&#34;)
                print()
                print(f&#34;Both methods consistent ? {np.allclose(transform, transform2)}&#34;)

        return ReferenceFrame(transformation=transform, ref=self.ref)



    def fitPlane(self,fitPlane=&#34;xy&#34;,verbose=True):
        &#34;&#34;&#34;
        fitPlane(self,fitPlane=&#34;xy&#34;,verbose=True)

        :returns: the best fitting parameters a, b, c corresponding to the fitted plane

        :param fitPlane: defines the expression of the fitted plane in [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;]:
                         &#39;xy&#39; : z = ax + by + c
                         &#39;yz&#39; : x = ay + bz + c
                         &#39;zx&#39; : y = az + bx + c

        :param verbose: default = True
        &#34;&#34;&#34;
        xyz = [self.x,self.y,self.z]

        ndata = len(xyz[0])

        # Account for cases
        startingIndex={&#39;xy&#39;:0,&#39;yz&#39;:1,&#39;zx&#39;:2}[fitPlane]

        # System matrix
        A = np.vstack([xyz[startingIndex],xyz[(startingIndex+1)%3], np.ones(ndata)]).T

        # Solve linear equations
        a, b, c = np.linalg.lstsq(A, xyz[(startingIndex+2)%3],rcond=None)[0]

        # Print results on screen
        if verbose:
            hprint = {&#39;xy&#39;:&#39;z = ax + by + c&#39;,&#39;yz&#39;:&#39;x = ay + bz + c&#39;,&#39;zx&#39;:&#39;y = az + bx + c&#39;}
            print(f&#39;{hprint[fitPlane]} : \n    a = {a:7.3e}  \n    b = {b:7.3e} \n    c = {c:7.3e}&#39;)

        return a,b,c

    @classmethod
    def fromPlaneParameters(cls,a,b,c,ref,plane=&#39;xy&#39;,verbose=False):
        &#34;&#34;&#34;fromPlaneParameters(cls,a,b,c,ref,plane=&#39;xy&#39;,verbose=False)

        Returns a Points object describing the unit axes and the origin of the reference frame defined by
        the input parameters.

        :param plane: The plane definition depends on the &#34;plane&#34; parameter plane must be in [&#34;xy&#34;,&#34;yz&#34;,&#34;zx&#34;]
                      &#39;xy&#39; : z = ax + by + c (origin defined at x = y = 0)
                      &#39;yz&#39; : x = ay + bz + c  --&gt; NOT IMPLEMENTED
                      &#39;zx&#39; : y = az + bx + c  --&gt; NOT IMPLEMENTED

        :returns:  A Points with 4 Point objects corresponding to
                   - the 3 unit axes defining a coordinate system with this plane as &#34;plane&#34; plane
                   - the origin
                   in this order (origin last)
        &#34;&#34;&#34;
        if plane != &#39;xy&#39;:
            print(f&#34;WARNING: plane = {plane} NOT IMPLEMENTED&#34;)
        # p0 : on the Z-axis
        # x = y = 0
        p0 = np.array([0,0,c])

        # pxy : on the intersection between target plane and plane // to xy passing through z=c
        if np.abs(b)&gt;1.e-5:
            # z = c, x = 1
            pxy = np.array([1,-a/float(b),c])
        else:
            # z = c, y = 1
            pxy = np.array([-b/float(a),1,c])

        # pyz : intersection of target plane and Y-Z plane
        # x = 0, y = 1
        pyz = np.array([0,1,b+c])

        &#34;&#34;&#34;
        # pzx : intersection of target plane and Z-X plane
        if np.abs(a)&gt;1.e-3:
            # y = 0, z = 1
            pzx = np.array([(1-c)/float(a),0,1])
        else:
            # y = 0, x = 1
            pzx = np.array([1,0,a+c])
        &#34;&#34;&#34;
        #
        # xunit = unit vector from [0,0,0] along the intersection between target plane and plane // to xy passing through z=c
        xunit = (pxy - p0)/np.linalg.norm(pxy-p0)
        # ytemp = unit vector from [0,0,0] along the intersection between target plane and Y-Z plane
        # ytemp is in the target plane, but not perpendicular to xunit
        # its norm doesn&#39;t matter
        ytemp = (pyz - p0)#/np.linalg.norm(pyz-p0)

        # xunit and ytemp are both in the plane
        # =&gt; zunit is perpendicular to both
        zunit = np.cross(xunit,ytemp)
        zunit /= np.linalg.norm(zunit)

        # yunit completes the right handed reference frame
        # The renormalisation shouldn&#39;t be necessary...
        yunit = np.cross(zunit,xunit)
        yunit /= np.linalg.norm(yunit)

        xu = Point(xunit,ref=ref)
        yu = Point(yunit,ref=ref)
        zu = Point(zunit,ref=ref)
        origin = Point(p0,ref=ref)

        if verbose:
            print(f&#39;xunit  {xunit}&#39;)
            print(f&#39;yunit  {yunit}&#39;)
            print(f&#39;zunit  {zunit}&#39;)
            print(f&#39;origin {p0}&#39;)
            print()

        return cls([xu,yu,zu,origin],ref=ref)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="egse.coordinates.point.Points.debug"><code class="name">var <span class="ident">debug</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="egse.coordinates.point.Points.fromPlaneParameters"><code class="name flex">
<span>def <span class="ident">fromPlaneParameters</span></span>(<span>a, b, c, ref, plane='xy', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>fromPlaneParameters(cls,a,b,c,ref,plane='xy',verbose=False)</p>
<p>Returns a Points object describing the unit axes and the origin of the reference frame defined by
the input parameters.</p>
<p>:param plane: The plane definition depends on the "plane" parameter plane must be in ["xy","yz","zx"]
'xy' : z = ax + by + c (origin defined at x = y = 0)
'yz' : x = ay + bz + c
&ndash;&gt; NOT IMPLEMENTED
'zx' : y = az + bx + c
&ndash;&gt; NOT IMPLEMENTED</p>
<p>:returns:
A Points with 4 Point objects corresponding to
- the 3 unit axes defining a coordinate system with this plane as "plane" plane
- the origin
in this order (origin last)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromPlaneParameters(cls,a,b,c,ref,plane=&#39;xy&#39;,verbose=False):
    &#34;&#34;&#34;fromPlaneParameters(cls,a,b,c,ref,plane=&#39;xy&#39;,verbose=False)

    Returns a Points object describing the unit axes and the origin of the reference frame defined by
    the input parameters.

    :param plane: The plane definition depends on the &#34;plane&#34; parameter plane must be in [&#34;xy&#34;,&#34;yz&#34;,&#34;zx&#34;]
                  &#39;xy&#39; : z = ax + by + c (origin defined at x = y = 0)
                  &#39;yz&#39; : x = ay + bz + c  --&gt; NOT IMPLEMENTED
                  &#39;zx&#39; : y = az + bx + c  --&gt; NOT IMPLEMENTED

    :returns:  A Points with 4 Point objects corresponding to
               - the 3 unit axes defining a coordinate system with this plane as &#34;plane&#34; plane
               - the origin
               in this order (origin last)
    &#34;&#34;&#34;
    if plane != &#39;xy&#39;:
        print(f&#34;WARNING: plane = {plane} NOT IMPLEMENTED&#34;)
    # p0 : on the Z-axis
    # x = y = 0
    p0 = np.array([0,0,c])

    # pxy : on the intersection between target plane and plane // to xy passing through z=c
    if np.abs(b)&gt;1.e-5:
        # z = c, x = 1
        pxy = np.array([1,-a/float(b),c])
    else:
        # z = c, y = 1
        pxy = np.array([-b/float(a),1,c])

    # pyz : intersection of target plane and Y-Z plane
    # x = 0, y = 1
    pyz = np.array([0,1,b+c])

    &#34;&#34;&#34;
    # pzx : intersection of target plane and Z-X plane
    if np.abs(a)&gt;1.e-3:
        # y = 0, z = 1
        pzx = np.array([(1-c)/float(a),0,1])
    else:
        # y = 0, x = 1
        pzx = np.array([1,0,a+c])
    &#34;&#34;&#34;
    #
    # xunit = unit vector from [0,0,0] along the intersection between target plane and plane // to xy passing through z=c
    xunit = (pxy - p0)/np.linalg.norm(pxy-p0)
    # ytemp = unit vector from [0,0,0] along the intersection between target plane and Y-Z plane
    # ytemp is in the target plane, but not perpendicular to xunit
    # its norm doesn&#39;t matter
    ytemp = (pyz - p0)#/np.linalg.norm(pyz-p0)

    # xunit and ytemp are both in the plane
    # =&gt; zunit is perpendicular to both
    zunit = np.cross(xunit,ytemp)
    zunit /= np.linalg.norm(zunit)

    # yunit completes the right handed reference frame
    # The renormalisation shouldn&#39;t be necessary...
    yunit = np.cross(zunit,xunit)
    yunit /= np.linalg.norm(yunit)

    xu = Point(xunit,ref=ref)
    yu = Point(yunit,ref=ref)
    zu = Point(zunit,ref=ref)
    origin = Point(p0,ref=ref)

    if verbose:
        print(f&#39;xunit  {xunit}&#39;)
        print(f&#39;yunit  {yunit}&#39;)
        print(f&#39;zunit  {zunit}&#39;)
        print(f&#39;origin {p0}&#39;)
        print()

    return cls([xu,yu,zu,origin],ref=ref)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.coordinates.point.Points.bestFittingPlane"><code class="name flex">
<span>def <span class="ident">bestFittingPlane</span></span>(<span>self, fitPlane='xy', usesvd=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>bestFittingPlane(self,fitPlane="xy", usesvd=False,verbose=True)</p>
<p>fitPlane in ['xy,'yz','zx']
usesvd
see transform3d_addon.affine_matrix_from_points.<strong>doc</strong></p>
<p>OUTPUT
returns the reference Frame having as X-Y plane the plane best fitting all points in self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bestFittingPlane(self,fitPlane=&#34;xy&#34;, usesvd=False,verbose=True):
    &#34;&#34;&#34;
    bestFittingPlane(self,fitPlane=&#34;xy&#34;, usesvd=False,verbose=True)

    fitPlane in [&#39;xy,&#39;yz&#39;,&#39;zx&#39;]
    usesvd   see transform3d_addon.affine_matrix_from_points.__doc__

    OUTPUT
    returns the reference Frame having as X-Y plane the plane best fitting all points in self
    &#34;&#34;&#34;
    # Import necessary due to a circular dependency between Point and ReferenceFrame
    from egse.coordinates.referenceFrame import ReferenceFrame

    debug=True

    a,b,c = self.fitPlane(fitPlane=fitPlane,verbose=verbose)
    #print (f&#34;a {a}, b {b}, c {c}&#34;)
    #print()

    unitaxes = Points.fromPlaneParameters(a,b,c,ref=self.ref,plane=fitPlane)
    #print(f&#34;Unitaxes coordinates \n{np.round(unitaxes.coordinates,3)}&#34;)
    #print()


    # unitaxes contain 3 unit axes and an origin
    # =&gt; the unit vectors do NOT belong to the target plane
    # =&gt; they must be translated before
    unitcoords = unitaxes.coordinates
    for ax in range(3):
        unitcoords[:3,ax] += unitcoords[:3,3]

    newaxes = Points(unitcoords, ref=self.ref)

    #print(f&#34;newaxes {np.round(newaxes.coordinates,3)}&#34;)

    selfaxes = Points(np.identity(4),ref=self.ref)

    transform  = t3add.affine_matrix_from_points(selfaxes.coordinates[:3,:], newaxes.coordinates[:3,:], shear=False, scale=False, usesvd=usesvd)


    if debug:
        transform2 =        t3add.rigid_transform_3D(selfaxes.coordinates[:3,:], newaxes.coordinates[:3,:], verbose=verbose)

    if verbose:
        print()
        print(f&#34;Transform  \n{np.round(transform,3)}&#34;)
        if debug:
            print()
            print(f&#34;Transform2 \n{np.round(transform2,3)}&#34;)
            print()
            print(f&#34;Both methods consistent ? {np.allclose(transform, transform2)}&#34;)

    return ReferenceFrame(transformation=transform, ref=self.ref)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.changeRef"><code class="name flex">
<span>def <span class="ident">changeRef</span></span>(<span>self, targetFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>We redefine self as attached to another reference frame
. calculate self's coordinates in the new reference frame
. update the definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeRef(self,targetFrame):
    &#34;&#34;&#34;
    We redefine self as attached to another reference frame
    . calculate self&#39;s coordinates in the new reference frame
    . update the definition
    &#34;&#34;&#34;
    newCoordinates = self.expressIn(targetFrame)
    self.setCoordinates(newCoordinates)
    self.ref = targetFrame
    return</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.expressIn"><code class="name flex">
<span>def <span class="ident">expressIn</span></span>(<span>self, targetFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>expressIn(self,targetFrame)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expressIn(self,targetFrame):
    &#34;&#34;&#34;
    expressIn(self,targetFrame)
    &#34;&#34;&#34;
    if targetFrame == self.ref:
        &#34;&#34;&#34;
        targetFrame == self.ref
        We&#39;re after the definition of self
        &#34;&#34;&#34;
        result = self.coordinates
    else:
        &#34;&#34;&#34;
        We&#39;re after the coordinates of self, i.e. the definition of self in targetFrame

        We know the coordinates in self.ref
        #We need to apply the transformation from targetFrame to self.ref
        self.ref        --&gt; self (self.transformation)
        &#34;&#34;&#34;
        #transform = targetFrame.getTransformationFrom(self.ref)
        transform = self.ref.getPassiveTransformationTo(targetFrame)
        if self.debug: print(&#34;transform \n{0}&#34;.format(transform))
        result    = np.dot(transform,self.coordinates)
    return result</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.fitPlane"><code class="name flex">
<span>def <span class="ident">fitPlane</span></span>(<span>self, fitPlane='xy', verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>fitPlane(self,fitPlane="xy",verbose=True)</p>
<p>:returns: the best fitting parameters a, b, c corresponding to the fitted plane</p>
<p>:param fitPlane: defines the expression of the fitted plane in ['xy','yz','zx']:
'xy' : z = ax + by + c
'yz' : x = ay + bz + c
'zx' : y = az + bx + c</p>
<p>:param verbose: default = True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitPlane(self,fitPlane=&#34;xy&#34;,verbose=True):
    &#34;&#34;&#34;
    fitPlane(self,fitPlane=&#34;xy&#34;,verbose=True)

    :returns: the best fitting parameters a, b, c corresponding to the fitted plane

    :param fitPlane: defines the expression of the fitted plane in [&#39;xy&#39;,&#39;yz&#39;,&#39;zx&#39;]:
                     &#39;xy&#39; : z = ax + by + c
                     &#39;yz&#39; : x = ay + bz + c
                     &#39;zx&#39; : y = az + bx + c

    :param verbose: default = True
    &#34;&#34;&#34;
    xyz = [self.x,self.y,self.z]

    ndata = len(xyz[0])

    # Account for cases
    startingIndex={&#39;xy&#39;:0,&#39;yz&#39;:1,&#39;zx&#39;:2}[fitPlane]

    # System matrix
    A = np.vstack([xyz[startingIndex],xyz[(startingIndex+1)%3], np.ones(ndata)]).T

    # Solve linear equations
    a, b, c = np.linalg.lstsq(A, xyz[(startingIndex+2)%3],rcond=None)[0]

    # Print results on screen
    if verbose:
        hprint = {&#39;xy&#39;:&#39;z = ax + by + c&#39;,&#39;yz&#39;:&#39;x = ay + bz + c&#39;,&#39;zx&#39;:&#39;y = az + bx + c&#39;}
        print(f&#39;{hprint[fitPlane]} : \n    a = {a:7.3e}  \n    b = {b:7.3e} \n    c = {c:7.3e}&#39;)

    return a,b,c</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, index, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the point with coordinates self.coordinates[:,index], in reference frame pts.ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPoint(self,index,name=None):
    &#34;&#34;&#34;
    Returns the point with coordinates self.coordinates[:,index], in reference frame pts.ref
    &#34;&#34;&#34;
    return Point(self.coordinates[:,index],ref=self.ref,name=name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.getCoordinates"><code class="name flex">
<span>def <span class="ident">getCoordinates</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCoordinates(self,ref=None):
    if ref is None:
        return self.coordinates
    else:
        return self.expressIn(ref)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.getPoint"><code class="name flex">
<span>def <span class="ident">getPoint</span></span>(<span>self, index, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the point with coordinates self.coordinates[:,index], in reference frame pts.ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPoint(self,index,name=None):
    &#34;&#34;&#34;
    Returns the point with coordinates self.coordinates[:,index], in reference frame pts.ref
    &#34;&#34;&#34;
    return Point(self.coordinates[:,index],ref=self.ref,name=name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.setCoordinates"><code class="name flex">
<span>def <span class="ident">setCoordinates</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCoordinates(self,coordinates):
    #coordinates = list(coordinates)
    #if len(coordinates)==3: coordinates.append(1)
    coordinates = Points.__coords__(coordinates)
    self.coordinates = coordinates

    self.x = self.coordinates[0,:]
    self.y = self.coordinates[1,:]
    self.z = self.coordinates[2,:]

    return</code></pre>
</details>
</dd>
<dt id="egse.coordinates.point.Points.setName"><code class="name flex">
<span>def <span class="ident">setName</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setName(self,name=None):
    if name is None:
        self.name = &#39;P&#39;+ &#39;&#39;.join(random.choices(string.ascii_lowercase, k=2))+\
                         &#39;&#39;.join(random.choices(string.ascii_uppercase, k=1))
    else:
        self.name = name</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.coordinates" href="index.html">egse.coordinates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.coordinates.point.Point" href="#egse.coordinates.point.Point">Point</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.coordinates.point.Point.changeRef" href="#egse.coordinates.point.Point.changeRef">changeRef</a></code></li>
<li><code><a title="egse.coordinates.point.Point.debug" href="#egse.coordinates.point.Point.debug">debug</a></code></li>
<li><code><a title="egse.coordinates.point.Point.distanceTo" href="#egse.coordinates.point.Point.distanceTo">distanceTo</a></code></li>
<li><code><a title="egse.coordinates.point.Point.distanceToPlane" href="#egse.coordinates.point.Point.distanceToPlane">distanceToPlane</a></code></li>
<li><code><a title="egse.coordinates.point.Point.expressIn" href="#egse.coordinates.point.Point.expressIn">expressIn</a></code></li>
<li><code><a title="egse.coordinates.point.Point.getCoordinates" href="#egse.coordinates.point.Point.getCoordinates">getCoordinates</a></code></li>
<li><code><a title="egse.coordinates.point.Point.inPlaneDistanceTo" href="#egse.coordinates.point.Point.inPlaneDistanceTo">inPlaneDistanceTo</a></code></li>
<li><code><a title="egse.coordinates.point.Point.isSame" href="#egse.coordinates.point.Point.isSame">isSame</a></code></li>
<li><code><a title="egse.coordinates.point.Point.setCoordinates" href="#egse.coordinates.point.Point.setCoordinates">setCoordinates</a></code></li>
<li><code><a title="egse.coordinates.point.Point.setName" href="#egse.coordinates.point.Point.setName">setName</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.coordinates.point.Points" href="#egse.coordinates.point.Points">Points</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.coordinates.point.Points.bestFittingPlane" href="#egse.coordinates.point.Points.bestFittingPlane">bestFittingPlane</a></code></li>
<li><code><a title="egse.coordinates.point.Points.changeRef" href="#egse.coordinates.point.Points.changeRef">changeRef</a></code></li>
<li><code><a title="egse.coordinates.point.Points.debug" href="#egse.coordinates.point.Points.debug">debug</a></code></li>
<li><code><a title="egse.coordinates.point.Points.expressIn" href="#egse.coordinates.point.Points.expressIn">expressIn</a></code></li>
<li><code><a title="egse.coordinates.point.Points.fitPlane" href="#egse.coordinates.point.Points.fitPlane">fitPlane</a></code></li>
<li><code><a title="egse.coordinates.point.Points.fromPlaneParameters" href="#egse.coordinates.point.Points.fromPlaneParameters">fromPlaneParameters</a></code></li>
<li><code><a title="egse.coordinates.point.Points.get" href="#egse.coordinates.point.Points.get">get</a></code></li>
<li><code><a title="egse.coordinates.point.Points.getCoordinates" href="#egse.coordinates.point.Points.getCoordinates">getCoordinates</a></code></li>
<li><code><a title="egse.coordinates.point.Points.getPoint" href="#egse.coordinates.point.Points.getPoint">getPoint</a></code></li>
<li><code><a title="egse.coordinates.point.Points.setCoordinates" href="#egse.coordinates.point.Points.setCoordinates">setCoordinates</a></code></li>
<li><code><a title="egse.coordinates.point.Points.setName" href="#egse.coordinates.point.Points.setName">setName</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
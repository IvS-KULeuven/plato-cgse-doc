<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.coordinates.refmodel API documentation</title>
<meta name="description" content="The Reference Frame Model is a self-consistent graph of reference frames that are connected by
reference and/or by explicit links …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.coordinates.refmodel</code></h1>
</header>
<section id="section-intro">
<p>The Reference Frame Model is a self-consistent graph of reference frames that are connected by
reference and/or by explicit links.</p>
<p>The ReferenceFrameModel class will keep the model consistent and self-contained.</p>
<p>Functionality:</p>
<ul>
<li>Initialization from a list of ReferenceFrames.</li>
<li>Serialization into a dictionary that can be saved into a YAML file.</li>
<li>Manipulation of the model<ul>
<li>Move a reference frame (translation, rotation) with respect to another reference frame<ul>
<li>Absolute movement, center of rotation either local or other</li>
<li>Relative Movement, center of rotation either local or other</li>
</ul>
</li>
<li>Move a reference frame (translation, rotation) with respect to itself<ul>
<li>Absolute movement</li>
<li>Relative Movement</li>
</ul>
</li>
<li>Change the definition of a reference frame in the model</li>
</ul>
</li>
<li>Inspection of the model<ul>
<li>Get the definition of a reference frame (what should this be? only translation &amp; rotation?)</li>
<li>Get position of a reference frame</li>
<li>Get the position of a point in a 'target' reference frame, but defined in a 'source'
reference frame</li>
<li>Get a string representation of the model.</li>
<li>Find inconsistencies in the model</li>
<li>What other information do we need?<ul>
<li>find the path from one reference frame to another reference frame?</li>
<li>find all reference frames that are affected by a movement or redefinition of a
reference frame?</li>
<li>&hellip;</li>
</ul>
</li>
</ul>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Reference Frame Model is a self-consistent graph of reference frames that are connected by
reference and/or by explicit links.

The ReferenceFrameModel class will keep the model consistent and self-contained.

Functionality:

* Initialization from a list of ReferenceFrames.
* Serialization into a dictionary that can be saved into a YAML file.
* Manipulation of the model
    * Move a reference frame (translation, rotation) with respect to another reference frame
        * Absolute movement, center of rotation either local or other
        * Relative Movement, center of rotation either local or other
    * Move a reference frame (translation, rotation) with respect to itself
        * Absolute movement
        * Relative Movement
    * Change the definition of a reference frame in the model
* Inspection of the model
    * Get the definition of a reference frame (what should this be? only translation &amp; rotation?)
    * Get position of a reference frame
    * Get the position of a point in a &#39;target&#39; reference frame, but defined in a &#39;source&#39;
      reference frame
    * Get a string representation of the model.
    * Find inconsistencies in the model
    * What other information do we need?
        * find the path from one reference frame to another reference frame?
        * find all reference frames that are affected by a movement or redefinition of a
          reference frame?
        * ...

&#34;&#34;&#34;
import logging
from typing import Dict
from typing import List
from typing import Union

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.transforms import ScaledTranslation
from mpl_toolkits.mplot3d import Axes3D

import egse.coordinates.transform3d_addon as t3add
from egse.coordinates import dict_to_ref_model
from egse.coordinates import ref_model_to_dict
from egse.coordinates.referenceFrame import ReferenceFrame
from egse.setup import NavigableDict

LOGGER = logging.getLogger(__name__)

# TODO : HANDLING &#34;moving_in_ref&#34; (obusr)  in move_absolute_ext and move_relative_ext
#        should it be added to the model temporarily ??
#        after the move : remove the link and delete that frame
#
# Priority 1
#   * access methods to allow for things like is_avoidance_ok(hexsim.cs_user, hexsim.cs_object,
#     setup=setup, verbose=True)
#
#  Priority 2
#   * Move name handling from ReferenceFrame to here (if necessary)


class ReferenceFrameModel:
    &#34;&#34;&#34;
    A ReferenceFrameModel is a collection of reference frames that are linked to each other to
    form a Graph.
    &#34;&#34;&#34;

    _ROT_CONFIG_DEFAULT = &#34;sxyz&#34;
    _ACTIVE_DEFAULT = True
    _DEGREES_DEFAULT = True

    def __init__(
        self,
        model: Union[Dict, List[ReferenceFrame]] = None,
        rot_config: str = _ROT_CONFIG_DEFAULT,
        use_degrees: bool = _DEGREES_DEFAULT,
        use_active_movements: bool = _ACTIVE_DEFAULT,
    ):
        &#34;&#34;&#34;
        When the model_dict is empty or None, a new model is created with a master reference frame.

        Args:
            model: a list or a dictionary of reference frames that make up the model
            use_degrees: use degrees throughout this model unless explicitly specified in the
                function call.
        &#34;&#34;&#34;
        self._use_degrees = use_degrees
        self._use_active_movements = use_active_movements
        self._rot_config = rot_config

        # Keep a dictionary with all reference frames that are part of the model. The keys shall
        # be the name of the reference frame. When the model passed is empty, create only a
        # master reference frame.

        if isinstance(model, (dict, list)):
            self._model = self.deserialize(model)
        else:
            self._model = NavigableDict({})

    def __str__(self):
        return self._model.pretty_str()

    def __len__(self):
        return len(self._model)

    def __contains__(self, item):
        return item in self._model

    def __iter__(self):
        return iter(self._model.values())

    def summary(self):
        result = f&#34;Nb of frames: {len(self)}\n&#34;

        for ref in self:
            result += (
                f&#34;{ref.name:&gt;10}[{ref.ref.name}]&#34; f&#34;  ---  {[link.name for link in ref.linkedTo]}\n&#34;
            )
        return result

    @staticmethod
    def deserialize(model_dict: dict) -&gt; NavigableDict:
        &#34;&#34;&#34;
        Deserialize means you take a serialized representation of a reference frames model and
        turn it into a dictionary containing all the reference frames with their links and
        references.

        Args:
            model_dict: a dictionary of serialized reference frames

        Returns:
            A dictionary of ReferenceFrames that make up a model.

        &#34;&#34;&#34;
        return dict_to_ref_model(model_dict)

    def serialize(self) -&gt; NavigableDict:
        &#34;&#34;&#34;
        Serialize the model by serializing each of the reference frames into an object that can
        easily be saved to a YAML or a JSON file. Return a dictionary with the serialized frames.

        Returns:
            A dictionary with all the reference framed serialized.
        &#34;&#34;&#34;

        return ref_model_to_dict(self._model)

    def add_master_frame(self):

        # TODO: First check if there is not already a Master frame in the model

        self._model[&#34;Master&#34;] = ReferenceFrame.createMaster()

    def add_frame(
        self,
        name: str,
        *,
        translation: List[float] = None,
        rotation: List[float] = None,
        transformation=None,
        ref: str,
    ):
        &#34;&#34;&#34;
        Add a reference frame to the model.

        .. note::
            Only the `name` parameter can be positional, all the other arguments (translation,
            rotation, transformation, and ref) must be given as keyword arguments.

        Args:
            name: the name for the reference frame. This name is it&#39;s identifier within the model.
            translation: the translation vector
            rotation: the rotation vector
            transformation: the transformation vector, if `transformation` is given,
                both `translation` and `rotation` are ignored.
            ref: the reference frame that is a reference for &#39;name&#39;, i.e. &#39;name&#39; is defined with
                respect to &#39;ref&#39;.
        &#34;&#34;&#34;

        if name in self._model:
            raise KeyError(&#34;A reference frame with the name &#39;{name} already exists in the model.&#34;)

        ref = self._model[ref]

        if transformation is not None:
            self._model[name] = ReferenceFrame(
                transformation, ref=ref, name=name, rot_config=self._rot_config,
            )
        else:
            self._model[name] = ReferenceFrame.fromTranslationRotation(
                translation,
                rotation,
                name=name,
                ref=ref,
                rot_config=self._rot_config,
                degrees=self._use_degrees,
                active=self._use_active_movements,
            )

    def remove_frame(self, name: str):
        &#34;&#34;&#34;
        Deletes the reference frame from the model. If the reference frame doesn&#39;t exist in the
        model, a warning message is logged.

        Args:
            name: the name of the reference frame to remove
        &#34;&#34;&#34;

        if name in self._model:

            frame: ReferenceFrame = self._model[name]

            # We need to get the links out in a list because the frame.removeLink() method deletes
            # frames from the linkedTo dictionary and that is not allowed in a for loop.

            links = [linked_frame for linked_frame in frame.linkedTo]
            for link in links:
                frame.removeLink(link)

            del self._model[name]
        else:
            LOGGER.warning(
                f&#34;You tried to remove a non-existing reference frame &#39;{name}&#39; from the model.&#34;
            )

    def get_frame(self, name: str) -&gt; ReferenceFrame:
        &#34;&#34;&#34;
        Returns a frame with the given name.

        .. note::
            Use this function with care since this breaks encapsulation and may lead to an
            inconsistent model when the frame is changed outside of the scope of the reference
            model.

        Args:
            name: the name of the requested reference frame

        Returns:
            The reference frame with the given name.
        &#34;&#34;&#34;
        return self._model[name]

    def add_link(self, source: str, target: str):
        &#34;&#34;&#34;
        Add a link between two reference frames. All links are bi-directional.

        Args:
            source: the source reference frame
            target: the target reference frame

        &#34;&#34;&#34;
        if source not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{source} in the model.&#34;)
        if target not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{target} in the model.&#34;)

        source = self._model[source]
        target = self._model[target]

        source.addLink(target)

    def remove_link(self, source: str, target: str):
        &#34;&#34;&#34;
        Remove a link between two reference frames. All links are bi-directional and this method
        removes both links.

        Args:
            source: the source reference frame
            target: the target reference frame

        &#34;&#34;&#34;
        if source not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{source} in the model.&#34;)
        if target not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{target} in the model.&#34;)

        source = self._model[source]
        target = self._model[target]

        source.removeLink(target)

    def move_absolute_self(self, frame: str, translation, rotation, degrees=_DEGREES_DEFAULT):
        &#34;&#34;&#34;
        Apply an absolute movement to the given ReferenceFrame such that it occupies a given
        absolute position wrt &#34;frame_ref&#34; after the movement.

        NO Hexapod equivalent.

        Args:
            frame (str): the name of the reference frame to move
        &#34;&#34;&#34;

        frame = self._model[frame]
        frame.setTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

    def move_absolute_in_other(
        self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
    ):
        &#34;&#34;&#34;
        Apply an absolute movement to the ReferenceFrame &#34;frame&#34;, such that it occupies
        a given absolute position with respect to &#34;other&#34; after the movement.

        EQUIVALENT PunaSimulator.move_absolute, setting hexobj wrt hexusr.

        Args:
            frame (str): the name (id) of the reference frame to move
            other (str): the name (id) of the reference frame
        &#34;&#34;&#34;

        # TODO:
        #   There can not be a link between frame and other, not direct and not indirect.
        #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

        frame = self._model[frame]
        other = self._model[other]

        transformation = other.getActiveTransformationTo(frame)

        moving_in_other = ReferenceFrame(
            transformation, rot_config=self._rot_config, ref=other, name=&#34;moving_in_other&#34;
        )

        moving_in_other.addLink(frame)

        moving_in_other.setTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

        moving_in_other.removeLink(frame)

        del moving_in_other

    def move_relative_self(self, frame: str, translation, rotation, degrees=_DEGREES_DEFAULT):
        &#34;&#34;&#34;
        Apply a relative movement to the given ReferenceFrame assuming the movement is expressed
        in that same frame.

        EQUIVALENT PunaSimulator.move_relative_object

        Args:
            frame (str): the name of the reference frame to move
        &#34;&#34;&#34;

        frame = self._model[frame]
        frame.applyTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

    def move_relative_other(
        self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
    ):
        &#34;&#34;&#34;
        Apply a relative movement to the ReferenceFrame &#34;frame&#34;. The movement is expressed wrt
        the axes of another frame, &#34;other&#34;.

        The center of rotation is the origin of the reference frame &#39;other&#39;.

        NO Hexapod equivalent.

        Args:
            frame (str): the name (id) of the reference frame to move
            other (str): the name (id) of the reference frame
        &#34;&#34;&#34;

        # TODO:
        #   There can not be a link between frame and other, not direct and not indirect.
        #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

        frame = self._model[frame]
        other = self._model[other]

        transformation = frame.getActiveTransformationTo(other)

        moving_in_other = ReferenceFrame(
            transformation, rot_config=self._rot_config, ref=other, name=&#34;moving_in_other&#34;
        )

        moving_in_other.addLink(frame)

        moving_in_other.applyTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

        moving_in_other.removeLink(frame)

        del moving_in_other  # not need as local scope

    def move_relative_other_local(
        self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
    ):
        &#34;&#34;&#34;
        Apply a relative movement to the ReferenceFrame &#34;frame&#34;.

        The movement is expressed wrt the axes of an external frame &#34;other&#34;

        The center of rotation is the origin of the reference frame &#39;frame&#39;.

        EQUIVALENT PunaSimulator.move_relative_user

        &#34;&#34;&#34;

        # TODO:
        #   There can not be a link between frame and other, not direct and not indirect.
        #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

        frame = self._model[frame]
        other = self._model[other]

        # Represent the requested movement

        # Derotation of MOVING --&gt; REF  (align frame_moving axes on those of frame_ref)

        derotation = frame.getActiveTransformationTo(other)
        derotation[:3, 3] = [0, 0, 0]

        # Reverse rotation (record inverse rotation, to restore the frame in the end)

        rerotation = derotation.T

        # Requested translation matrix  (already expressed wrt frame_ref)

        translation_ = np.identity(4)
        translation_[:3, 3] = translation

        # Requested rotation matrix (already expressed wrt frame_ref)

        zeros = [0, 0, 0]
        rotation_ = t3add.translationRotationToTransformation(
            zeros, rotation, rot_config=self._rot_config
        )

        # All translations and rotations are applied to frame_moving
        # ==&gt; a. need for &#34;derotation&#34; before applying the translation
        #     b. the center or rotation is always the origin of frame_moving
        # 1. rotate frame_moving to align it with frame_ref (i.e. render their axes parallel)
        # 2. apply the translation in this frame
        # 3. restore the original orientation of the moving frame
        # 4. apply the requested rotation

        transformation = derotation @ translation_ @ rerotation @ rotation_

        # Apply the requested movement

        frame.applyTransformation(transformation, preserveLinks=True)


def plot_ref_model(model: ReferenceFrameModel):

    # figsize is in inch, 6 inch = 15.24 cm, 5 inch = 12.7 cm

    fig = plt.figure(figsize=(6, 5), dpi=100)

    ax = fig.add_subplot(1, 1, 1)

    # Set axes limits in data coordinates

    ax.set_xlim(-10, 10)
    ax.set_ylim(-10, 10)
    ax.set_xticks(range(-10, 11, 2))
    ax.set_yticks(range(-10, 11, 2))
    ax.grid(True)

    for frame in model:
        draw_frame(ax, frame, plane=&#34;xz&#34;)

    plt.show()


def plot_ref_model_3d(model: ReferenceFrameModel):

    fig = plt.figure(figsize=(8, 8), dpi=100)
    ax = Axes3D(fig)
    # ax.set_box_aspect([1, 1, 1])

    ax.set_xlabel(&#34;x&#34;)
    ax.set_ylabel(&#34;y&#34;)
    ax.set_zlabel(&#34;z&#34;)

    def get_fix_mins_maxs(mins, maxs):
        deltas = (maxs - mins) / 12.0
        mins = mins + deltas / 4.0
        maxs = maxs - deltas / 4.0

        return [mins, maxs]

    min_ = -8
    max_ = 8
    minmax = get_fix_mins_maxs(min_, max_)

    # ax.set_xticks(range(min_, max_, 2))
    # ax.set_yticks(range(min_, max_, 2))
    # ax.set_zticks(range(min_, max_, 2))

    ax.set_xlim(minmax)
    ax.set_ylim(minmax)
    ax.set_zlim(minmax)

    delta = 0.1
    ax.scatter(
        [min_ + delta, max_ - delta],
        [min_ + delta, max_ - delta],
        [min_ + delta, max_ - delta],
        color=&#34;k&#34;,
        marker=&#34;.&#34;,
    )

    for frame in model:
        draw_frame_3d(ax, frame)

    # ax.set_proj_type(&#39;ortho&#39;)
    ax.set_proj_type(&#34;persp&#34;)

    set_axes_equal(ax)
    plt.show()


# The aspect ration of the plots is not equal by default.
# This solution was given in SO: https://stackoverflow.com/a/63625222/4609203


def set_axes_equal(ax: plt.Axes):
    &#34;&#34;&#34;Set 3D plot axes to equal scale.

    Make axes of 3D plot have equal scale so that spheres appear as
    spheres and cubes as cubes.  Required since `ax.axis(&#39;equal&#39;)`
    and `ax.set_aspect(&#39;equal&#39;)` don&#39;t work on 3D.
    &#34;&#34;&#34;
    limits = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])
    origin = np.mean(limits, axis=1)
    radius = 0.5 * np.max(np.abs(limits[:, 1] - limits[:, 0]))
    x, y, z = origin
    ax.set_xlim3d([x - radius, x + radius])
    ax.set_ylim3d([y - radius, y + radius])
    ax.set_zlim3d([z - radius, z + radius])


def draw_frame_3d(ax: Axes3D, frame: ReferenceFrame, DEFAULT_AXIS_LENGTH=100, **kwargs):

    master = frame.find_master()

    f0 = frame.getOrigin()
    fx = frame.getAxis(&#34;x&#34;, name=&#34;fx&#34;)
    fy = frame.getAxis(&#34;y&#34;, name=&#34;fy&#34;)
    fz = frame.getAxis(&#34;z&#34;, name=&#34;fz&#34;)
    f0m = f0.expressIn(master)[:3]
    fxm = fx.expressIn(master)[:3]
    fym = fy.expressIn(master)[:3]
    fzm = fz.expressIn(master)[:3]

    # Origin of the X,Y and Z vectors (x = the &#39;x&#39; coordinates of the origin of all 3 vectors)
    # Every vector independently (--&gt; plot in diff. colors)
    x, y, z = np.array([f0m[0]]), np.array([f0m[1]]), np.array([f0m[2]])

    # Orientation of the X,Y and Z vectors
    vecxx, vecyx, veczx = (
        np.array([fxm[0] - f0m[0]]),
        np.array([fym[0] - f0m[0]]),
        np.array([fzm[0] - f0m[0]]),
    )
    vecxy, vecyy, veczy = (
        np.array([fxm[1] - f0m[1]]),
        np.array([fym[1] - f0m[1]]),
        np.array([fzm[1] - f0m[1]]),
    )
    vecxz, vecyz, veczz = (
        np.array([fxm[2] - f0m[2]]),
        np.array([fym[2] - f0m[2]]),
        np.array([fzm[2] - f0m[2]]),
    )

    kwargs.setdefault(&#34;length&#34;, 2)
    kwargs.setdefault(&#34;normalize&#34;, True)

    ax.quiver(x, y, z, vecxx, vecxy, vecxz, color=&#34;r&#34;, **kwargs)
    ax.quiver(x, y, z, vecyx, vecyy, vecyz, color=&#34;g&#34;, **kwargs)
    ax.quiver(x, y, z, veczx, veczy, veczz, color=&#34;b&#34;, **kwargs)

    offset = 0.1
    ax.text(f0m[0] + offset, f0m[1] + offset, f0m[2] + offset, frame.name)


def draw_frame(ax, frame: ReferenceFrame, plane=&#34;xz&#34;, DEFAULT_AXIS_LENGTH=100):

    fig = ax.get_figure()

    # FC : Figure coordinates (pixels)
    # NFC : Normalized figure coordinates (0 → 1)
    # DC : Data coordinates (data units)
    # NDC : Normalized data coordinates (0 → 1)

    dc2fc = ax.transData.transform
    fc2dc = ax.transData.inverted().transform
    fc2ndc = ax.transAxes.inverted().transform

    def dc2ndc(x):  # better than defining and assigning a lambda function
        return fc2ndc(dc2fc(x))

    x_idx, y_idx = {&#34;xz&#34;: (0, 2), &#34;xy&#34;: (0, 1), &#34;yz&#34;: (1, 2)}[plane]

    # Draw the origin

    origin = frame.getOrigin()
    origin_in_master = origin.expressIn(frame.find_master())

    ax.scatter([origin_in_master[x_idx]], [origin_in_master[y_idx]], color=&#34;k&#34;)

    # Draw the axis

    origin_dc = np.array([[origin_in_master[x_idx], origin_in_master[y_idx]]])

    point = dc2fc(origin_dc[0])
    point[0] += DEFAULT_AXIS_LENGTH
    target_dc = np.append(origin_dc, [fc2dc(point)], axis=0)

    ax.plot(target_dc[:, 0], target_dc[:, 1], color=&#34;k&#34;)

    point = dc2fc(origin_dc[0])
    point[1] += DEFAULT_AXIS_LENGTH
    target_dc = np.append(origin_dc, [fc2dc(point)], axis=0)

    ax.plot(target_dc[:, 0], target_dc[:, 1], color=&#34;k&#34;)

    # Draw the axes label

    dx, dy = 10 / fig.dpi, 10 / fig.dpi
    offset = ScaledTranslation(dx, dy, fig.dpi_scale_trans)
    point = dc2ndc(origin_dc[0])
    plt.text(point[0], point[1], frame.name, transform=ax.transAxes + offset)


def define_the_initial_setup():
    model = ReferenceFrameModel()

    model.add_master_frame()
    model.add_frame(&#34;A&#34;, translation=[2, 2, 2], rotation=[0, 0, 0], ref=&#34;Master&#34;)
    model.add_frame(&#34;B&#34;, translation=[-2, 2, 2], rotation=[0, 0, 0], ref=&#34;Master&#34;)
    model.add_frame(&#34;C&#34;, translation=[2, 2, 5], rotation=[0, 0, 0], ref=&#34;A&#34;)
    model.add_frame(&#34;D&#34;, translation=[2, 2, 2], rotation=[0, 0, 0], ref=&#34;B&#34;)

    model.add_link(&#34;A&#34;, &#34;B&#34;)
    model.add_link(&#34;B&#34;, &#34;C&#34;)

    print(model.serialize())
    plot_ref_model_3d(model)

    return model


if __name__ == &#34;__main__&#34;:

    logging.basicConfig(level=20)

    model = define_the_initial_setup()

    print(model.summary())

    print(&#34;\nMove frame &#39;A&#39;, frames &#39;B&#39; and &#39;C&#39; move with it.\n&#34;)
    model.move_absolute_self(&#34;A&#34;, [1, 1, 3], [0, 0, 45])
    print(model.serialize())
    plot_ref_model_3d(model)

    model = define_the_initial_setup()

    print(&#34;\nMove frame &#39;B&#39; with respect to &#39;Master, frames &#39;A&#39; and &#39;C&#39; move with it.\n&#34;)
    model.move_absolute_in_other(&#34;B&#34;, &#34;Master&#34;, [1, 1, -1], [0, 0, 0])
    print(model.serialize())
    plot_ref_model_3d(model)

    model = define_the_initial_setup()

    print(&#34;\nMove frame &#39;D&#39; relative to itself, turn 45º\n&#34;)
    model.move_relative_self(&#34;D&#34;, [0, 0, 0], [45, 0, 0])
    print(model.serialize())
    plot_ref_model_3d(model)

    model = define_the_initial_setup()

    print(&#34;\nMove frame &#39;D&#39; relative to &#39;A&#39;, turn 45º around origin of &#39;A&#39;\n&#34;)
    model.move_relative_other(&#34;D&#34;, &#34;A&#34;, [0, 0, 0], [0, 45, 0])
    print(model.serialize())
    plot_ref_model_3d(model)

    model = define_the_initial_setup()

    print(&#34;\nMove frame &#39;D&#39; relative to &#39;A&#39;, turn 45º around origin of &#39;D&#39;\n&#34;)
    model.move_relative_other_local(&#34;D&#34;, &#34;A&#34;, [0, 0, 0], [0, 45, 0])
    print(model.serialize())
    plot_ref_model_3d(model)

    model = define_the_initial_setup()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.coordinates.refmodel.define_the_initial_setup"><code class="name flex">
<span>def <span class="ident">define_the_initial_setup</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_the_initial_setup():
    model = ReferenceFrameModel()

    model.add_master_frame()
    model.add_frame(&#34;A&#34;, translation=[2, 2, 2], rotation=[0, 0, 0], ref=&#34;Master&#34;)
    model.add_frame(&#34;B&#34;, translation=[-2, 2, 2], rotation=[0, 0, 0], ref=&#34;Master&#34;)
    model.add_frame(&#34;C&#34;, translation=[2, 2, 5], rotation=[0, 0, 0], ref=&#34;A&#34;)
    model.add_frame(&#34;D&#34;, translation=[2, 2, 2], rotation=[0, 0, 0], ref=&#34;B&#34;)

    model.add_link(&#34;A&#34;, &#34;B&#34;)
    model.add_link(&#34;B&#34;, &#34;C&#34;)

    print(model.serialize())
    plot_ref_model_3d(model)

    return model</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.draw_frame"><code class="name flex">
<span>def <span class="ident">draw_frame</span></span>(<span>ax, frame: <a title="egse.coordinates.referenceFrame.ReferenceFrame" href="referenceFrame.html#egse.coordinates.referenceFrame.ReferenceFrame">ReferenceFrame</a>, plane='xz', DEFAULT_AXIS_LENGTH=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_frame(ax, frame: ReferenceFrame, plane=&#34;xz&#34;, DEFAULT_AXIS_LENGTH=100):

    fig = ax.get_figure()

    # FC : Figure coordinates (pixels)
    # NFC : Normalized figure coordinates (0 → 1)
    # DC : Data coordinates (data units)
    # NDC : Normalized data coordinates (0 → 1)

    dc2fc = ax.transData.transform
    fc2dc = ax.transData.inverted().transform
    fc2ndc = ax.transAxes.inverted().transform

    def dc2ndc(x):  # better than defining and assigning a lambda function
        return fc2ndc(dc2fc(x))

    x_idx, y_idx = {&#34;xz&#34;: (0, 2), &#34;xy&#34;: (0, 1), &#34;yz&#34;: (1, 2)}[plane]

    # Draw the origin

    origin = frame.getOrigin()
    origin_in_master = origin.expressIn(frame.find_master())

    ax.scatter([origin_in_master[x_idx]], [origin_in_master[y_idx]], color=&#34;k&#34;)

    # Draw the axis

    origin_dc = np.array([[origin_in_master[x_idx], origin_in_master[y_idx]]])

    point = dc2fc(origin_dc[0])
    point[0] += DEFAULT_AXIS_LENGTH
    target_dc = np.append(origin_dc, [fc2dc(point)], axis=0)

    ax.plot(target_dc[:, 0], target_dc[:, 1], color=&#34;k&#34;)

    point = dc2fc(origin_dc[0])
    point[1] += DEFAULT_AXIS_LENGTH
    target_dc = np.append(origin_dc, [fc2dc(point)], axis=0)

    ax.plot(target_dc[:, 0], target_dc[:, 1], color=&#34;k&#34;)

    # Draw the axes label

    dx, dy = 10 / fig.dpi, 10 / fig.dpi
    offset = ScaledTranslation(dx, dy, fig.dpi_scale_trans)
    point = dc2ndc(origin_dc[0])
    plt.text(point[0], point[1], frame.name, transform=ax.transAxes + offset)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.draw_frame_3d"><code class="name flex">
<span>def <span class="ident">draw_frame_3d</span></span>(<span>ax: mpl_toolkits.mplot3d.axes3d.Axes3D, frame: <a title="egse.coordinates.referenceFrame.ReferenceFrame" href="referenceFrame.html#egse.coordinates.referenceFrame.ReferenceFrame">ReferenceFrame</a>, DEFAULT_AXIS_LENGTH=100, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_frame_3d(ax: Axes3D, frame: ReferenceFrame, DEFAULT_AXIS_LENGTH=100, **kwargs):

    master = frame.find_master()

    f0 = frame.getOrigin()
    fx = frame.getAxis(&#34;x&#34;, name=&#34;fx&#34;)
    fy = frame.getAxis(&#34;y&#34;, name=&#34;fy&#34;)
    fz = frame.getAxis(&#34;z&#34;, name=&#34;fz&#34;)
    f0m = f0.expressIn(master)[:3]
    fxm = fx.expressIn(master)[:3]
    fym = fy.expressIn(master)[:3]
    fzm = fz.expressIn(master)[:3]

    # Origin of the X,Y and Z vectors (x = the &#39;x&#39; coordinates of the origin of all 3 vectors)
    # Every vector independently (--&gt; plot in diff. colors)
    x, y, z = np.array([f0m[0]]), np.array([f0m[1]]), np.array([f0m[2]])

    # Orientation of the X,Y and Z vectors
    vecxx, vecyx, veczx = (
        np.array([fxm[0] - f0m[0]]),
        np.array([fym[0] - f0m[0]]),
        np.array([fzm[0] - f0m[0]]),
    )
    vecxy, vecyy, veczy = (
        np.array([fxm[1] - f0m[1]]),
        np.array([fym[1] - f0m[1]]),
        np.array([fzm[1] - f0m[1]]),
    )
    vecxz, vecyz, veczz = (
        np.array([fxm[2] - f0m[2]]),
        np.array([fym[2] - f0m[2]]),
        np.array([fzm[2] - f0m[2]]),
    )

    kwargs.setdefault(&#34;length&#34;, 2)
    kwargs.setdefault(&#34;normalize&#34;, True)

    ax.quiver(x, y, z, vecxx, vecxy, vecxz, color=&#34;r&#34;, **kwargs)
    ax.quiver(x, y, z, vecyx, vecyy, vecyz, color=&#34;g&#34;, **kwargs)
    ax.quiver(x, y, z, veczx, veczy, veczz, color=&#34;b&#34;, **kwargs)

    offset = 0.1
    ax.text(f0m[0] + offset, f0m[1] + offset, f0m[2] + offset, frame.name)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.plot_ref_model"><code class="name flex">
<span>def <span class="ident">plot_ref_model</span></span>(<span>model: <a title="egse.coordinates.refmodel.ReferenceFrameModel" href="#egse.coordinates.refmodel.ReferenceFrameModel">ReferenceFrameModel</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ref_model(model: ReferenceFrameModel):

    # figsize is in inch, 6 inch = 15.24 cm, 5 inch = 12.7 cm

    fig = plt.figure(figsize=(6, 5), dpi=100)

    ax = fig.add_subplot(1, 1, 1)

    # Set axes limits in data coordinates

    ax.set_xlim(-10, 10)
    ax.set_ylim(-10, 10)
    ax.set_xticks(range(-10, 11, 2))
    ax.set_yticks(range(-10, 11, 2))
    ax.grid(True)

    for frame in model:
        draw_frame(ax, frame, plane=&#34;xz&#34;)

    plt.show()</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.plot_ref_model_3d"><code class="name flex">
<span>def <span class="ident">plot_ref_model_3d</span></span>(<span>model: <a title="egse.coordinates.refmodel.ReferenceFrameModel" href="#egse.coordinates.refmodel.ReferenceFrameModel">ReferenceFrameModel</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_ref_model_3d(model: ReferenceFrameModel):

    fig = plt.figure(figsize=(8, 8), dpi=100)
    ax = Axes3D(fig)
    # ax.set_box_aspect([1, 1, 1])

    ax.set_xlabel(&#34;x&#34;)
    ax.set_ylabel(&#34;y&#34;)
    ax.set_zlabel(&#34;z&#34;)

    def get_fix_mins_maxs(mins, maxs):
        deltas = (maxs - mins) / 12.0
        mins = mins + deltas / 4.0
        maxs = maxs - deltas / 4.0

        return [mins, maxs]

    min_ = -8
    max_ = 8
    minmax = get_fix_mins_maxs(min_, max_)

    # ax.set_xticks(range(min_, max_, 2))
    # ax.set_yticks(range(min_, max_, 2))
    # ax.set_zticks(range(min_, max_, 2))

    ax.set_xlim(minmax)
    ax.set_ylim(minmax)
    ax.set_zlim(minmax)

    delta = 0.1
    ax.scatter(
        [min_ + delta, max_ - delta],
        [min_ + delta, max_ - delta],
        [min_ + delta, max_ - delta],
        color=&#34;k&#34;,
        marker=&#34;.&#34;,
    )

    for frame in model:
        draw_frame_3d(ax, frame)

    # ax.set_proj_type(&#39;ortho&#39;)
    ax.set_proj_type(&#34;persp&#34;)

    set_axes_equal(ax)
    plt.show()</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.set_axes_equal"><code class="name flex">
<span>def <span class="ident">set_axes_equal</span></span>(<span>ax: matplotlib.axes._axes.Axes)</span>
</code></dt>
<dd>
<div class="desc"><p>Set 3D plot axes to equal scale.</p>
<p>Make axes of 3D plot have equal scale so that spheres appear as
spheres and cubes as cubes.
Required since <code>ax.axis('equal')</code>
and <code>ax.set_aspect('equal')</code> don't work on 3D.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_axes_equal(ax: plt.Axes):
    &#34;&#34;&#34;Set 3D plot axes to equal scale.

    Make axes of 3D plot have equal scale so that spheres appear as
    spheres and cubes as cubes.  Required since `ax.axis(&#39;equal&#39;)`
    and `ax.set_aspect(&#39;equal&#39;)` don&#39;t work on 3D.
    &#34;&#34;&#34;
    limits = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])
    origin = np.mean(limits, axis=1)
    radius = 0.5 * np.max(np.abs(limits[:, 1] - limits[:, 0]))
    x, y, z = origin
    ax.set_xlim3d([x - radius, x + radius])
    ax.set_ylim3d([y - radius, y + radius])
    ax.set_zlim3d([z - radius, z + radius])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel"><code class="flex name class">
<span>class <span class="ident">ReferenceFrameModel</span></span>
<span>(</span><span>model: Union[Dict[~KT, ~VT], List[<a title="egse.coordinates.referenceFrame.ReferenceFrame" href="referenceFrame.html#egse.coordinates.referenceFrame.ReferenceFrame">ReferenceFrame</a>]] = None, rot_config: str = 'sxyz', use_degrees: bool = True, use_active_movements: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>A ReferenceFrameModel is a collection of reference frames that are linked to each other to
form a Graph.</p>
<p>When the model_dict is empty or None, a new model is created with a master reference frame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>a list or a dictionary of reference frames that make up the model</dd>
<dt><strong><code>use_degrees</code></strong></dt>
<dd>use degrees throughout this model unless explicitly specified in the
function call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenceFrameModel:
    &#34;&#34;&#34;
    A ReferenceFrameModel is a collection of reference frames that are linked to each other to
    form a Graph.
    &#34;&#34;&#34;

    _ROT_CONFIG_DEFAULT = &#34;sxyz&#34;
    _ACTIVE_DEFAULT = True
    _DEGREES_DEFAULT = True

    def __init__(
        self,
        model: Union[Dict, List[ReferenceFrame]] = None,
        rot_config: str = _ROT_CONFIG_DEFAULT,
        use_degrees: bool = _DEGREES_DEFAULT,
        use_active_movements: bool = _ACTIVE_DEFAULT,
    ):
        &#34;&#34;&#34;
        When the model_dict is empty or None, a new model is created with a master reference frame.

        Args:
            model: a list or a dictionary of reference frames that make up the model
            use_degrees: use degrees throughout this model unless explicitly specified in the
                function call.
        &#34;&#34;&#34;
        self._use_degrees = use_degrees
        self._use_active_movements = use_active_movements
        self._rot_config = rot_config

        # Keep a dictionary with all reference frames that are part of the model. The keys shall
        # be the name of the reference frame. When the model passed is empty, create only a
        # master reference frame.

        if isinstance(model, (dict, list)):
            self._model = self.deserialize(model)
        else:
            self._model = NavigableDict({})

    def __str__(self):
        return self._model.pretty_str()

    def __len__(self):
        return len(self._model)

    def __contains__(self, item):
        return item in self._model

    def __iter__(self):
        return iter(self._model.values())

    def summary(self):
        result = f&#34;Nb of frames: {len(self)}\n&#34;

        for ref in self:
            result += (
                f&#34;{ref.name:&gt;10}[{ref.ref.name}]&#34; f&#34;  ---  {[link.name for link in ref.linkedTo]}\n&#34;
            )
        return result

    @staticmethod
    def deserialize(model_dict: dict) -&gt; NavigableDict:
        &#34;&#34;&#34;
        Deserialize means you take a serialized representation of a reference frames model and
        turn it into a dictionary containing all the reference frames with their links and
        references.

        Args:
            model_dict: a dictionary of serialized reference frames

        Returns:
            A dictionary of ReferenceFrames that make up a model.

        &#34;&#34;&#34;
        return dict_to_ref_model(model_dict)

    def serialize(self) -&gt; NavigableDict:
        &#34;&#34;&#34;
        Serialize the model by serializing each of the reference frames into an object that can
        easily be saved to a YAML or a JSON file. Return a dictionary with the serialized frames.

        Returns:
            A dictionary with all the reference framed serialized.
        &#34;&#34;&#34;

        return ref_model_to_dict(self._model)

    def add_master_frame(self):

        # TODO: First check if there is not already a Master frame in the model

        self._model[&#34;Master&#34;] = ReferenceFrame.createMaster()

    def add_frame(
        self,
        name: str,
        *,
        translation: List[float] = None,
        rotation: List[float] = None,
        transformation=None,
        ref: str,
    ):
        &#34;&#34;&#34;
        Add a reference frame to the model.

        .. note::
            Only the `name` parameter can be positional, all the other arguments (translation,
            rotation, transformation, and ref) must be given as keyword arguments.

        Args:
            name: the name for the reference frame. This name is it&#39;s identifier within the model.
            translation: the translation vector
            rotation: the rotation vector
            transformation: the transformation vector, if `transformation` is given,
                both `translation` and `rotation` are ignored.
            ref: the reference frame that is a reference for &#39;name&#39;, i.e. &#39;name&#39; is defined with
                respect to &#39;ref&#39;.
        &#34;&#34;&#34;

        if name in self._model:
            raise KeyError(&#34;A reference frame with the name &#39;{name} already exists in the model.&#34;)

        ref = self._model[ref]

        if transformation is not None:
            self._model[name] = ReferenceFrame(
                transformation, ref=ref, name=name, rot_config=self._rot_config,
            )
        else:
            self._model[name] = ReferenceFrame.fromTranslationRotation(
                translation,
                rotation,
                name=name,
                ref=ref,
                rot_config=self._rot_config,
                degrees=self._use_degrees,
                active=self._use_active_movements,
            )

    def remove_frame(self, name: str):
        &#34;&#34;&#34;
        Deletes the reference frame from the model. If the reference frame doesn&#39;t exist in the
        model, a warning message is logged.

        Args:
            name: the name of the reference frame to remove
        &#34;&#34;&#34;

        if name in self._model:

            frame: ReferenceFrame = self._model[name]

            # We need to get the links out in a list because the frame.removeLink() method deletes
            # frames from the linkedTo dictionary and that is not allowed in a for loop.

            links = [linked_frame for linked_frame in frame.linkedTo]
            for link in links:
                frame.removeLink(link)

            del self._model[name]
        else:
            LOGGER.warning(
                f&#34;You tried to remove a non-existing reference frame &#39;{name}&#39; from the model.&#34;
            )

    def get_frame(self, name: str) -&gt; ReferenceFrame:
        &#34;&#34;&#34;
        Returns a frame with the given name.

        .. note::
            Use this function with care since this breaks encapsulation and may lead to an
            inconsistent model when the frame is changed outside of the scope of the reference
            model.

        Args:
            name: the name of the requested reference frame

        Returns:
            The reference frame with the given name.
        &#34;&#34;&#34;
        return self._model[name]

    def add_link(self, source: str, target: str):
        &#34;&#34;&#34;
        Add a link between two reference frames. All links are bi-directional.

        Args:
            source: the source reference frame
            target: the target reference frame

        &#34;&#34;&#34;
        if source not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{source} in the model.&#34;)
        if target not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{target} in the model.&#34;)

        source = self._model[source]
        target = self._model[target]

        source.addLink(target)

    def remove_link(self, source: str, target: str):
        &#34;&#34;&#34;
        Remove a link between two reference frames. All links are bi-directional and this method
        removes both links.

        Args:
            source: the source reference frame
            target: the target reference frame

        &#34;&#34;&#34;
        if source not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{source} in the model.&#34;)
        if target not in self._model:
            raise KeyError(f&#34;There is no reference frame with the name &#39;{target} in the model.&#34;)

        source = self._model[source]
        target = self._model[target]

        source.removeLink(target)

    def move_absolute_self(self, frame: str, translation, rotation, degrees=_DEGREES_DEFAULT):
        &#34;&#34;&#34;
        Apply an absolute movement to the given ReferenceFrame such that it occupies a given
        absolute position wrt &#34;frame_ref&#34; after the movement.

        NO Hexapod equivalent.

        Args:
            frame (str): the name of the reference frame to move
        &#34;&#34;&#34;

        frame = self._model[frame]
        frame.setTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

    def move_absolute_in_other(
        self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
    ):
        &#34;&#34;&#34;
        Apply an absolute movement to the ReferenceFrame &#34;frame&#34;, such that it occupies
        a given absolute position with respect to &#34;other&#34; after the movement.

        EQUIVALENT PunaSimulator.move_absolute, setting hexobj wrt hexusr.

        Args:
            frame (str): the name (id) of the reference frame to move
            other (str): the name (id) of the reference frame
        &#34;&#34;&#34;

        # TODO:
        #   There can not be a link between frame and other, not direct and not indirect.
        #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

        frame = self._model[frame]
        other = self._model[other]

        transformation = other.getActiveTransformationTo(frame)

        moving_in_other = ReferenceFrame(
            transformation, rot_config=self._rot_config, ref=other, name=&#34;moving_in_other&#34;
        )

        moving_in_other.addLink(frame)

        moving_in_other.setTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

        moving_in_other.removeLink(frame)

        del moving_in_other

    def move_relative_self(self, frame: str, translation, rotation, degrees=_DEGREES_DEFAULT):
        &#34;&#34;&#34;
        Apply a relative movement to the given ReferenceFrame assuming the movement is expressed
        in that same frame.

        EQUIVALENT PunaSimulator.move_relative_object

        Args:
            frame (str): the name of the reference frame to move
        &#34;&#34;&#34;

        frame = self._model[frame]
        frame.applyTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

    def move_relative_other(
        self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
    ):
        &#34;&#34;&#34;
        Apply a relative movement to the ReferenceFrame &#34;frame&#34;. The movement is expressed wrt
        the axes of another frame, &#34;other&#34;.

        The center of rotation is the origin of the reference frame &#39;other&#39;.

        NO Hexapod equivalent.

        Args:
            frame (str): the name (id) of the reference frame to move
            other (str): the name (id) of the reference frame
        &#34;&#34;&#34;

        # TODO:
        #   There can not be a link between frame and other, not direct and not indirect.
        #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

        frame = self._model[frame]
        other = self._model[other]

        transformation = frame.getActiveTransformationTo(other)

        moving_in_other = ReferenceFrame(
            transformation, rot_config=self._rot_config, ref=other, name=&#34;moving_in_other&#34;
        )

        moving_in_other.addLink(frame)

        moving_in_other.applyTranslationRotation(
            translation,
            rotation,
            rot_config=self._rot_config,
            active=self._use_active_movements,
            degrees=degrees,
            preserveLinks=True,
        )

        moving_in_other.removeLink(frame)

        del moving_in_other  # not need as local scope

    def move_relative_other_local(
        self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
    ):
        &#34;&#34;&#34;
        Apply a relative movement to the ReferenceFrame &#34;frame&#34;.

        The movement is expressed wrt the axes of an external frame &#34;other&#34;

        The center of rotation is the origin of the reference frame &#39;frame&#39;.

        EQUIVALENT PunaSimulator.move_relative_user

        &#34;&#34;&#34;

        # TODO:
        #   There can not be a link between frame and other, not direct and not indirect.
        #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

        frame = self._model[frame]
        other = self._model[other]

        # Represent the requested movement

        # Derotation of MOVING --&gt; REF  (align frame_moving axes on those of frame_ref)

        derotation = frame.getActiveTransformationTo(other)
        derotation[:3, 3] = [0, 0, 0]

        # Reverse rotation (record inverse rotation, to restore the frame in the end)

        rerotation = derotation.T

        # Requested translation matrix  (already expressed wrt frame_ref)

        translation_ = np.identity(4)
        translation_[:3, 3] = translation

        # Requested rotation matrix (already expressed wrt frame_ref)

        zeros = [0, 0, 0]
        rotation_ = t3add.translationRotationToTransformation(
            zeros, rotation, rot_config=self._rot_config
        )

        # All translations and rotations are applied to frame_moving
        # ==&gt; a. need for &#34;derotation&#34; before applying the translation
        #     b. the center or rotation is always the origin of frame_moving
        # 1. rotate frame_moving to align it with frame_ref (i.e. render their axes parallel)
        # 2. apply the translation in this frame
        # 3. restore the original orientation of the moving frame
        # 4. apply the requested rotation

        transformation = derotation @ translation_ @ rerotation @ rotation_

        # Apply the requested movement

        frame.applyTransformation(transformation, preserveLinks=True)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.coordinates.cslmodel.CSLReferenceFrameModel" href="cslmodel.html#egse.coordinates.cslmodel.CSLReferenceFrameModel">CSLReferenceFrameModel</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>model_dict: dict) ‑> egse.setup.NavigableDict</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize means you take a serialized representation of a reference frames model and
turn it into a dictionary containing all the reference frames with their links and
references.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_dict</code></strong></dt>
<dd>a dictionary of serialized reference frames</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary of ReferenceFrames that make up a model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def deserialize(model_dict: dict) -&gt; NavigableDict:
    &#34;&#34;&#34;
    Deserialize means you take a serialized representation of a reference frames model and
    turn it into a dictionary containing all the reference frames with their links and
    references.

    Args:
        model_dict: a dictionary of serialized reference frames

    Returns:
        A dictionary of ReferenceFrames that make up a model.

    &#34;&#34;&#34;
    return dict_to_ref_model(model_dict)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.add_frame"><code class="name flex">
<span>def <span class="ident">add_frame</span></span>(<span>self, name: str, *, translation: List[float] = None, rotation: List[float] = None, transformation=None, ref: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a reference frame to the model.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only the <code>name</code> parameter can be positional, all the other arguments (translation,
rotation, transformation, and ref) must be given as keyword arguments.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the name for the reference frame. This name is it's identifier within the model.</dd>
<dt><strong><code>translation</code></strong></dt>
<dd>the translation vector</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>the rotation vector</dd>
<dt><strong><code>transformation</code></strong></dt>
<dd>the transformation vector, if <code>transformation</code> is given,
both <code>translation</code> and <code>rotation</code> are ignored.</dd>
<dt><strong><code>ref</code></strong></dt>
<dd>the reference frame that is a reference for 'name', i.e. 'name' is defined with
respect to 'ref'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_frame(
    self,
    name: str,
    *,
    translation: List[float] = None,
    rotation: List[float] = None,
    transformation=None,
    ref: str,
):
    &#34;&#34;&#34;
    Add a reference frame to the model.

    .. note::
        Only the `name` parameter can be positional, all the other arguments (translation,
        rotation, transformation, and ref) must be given as keyword arguments.

    Args:
        name: the name for the reference frame. This name is it&#39;s identifier within the model.
        translation: the translation vector
        rotation: the rotation vector
        transformation: the transformation vector, if `transformation` is given,
            both `translation` and `rotation` are ignored.
        ref: the reference frame that is a reference for &#39;name&#39;, i.e. &#39;name&#39; is defined with
            respect to &#39;ref&#39;.
    &#34;&#34;&#34;

    if name in self._model:
        raise KeyError(&#34;A reference frame with the name &#39;{name} already exists in the model.&#34;)

    ref = self._model[ref]

    if transformation is not None:
        self._model[name] = ReferenceFrame(
            transformation, ref=ref, name=name, rot_config=self._rot_config,
        )
    else:
        self._model[name] = ReferenceFrame.fromTranslationRotation(
            translation,
            rotation,
            name=name,
            ref=ref,
            rot_config=self._rot_config,
            degrees=self._use_degrees,
            active=self._use_active_movements,
        )</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self, source: str, target: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a link between two reference frames. All links are bi-directional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>the source reference frame</dd>
<dt><strong><code>target</code></strong></dt>
<dd>the target reference frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self, source: str, target: str):
    &#34;&#34;&#34;
    Add a link between two reference frames. All links are bi-directional.

    Args:
        source: the source reference frame
        target: the target reference frame

    &#34;&#34;&#34;
    if source not in self._model:
        raise KeyError(f&#34;There is no reference frame with the name &#39;{source} in the model.&#34;)
    if target not in self._model:
        raise KeyError(f&#34;There is no reference frame with the name &#39;{target} in the model.&#34;)

    source = self._model[source]
    target = self._model[target]

    source.addLink(target)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.add_master_frame"><code class="name flex">
<span>def <span class="ident">add_master_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_master_frame(self):

    # TODO: First check if there is not already a Master frame in the model

    self._model[&#34;Master&#34;] = ReferenceFrame.createMaster()</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.get_frame"><code class="name flex">
<span>def <span class="ident">get_frame</span></span>(<span>self, name: str) ‑> <a title="egse.coordinates.referenceFrame.ReferenceFrame" href="referenceFrame.html#egse.coordinates.referenceFrame.ReferenceFrame">ReferenceFrame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a frame with the given name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use this function with care since this breaks encapsulation and may lead to an
inconsistent model when the frame is changed outside of the scope of the reference
model.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the requested reference frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The reference frame with the given name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frame(self, name: str) -&gt; ReferenceFrame:
    &#34;&#34;&#34;
    Returns a frame with the given name.

    .. note::
        Use this function with care since this breaks encapsulation and may lead to an
        inconsistent model when the frame is changed outside of the scope of the reference
        model.

    Args:
        name: the name of the requested reference frame

    Returns:
        The reference frame with the given name.
    &#34;&#34;&#34;
    return self._model[name]</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.move_absolute_in_other"><code class="name flex">
<span>def <span class="ident">move_absolute_in_other</span></span>(<span>self, frame: str, other: str, translation, rotation, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an absolute movement to the ReferenceFrame "frame", such that it occupies
a given absolute position with respect to "other" after the movement.</p>
<p>EQUIVALENT PunaSimulator.move_absolute, setting hexobj wrt hexusr.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>str</code></dt>
<dd>the name (id) of the reference frame to move</dd>
<dt><strong><code>other</code></strong> :&ensp;<code>str</code></dt>
<dd>the name (id) of the reference frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_absolute_in_other(
    self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
):
    &#34;&#34;&#34;
    Apply an absolute movement to the ReferenceFrame &#34;frame&#34;, such that it occupies
    a given absolute position with respect to &#34;other&#34; after the movement.

    EQUIVALENT PunaSimulator.move_absolute, setting hexobj wrt hexusr.

    Args:
        frame (str): the name (id) of the reference frame to move
        other (str): the name (id) of the reference frame
    &#34;&#34;&#34;

    # TODO:
    #   There can not be a link between frame and other, not direct and not indirect.
    #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

    frame = self._model[frame]
    other = self._model[other]

    transformation = other.getActiveTransformationTo(frame)

    moving_in_other = ReferenceFrame(
        transformation, rot_config=self._rot_config, ref=other, name=&#34;moving_in_other&#34;
    )

    moving_in_other.addLink(frame)

    moving_in_other.setTranslationRotation(
        translation,
        rotation,
        rot_config=self._rot_config,
        active=self._use_active_movements,
        degrees=degrees,
        preserveLinks=True,
    )

    moving_in_other.removeLink(frame)

    del moving_in_other</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.move_absolute_self"><code class="name flex">
<span>def <span class="ident">move_absolute_self</span></span>(<span>self, frame: str, translation, rotation, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an absolute movement to the given ReferenceFrame such that it occupies a given
absolute position wrt "frame_ref" after the movement.</p>
<p>NO Hexapod equivalent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the reference frame to move</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_absolute_self(self, frame: str, translation, rotation, degrees=_DEGREES_DEFAULT):
    &#34;&#34;&#34;
    Apply an absolute movement to the given ReferenceFrame such that it occupies a given
    absolute position wrt &#34;frame_ref&#34; after the movement.

    NO Hexapod equivalent.

    Args:
        frame (str): the name of the reference frame to move
    &#34;&#34;&#34;

    frame = self._model[frame]
    frame.setTranslationRotation(
        translation,
        rotation,
        rot_config=self._rot_config,
        active=self._use_active_movements,
        degrees=degrees,
        preserveLinks=True,
    )</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.move_relative_other"><code class="name flex">
<span>def <span class="ident">move_relative_other</span></span>(<span>self, frame: str, other: str, translation, rotation, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a relative movement to the ReferenceFrame "frame". The movement is expressed wrt
the axes of another frame, "other".</p>
<p>The center of rotation is the origin of the reference frame 'other'.</p>
<p>NO Hexapod equivalent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>str</code></dt>
<dd>the name (id) of the reference frame to move</dd>
<dt><strong><code>other</code></strong> :&ensp;<code>str</code></dt>
<dd>the name (id) of the reference frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_relative_other(
    self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
):
    &#34;&#34;&#34;
    Apply a relative movement to the ReferenceFrame &#34;frame&#34;. The movement is expressed wrt
    the axes of another frame, &#34;other&#34;.

    The center of rotation is the origin of the reference frame &#39;other&#39;.

    NO Hexapod equivalent.

    Args:
        frame (str): the name (id) of the reference frame to move
        other (str): the name (id) of the reference frame
    &#34;&#34;&#34;

    # TODO:
    #   There can not be a link between frame and other, not direct and not indirect.
    #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

    frame = self._model[frame]
    other = self._model[other]

    transformation = frame.getActiveTransformationTo(other)

    moving_in_other = ReferenceFrame(
        transformation, rot_config=self._rot_config, ref=other, name=&#34;moving_in_other&#34;
    )

    moving_in_other.addLink(frame)

    moving_in_other.applyTranslationRotation(
        translation,
        rotation,
        rot_config=self._rot_config,
        active=self._use_active_movements,
        degrees=degrees,
        preserveLinks=True,
    )

    moving_in_other.removeLink(frame)

    del moving_in_other  # not need as local scope</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.move_relative_other_local"><code class="name flex">
<span>def <span class="ident">move_relative_other_local</span></span>(<span>self, frame: str, other: str, translation, rotation, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a relative movement to the ReferenceFrame "frame".</p>
<p>The movement is expressed wrt the axes of an external frame "other"</p>
<p>The center of rotation is the origin of the reference frame 'frame'.</p>
<p>EQUIVALENT PunaSimulator.move_relative_user</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_relative_other_local(
    self, frame: str, other: str, translation, rotation, degrees=_DEGREES_DEFAULT
):
    &#34;&#34;&#34;
    Apply a relative movement to the ReferenceFrame &#34;frame&#34;.

    The movement is expressed wrt the axes of an external frame &#34;other&#34;

    The center of rotation is the origin of the reference frame &#39;frame&#39;.

    EQUIVALENT PunaSimulator.move_relative_user

    &#34;&#34;&#34;

    # TODO:
    #   There can not be a link between frame and other, not direct and not indirect.
    #   So, with A-link-B-link-C-link-D, we can not do move_absolute_in_other(&#39;A&#39;, &#39;D&#39;, ...)

    frame = self._model[frame]
    other = self._model[other]

    # Represent the requested movement

    # Derotation of MOVING --&gt; REF  (align frame_moving axes on those of frame_ref)

    derotation = frame.getActiveTransformationTo(other)
    derotation[:3, 3] = [0, 0, 0]

    # Reverse rotation (record inverse rotation, to restore the frame in the end)

    rerotation = derotation.T

    # Requested translation matrix  (already expressed wrt frame_ref)

    translation_ = np.identity(4)
    translation_[:3, 3] = translation

    # Requested rotation matrix (already expressed wrt frame_ref)

    zeros = [0, 0, 0]
    rotation_ = t3add.translationRotationToTransformation(
        zeros, rotation, rot_config=self._rot_config
    )

    # All translations and rotations are applied to frame_moving
    # ==&gt; a. need for &#34;derotation&#34; before applying the translation
    #     b. the center or rotation is always the origin of frame_moving
    # 1. rotate frame_moving to align it with frame_ref (i.e. render their axes parallel)
    # 2. apply the translation in this frame
    # 3. restore the original orientation of the moving frame
    # 4. apply the requested rotation

    transformation = derotation @ translation_ @ rerotation @ rotation_

    # Apply the requested movement

    frame.applyTransformation(transformation, preserveLinks=True)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.move_relative_self"><code class="name flex">
<span>def <span class="ident">move_relative_self</span></span>(<span>self, frame: str, translation, rotation, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a relative movement to the given ReferenceFrame assuming the movement is expressed
in that same frame.</p>
<p>EQUIVALENT PunaSimulator.move_relative_object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the reference frame to move</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_relative_self(self, frame: str, translation, rotation, degrees=_DEGREES_DEFAULT):
    &#34;&#34;&#34;
    Apply a relative movement to the given ReferenceFrame assuming the movement is expressed
    in that same frame.

    EQUIVALENT PunaSimulator.move_relative_object

    Args:
        frame (str): the name of the reference frame to move
    &#34;&#34;&#34;

    frame = self._model[frame]
    frame.applyTranslationRotation(
        translation,
        rotation,
        rot_config=self._rot_config,
        active=self._use_active_movements,
        degrees=degrees,
        preserveLinks=True,
    )</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.remove_frame"><code class="name flex">
<span>def <span class="ident">remove_frame</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the reference frame from the model. If the reference frame doesn't exist in the
model, a warning message is logged.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>the name of the reference frame to remove</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_frame(self, name: str):
    &#34;&#34;&#34;
    Deletes the reference frame from the model. If the reference frame doesn&#39;t exist in the
    model, a warning message is logged.

    Args:
        name: the name of the reference frame to remove
    &#34;&#34;&#34;

    if name in self._model:

        frame: ReferenceFrame = self._model[name]

        # We need to get the links out in a list because the frame.removeLink() method deletes
        # frames from the linkedTo dictionary and that is not allowed in a for loop.

        links = [linked_frame for linked_frame in frame.linkedTo]
        for link in links:
            frame.removeLink(link)

        del self._model[name]
    else:
        LOGGER.warning(
            f&#34;You tried to remove a non-existing reference frame &#39;{name}&#39; from the model.&#34;
        )</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.remove_link"><code class="name flex">
<span>def <span class="ident">remove_link</span></span>(<span>self, source: str, target: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a link between two reference frames. All links are bi-directional and this method
removes both links.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>the source reference frame</dd>
<dt><strong><code>target</code></strong></dt>
<dd>the target reference frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_link(self, source: str, target: str):
    &#34;&#34;&#34;
    Remove a link between two reference frames. All links are bi-directional and this method
    removes both links.

    Args:
        source: the source reference frame
        target: the target reference frame

    &#34;&#34;&#34;
    if source not in self._model:
        raise KeyError(f&#34;There is no reference frame with the name &#39;{source} in the model.&#34;)
    if target not in self._model:
        raise KeyError(f&#34;There is no reference frame with the name &#39;{target} in the model.&#34;)

    source = self._model[source]
    target = self._model[target]

    source.removeLink(target)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> egse.setup.NavigableDict</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize the model by serializing each of the reference frames into an object that can
easily be saved to a YAML or a JSON file. Return a dictionary with the serialized frames.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary with all the reference framed serialized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; NavigableDict:
    &#34;&#34;&#34;
    Serialize the model by serializing each of the reference frames into an object that can
    easily be saved to a YAML or a JSON file. Return a dictionary with the serialized frames.

    Returns:
        A dictionary with all the reference framed serialized.
    &#34;&#34;&#34;

    return ref_model_to_dict(self._model)</code></pre>
</details>
</dd>
<dt id="egse.coordinates.refmodel.ReferenceFrameModel.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self):
    result = f&#34;Nb of frames: {len(self)}\n&#34;

    for ref in self:
        result += (
            f&#34;{ref.name:&gt;10}[{ref.ref.name}]&#34; f&#34;  ---  {[link.name for link in ref.linkedTo]}\n&#34;
        )
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.coordinates" href="index.html">egse.coordinates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.coordinates.refmodel.define_the_initial_setup" href="#egse.coordinates.refmodel.define_the_initial_setup">define_the_initial_setup</a></code></li>
<li><code><a title="egse.coordinates.refmodel.draw_frame" href="#egse.coordinates.refmodel.draw_frame">draw_frame</a></code></li>
<li><code><a title="egse.coordinates.refmodel.draw_frame_3d" href="#egse.coordinates.refmodel.draw_frame_3d">draw_frame_3d</a></code></li>
<li><code><a title="egse.coordinates.refmodel.plot_ref_model" href="#egse.coordinates.refmodel.plot_ref_model">plot_ref_model</a></code></li>
<li><code><a title="egse.coordinates.refmodel.plot_ref_model_3d" href="#egse.coordinates.refmodel.plot_ref_model_3d">plot_ref_model_3d</a></code></li>
<li><code><a title="egse.coordinates.refmodel.set_axes_equal" href="#egse.coordinates.refmodel.set_axes_equal">set_axes_equal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.coordinates.refmodel.ReferenceFrameModel" href="#egse.coordinates.refmodel.ReferenceFrameModel">ReferenceFrameModel</a></code></h4>
<ul class="">
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.add_frame" href="#egse.coordinates.refmodel.ReferenceFrameModel.add_frame">add_frame</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.add_link" href="#egse.coordinates.refmodel.ReferenceFrameModel.add_link">add_link</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.add_master_frame" href="#egse.coordinates.refmodel.ReferenceFrameModel.add_master_frame">add_master_frame</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.deserialize" href="#egse.coordinates.refmodel.ReferenceFrameModel.deserialize">deserialize</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.get_frame" href="#egse.coordinates.refmodel.ReferenceFrameModel.get_frame">get_frame</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.move_absolute_in_other" href="#egse.coordinates.refmodel.ReferenceFrameModel.move_absolute_in_other">move_absolute_in_other</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.move_absolute_self" href="#egse.coordinates.refmodel.ReferenceFrameModel.move_absolute_self">move_absolute_self</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.move_relative_other" href="#egse.coordinates.refmodel.ReferenceFrameModel.move_relative_other">move_relative_other</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.move_relative_other_local" href="#egse.coordinates.refmodel.ReferenceFrameModel.move_relative_other_local">move_relative_other_local</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.move_relative_self" href="#egse.coordinates.refmodel.ReferenceFrameModel.move_relative_self">move_relative_self</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.remove_frame" href="#egse.coordinates.refmodel.ReferenceFrameModel.remove_frame">remove_frame</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.remove_link" href="#egse.coordinates.refmodel.ReferenceFrameModel.remove_link">remove_link</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.serialize" href="#egse.coordinates.refmodel.ReferenceFrameModel.serialize">serialize</a></code></li>
<li><code><a title="egse.coordinates.refmodel.ReferenceFrameModel.summary" href="#egse.coordinates.refmodel.ReferenceFrameModel.summary">summary</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
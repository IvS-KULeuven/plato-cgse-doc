<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.collimator.fcul.ogse API documentation</title>
<meta name="description" content="This module defines the device classes to be used to connect to and control the OGSE." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.collimator.fcul.ogse</code></h1>
</header>
<section id="section-intro">
<p>This module defines the device classes to be used to connect to and control the OGSE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the device classes to be used to connect to and control the OGSE.
&#34;&#34;&#34;
from __future__ import annotations
import logging
import math
import random
import re
import time
from enum import Enum
from typing import Union

import numpy as np

from egse.collimator.fcul.ogse_devif import OGSEEthernetInterface
from egse.command import ClientServerCommand
from egse.command import CommandError
from egse.control import Failure
from egse.control import is_control_server_active
from egse.device import DeviceConnectionState
from egse.device import DeviceInterface
from egse.mixin import DynamicCommandMixin
from egse.mixin import add_lf
from egse.mixin import dynamic_command
from egse.proxy import DynamicProxy
from egse.settings import Settings
from egse.system import format_datetime
from egse.zmq_ser import connect_address

logger = logging.getLogger(__name__)

OGSE_SETTINGS = Settings.load(&#34;OGSE Controller&#34;)
CTRL_SETTINGS = Settings.load(&#34;OGSE Control Server&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;ogse.yaml&#34;)


def is_ogse_cs_active(timeout: float = 2.0):
    &#34;&#34;&#34;
    Checks whether the OGSE Control Server is running.

    Args:
        timeout (float): Timeout when waiting for a reply [seconds, default=2.0]

    Returns:
        True if the OGSE CS is running and replied with the expected answer.
    &#34;&#34;&#34;

    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )

    return is_control_server_active(endpoint, timeout)


def decode_response(response: bytes) -&gt; str:
    &#34;&#34;&#34;Decodes the bytes object and strips off the newline.&#34;&#34;&#34;
    return response.decode().rstrip()


def _convert_to_float(value: str) -&gt; float:
    try:
        return float(value)
    except ValueError:
        return math.nan


def check_cmd_att_index(cmd_string: str):
    &#34;&#34;&#34;Check if the &#39;level #&lt;index&gt;&#39; command has a correct index.&#34;&#34;&#34;

    # index is expected to be in the range [0-46] (inclusive)

    index = int(cmd_string.split()[-1][1:])

    if not (0 &lt;= index &lt;= 46):
        raise CommandError(&#34;ERROR: usage: attenuator level #index  -- index goes from 0 to 46&#34;)

    return add_lf(cmd_string)


def decode_pm_status_response(response: bytes):
    &#34;&#34;&#34; Decode the response from the OGSE &#39;pm status&#39; command.

    The command will return a bytes object of the following format:

        b&#39;pm1: OK, pm2: OK\n&#39;&#39;

    After processing, the function returns a dictionary with the following tpw entries:

    * &#34;pm1&#34;: power status of channel 1
    * &#34;pm2&#34;: power status of channel 2

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the power status of channel 1 and 2. If the response can not
        be processed,  a Failure object will be returned.
    &#34;&#34;&#34;

    if not isinstance(response, bytes):

        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        _, pm1, _, pm2 = re.split(&#39;, |: &#39;, response)

    except ValueError as exc:

        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE read command: {response=}&#34;, exc)

    return {
        &#34;pm1&#34;: pm1,
        &#34;pm2&#34;: pm2
    }


def decode_read_command(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Decode the response from the OGSE &#39;read&#39; command.

    The command will return a bytes object of the following format:

        b&#39;pm1: -2.323670e-14 W +21.6 \xc2\xbaC, pm2: +2.143803e-07 W +22.7 \xc2\xbaC\n&#39;

    After processing, the function returns a dictionary with the following four entries:

    * &#34;power1&#34;: power measure for power meter 1 in Watt
    * &#34;temp1&#34;: temperature of the power meter 1 in degrees Celsius
    * &#34;power2&#34;: power measure for power meter 2 in Watt
    * &#34;temp2&#34;: temperature of the power meter 2 in degrees Celsius

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the power and temperature values as floats. If the response can not
        be processed,  a Failure object will be returned.
    &#34;&#34;&#34;

    # This function cannot raise exceptions, but should return a proper Failure method.
    # The reason for this is that the result of this function will be returned to the Proxy object
    # that issued the command.

    if not isinstance(response, bytes):

        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        _, power1, _, temp1, _, _, power2, _, temp2, _ = response.split()
    except ValueError as exc:
        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE read command: {response=}&#34;, exc)

    power1 = _convert_to_float(power1)
    temp1 = _convert_to_float(temp1)
    power2 = _convert_to_float(power2)
    temp2 = _convert_to_float(temp2)

    return {
        &#34;power1&#34;: power1,
        &#34;temp1&#34;: temp1,
        &#34;power2&#34;: power2,
        &#34;temp2&#34;: temp2
    }


def decode_status_command(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Decode the response from the OGSE &#39;status&#39; command.

    The command will return a bytes object of the following format:

        b&#39;power: OFF, lamp: OFF, interlock: OFF, psu: OFF, att: 0E-9 #0, power-ch1: +3.185751e-11 W,
         power-ch2: +2.068336e-07 W, temp-ch1: +21.5 \xc2\xbaC, temp-ch2: +22.6 \xc2\xbaC\n&#39;

    In the case the attenuator is still moving, an asterisk &#39;*&#39; will appear after &#39;att:&#39; as in:

        b&#39;power: OFF, lamp: OFF, interlock: OFF, psu: OFF, att: * 280E-3 #39,
          power-ch1: -6.378473e-11 W, power-ch2: +2.190483e-07 W,
          temp-ch1: +21.5 \xc2\xbaC, temp-ch2: +22.6 \xc2\xbaC\n&#39;

    After processing, the function returns a dictionary with the following eleven (11) values:

    * &#39;power&#39;: The status of the power
    * &#39;lamp&#39;: The status of the lamp
    * &#39;interlock&#39;: The status of the interlock
    * &#39;psu&#39;: The status of the PSU
    * &#39;att_moving&#39;:The status of the attenuator: True=Moving, False=Not Moving
    * &#39;att_factor&#39;: The attenuation factor as a float
    * &#39;att_index&#39;: The attenuation index as an int
    * &#39;power1&#39;: The power measure for power meter 1 in Watt
    * &#39;temp1&#39;: The temperature of the power meter 1 in degrees Celsius
    * &#39;power2&#39;: The power measure for power meter 2 in Watt
    * &#39;temp2&#39;: The temperature of the power meter 2 in degrees Celsius

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the status and measures of most important parameters (see above).
        If the response can not be processed, a Failure object will be returned.

    &#34;&#34;&#34;

    # This function cannot raise exceptions, but should return a proper Failure method.
    # The reason for this is that the result of this function will be returned to the Proxy object
    # that issued the command.

    if not isinstance(response, bytes):
        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        if &#39;*&#39; in response:
            (_, power_status, _, lamp_status, _, interlock_status, _, psu_status,
             _, att_moving, att_factor, att_index, _, power1, _, _, power2, _,
             _, temp1, _, _, temp2, _) = response.split()
            att_moving = True
        else:
            (_, power_status, _, lamp_status, _, interlock_status, _, psu_status,
             _, att_factor, att_index, _, power1, _, _, power2, _,
             _, temp1, _, _, temp2, _) = response.split()
            att_moving = False
    except ValueError as exc:
        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE status command: {response=}&#34;, exc)

    # cut off the trailing comma

    power_status, lamp_status, interlock_status, psu_status = [
        x[:-1] for x in (power_status, lamp_status, interlock_status, psu_status)]

    att_factor = _convert_to_float(att_factor)
    att_index = int(att_index[1:-1])  # cut off the leading &#39;#&#39; and the trailing &#39;,&#39;
    power1 = _convert_to_float(power1)
    temp1 = _convert_to_float(temp1)
    power2 = _convert_to_float(power2)
    temp2 = _convert_to_float(temp2)

    return {
        &#34;power&#34;: power_status,
        &#34;lamp&#34;: lamp_status,
        &#34;interlock&#34;: interlock_status,
        &#34;psu&#34;: psu_status,
        &#34;att_moving&#34;: att_moving,
        &#34;att_factor&#34;: att_factor,
        &#34;att_index&#34;: att_index,
        &#34;power1&#34;: power1,
        &#34;temp1&#34;: temp1,
        &#34;power2&#34;: power2,
        &#34;temp2&#34;: temp2
    }


def decode_att_get_level_command(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Decode the response from the OGSE &#39;level&#39; command.

    The command will return a bytes object of the following format:

        b&#39;att-level:        1E+0  #46\n&#39;
        b&#39;att-level: *      1E+0  #46\n&#39;

    After processing, the function returns a tuple with the following eleven (11) values:

    * The status of the attenuator: True=Moving, False=Not Moving
    * The attenuation factor as a float
    * The attenuation index as an int

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the moving status of the attenuator, the level (factor)
        and the index. If the response can not be processed, a Failure object will be returned.

    &#34;&#34;&#34;

    # This function cannot raise exceptions, but should return a proper Failure method.
    # The reason for this is that the result of this function will be returned to the Proxy object
    # that issued the command.

    if not isinstance(response, bytes):
        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        if &#39;*&#39; in response:
            _, att_moving, att_factor, att_index = response.split()
            att_moving = True
        else:
            _, att_factor, att_index = response.split()
            att_moving = False
    except ValueError as exc:
        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE level command: {response=}&#34;, exc)

    try:
        att_factor = _convert_to_float(att_factor)
        att_index = int(att_index[1:])  # cut off the leading &#39;#&#39;
    except Exception as exc:
        logger.error(f&#34;Exception caught: {exc=}&#34;)
        return Failure(f&#34;Exception caught when converting values from &#34;
                       f&#34;the OGSE level command: {response=}&#34;, exc)

    return {
        &#34;att_moving&#34;: att_moving,
        &#34;att_factor&#34;: att_factor,
        &#34;att_index&#34;: att_index
    }


class OnOffSwitch(str, Enum):
    on = &#34;on&#34;
    off = &#34;off&#34;


class OGSECommand(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\n&#34;


class OGSEInterface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Controller, Simulator and Proxy classes for this device.
    &#34;&#34;&#34;

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;version&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def version(self) -&gt; str:
        &#34;&#34;&#34;Returns version information about the OGSE hardware controller.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;quit&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def quit(self):
        &#34;&#34;&#34;Disconnects client from the server.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;exit&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def exit(self):
        &#34;&#34;&#34;Disconnects client from the server.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;ldls status&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def ldls_status(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the state of the connection to the LDLS device. The returned value is &#39;OK&#39;
        when the LDLS device is initialised and ready, &#39;ERROR&#39; when the device failed to
        initialise.

        Returns:
            &#39;ldls: OK&#39; or &#39;ldls: ERROR&#39;
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;pm status&#34;, process_cmd_string=add_lf,
                     process_response=decode_pm_status_response)
    def pm_status(self) -&gt; dict:
        &#34;&#34;&#34;
        Returns the state of the connection to the power-meter devices. The returned value is &#39;OK&#39;
        when the power-meter device is initialised and ready, &#39;ERROR&#39; when the device failed to
        initialise.

        Returns:
            A dictionary with keys: &#39;pm1&#39;, &#39;pm2&#39; and values &#39;OK&#39; or &#39;ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;att status&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_status(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the state of the connection to attenuator device. The returned value contains &#39;OK&#39;
        when the attenuator device is initialised and ready, &#39;ERROR&#39; when the device failed to
        initialise.

        Returns:
            A string containing &#39;OK&#39; or &#39;ERROR&#39;, i.e. &#39;att: OK&#39; or &#39;att: ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get interlock&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_interlock(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the interlock.

        Returns:
            A string containg &#39;OPEN&#39; or &#39;CLOSE&#39;, i.e. &#39;interlock: OPEN&#39; or &#39;interlock: CLOSE&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get power&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_power(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the power supply. Returns &#39;power: ON&#39; or &#39;power: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get lamp&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_lamp(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the lamp.  Returns &#39;lamp: ON&#39; or &#39;lamp: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get laser&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_laser(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the laser.  Returns &#39;laser: ON&#39; or &#39;laser: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get lamp-fault&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_lamp_fault(self) -&gt; str:
        &#34;&#34;&#34;
        Returns if there was an error with the lamp.
        Returned value is &#39;lamp-fault: ERROR&#39; or &#39;lamp-fault: NO-ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get controller-fault&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_controller_fault(self) -&gt; str:
        &#34;&#34;&#34;
        Returns if there was an error with the controller.
        The returned value is &#39;controller-fault: ERROR&#39; or &#39;controller-fault: NO-ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get psu&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_psu(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the power supply unit.  Returns &#39;psu: ON&#39; or &#39;psu: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get operate&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_operate(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the laser (operate).  Returns &#39;operate: ON&#39; or &#39;operate: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get flags&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_flags(self) -&gt; str:
        &#34;&#34;&#34;
        Get the state of all parameters encoded in a single number formatted in hexadecimal
        and binary. The bit order from msb to lsb is:

        * bit 0 - interlock
        * bit 1 - power
        * bit 2 - lamp
        * bit 3 - laser
        * bit 4 - lamp-fault
        * bit 5 - controller-fault
        * bit 6 - psu
        * bit 7 - operate

        Returns:
            flags: 0xhh bbbb bbbb.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;read&#34;, process_cmd_string=add_lf,
                     process_response=decode_read_command)
    def get_power_and_temperature(self) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Gets a power and temperature reading of both power-meters. Units are in Watt and degrees
        Celsius.

        Returns:
            A dictionary containing the power and temperature values as floats. If the response
            can not be processed, a Failure object will be returned.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;status&#34;, process_cmd_string=add_lf,
                     process_response=decode_status_command)
    def status(self) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Gets a global view of various relevant parameters. Returns a comma separated with the
        current value of 9 parameters. Optionally, the attenuation shows an asterisk &#39;*&#39; when
        the wheels are moving.

        Returns:
            power: &lt;flag&gt;, lamp: &lt;flag&gt;, interlock: &lt;flag&gt;, psu: &lt;flag&gt;, att: [*] &lt;level&gt; #index,
            power-ch1: &lt;value&gt; W, power-ch2: &lt;value&gt; W, temp-ch1: &lt;value&gt; ºC, temp-ch2: &lt;value&gt; ºC.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;level&#34;, process_cmd_string=add_lf,
                     process_response=decode_att_get_level_command)
    def att_get_level(self) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Returns a dictionary with the following keys: att_moving [bool], att_factor [float],
        and att_index [int].  In case of an error a Failure object will be returned.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level ${factor}&#34;,
                     process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_set_level_factor(self, factor: int | float) -&gt; str:
        &#34;&#34;&#34;
        Sets attenuator to the level closest to &lt;factor&gt;. There are 47 levels of attenuation
        available, from 0 to 1.
        This command chooses the level closest to the requested value.

        Args:
            factor (float): value between 0.0 and 1.0, where 0.0 is opaque and 1.0 is transparant.

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level #${index}&#34;,
                     process_cmd_string=check_cmd_att_index,
                     process_response=decode_response)
    def att_set_level_index(self, index: int) -&gt; str:
        &#34;&#34;&#34;
        Sets attenuator to the level closest to &lt;index&gt;. There are 47 levels of attenuation
        available, from 0 to 46. This command chooses the level closest to the requested value.

        Args:
            index (int): value between 0-46 (inclusive).

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level ${pos1} ${pos2}&#34;,
                     process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_set_level_position(self, pos1: int, pos2: int) -&gt; str:
        &#34;&#34;&#34;
        Sets the two filter wheels to the given values (pos1 and pos2 must be between 1 and 8).

        Args:
            pos1: the requested position for wheel 1
            pos2: the requested position for wheel 2

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level up&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_level_up(self) -&gt; str:
        &#34;&#34;&#34;
        Selects the attenuation one step higher than the current value.
        It has no effect if the current level is already the highest value allowed.

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level down&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_level_down(self) -&gt; str:
        &#34;&#34;&#34;
        Selects the attenuation one step lower than the current value.
        It has no effect if the current level is already the lowest value allowed.

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;power on&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def power_on(self) -&gt; str:
        &#34;&#34;&#34;Turns the power supply on, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;power off&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def power_off(self) -&gt; str:
        &#34;&#34;&#34;Turns the power supply off, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;operate on&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def operate_on(self) -&gt; str:
        &#34;&#34;&#34;Turns the laser on, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;operate off&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def operate_off(self) -&gt; str:
        &#34;&#34;&#34;Turns the laser off, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;reset&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def reset(self) -&gt; str:
        &#34;&#34;&#34;Performs a ‘reset’ cycle. This is sometimes needed to take LDLS out of a locked state.
        Returns &#39;OK&#39; or &#39;ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError


class OGSEController(OGSEInterface, DynamicCommandMixin):
    &#34;&#34;&#34;
    This is the class that talks directly to the OGSE device. It opens a TCP/IP socket
    connection with the OGSE Hardware Controller and sends commands to the device.
    &#34;&#34;&#34;

    def __init__(self, hostname=OGSE_SETTINGS.HOSTNAME, port=OGSE_SETTINGS.PORT):
        &#34;&#34;&#34;
        Args:
            hostname (str): the IP address or fully qualified hostname of the OGSE hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the `settings.yaml`
                configuration file.
        &#34;&#34;&#34;

        super().__init__()

        logger.debug(f&#34;Initializing OGSEController with hostname={hostname} on port={port}&#34;)

        self.transport = self.ogse = OGSEEthernetInterface(hostname, port)

    def connect(self):
        self.transport.connect()
        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        self.transport.disconnect()
        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        self.transport.reconnect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the OGSE Controller is connected. &#34;&#34;&#34;
        return self.transport.is_connected()

    def is_simulator(self):
        return &#34;sim&#34; in self.version()


ATT_LEVELS_BY_WHEEL = {
    (1, 1):      1E+0,
    (1, 2):      0E-9,
    (1, 3):    600E-3,
    (1, 4):    350E-3,
    (1, 5):    250E-3,
    (1, 6):     90E-3,
    (1, 7):    7.5E-3,
    (1, 8):    900E-6,
    (2, 1):      0E-9,
    (2, 2):      0E-9,
    (2, 3):      0E-9,
    (2, 4):      0E-9,
    (2, 5):      0E-9,
    (2, 6):      0E-9,
    (2, 7):      0E-9,
    (2, 8):      0E-9,
    (3, 1):    800E-3,
    (3, 2):      0E-9,
    (3, 3):    480E-3,
    (3, 4):    280E-3,
    (3, 5):    200E-3,
    (3, 6):     72E-3,
    (3, 7):      6E-3,
    (3, 8):    720E-6,
    (4, 1):    550E-3,
    (4, 2):      0E-9,
    (4, 3):    330E-3,
    (4, 4):  192.5E-3,
    (4, 5):  137.5E-3,
    (4, 6):   49.5E-3,
    (4, 7):  4.125E-3,
    (4, 8):    495E-6,
    (5, 1):    260E-3,
    (5, 2):      0E-9,
    (5, 3):    156E-3,
    (5, 4):     91E-3,
    (5, 5):     65E-3,
    (5, 6):   23.4E-3,
    (5, 7):   1.95E-3,
    (5, 8):    234E-6,
    (6, 1):     90E-3,
    (6, 2):      0E-9,
    (6, 3):     54E-3,
    (6, 4):   31.5E-3,
    (6, 5):   22.5E-3,
    (6, 6):    8.1E-3,
    (6, 7):    675E-6,
    (6, 8):     81E-6,
    (7, 1):     25E-3,
    (7, 2):      0E-9,
    (7, 3):     15E-3,
    (7, 4):   8.75E-3,
    (7, 5):   6.25E-3,
    (7, 6):   2.25E-3,
    (7, 7):  187.5E-6,
    (7, 8):   22.5E-6,
    (8, 1):    900E-6,
    (8, 2):      0E-9,
    (8, 3):    540E-6,
    (8, 4):    315E-6,
    (8, 5):    225E-6,
    (8, 6):     81E-6,
    (8, 7):   6.75E-6,
    (8, 8):    810E-9,
}

ATT_LEVELS_BY_FACTOR = {
     0:     0.0,
     1: 8.10E-7,
     2: 6.75E-6,
     3: 2.25E-5,
     4: 8.10E-5,
     5: 1.88E-4,
     6: 2.25E-4,
     7: 2.34E-4,
     8: 3.15E-4,
     9: 4.95E-4,
    10: 5.40E-4,
    11: 6.75E-4,
    12: 7.20E-4,
    13: 9.00E-4,
    14: 1.95E-3,
    15: 2.25E-3,
    16: 4.13E-3,
    17: 6.00E-3,
    18: 6.25E-3,
    19: 7.50E-3,
    20: 8.10E-3,
    21: 8.75E-3,
    22: 1.50E-2,
    23: 2.25E-2,
    24: 2.34E-2,
    25: 2.50E-2,
    26: 3.15E-2,
    27: 4.95E-2,
    28: 5.40E-2,
    29: 6.50E-2,
    30: 7.20E-2,
    31: 9.00E-2,
    32: 9.10E-2,
    33: 1.38E-1,
    34: 1.56E-1,
    35: 1.93E-1,
    36: 2.00E-1,
    37: 2.50E-1,
    38: 2.60E-1,
    39: 2.80E-1,
    40: 3.30E-1,
    41: 3.50E-1,
    42: 4.80E-1,
    43: 5.50E-1,
    44: 6.00E-1,
    45: 8.00E-1,
    46: 1.0,
}


def get_attenuation_index(attenuation_level: float):
    &#34;&#34;&#34;
    Determine the attenuation index corresponding to the given transmittance.

    Args:
        attenuation level: Transmittance.

    Returns:
        Attenuation index corresponding to the given transmittance.
    &#34;&#34;&#34;
    attenuation_levels = np.array([level for level in ATT_LEVELS_BY_FACTOR.values()])

    return np.abs(attenuation_levels - attenuation_level).argmin()


class OGSESimulator(OGSEInterface):

    def __init__(self):

        super().__init__()

        self._lamp = False
        self._laser = False
        self._psu = False
        self._interlock = False
        self._operate = False
        self._power = False
        self._att_level = 1.0
        self._att_index = 46
        self._att_position_1 = 1
        self._att_position_2 = 1
        self._connected = False

    def is_simulator(self) -&gt; bool:
        return True

    def connect(self):
        self._connected = True

    def disconnect(self):
        self._connected = False

    def reconnect(self):
        self._connected = True

    def is_connected(self) -&gt; bool:
        return self._connected

    def version(self):
        return &#34;PLATO-RT-OGSE (v2.1)&#34;

    def get_flags(self):

        return &#34;flags: 0x00  0000 0000&#34;

    def get_interlock(self):

        return &#34;interlock: OPEN&#34; if self._interlock else &#34;interlock: CLOSED&#34;

    def get_power(self):

        return &#34;power: ON&#34; if self._power else &#34;power: OFF&#34;

    def get_lamp(self):

        return &#34;lamp: ON&#34; if self._lamp else &#34;lamp: OFF&#34;

    def get_laser(self):

        return &#34;laser: ON&#34; if self._laser else &#34;laser: OFF&#34;

    def quit(self):
        pass

    def exit(self):
        pass

    def ldls_status(self):

        return &#34;ldls: OK&#34;

    def get_lamp_fault(self):

        return &#34;lamp-fault: NO-ERROR&#34;

    def get_controller_fault(self):

        return &#34;controller-fault: NO-ERROR&#34;

    def get_psu(self):

        return &#34;psu: ON&#34; if self._psu else &#34;psu: OFF&#34;

    def get_operate(self):

        return &#34;operate: ON&#34; if self._operate else &#34;operate: OFF&#34;

    def att_status(self):

        return &#34;att: OK&#34;

    def att_get_level(self):

        return {
            &#34;att_moving&#34;: False,
            &#34;att_factor&#34;: self._att_level,
            &#34;att_index&#34;: self._att_index
        }

    def att_set_level_factor(self, factor):

        if 0 &lt;= factor &lt;= 1:

            self._att_level = factor
            self._att_index = get_attenuation_index(factor)

            time.sleep(random.random() * 3 + 6)  # wait between 6.0 and 9.0 seconds

            return &#34;OK&#34;

        else:

            return &#34;ERROR: usage: attenuator level &lt;value&gt;  -- value must be in [0,1]&#34;

    def att_set_level_position(self, level1, level2):

        if 1 &lt;= level1 &lt;= 8 and 1 &lt;= level2 &lt;= 8:

            self._att_position_1 = level1
            self._att_position_2 = level2

            self._att_level = ATT_LEVELS_BY_WHEEL[(level1, level2)]
            self._att_index = get_attenuation_index(self._att_level)

            time.sleep(random.random() * 3 + 6)  # wait between 6.0 and 9.0 seconds

            return &#34;OK&#34;

        else:

            return (
                &#34;ERROR: usage: attenuator level &lt;wheel_1&gt; &lt;wheel_2&gt;  -- &#34; 
                &#34;wheel positions must be integer = 1..8&#34;
            )

    def att_level_up(self):

        self.att_set_level_index(min(self._att_index + 1, len(ATT_LEVELS_BY_FACTOR) - 1))

        return &#34;OK&#34;

    def att_level_down(self):

        self.att_set_level_index(max(self._att_index - 1, 0))

        return &#34;OK&#34;

    def pm_status(self):

        return {
            &#34;pm1&#34;: &#34;OK&#34;,
            &#34;pm2&#34;: &#34;OK&#34;
        }

    def get_power_and_temperature(self):

        return {
            &#34;power1&#34;: 6.376149e-11,
            &#34;temp1&#34;: 21.3,
            &#34;power2&#34;: 1.484441e-07,
            &#34;temp2&#34;: 21.3
        }

    def status(self):

        power_and_temp = self.get_power_and_temperature()
        _, att_level, att_index = self.att_get_level()

        # return self.get_power(), self.get_lamp(), self.get_interlock(), self.get_psu(), \
        #     f&#34;att: {att_level} #{att_index}&#34;,  f&#34;power-ch1: {power_ch1} W&#34;, f&#34;temp-ch1: {temp_ch1} °C&#34;, \
        #     f&#34;power-ch2: {power_ch2} W&#34;, f&#34;temp-ch2: {temp_ch2} °C&#34;,
        #
        status = {
            &#34;power&#34;: &#34;ON&#34; if self._power else &#34;OFF&#34;,
            &#34;lamp&#34;: &#34;ON&#34; if self._lamp else &#34;OFF&#34;,
            &#34;interlock&#34;: &#34;ON&#34; if self._interlock else &#34;OFF&#34;,
            &#34;psu&#34;: &#34;ON&#34; if self._psu else &#34;OFF&#34;,
            &#34;att_moving&#34;: False,
            &#34;att_factor&#34;: self._att_level,
            &#34;att_index&#34;: self._att_index
        }

        status.update(power_and_temp)

        return status

    def att_set_level_index(self, index: int):

        if 0 &lt;= factor &lt; len(ATT_LEVELS_BY_FACTOR):

            self._att_index = index
            self._att_level = ATT_LEVELS_BY_FACTOR[index][0]

            time.sleep(random.random() * 3 + 6)  # wait between 6.0 and 9.0 seconds

            return &#34;OK&#34;

        else:

            return &#34;ERROR: usage: attenuator level #index  -- index goes from 0 to 47&#34;

    def power_on(self):

        self._power = True

        return &#34;OK&#34;

    def power_off(self):

        self._power = False

        return &#34;OK&#34;

    def operate_on(self):

        self._operate = True

        return &#34;OK&#34;

    def operate_off(self):

        self._operate = True

        return &#34;OK&#34;

    def reset(self):
        pass


REQUEST_TIMEOUT = 10_000  # setting the attenuator can take up to 10 seconds


class OGSEProxy(DynamicProxy, OGSEInterface):
    &#34;&#34;&#34;
    The OGSEProxy class is used to connect to the OGSE control server and send commands
    to the OGSE Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
            self,
            protocol=CTRL_SETTINGS.PROTOCOL,
            hostname=CTRL_SETTINGS.HOSTNAME,
            port=CTRL_SETTINGS.COMMANDING_PORT,
            timeout=REQUEST_TIMEOUT
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol
                [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
            timeout: time out on the response from the control server [milliseconds]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)


# commands = load_commands(CommandProtocol, COMMAND_SETTINGS.Commands, OGSECommand, OGSEController)


if __name__ == &#34;__main__&#34;:
    import logging

    logging.basicConfig(level=20)

    from egse.collimator.fcul.ogse import OGSEController

    ogse = OGSEController()
    ogse.connect()

    print(ogse.version())
    print(ogse.status())

    print(&#34;att level: &#34;, ogse.att_get_level())

    for factor in 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0:
        print(format_datetime(), end=&#34; &#34;)
        print(f&#34;set att level: {factor:10e}&#34;, end=&#34; &#34;)
        print(ogse.att_set_level_factor(factor), end=&#34; &#34;)
        print(ogse.att_get_level())

    for factor in 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0:
        print(format_datetime(), end=&#34; &#34;)
        print(f&#34;set att level: {factor:10e}&#34;, end=&#34; &#34;)
        print(ogse.att_set_level_factor(factor), end=&#34; &#34;)
        print(ogse.att_get_level())

    ogse.disconnect()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.collimator.fcul.ogse.check_cmd_att_index"><code class="name flex">
<span>def <span class="ident">check_cmd_att_index</span></span>(<span>cmd_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the 'level #<index>' command has a correct index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cmd_att_index(cmd_string: str):
    &#34;&#34;&#34;Check if the &#39;level #&lt;index&gt;&#39; command has a correct index.&#34;&#34;&#34;

    # index is expected to be in the range [0-46] (inclusive)

    index = int(cmd_string.split()[-1][1:])

    if not (0 &lt;= index &lt;= 46):
        raise CommandError(&#34;ERROR: usage: attenuator level #index  -- index goes from 0 to 46&#34;)

    return add_lf(cmd_string)</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.decode_att_get_level_command"><code class="name flex">
<span>def <span class="ident">decode_att_get_level_command</span></span>(<span>response: bytes) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the response from the OGSE 'level' command.</p>
<pre><code>The command will return a bytes object of the following format:

    b'att-level:        1E+0  #46
</code></pre>
<p>'
b'att-level: *
1E+0
#46
'</p>
<pre><code>After processing, the function returns a tuple with the following eleven (11) values:

* The status of the attenuator: True=Moving, False=Not Moving
* The attenuation factor as a float
* The attenuation index as an int

Args:
    response: the unprocessed response from the device.

Returns:
    A dictionary containing the moving status of the attenuator, the level (factor)
    and the index. If the response can not be processed, a Failure object will be returned.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_att_get_level_command(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Decode the response from the OGSE &#39;level&#39; command.

    The command will return a bytes object of the following format:

        b&#39;att-level:        1E+0  #46\n&#39;
        b&#39;att-level: *      1E+0  #46\n&#39;

    After processing, the function returns a tuple with the following eleven (11) values:

    * The status of the attenuator: True=Moving, False=Not Moving
    * The attenuation factor as a float
    * The attenuation index as an int

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the moving status of the attenuator, the level (factor)
        and the index. If the response can not be processed, a Failure object will be returned.

    &#34;&#34;&#34;

    # This function cannot raise exceptions, but should return a proper Failure method.
    # The reason for this is that the result of this function will be returned to the Proxy object
    # that issued the command.

    if not isinstance(response, bytes):
        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        if &#39;*&#39; in response:
            _, att_moving, att_factor, att_index = response.split()
            att_moving = True
        else:
            _, att_factor, att_index = response.split()
            att_moving = False
    except ValueError as exc:
        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE level command: {response=}&#34;, exc)

    try:
        att_factor = _convert_to_float(att_factor)
        att_index = int(att_index[1:])  # cut off the leading &#39;#&#39;
    except Exception as exc:
        logger.error(f&#34;Exception caught: {exc=}&#34;)
        return Failure(f&#34;Exception caught when converting values from &#34;
                       f&#34;the OGSE level command: {response=}&#34;, exc)

    return {
        &#34;att_moving&#34;: att_moving,
        &#34;att_factor&#34;: att_factor,
        &#34;att_index&#34;: att_index
    }</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.decode_pm_status_response"><code class="name flex">
<span>def <span class="ident">decode_pm_status_response</span></span>(<span>response: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the response from the OGSE 'pm status' command.</p>
<pre><code>The command will return a bytes object of the following format:

    b'pm1: OK, pm2: OK
</code></pre>
<p>''</p>
<pre><code>After processing, the function returns a dictionary with the following tpw entries:

* "pm1": power status of channel 1
* "pm2": power status of channel 2

Args:
    response: the unprocessed response from the device.

Returns:
    A dictionary containing the power status of channel 1 and 2. If the response can not
    be processed,  a Failure object will be returned.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_pm_status_response(response: bytes):
    &#34;&#34;&#34; Decode the response from the OGSE &#39;pm status&#39; command.

    The command will return a bytes object of the following format:

        b&#39;pm1: OK, pm2: OK\n&#39;&#39;

    After processing, the function returns a dictionary with the following tpw entries:

    * &#34;pm1&#34;: power status of channel 1
    * &#34;pm2&#34;: power status of channel 2

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the power status of channel 1 and 2. If the response can not
        be processed,  a Failure object will be returned.
    &#34;&#34;&#34;

    if not isinstance(response, bytes):

        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        _, pm1, _, pm2 = re.split(&#39;, |: &#39;, response)

    except ValueError as exc:

        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE read command: {response=}&#34;, exc)

    return {
        &#34;pm1&#34;: pm1,
        &#34;pm2&#34;: pm2
    }</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.decode_read_command"><code class="name flex">
<span>def <span class="ident">decode_read_command</span></span>(<span>response: bytes) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the response from the OGSE 'read' command.</p>
<pre><code>The command will return a bytes object of the following format:

    b'pm1: -2.323670e-14 W +21.6 ÂºC, pm2: +2.143803e-07 W +22.7 ÂºC
</code></pre>
<p>'</p>
<pre><code>After processing, the function returns a dictionary with the following four entries:

* "power1": power measure for power meter 1 in Watt
* "temp1": temperature of the power meter 1 in degrees Celsius
* "power2": power measure for power meter 2 in Watt
* "temp2": temperature of the power meter 2 in degrees Celsius

Args:
    response: the unprocessed response from the device.

Returns:
    A dictionary containing the power and temperature values as floats. If the response can not
    be processed,  a Failure object will be returned.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_read_command(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Decode the response from the OGSE &#39;read&#39; command.

    The command will return a bytes object of the following format:

        b&#39;pm1: -2.323670e-14 W +21.6 \xc2\xbaC, pm2: +2.143803e-07 W +22.7 \xc2\xbaC\n&#39;

    After processing, the function returns a dictionary with the following four entries:

    * &#34;power1&#34;: power measure for power meter 1 in Watt
    * &#34;temp1&#34;: temperature of the power meter 1 in degrees Celsius
    * &#34;power2&#34;: power measure for power meter 2 in Watt
    * &#34;temp2&#34;: temperature of the power meter 2 in degrees Celsius

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the power and temperature values as floats. If the response can not
        be processed,  a Failure object will be returned.
    &#34;&#34;&#34;

    # This function cannot raise exceptions, but should return a proper Failure method.
    # The reason for this is that the result of this function will be returned to the Proxy object
    # that issued the command.

    if not isinstance(response, bytes):

        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        _, power1, _, temp1, _, _, power2, _, temp2, _ = response.split()
    except ValueError as exc:
        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE read command: {response=}&#34;, exc)

    power1 = _convert_to_float(power1)
    temp1 = _convert_to_float(temp1)
    power2 = _convert_to_float(power2)
    temp2 = _convert_to_float(temp2)

    return {
        &#34;power1&#34;: power1,
        &#34;temp1&#34;: temp1,
        &#34;power2&#34;: power2,
        &#34;temp2&#34;: temp2
    }</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.decode_response"><code class="name flex">
<span>def <span class="ident">decode_response</span></span>(<span>response: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the bytes object and strips off the newline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_response(response: bytes) -&gt; str:
    &#34;&#34;&#34;Decodes the bytes object and strips off the newline.&#34;&#34;&#34;
    return response.decode().rstrip()</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.decode_status_command"><code class="name flex">
<span>def <span class="ident">decode_status_command</span></span>(<span>response: bytes) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the response from the OGSE 'status' command.</p>
<pre><code>The command will return a bytes object of the following format:

    b'power: OFF, lamp: OFF, interlock: OFF, psu: OFF, att: 0E-9 #0, power-ch1: +3.185751e-11 W,
     power-ch2: +2.068336e-07 W, temp-ch1: +21.5 ÂºC, temp-ch2: +22.6 ÂºC
</code></pre>
<p>'</p>
<pre><code>In the case the attenuator is still moving, an asterisk '*' will appear after 'att:' as in:

    b'power: OFF, lamp: OFF, interlock: OFF, psu: OFF, att: * 280E-3 #39,
      power-ch1: -6.378473e-11 W, power-ch2: +2.190483e-07 W,
      temp-ch1: +21.5 ÂºC, temp-ch2: +22.6 ÂºC
</code></pre>
<p>'</p>
<pre><code>After processing, the function returns a dictionary with the following eleven (11) values:

* 'power': The status of the power
* 'lamp': The status of the lamp
* 'interlock': The status of the interlock
* 'psu': The status of the PSU
* 'att_moving':The status of the attenuator: True=Moving, False=Not Moving
* 'att_factor': The attenuation factor as a float
* 'att_index': The attenuation index as an int
* 'power1': The power measure for power meter 1 in Watt
* 'temp1': The temperature of the power meter 1 in degrees Celsius
* 'power2': The power measure for power meter 2 in Watt
* 'temp2': The temperature of the power meter 2 in degrees Celsius

Args:
    response: the unprocessed response from the device.

Returns:
    A dictionary containing the status and measures of most important parameters (see above).
    If the response can not be processed, a Failure object will be returned.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_status_command(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Decode the response from the OGSE &#39;status&#39; command.

    The command will return a bytes object of the following format:

        b&#39;power: OFF, lamp: OFF, interlock: OFF, psu: OFF, att: 0E-9 #0, power-ch1: +3.185751e-11 W,
         power-ch2: +2.068336e-07 W, temp-ch1: +21.5 \xc2\xbaC, temp-ch2: +22.6 \xc2\xbaC\n&#39;

    In the case the attenuator is still moving, an asterisk &#39;*&#39; will appear after &#39;att:&#39; as in:

        b&#39;power: OFF, lamp: OFF, interlock: OFF, psu: OFF, att: * 280E-3 #39,
          power-ch1: -6.378473e-11 W, power-ch2: +2.190483e-07 W,
          temp-ch1: +21.5 \xc2\xbaC, temp-ch2: +22.6 \xc2\xbaC\n&#39;

    After processing, the function returns a dictionary with the following eleven (11) values:

    * &#39;power&#39;: The status of the power
    * &#39;lamp&#39;: The status of the lamp
    * &#39;interlock&#39;: The status of the interlock
    * &#39;psu&#39;: The status of the PSU
    * &#39;att_moving&#39;:The status of the attenuator: True=Moving, False=Not Moving
    * &#39;att_factor&#39;: The attenuation factor as a float
    * &#39;att_index&#39;: The attenuation index as an int
    * &#39;power1&#39;: The power measure for power meter 1 in Watt
    * &#39;temp1&#39;: The temperature of the power meter 1 in degrees Celsius
    * &#39;power2&#39;: The power measure for power meter 2 in Watt
    * &#39;temp2&#39;: The temperature of the power meter 2 in degrees Celsius

    Args:
        response: the unprocessed response from the device.

    Returns:
        A dictionary containing the status and measures of most important parameters (see above).
        If the response can not be processed, a Failure object will be returned.

    &#34;&#34;&#34;

    # This function cannot raise exceptions, but should return a proper Failure method.
    # The reason for this is that the result of this function will be returned to the Proxy object
    # that issued the command.

    if not isinstance(response, bytes):
        return Failure(f&#34;The given argument is not a bytes object as expected: {response=}&#34;)

    response = response.decode().rstrip()

    try:
        if &#39;*&#39; in response:
            (_, power_status, _, lamp_status, _, interlock_status, _, psu_status,
             _, att_moving, att_factor, att_index, _, power1, _, _, power2, _,
             _, temp1, _, _, temp2, _) = response.split()
            att_moving = True
        else:
            (_, power_status, _, lamp_status, _, interlock_status, _, psu_status,
             _, att_factor, att_index, _, power1, _, _, power2, _,
             _, temp1, _, _, temp2, _) = response.split()
            att_moving = False
    except ValueError as exc:
        logger.error(f&#34;ValueError caught: {exc}&#34;)
        return Failure(f&#34;Unexpected response from the OGSE status command: {response=}&#34;, exc)

    # cut off the trailing comma

    power_status, lamp_status, interlock_status, psu_status = [
        x[:-1] for x in (power_status, lamp_status, interlock_status, psu_status)]

    att_factor = _convert_to_float(att_factor)
    att_index = int(att_index[1:-1])  # cut off the leading &#39;#&#39; and the trailing &#39;,&#39;
    power1 = _convert_to_float(power1)
    temp1 = _convert_to_float(temp1)
    power2 = _convert_to_float(power2)
    temp2 = _convert_to_float(temp2)

    return {
        &#34;power&#34;: power_status,
        &#34;lamp&#34;: lamp_status,
        &#34;interlock&#34;: interlock_status,
        &#34;psu&#34;: psu_status,
        &#34;att_moving&#34;: att_moving,
        &#34;att_factor&#34;: att_factor,
        &#34;att_index&#34;: att_index,
        &#34;power1&#34;: power1,
        &#34;temp1&#34;: temp1,
        &#34;power2&#34;: power2,
        &#34;temp2&#34;: temp2
    }</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.get_attenuation_index"><code class="name flex">
<span>def <span class="ident">get_attenuation_index</span></span>(<span>attenuation_level: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the attenuation index corresponding to the given transmittance.</p>
<h2 id="args">Args</h2>
<p>attenuation level: Transmittance.</p>
<h2 id="returns">Returns</h2>
<p>Attenuation index corresponding to the given transmittance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attenuation_index(attenuation_level: float):
    &#34;&#34;&#34;
    Determine the attenuation index corresponding to the given transmittance.

    Args:
        attenuation level: Transmittance.

    Returns:
        Attenuation index corresponding to the given transmittance.
    &#34;&#34;&#34;
    attenuation_levels = np.array([level for level in ATT_LEVELS_BY_FACTOR.values()])

    return np.abs(attenuation_levels - attenuation_level).argmin()</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.is_ogse_cs_active"><code class="name flex">
<span>def <span class="ident">is_ogse_cs_active</span></span>(<span>timeout: float = 2.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the OGSE Control Server is running.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>Timeout when waiting for a reply [seconds, default=2.0]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the OGSE CS is running and replied with the expected answer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ogse_cs_active(timeout: float = 2.0):
    &#34;&#34;&#34;
    Checks whether the OGSE Control Server is running.

    Args:
        timeout (float): Timeout when waiting for a reply [seconds, default=2.0]

    Returns:
        True if the OGSE CS is running and replied with the expected answer.
    &#34;&#34;&#34;

    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )

    return is_control_server_active(endpoint, timeout)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.collimator.fcul.ogse.OGSECommand"><code class="flex name class">
<span>class <span class="ident">OGSECommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OGSECommand(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.collimator.fcul.ogse.OGSECommand.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    out = super().get_cmd_string(*args, **kwargs)
    return out + &#34;\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEController"><code class="flex name class">
<span>class <span class="ident">OGSEController</span></span>
<span>(</span><span>hostname='139.165.177.76', port=4181)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the class that talks directly to the OGSE device. It opens a TCP/IP socket
connection with the OGSE Hardware Controller and sends commands to the device.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the OGSE hardware
controller. The default is defined in the <code>settings.yaml</code> configuration file.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to, by default set in the <code>settings.yaml</code>
configuration file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OGSEController(OGSEInterface, DynamicCommandMixin):
    &#34;&#34;&#34;
    This is the class that talks directly to the OGSE device. It opens a TCP/IP socket
    connection with the OGSE Hardware Controller and sends commands to the device.
    &#34;&#34;&#34;

    def __init__(self, hostname=OGSE_SETTINGS.HOSTNAME, port=OGSE_SETTINGS.PORT):
        &#34;&#34;&#34;
        Args:
            hostname (str): the IP address or fully qualified hostname of the OGSE hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the `settings.yaml`
                configuration file.
        &#34;&#34;&#34;

        super().__init__()

        logger.debug(f&#34;Initializing OGSEController with hostname={hostname} on port={port}&#34;)

        self.transport = self.ogse = OGSEEthernetInterface(hostname, port)

    def connect(self):
        self.transport.connect()
        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        self.transport.disconnect()
        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        self.transport.reconnect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the OGSE Controller is connected. &#34;&#34;&#34;
        return self.transport.is_connected()

    def is_simulator(self):
        return &#34;sim&#34; in self.version()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
<li><a title="egse.mixin.DynamicCommandMixin" href="../../mixin.html#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.collimator.fcul.ogse.OGSEController.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the OGSE Controller is connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34;Check if the OGSE Controller is connected. &#34;&#34;&#34;
    return self.transport.is_connected()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_get_level" href="#egse.collimator.fcul.ogse.OGSEInterface.att_get_level">att_get_level</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_down" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_down">att_level_down</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_up" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_up">att_level_up</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor">att_set_level_factor</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index">att_set_level_index</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position">att_set_level_position</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_status" href="#egse.collimator.fcul.ogse.OGSEInterface.att_status">att_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.exit" href="#egse.collimator.fcul.ogse.OGSEInterface.exit">exit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault">get_controller_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_flags" href="#egse.collimator.fcul.ogse.OGSEInterface.get_flags">get_flags</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_interlock" href="#egse.collimator.fcul.ogse.OGSEInterface.get_interlock">get_interlock</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp">get_lamp</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault">get_lamp_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_laser" href="#egse.collimator.fcul.ogse.OGSEInterface.get_laser">get_laser</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_operate" href="#egse.collimator.fcul.ogse.OGSEInterface.get_operate">get_operate</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power">get_power</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature">get_power_and_temperature</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_psu" href="#egse.collimator.fcul.ogse.OGSEInterface.get_psu">get_psu</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.ldls_status" href="#egse.collimator.fcul.ogse.OGSEInterface.ldls_status">ldls_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_off" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_off">operate_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_on" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_on">operate_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.pm_status" href="#egse.collimator.fcul.ogse.OGSEInterface.pm_status">pm_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_off" href="#egse.collimator.fcul.ogse.OGSEInterface.power_off">power_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_on" href="#egse.collimator.fcul.ogse.OGSEInterface.power_on">power_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.quit" href="#egse.collimator.fcul.ogse.OGSEInterface.quit">quit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reset" href="#egse.collimator.fcul.ogse.OGSEInterface.reset">reset</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.status" href="#egse.collimator.fcul.ogse.OGSEInterface.status">status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.version" href="#egse.collimator.fcul.ogse.OGSEInterface.version">version</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.mixin.DynamicCommandMixin" href="../../mixin.html#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.mixin.DynamicCommandMixin.create_command_string" href="../../mixin.html#egse.mixin.DynamicCommandMixin.create_command_string">create_command_string</a></code></li>
<li><code><a title="egse.mixin.DynamicCommandMixin.handle_dynamic_command" href="../../mixin.html#egse.mixin.DynamicCommandMixin.handle_dynamic_command">handle_dynamic_command</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface"><code class="flex name class">
<span>class <span class="ident">OGSEInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Controller, Simulator and Proxy classes for this device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OGSEInterface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Controller, Simulator and Proxy classes for this device.
    &#34;&#34;&#34;

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;version&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def version(self) -&gt; str:
        &#34;&#34;&#34;Returns version information about the OGSE hardware controller.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;quit&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def quit(self):
        &#34;&#34;&#34;Disconnects client from the server.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;exit&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def exit(self):
        &#34;&#34;&#34;Disconnects client from the server.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;ldls status&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def ldls_status(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the state of the connection to the LDLS device. The returned value is &#39;OK&#39;
        when the LDLS device is initialised and ready, &#39;ERROR&#39; when the device failed to
        initialise.

        Returns:
            &#39;ldls: OK&#39; or &#39;ldls: ERROR&#39;
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;pm status&#34;, process_cmd_string=add_lf,
                     process_response=decode_pm_status_response)
    def pm_status(self) -&gt; dict:
        &#34;&#34;&#34;
        Returns the state of the connection to the power-meter devices. The returned value is &#39;OK&#39;
        when the power-meter device is initialised and ready, &#39;ERROR&#39; when the device failed to
        initialise.

        Returns:
            A dictionary with keys: &#39;pm1&#39;, &#39;pm2&#39; and values &#39;OK&#39; or &#39;ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;att status&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_status(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the state of the connection to attenuator device. The returned value contains &#39;OK&#39;
        when the attenuator device is initialised and ready, &#39;ERROR&#39; when the device failed to
        initialise.

        Returns:
            A string containing &#39;OK&#39; or &#39;ERROR&#39;, i.e. &#39;att: OK&#39; or &#39;att: ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get interlock&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_interlock(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the interlock.

        Returns:
            A string containg &#39;OPEN&#39; or &#39;CLOSE&#39;, i.e. &#39;interlock: OPEN&#39; or &#39;interlock: CLOSE&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get power&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_power(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the power supply. Returns &#39;power: ON&#39; or &#39;power: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get lamp&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_lamp(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the lamp.  Returns &#39;lamp: ON&#39; or &#39;lamp: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get laser&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_laser(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the laser.  Returns &#39;laser: ON&#39; or &#39;laser: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get lamp-fault&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_lamp_fault(self) -&gt; str:
        &#34;&#34;&#34;
        Returns if there was an error with the lamp.
        Returned value is &#39;lamp-fault: ERROR&#39; or &#39;lamp-fault: NO-ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get controller-fault&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_controller_fault(self) -&gt; str:
        &#34;&#34;&#34;
        Returns if there was an error with the controller.
        The returned value is &#39;controller-fault: ERROR&#39; or &#39;controller-fault: NO-ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get psu&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_psu(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the power supply unit.  Returns &#39;psu: ON&#39; or &#39;psu: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get operate&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_operate(self) -&gt; str:
        &#34;&#34;&#34;Get the state of the laser (operate).  Returns &#39;operate: ON&#39; or &#39;operate: OFF&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get flags&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def get_flags(self) -&gt; str:
        &#34;&#34;&#34;
        Get the state of all parameters encoded in a single number formatted in hexadecimal
        and binary. The bit order from msb to lsb is:

        * bit 0 - interlock
        * bit 1 - power
        * bit 2 - lamp
        * bit 3 - laser
        * bit 4 - lamp-fault
        * bit 5 - controller-fault
        * bit 6 - psu
        * bit 7 - operate

        Returns:
            flags: 0xhh bbbb bbbb.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;read&#34;, process_cmd_string=add_lf,
                     process_response=decode_read_command)
    def get_power_and_temperature(self) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Gets a power and temperature reading of both power-meters. Units are in Watt and degrees
        Celsius.

        Returns:
            A dictionary containing the power and temperature values as floats. If the response
            can not be processed, a Failure object will be returned.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;status&#34;, process_cmd_string=add_lf,
                     process_response=decode_status_command)
    def status(self) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Gets a global view of various relevant parameters. Returns a comma separated with the
        current value of 9 parameters. Optionally, the attenuation shows an asterisk &#39;*&#39; when
        the wheels are moving.

        Returns:
            power: &lt;flag&gt;, lamp: &lt;flag&gt;, interlock: &lt;flag&gt;, psu: &lt;flag&gt;, att: [*] &lt;level&gt; #index,
            power-ch1: &lt;value&gt; W, power-ch2: &lt;value&gt; W, temp-ch1: &lt;value&gt; ºC, temp-ch2: &lt;value&gt; ºC.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;level&#34;, process_cmd_string=add_lf,
                     process_response=decode_att_get_level_command)
    def att_get_level(self) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Returns a dictionary with the following keys: att_moving [bool], att_factor [float],
        and att_index [int].  In case of an error a Failure object will be returned.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level ${factor}&#34;,
                     process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_set_level_factor(self, factor: int | float) -&gt; str:
        &#34;&#34;&#34;
        Sets attenuator to the level closest to &lt;factor&gt;. There are 47 levels of attenuation
        available, from 0 to 1.
        This command chooses the level closest to the requested value.

        Args:
            factor (float): value between 0.0 and 1.0, where 0.0 is opaque and 1.0 is transparant.

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level #${index}&#34;,
                     process_cmd_string=check_cmd_att_index,
                     process_response=decode_response)
    def att_set_level_index(self, index: int) -&gt; str:
        &#34;&#34;&#34;
        Sets attenuator to the level closest to &lt;index&gt;. There are 47 levels of attenuation
        available, from 0 to 46. This command chooses the level closest to the requested value.

        Args:
            index (int): value between 0-46 (inclusive).

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level ${pos1} ${pos2}&#34;,
                     process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_set_level_position(self, pos1: int, pos2: int) -&gt; str:
        &#34;&#34;&#34;
        Sets the two filter wheels to the given values (pos1 and pos2 must be between 1 and 8).

        Args:
            pos1: the requested position for wheel 1
            pos2: the requested position for wheel 2

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level up&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_level_up(self) -&gt; str:
        &#34;&#34;&#34;
        Selects the attenuation one step higher than the current value.
        It has no effect if the current level is already the highest value allowed.

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level down&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def att_level_down(self) -&gt; str:
        &#34;&#34;&#34;
        Selects the attenuation one step lower than the current value.
        It has no effect if the current level is already the lowest value allowed.

        Returns:
            The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
            was accepted or the attenuator device is not ready.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;power on&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def power_on(self) -&gt; str:
        &#34;&#34;&#34;Turns the power supply on, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;power off&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def power_off(self) -&gt; str:
        &#34;&#34;&#34;Turns the power supply off, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;operate on&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def operate_on(self) -&gt; str:
        &#34;&#34;&#34;Turns the laser on, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;operate off&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def operate_off(self) -&gt; str:
        &#34;&#34;&#34;Turns the laser off, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;reset&#34;, process_cmd_string=add_lf,
                     process_response=decode_response)
    def reset(self) -&gt; str:
        &#34;&#34;&#34;Performs a ‘reset’ cycle. This is sometimes needed to take LDLS out of a locked state.
        Returns &#39;OK&#39; or &#39;ERROR&#39;.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.collimator.fcul.ogse.OGSEController" href="#egse.collimator.fcul.ogse.OGSEController">OGSEController</a></li>
<li><a title="egse.collimator.fcul.ogse.OGSEProxy" href="#egse.collimator.fcul.ogse.OGSEProxy">OGSEProxy</a></li>
<li><a title="egse.collimator.fcul.ogse.OGSESimulator" href="#egse.collimator.fcul.ogse.OGSESimulator">OGSESimulator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_get_level"><code class="name flex">
<span>def <span class="ident">att_get_level</span></span>(<span>self) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with the following keys: att_moving [bool], att_factor [float],
and att_index [int].
In case of an error a Failure object will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;level&#34;, process_cmd_string=add_lf,
                 process_response=decode_att_get_level_command)
def att_get_level(self) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Returns a dictionary with the following keys: att_moving [bool], att_factor [float],
    and att_index [int].  In case of an error a Failure object will be returned.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_level_down"><code class="name flex">
<span>def <span class="ident">att_level_down</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Selects the attenuation one step lower than the current value.
It has no effect if the current level is already the lowest value allowed.</p>
<h2 id="returns">Returns</h2>
<p>The string 'OK' or 'ERROR' depending whether the command
was accepted or the attenuator device is not ready.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level down&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def att_level_down(self) -&gt; str:
    &#34;&#34;&#34;
    Selects the attenuation one step lower than the current value.
    It has no effect if the current level is already the lowest value allowed.

    Returns:
        The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
        was accepted or the attenuator device is not ready.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_level_up"><code class="name flex">
<span>def <span class="ident">att_level_up</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Selects the attenuation one step higher than the current value.
It has no effect if the current level is already the highest value allowed.</p>
<h2 id="returns">Returns</h2>
<p>The string 'OK' or 'ERROR' depending whether the command
was accepted or the attenuator device is not ready.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level up&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def att_level_up(self) -&gt; str:
    &#34;&#34;&#34;
    Selects the attenuation one step higher than the current value.
    It has no effect if the current level is already the highest value allowed.

    Returns:
        The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
        was accepted or the attenuator device is not ready.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor"><code class="name flex">
<span>def <span class="ident">att_set_level_factor</span></span>(<span>self, factor: int | float) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sets attenuator to the level closest to <factor>. There are 47 levels of attenuation
available, from 0 to 1.
This command chooses the level closest to the requested value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>value between 0.0 and 1.0, where 0.0 is opaque and 1.0 is transparant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string 'OK' or 'ERROR' depending whether the command
was accepted or the attenuator device is not ready.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level ${factor}&#34;,
                 process_cmd_string=add_lf,
                 process_response=decode_response)
def att_set_level_factor(self, factor: int | float) -&gt; str:
    &#34;&#34;&#34;
    Sets attenuator to the level closest to &lt;factor&gt;. There are 47 levels of attenuation
    available, from 0 to 1.
    This command chooses the level closest to the requested value.

    Args:
        factor (float): value between 0.0 and 1.0, where 0.0 is opaque and 1.0 is transparant.

    Returns:
        The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
        was accepted or the attenuator device is not ready.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index"><code class="name flex">
<span>def <span class="ident">att_set_level_index</span></span>(<span>self, index: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sets attenuator to the level closest to <index>. There are 47 levels of attenuation
available, from 0 to 46. This command chooses the level closest to the requested value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>value between 0-46 (inclusive).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string 'OK' or 'ERROR' depending whether the command
was accepted or the attenuator device is not ready.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level #${index}&#34;,
                 process_cmd_string=check_cmd_att_index,
                 process_response=decode_response)
def att_set_level_index(self, index: int) -&gt; str:
    &#34;&#34;&#34;
    Sets attenuator to the level closest to &lt;index&gt;. There are 47 levels of attenuation
    available, from 0 to 46. This command chooses the level closest to the requested value.

    Args:
        index (int): value between 0-46 (inclusive).

    Returns:
        The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
        was accepted or the attenuator device is not ready.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position"><code class="name flex">
<span>def <span class="ident">att_set_level_position</span></span>(<span>self, pos1: int, pos2: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the two filter wheels to the given values (pos1 and pos2 must be between 1 and 8).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos1</code></strong></dt>
<dd>the requested position for wheel 1</dd>
<dt><strong><code>pos2</code></strong></dt>
<dd>the requested position for wheel 2</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string 'OK' or 'ERROR' depending whether the command
was accepted or the attenuator device is not ready.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;level ${pos1} ${pos2}&#34;,
                 process_cmd_string=add_lf,
                 process_response=decode_response)
def att_set_level_position(self, pos1: int, pos2: int) -&gt; str:
    &#34;&#34;&#34;
    Sets the two filter wheels to the given values (pos1 and pos2 must be between 1 and 8).

    Args:
        pos1: the requested position for wheel 1
        pos2: the requested position for wheel 2

    Returns:
        The string &#39;OK&#39; or &#39;ERROR&#39; depending whether the command
        was accepted or the attenuator device is not ready.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.att_status"><code class="name flex">
<span>def <span class="ident">att_status</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the state of the connection to attenuator device. The returned value contains 'OK'
when the attenuator device is initialised and ready, 'ERROR' when the device failed to
initialise.</p>
<h2 id="returns">Returns</h2>
<p>A string containing 'OK' or 'ERROR', i.e. 'att: OK' or 'att: ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;att status&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def att_status(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the state of the connection to attenuator device. The returned value contains &#39;OK&#39;
    when the attenuator device is initialised and ready, &#39;ERROR&#39; when the device failed to
    initialise.

    Returns:
        A string containing &#39;OK&#39; or &#39;ERROR&#39;, i.e. &#39;att: OK&#39; or &#39;att: ERROR&#39;.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnects client from the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;exit&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def exit(self):
    &#34;&#34;&#34;Disconnects client from the server.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault"><code class="name flex">
<span>def <span class="ident">get_controller_fault</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if there was an error with the controller.
The returned value is 'controller-fault: ERROR' or 'controller-fault: NO-ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get controller-fault&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_controller_fault(self) -&gt; str:
    &#34;&#34;&#34;
    Returns if there was an error with the controller.
    The returned value is &#39;controller-fault: ERROR&#39; or &#39;controller-fault: NO-ERROR&#39;.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_flags"><code class="name flex">
<span>def <span class="ident">get_flags</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of all parameters encoded in a single number formatted in hexadecimal
and binary. The bit order from msb to lsb is:</p>
<ul>
<li>bit 0 - interlock</li>
<li>bit 1 - power</li>
<li>bit 2 - lamp</li>
<li>bit 3 - laser</li>
<li>bit 4 - lamp-fault</li>
<li>bit 5 - controller-fault</li>
<li>bit 6 - psu</li>
<li>bit 7 - operate</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>flags</code></dt>
<dd>0xhh bbbb bbbb.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get flags&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_flags(self) -&gt; str:
    &#34;&#34;&#34;
    Get the state of all parameters encoded in a single number formatted in hexadecimal
    and binary. The bit order from msb to lsb is:

    * bit 0 - interlock
    * bit 1 - power
    * bit 2 - lamp
    * bit 3 - laser
    * bit 4 - lamp-fault
    * bit 5 - controller-fault
    * bit 6 - psu
    * bit 7 - operate

    Returns:
        flags: 0xhh bbbb bbbb.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_interlock"><code class="name flex">
<span>def <span class="ident">get_interlock</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of the interlock.</p>
<h2 id="returns">Returns</h2>
<p>A string containg 'OPEN' or 'CLOSE', i.e. 'interlock: OPEN' or 'interlock: CLOSE'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get interlock&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_interlock(self) -&gt; str:
    &#34;&#34;&#34;Get the state of the interlock.

    Returns:
        A string containg &#39;OPEN&#39; or &#39;CLOSE&#39;, i.e. &#39;interlock: OPEN&#39; or &#39;interlock: CLOSE&#39;.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_lamp"><code class="name flex">
<span>def <span class="ident">get_lamp</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of the lamp.
Returns 'lamp: ON' or 'lamp: OFF'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get lamp&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_lamp(self) -&gt; str:
    &#34;&#34;&#34;Get the state of the lamp.  Returns &#39;lamp: ON&#39; or &#39;lamp: OFF&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault"><code class="name flex">
<span>def <span class="ident">get_lamp_fault</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns if there was an error with the lamp.
Returned value is 'lamp-fault: ERROR' or 'lamp-fault: NO-ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get lamp-fault&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_lamp_fault(self) -&gt; str:
    &#34;&#34;&#34;
    Returns if there was an error with the lamp.
    Returned value is &#39;lamp-fault: ERROR&#39; or &#39;lamp-fault: NO-ERROR&#39;.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_laser"><code class="name flex">
<span>def <span class="ident">get_laser</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of the laser.
Returns 'laser: ON' or 'laser: OFF'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get laser&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_laser(self) -&gt; str:
    &#34;&#34;&#34;Get the state of the laser.  Returns &#39;laser: ON&#39; or &#39;laser: OFF&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_operate"><code class="name flex">
<span>def <span class="ident">get_operate</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of the laser (operate).
Returns 'operate: ON' or 'operate: OFF'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get operate&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_operate(self) -&gt; str:
    &#34;&#34;&#34;Get the state of the laser (operate).  Returns &#39;operate: ON&#39; or &#39;operate: OFF&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_power"><code class="name flex">
<span>def <span class="ident">get_power</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of the power supply. Returns 'power: ON' or 'power: OFF'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get power&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_power(self) -&gt; str:
    &#34;&#34;&#34;Get the state of the power supply. Returns &#39;power: ON&#39; or &#39;power: OFF&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature"><code class="name flex">
<span>def <span class="ident">get_power_and_temperature</span></span>(<span>self) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a power and temperature reading of both power-meters. Units are in Watt and degrees
Celsius.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the power and temperature values as floats. If the response
can not be processed, a Failure object will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;read&#34;, process_cmd_string=add_lf,
                 process_response=decode_read_command)
def get_power_and_temperature(self) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Gets a power and temperature reading of both power-meters. Units are in Watt and degrees
    Celsius.

    Returns:
        A dictionary containing the power and temperature values as floats. If the response
        can not be processed, a Failure object will be returned.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.get_psu"><code class="name flex">
<span>def <span class="ident">get_psu</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the state of the power supply unit.
Returns 'psu: ON' or 'psu: OFF'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;get psu&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def get_psu(self) -&gt; str:
    &#34;&#34;&#34;Get the state of the power supply unit.  Returns &#39;psu: ON&#39; or &#39;psu: OFF&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.ldls_status"><code class="name flex">
<span>def <span class="ident">ldls_status</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the state of the connection to the LDLS device. The returned value is 'OK'
when the LDLS device is initialised and ready, 'ERROR' when the device failed to
initialise.</p>
<h2 id="returns">Returns</h2>
<p>'ldls: OK' or 'ldls: ERROR'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;ldls status&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def ldls_status(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the state of the connection to the LDLS device. The returned value is &#39;OK&#39;
    when the LDLS device is initialised and ready, &#39;ERROR&#39; when the device failed to
    initialise.

    Returns:
        &#39;ldls: OK&#39; or &#39;ldls: ERROR&#39;
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.operate_off"><code class="name flex">
<span>def <span class="ident">operate_off</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the laser off, returns 'OK' or 'ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;operate off&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def operate_off(self) -&gt; str:
    &#34;&#34;&#34;Turns the laser off, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.operate_on"><code class="name flex">
<span>def <span class="ident">operate_on</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the laser on, returns 'OK' or 'ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;operate on&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def operate_on(self) -&gt; str:
    &#34;&#34;&#34;Turns the laser on, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.pm_status"><code class="name flex">
<span>def <span class="ident">pm_status</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the state of the connection to the power-meter devices. The returned value is 'OK'
when the power-meter device is initialised and ready, 'ERROR' when the device failed to
initialise.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A dictionary with keys</code></dt>
<dd>'pm1', 'pm2' and values 'OK' or 'ERROR'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;pm status&#34;, process_cmd_string=add_lf,
                 process_response=decode_pm_status_response)
def pm_status(self) -&gt; dict:
    &#34;&#34;&#34;
    Returns the state of the connection to the power-meter devices. The returned value is &#39;OK&#39;
    when the power-meter device is initialised and ready, &#39;ERROR&#39; when the device failed to
    initialise.

    Returns:
        A dictionary with keys: &#39;pm1&#39;, &#39;pm2&#39; and values &#39;OK&#39; or &#39;ERROR&#39;.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.power_off"><code class="name flex">
<span>def <span class="ident">power_off</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the power supply off, returns 'OK' or 'ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;power off&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def power_off(self) -&gt; str:
    &#34;&#34;&#34;Turns the power supply off, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.power_on"><code class="name flex">
<span>def <span class="ident">power_on</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Turns the power supply on, returns 'OK' or 'ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;power on&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def power_on(self) -&gt; str:
    &#34;&#34;&#34;Turns the power supply on, returns &#39;OK&#39; or &#39;ERROR&#39;.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnects client from the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;quit&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def quit(self):
    &#34;&#34;&#34;Disconnects client from the server.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a ‘reset’ cycle. This is sometimes needed to take LDLS out of a locked state.
Returns 'OK' or 'ERROR'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;transaction&#34;, cmd_string=&#34;reset&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def reset(self) -&gt; str:
    &#34;&#34;&#34;Performs a ‘reset’ cycle. This is sometimes needed to take LDLS out of a locked state.
    Returns &#39;OK&#39; or &#39;ERROR&#39;.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>self) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a global view of various relevant parameters. Returns a comma separated with the
current value of 9 parameters. Optionally, the attenuation shows an asterisk '*' when
the wheels are moving.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>power</code></dt>
<dd><flag>, lamp: <flag>, interlock: <flag>, psu: <flag>, att: [*] <level> #index,</dd>
</dl>
<p>power-ch1: <value> W, power-ch2: <value> W, temp-ch1: <value> ºC, temp-ch2: <value> ºC.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;status&#34;, process_cmd_string=add_lf,
                 process_response=decode_status_command)
def status(self) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Gets a global view of various relevant parameters. Returns a comma separated with the
    current value of 9 parameters. Optionally, the attenuation shows an asterisk &#39;*&#39; when
    the wheels are moving.

    Returns:
        power: &lt;flag&gt;, lamp: &lt;flag&gt;, interlock: &lt;flag&gt;, psu: &lt;flag&gt;, att: [*] &lt;level&gt; #index,
        power-ch1: &lt;value&gt; W, power-ch2: &lt;value&gt; W, temp-ch1: &lt;value&gt; ºC, temp-ch2: &lt;value&gt; ºC.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEInterface.version"><code class="name flex">
<span>def <span class="ident">version</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns version information about the OGSE hardware controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;query&#34;, cmd_string=&#34;version&#34;, process_cmd_string=add_lf,
                 process_response=decode_response)
def version(self) -&gt; str:
    &#34;&#34;&#34;Returns version information about the OGSE hardware controller.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSEProxy"><code class="flex name class">
<span>class <span class="ident">OGSEProxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=4242, timeout=10000)</span>
</code></dt>
<dd>
<div class="desc"><p>The OGSEProxy class is used to connect to the OGSE control server and send commands
to the OGSE Hardware Controller remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol
[default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address)
[default is taken from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>time out on the response from the control server [milliseconds]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OGSEProxy(DynamicProxy, OGSEInterface):
    &#34;&#34;&#34;
    The OGSEProxy class is used to connect to the OGSE control server and send commands
    to the OGSE Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
            self,
            protocol=CTRL_SETTINGS.PROTOCOL,
            hostname=CTRL_SETTINGS.HOSTNAME,
            port=CTRL_SETTINGS.COMMANDING_PORT,
            timeout=REQUEST_TIMEOUT
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol
                [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
            timeout: time out on the response from the control server [milliseconds]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.DynamicProxy" href="../../proxy.html#egse.proxy.DynamicProxy">DynamicProxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li>egse.mixin.DynamicClientCommandMixin</li>
<li><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.DynamicProxy" href="../../proxy.html#egse.proxy.DynamicProxy">DynamicProxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.DynamicProxy.connect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.disconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_commanding_port" href="../../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_endpoint" href="../../proxy.html#egse.proxy.BaseProxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_ip_address" href="../../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_monitoring_port" href="../../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_service_port" href="../../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_service_proxy" href="../../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.is_cs_connected" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.reconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.reset_cs_connection" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.send" href="../../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_get_level" href="#egse.collimator.fcul.ogse.OGSEInterface.att_get_level">att_get_level</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_down" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_down">att_level_down</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_up" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_up">att_level_up</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor">att_set_level_factor</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index">att_set_level_index</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position">att_set_level_position</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_status" href="#egse.collimator.fcul.ogse.OGSEInterface.att_status">att_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.exit" href="#egse.collimator.fcul.ogse.OGSEInterface.exit">exit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault">get_controller_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_flags" href="#egse.collimator.fcul.ogse.OGSEInterface.get_flags">get_flags</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_interlock" href="#egse.collimator.fcul.ogse.OGSEInterface.get_interlock">get_interlock</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp">get_lamp</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault">get_lamp_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_laser" href="#egse.collimator.fcul.ogse.OGSEInterface.get_laser">get_laser</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_operate" href="#egse.collimator.fcul.ogse.OGSEInterface.get_operate">get_operate</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power">get_power</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature">get_power_and_temperature</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_psu" href="#egse.collimator.fcul.ogse.OGSEInterface.get_psu">get_psu</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.ldls_status" href="#egse.collimator.fcul.ogse.OGSEInterface.ldls_status">ldls_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_off" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_off">operate_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_on" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_on">operate_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.pm_status" href="#egse.collimator.fcul.ogse.OGSEInterface.pm_status">pm_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_off" href="#egse.collimator.fcul.ogse.OGSEInterface.power_off">power_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_on" href="#egse.collimator.fcul.ogse.OGSEInterface.power_on">power_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.quit" href="#egse.collimator.fcul.ogse.OGSEInterface.quit">quit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reset" href="#egse.collimator.fcul.ogse.OGSEInterface.reset">reset</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.status" href="#egse.collimator.fcul.ogse.OGSEInterface.status">status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.version" href="#egse.collimator.fcul.ogse.OGSEInterface.version">version</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.collimator.fcul.ogse.OGSESimulator"><code class="flex name class">
<span>class <span class="ident">OGSESimulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Controller, Simulator and Proxy classes for this device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OGSESimulator(OGSEInterface):

    def __init__(self):

        super().__init__()

        self._lamp = False
        self._laser = False
        self._psu = False
        self._interlock = False
        self._operate = False
        self._power = False
        self._att_level = 1.0
        self._att_index = 46
        self._att_position_1 = 1
        self._att_position_2 = 1
        self._connected = False

    def is_simulator(self) -&gt; bool:
        return True

    def connect(self):
        self._connected = True

    def disconnect(self):
        self._connected = False

    def reconnect(self):
        self._connected = True

    def is_connected(self) -&gt; bool:
        return self._connected

    def version(self):
        return &#34;PLATO-RT-OGSE (v2.1)&#34;

    def get_flags(self):

        return &#34;flags: 0x00  0000 0000&#34;

    def get_interlock(self):

        return &#34;interlock: OPEN&#34; if self._interlock else &#34;interlock: CLOSED&#34;

    def get_power(self):

        return &#34;power: ON&#34; if self._power else &#34;power: OFF&#34;

    def get_lamp(self):

        return &#34;lamp: ON&#34; if self._lamp else &#34;lamp: OFF&#34;

    def get_laser(self):

        return &#34;laser: ON&#34; if self._laser else &#34;laser: OFF&#34;

    def quit(self):
        pass

    def exit(self):
        pass

    def ldls_status(self):

        return &#34;ldls: OK&#34;

    def get_lamp_fault(self):

        return &#34;lamp-fault: NO-ERROR&#34;

    def get_controller_fault(self):

        return &#34;controller-fault: NO-ERROR&#34;

    def get_psu(self):

        return &#34;psu: ON&#34; if self._psu else &#34;psu: OFF&#34;

    def get_operate(self):

        return &#34;operate: ON&#34; if self._operate else &#34;operate: OFF&#34;

    def att_status(self):

        return &#34;att: OK&#34;

    def att_get_level(self):

        return {
            &#34;att_moving&#34;: False,
            &#34;att_factor&#34;: self._att_level,
            &#34;att_index&#34;: self._att_index
        }

    def att_set_level_factor(self, factor):

        if 0 &lt;= factor &lt;= 1:

            self._att_level = factor
            self._att_index = get_attenuation_index(factor)

            time.sleep(random.random() * 3 + 6)  # wait between 6.0 and 9.0 seconds

            return &#34;OK&#34;

        else:

            return &#34;ERROR: usage: attenuator level &lt;value&gt;  -- value must be in [0,1]&#34;

    def att_set_level_position(self, level1, level2):

        if 1 &lt;= level1 &lt;= 8 and 1 &lt;= level2 &lt;= 8:

            self._att_position_1 = level1
            self._att_position_2 = level2

            self._att_level = ATT_LEVELS_BY_WHEEL[(level1, level2)]
            self._att_index = get_attenuation_index(self._att_level)

            time.sleep(random.random() * 3 + 6)  # wait between 6.0 and 9.0 seconds

            return &#34;OK&#34;

        else:

            return (
                &#34;ERROR: usage: attenuator level &lt;wheel_1&gt; &lt;wheel_2&gt;  -- &#34; 
                &#34;wheel positions must be integer = 1..8&#34;
            )

    def att_level_up(self):

        self.att_set_level_index(min(self._att_index + 1, len(ATT_LEVELS_BY_FACTOR) - 1))

        return &#34;OK&#34;

    def att_level_down(self):

        self.att_set_level_index(max(self._att_index - 1, 0))

        return &#34;OK&#34;

    def pm_status(self):

        return {
            &#34;pm1&#34;: &#34;OK&#34;,
            &#34;pm2&#34;: &#34;OK&#34;
        }

    def get_power_and_temperature(self):

        return {
            &#34;power1&#34;: 6.376149e-11,
            &#34;temp1&#34;: 21.3,
            &#34;power2&#34;: 1.484441e-07,
            &#34;temp2&#34;: 21.3
        }

    def status(self):

        power_and_temp = self.get_power_and_temperature()
        _, att_level, att_index = self.att_get_level()

        # return self.get_power(), self.get_lamp(), self.get_interlock(), self.get_psu(), \
        #     f&#34;att: {att_level} #{att_index}&#34;,  f&#34;power-ch1: {power_ch1} W&#34;, f&#34;temp-ch1: {temp_ch1} °C&#34;, \
        #     f&#34;power-ch2: {power_ch2} W&#34;, f&#34;temp-ch2: {temp_ch2} °C&#34;,
        #
        status = {
            &#34;power&#34;: &#34;ON&#34; if self._power else &#34;OFF&#34;,
            &#34;lamp&#34;: &#34;ON&#34; if self._lamp else &#34;OFF&#34;,
            &#34;interlock&#34;: &#34;ON&#34; if self._interlock else &#34;OFF&#34;,
            &#34;psu&#34;: &#34;ON&#34; if self._psu else &#34;OFF&#34;,
            &#34;att_moving&#34;: False,
            &#34;att_factor&#34;: self._att_level,
            &#34;att_index&#34;: self._att_index
        }

        status.update(power_and_temp)

        return status

    def att_set_level_index(self, index: int):

        if 0 &lt;= factor &lt; len(ATT_LEVELS_BY_FACTOR):

            self._att_index = index
            self._att_level = ATT_LEVELS_BY_FACTOR[index][0]

            time.sleep(random.random() * 3 + 6)  # wait between 6.0 and 9.0 seconds

            return &#34;OK&#34;

        else:

            return &#34;ERROR: usage: attenuator level #index  -- index goes from 0 to 47&#34;

    def power_on(self):

        self._power = True

        return &#34;OK&#34;

    def power_off(self):

        self._power = False

        return &#34;OK&#34;

    def operate_on(self):

        self._operate = True

        return &#34;OK&#34;

    def operate_off(self):

        self._operate = True

        return &#34;OK&#34;

    def reset(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_get_level" href="#egse.collimator.fcul.ogse.OGSEInterface.att_get_level">att_get_level</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_down" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_down">att_level_down</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_up" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_up">att_level_up</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor">att_set_level_factor</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index">att_set_level_index</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position">att_set_level_position</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_status" href="#egse.collimator.fcul.ogse.OGSEInterface.att_status">att_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.exit" href="#egse.collimator.fcul.ogse.OGSEInterface.exit">exit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault">get_controller_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_flags" href="#egse.collimator.fcul.ogse.OGSEInterface.get_flags">get_flags</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_interlock" href="#egse.collimator.fcul.ogse.OGSEInterface.get_interlock">get_interlock</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp">get_lamp</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault">get_lamp_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_laser" href="#egse.collimator.fcul.ogse.OGSEInterface.get_laser">get_laser</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_operate" href="#egse.collimator.fcul.ogse.OGSEInterface.get_operate">get_operate</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power">get_power</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature">get_power_and_temperature</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_psu" href="#egse.collimator.fcul.ogse.OGSEInterface.get_psu">get_psu</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.ldls_status" href="#egse.collimator.fcul.ogse.OGSEInterface.ldls_status">ldls_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_off" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_off">operate_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_on" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_on">operate_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.pm_status" href="#egse.collimator.fcul.ogse.OGSEInterface.pm_status">pm_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_off" href="#egse.collimator.fcul.ogse.OGSEInterface.power_off">power_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_on" href="#egse.collimator.fcul.ogse.OGSEInterface.power_on">power_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.quit" href="#egse.collimator.fcul.ogse.OGSEInterface.quit">quit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reset" href="#egse.collimator.fcul.ogse.OGSEInterface.reset">reset</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.status" href="#egse.collimator.fcul.ogse.OGSEInterface.status">status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.version" href="#egse.collimator.fcul.ogse.OGSEInterface.version">version</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.collimator.fcul.ogse.OnOffSwitch"><code class="flex name class">
<span>class <span class="ident">OnOffSwitch</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OnOffSwitch(str, Enum):
    on = &#34;on&#34;
    off = &#34;off&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.collimator.fcul.ogse.OnOffSwitch.off"><code class="name">var <span class="ident">off</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.collimator.fcul.ogse.OnOffSwitch.on"><code class="name">var <span class="ident">on</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.collimator.fcul" href="index.html">egse.collimator.fcul</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.collimator.fcul.ogse.check_cmd_att_index" href="#egse.collimator.fcul.ogse.check_cmd_att_index">check_cmd_att_index</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.decode_att_get_level_command" href="#egse.collimator.fcul.ogse.decode_att_get_level_command">decode_att_get_level_command</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.decode_pm_status_response" href="#egse.collimator.fcul.ogse.decode_pm_status_response">decode_pm_status_response</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.decode_read_command" href="#egse.collimator.fcul.ogse.decode_read_command">decode_read_command</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.decode_response" href="#egse.collimator.fcul.ogse.decode_response">decode_response</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.decode_status_command" href="#egse.collimator.fcul.ogse.decode_status_command">decode_status_command</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.get_attenuation_index" href="#egse.collimator.fcul.ogse.get_attenuation_index">get_attenuation_index</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.is_ogse_cs_active" href="#egse.collimator.fcul.ogse.is_ogse_cs_active">is_ogse_cs_active</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.collimator.fcul.ogse.OGSECommand" href="#egse.collimator.fcul.ogse.OGSECommand">OGSECommand</a></code></h4>
<ul class="">
<li><code><a title="egse.collimator.fcul.ogse.OGSECommand.get_cmd_string" href="#egse.collimator.fcul.ogse.OGSECommand.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.collimator.fcul.ogse.OGSEController" href="#egse.collimator.fcul.ogse.OGSEController">OGSEController</a></code></h4>
<ul class="">
<li><code><a title="egse.collimator.fcul.ogse.OGSEController.is_connected" href="#egse.collimator.fcul.ogse.OGSEController.is_connected">is_connected</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.collimator.fcul.ogse.OGSEInterface" href="#egse.collimator.fcul.ogse.OGSEInterface">OGSEInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_get_level" href="#egse.collimator.fcul.ogse.OGSEInterface.att_get_level">att_get_level</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_down" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_down">att_level_down</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_level_up" href="#egse.collimator.fcul.ogse.OGSEInterface.att_level_up">att_level_up</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_factor">att_set_level_factor</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_index">att_set_level_index</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position" href="#egse.collimator.fcul.ogse.OGSEInterface.att_set_level_position">att_set_level_position</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.att_status" href="#egse.collimator.fcul.ogse.OGSEInterface.att_status">att_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.exit" href="#egse.collimator.fcul.ogse.OGSEInterface.exit">exit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_controller_fault">get_controller_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_flags" href="#egse.collimator.fcul.ogse.OGSEInterface.get_flags">get_flags</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_interlock" href="#egse.collimator.fcul.ogse.OGSEInterface.get_interlock">get_interlock</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp">get_lamp</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault" href="#egse.collimator.fcul.ogse.OGSEInterface.get_lamp_fault">get_lamp_fault</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_laser" href="#egse.collimator.fcul.ogse.OGSEInterface.get_laser">get_laser</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_operate" href="#egse.collimator.fcul.ogse.OGSEInterface.get_operate">get_operate</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power">get_power</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature" href="#egse.collimator.fcul.ogse.OGSEInterface.get_power_and_temperature">get_power_and_temperature</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.get_psu" href="#egse.collimator.fcul.ogse.OGSEInterface.get_psu">get_psu</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.ldls_status" href="#egse.collimator.fcul.ogse.OGSEInterface.ldls_status">ldls_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_off" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_off">operate_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.operate_on" href="#egse.collimator.fcul.ogse.OGSEInterface.operate_on">operate_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.pm_status" href="#egse.collimator.fcul.ogse.OGSEInterface.pm_status">pm_status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_off" href="#egse.collimator.fcul.ogse.OGSEInterface.power_off">power_off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.power_on" href="#egse.collimator.fcul.ogse.OGSEInterface.power_on">power_on</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.quit" href="#egse.collimator.fcul.ogse.OGSEInterface.quit">quit</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.reset" href="#egse.collimator.fcul.ogse.OGSEInterface.reset">reset</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.status" href="#egse.collimator.fcul.ogse.OGSEInterface.status">status</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OGSEInterface.version" href="#egse.collimator.fcul.ogse.OGSEInterface.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.collimator.fcul.ogse.OGSEProxy" href="#egse.collimator.fcul.ogse.OGSEProxy">OGSEProxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.collimator.fcul.ogse.OGSESimulator" href="#egse.collimator.fcul.ogse.OGSESimulator">OGSESimulator</a></code></h4>
</li>
<li>
<h4><code><a title="egse.collimator.fcul.ogse.OnOffSwitch" href="#egse.collimator.fcul.ogse.OnOffSwitch">OnOffSwitch</a></code></h4>
<ul class="">
<li><code><a title="egse.collimator.fcul.ogse.OnOffSwitch.off" href="#egse.collimator.fcul.ogse.OnOffSwitch.off">off</a></code></li>
<li><code><a title="egse.collimator.fcul.ogse.OnOffSwitch.on" href="#egse.collimator.fcul.ogse.OnOffSwitch.on">on</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.setup API documentation</title>
<meta name="description" content="This module defines the Setup, which contains the complete configuration information for a test â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.setup</code></h1>
</header>
<section id="section-intro">
<p>This module defines the Setup, which contains the complete configuration information for a test.</p>
<p>The Setup class contains all configuration items that are specific for a test or observation
and is normally (during nominal operation/testing) loaded automatically from the configuration
manager. The Setup includes type and identification of hardware that is used, calibration files,
software versions, reference frames and coordinate systems that link positions of alignment
equipment, conversion functions for temperature sensors, etc.</p>
<p>The configuration information that is in the Setup can be navigated in two different ways. First,
the Setup is a dictionary, so all information can be accessed by keys as in the following example.</p>
<pre><code>&gt;&gt;&gt; setup = Setup({"gse": {"hexapod": {"ID": 42, "calibration": [0,1,2,3,4,5]}}})
&gt;&gt;&gt; setup["gse"]["hexapod"]["ID"]
42
</code></pre>
<p>Second, each of the <em>keys</em> is also available as an attribute of the Setup and that make it
possible to navigate the Setup with dot-notation:</p>
<pre><code>&gt;&gt;&gt; id = setup.gse.hexapod.ID
</code></pre>
<p>In the above example you can see how to navigate from the setup to a device like the PUNA Hexapod.
The Hexapod device is connected to the control server and accepts commands as usual. If you want to
know which keys you can use to navigate the Setup, use the <code>keys()</code> method.</p>
<pre><code>&gt;&gt;&gt; setup.gse.hexapod.keys()
dict_keys(['ID', 'calibration'])
&gt;&gt;&gt; setup.gse.hexapod.calibration
[0, 1, 2, 3, 4, 5]
</code></pre>
<p>To get a full printout of the Setup, you can use the <code>pretty_str()</code> method. Be careful, because
this can print out a lot of information when a full Setup is loaded.</p>
<pre><code>&gt;&gt;&gt; print(setup)
gse:
    hexapod:
        ID: 42
        calibration: [0, 1, 2, 3, 4, 5]
&lt;BLANKLINE&gt;
</code></pre>
<h3 id="special-values">Special Values</h3>
<p>Some of the information in the Setup is interpreted in a special way, i.e. some values are
processed before returning. Examples are the device classes and calibration/data files. The
following values are treated special if they start with:</p>
<ul>
<li><code>class//</code>: the class in instantiated and the object is returned</li>
<li><code>csv//</code>: the CSV file is loaded and a numpy array is returned</li>
<li><code>yaml//</code>: the YAML file is loaded and a dictionary is returned</li>
<li><code>enum//</code>: the enumeration is created dynamically and the object is returned</li>
</ul>
<h4 id="device-classes">Device Classes</h4>
<p>Most of the hardware components in the Setup will have a <code>device</code> key that defines the class for
the device controller. The <code>device</code> keys have a value that starts with <code>class//</code> and it will
return the device object. As an example, the following defines the Hexapod device:</p>
<pre><code>&gt;&gt;&gt; setup = Setup({
...     "gse": {
...         "hexapod": {"ID": 42, "device": "class//egse.hexapod.symetrie.puna.PunaSimulator"}
...     }
... })
&gt;&gt;&gt; setup.gse.hexapod.device.is_homing_done()
False
&gt;&gt;&gt; setup.gse.hexapod.device.info()  # doctest: +ELLIPSIS
'Info about the PunaSimulator...
</code></pre>
<p>In the above example you see that we can call the <code>is_homing_done()</code> and <code>info()</code> methodes
directly on the device by navigating the Setup. It would however be better (more performant) to
put the device object in a variable and work with that variable:</p>
<pre><code>&gt;&gt;&gt; hexapod = setup.gse.hexapod.device
&gt;&gt;&gt; _ = hexapod.homing()
&gt;&gt;&gt; hexapod.is_homing_done()
True
&gt;&gt;&gt; _ = hexapod.get_user_positions()
</code></pre>
<p>If you need, for some reason, to have access to the actual raw value of the hexapod device key,
use the <code>get_raw_value()</code> method:</p>
<pre><code>&gt;&gt;&gt; setup.gse.hexapod.get_raw_value("device")  # doctest: +ELLIPSIS
&lt;egse.hexapod.symetrie.puna.PunaSimulator object at ...
</code></pre>
<h4 id="data-files">Data Files</h4>
<p>Some information is too large to add to the Setup as such and should be loaded from a data file.
Examples are calibration files, flat-fields, temperature conversion curves, etc.</p>
<p>The Setup will automatically load the file when you access a key that contains a value that
starts with <code>csv//</code> or <code>yaml//</code>.</p>
<pre><code>&gt;&gt;&gt; setup = Setup({
...     "instrument": {"coeff": "csv//cal_coeff_1234.csv"}
... })
&gt;&gt;&gt; setup.instrument.coeff[0, 4]
5.0
</code></pre>
<p>Note: the resource location is always relative to the path defined by the PLATO_CONF_DATA_LOCATION
environment variable.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the Setup, which contains the complete configuration information for a test.

The Setup class contains all configuration items that are specific for a test or observation
and is normally (during nominal operation/testing) loaded automatically from the configuration
manager. The Setup includes type and identification of hardware that is used, calibration files,
software versions, reference frames and coordinate systems that link positions of alignment
equipment, conversion functions for temperature sensors, etc.

The configuration information that is in the Setup can be navigated in two different ways. First,
the Setup is a dictionary, so all information can be accessed by keys as in the following example.

    &gt;&gt;&gt; setup = Setup({&#34;gse&#34;: {&#34;hexapod&#34;: {&#34;ID&#34;: 42, &#34;calibration&#34;: [0,1,2,3,4,5]}}})
    &gt;&gt;&gt; setup[&#34;gse&#34;][&#34;hexapod&#34;][&#34;ID&#34;]
    42

Second, each of the _keys_ is also available as an attribute of the Setup and that make it
possible to navigate the Setup with dot-notation:

    &gt;&gt;&gt; id = setup.gse.hexapod.ID

In the above example you can see how to navigate from the setup to a device like the PUNA Hexapod.
The Hexapod device is connected to the control server and accepts commands as usual. If you want to
know which keys you can use to navigate the Setup, use the `keys()` method.

    &gt;&gt;&gt; setup.gse.hexapod.keys()
    dict_keys([&#39;ID&#39;, &#39;calibration&#39;])
    &gt;&gt;&gt; setup.gse.hexapod.calibration
    [0, 1, 2, 3, 4, 5]

To get a full printout of the Setup, you can use the `pretty_str()` method. Be careful, because
this can print out a lot of information when a full Setup is loaded.

    &gt;&gt;&gt; print(setup)
    gse:
        hexapod:
            ID: 42
            calibration: [0, 1, 2, 3, 4, 5]
    &lt;BLANKLINE&gt;

### Special Values

Some of the information in the Setup is interpreted in a special way, i.e. some values are
processed before returning. Examples are the device classes and calibration/data files. The
following values are treated special if they start with:

* `class//`: the class in instantiated and the object is returned
* `csv//`: the CSV file is loaded and a numpy array is returned
* `yaml//`: the YAML file is loaded and a dictionary is returned
* `enum//`: the enumeration is created dynamically and the object is returned

#### Device Classes

Most of the hardware components in the Setup will have a `device` key that defines the class for
the device controller. The `device` keys have a value that starts with `class//` and it will
return the device object. As an example, the following defines the Hexapod device:

    &gt;&gt;&gt; setup = Setup({
    ...     &#34;gse&#34;: {
    ...         &#34;hexapod&#34;: {&#34;ID&#34;: 42, &#34;device&#34;: &#34;class//egse.hexapod.symetrie.puna.PunaSimulator&#34;}
    ...     }
    ... })
    &gt;&gt;&gt; setup.gse.hexapod.device.is_homing_done()
    False
    &gt;&gt;&gt; setup.gse.hexapod.device.info()  # doctest: +ELLIPSIS
    &#39;Info about the PunaSimulator...

In the above example you see that we can call the `is_homing_done()` and `info()` methodes
directly on the device by navigating the Setup. It would however be better (more performant) to
put the device object in a variable and work with that variable:

    &gt;&gt;&gt; hexapod = setup.gse.hexapod.device
    &gt;&gt;&gt; _ = hexapod.homing()
    &gt;&gt;&gt; hexapod.is_homing_done()
    True
    &gt;&gt;&gt; _ = hexapod.get_user_positions()

If you need, for some reason, to have access to the actual raw value of the hexapod device key,
use the `get_raw_value()` method:

    &gt;&gt;&gt; setup.gse.hexapod.get_raw_value(&#34;device&#34;)  # doctest: +ELLIPSIS
    &lt;egse.hexapod.symetrie.puna.PunaSimulator object at ...

#### Data Files

Some information is too large to add to the Setup as such and should be loaded from a data file.
Examples are calibration files, flat-fields, temperature conversion curves, etc.

The Setup will automatically load the file when you access a key that contains a value that
starts with `csv//` or `yaml//`.

    &gt;&gt;&gt; setup = Setup({
    ...     &#34;instrument&#34;: {&#34;coeff&#34;: &#34;csv//cal_coeff_1234.csv&#34;}
    ... })
    &gt;&gt;&gt; setup.instrument.coeff[0, 4]
    5.0

Note: the resource location is always relative to the path defined by the PLATO_CONF_DATA_LOCATION
environment variable.

&#34;&#34;&#34;
from __future__ import annotations

import enum
import importlib
import logging
import os
import re
import textwrap
from functools import lru_cache
from pathlib import Path
from typing import Any
from typing import Optional
from typing import Union

import pandas
import rich
import yaml
from deepdiff import DeepDiff
from numpy import genfromtxt
from rich.tree import Tree

from egse.control import Failure
from egse.system import format_datetime
from egse.system import sanity_check
from egse.system import walk_dict_tree

MODULE_LOGGER = logging.getLogger(__name__)


class SetupError(Exception):
    &#34;&#34;&#34; A setup-specific error.&#34;&#34;&#34;
    pass


def _load_class(class_name: str):
    &#34;&#34;&#34;Find and returns a class based on the fully qualified name.

    A class name can be preceded with the string `class//`. This is used in YAML
    files where the class is then instantiated on load.

    Args:
        class_name (str): a fully qualified name for the class
    &#34;&#34;&#34;
    if class_name.startswith(&#34;class//&#34;):
        class_name = class_name[7:]
    elif class_name.startswith(&#34;factory//&#34;):
        class_name = class_name[9:]

    module_name, class_name = class_name.rsplit(&#34;.&#34;, 1)
    module = importlib.import_module(module_name)
    return getattr(module, class_name)


def _load_csv(resource_name: str):
    &#34;&#34;&#34;Find and return the content of a CSV file.&#34;&#34;&#34;
    parts = resource_name[5:].rsplit(&#34;/&#34;, 1)
    [in_dir, fn] = parts if len(parts) &gt; 1 else [None, parts[0]]
    conf_location = os.environ[&#39;PLATO_CONF_DATA_LOCATION&#39;]
    try:
        csv_location = Path(conf_location) / in_dir / fn
        content = genfromtxt(csv_location, delimiter=&#34;,&#34;, skip_header=1)
    except TypeError as exc:
        raise ValueError(
            f&#34;Couldn&#39;t load resource &#39;{resource_name}&#39; from default {conf_location=}&#34;) from exc
    return content


def _load_int_enum(enum_name: str, enum_content):
    &#34;&#34;&#34; Dynamically build (and return) and IntEnum.

    Args:
        - enum_name: Enumeration name (potentially prepended with &#34;int_enum//&#34;).
        - enum_content: Content of the enumeration, as read from the setup.
    &#34;&#34;&#34;
    if enum_name.startswith(&#34;int_enum//&#34;):
        enum_name = enum_name[10:]

    definition = {}
    for side_name, side_definition in enum_content.items():

        if &#34;alias&#34; in side_definition:
            aliases = side_definition[&#34;alias&#34;]
        else:
            aliases = []
        value = side_definition[&#34;value&#34;]

        definition[side_name] = value

        for alias in aliases:
            definition[alias] = value
    return enum.IntEnum(enum_name, definition)


def _load_yaml(resource_name: str):
    &#34;&#34;&#34;Find and return the content of a YAML file.&#34;&#34;&#34;
    from egse.settings import Settings
    from egse.settings import SettingsError

    parts = resource_name[6:].rsplit(&#34;/&#34;, 1)
    [in_dir, fn] = parts if len(parts) &gt; 1 else [None, parts[0]]
    conf_location = os.environ[&#39;PLATO_CONF_DATA_LOCATION&#39;]
    try:
        yaml_location = Path(conf_location) / in_dir / fn
        content = NavigableDict(Settings.load(filename=yaml_location, add_local_settings=False))
    except (TypeError, SettingsError) as exc:
        raise ValueError(
            f&#34;Couldn&#39;t load resource &#39;{resource_name}&#39; from default {conf_location=}&#34;) from exc
    return content


def _load_pandas(resource_name: str, separator: str):
    &#34;&#34;&#34; Find and return the content of the given files as a pandas DataFrame object.

    Args:
        - resource_name: Filename, preceded by &#34;pandas//&#34;.
        - separator: Column separator.
    &#34;&#34;&#34;
    parts = resource_name[8:].rsplit(&#34;/&#34;, 1)
    [in_dir, fn] = parts if len(parts) &gt; 1 else [None, parts[0]]
    conf_location = os.environ[&#39;PLATO_CONF_DATA_LOCATION&#39;]

    try:
        pandas_file_location = Path(conf_location) / in_dir / fn
        return pandas.read_csv(pandas_file_location, sep=separator)
    except TypeError as exc:
        raise ValueError(
            f&#34;Couldn&#39;t load resource &#39;{resource_name}&#39; from default {conf_location=}&#34;) from exc


def _get_attribute(self, name, default):
    try:
        attr = object.__getattribute__(self, name)
    except AttributeError:
        attr = default
    return attr


def _parse_filename_for_setup_id(filename: str):
    &#34;&#34;&#34;Returns the setup_id from the filename, or None when no match was found.&#34;&#34;&#34;

    match = re.search(r&#34;SETUP_([^_]+)_(\d+)&#34;, filename)

    # TypeError when match is None

    try:
        return match[2]  # match[2] is setup_id
    except (IndexError, TypeError) as exc:
        return None


def get_last_setup_id_file_path():
    return Path(
        os.environ.get(&#34;PLATO_DATA_STORAGE_LOCATION&#34;) or &#34;~&#34;).expanduser().resolve() / &#34;last_setup_id.txt&#34;


def load_last_setup_id() -&gt; int:
    &#34;&#34;&#34;
    Returns the ID of the last Setup that was used by the configuration manager.
    The file shall only contain the Setup ID which must be an integer on the first line of the file.
    If no such ID can be found, the Setup ID = 0 will be returned.
    &#34;&#34;&#34;

    last_setup_id_file_path = get_last_setup_id_file_path()
    try:
        with last_setup_id_file_path.open(&#39;r&#39;) as fd:
            setup_id = int(fd.read().strip())
    except FileNotFoundError:
        setup_id = 0
        save_last_setup_id(setup_id)

    return setup_id


def save_last_setup_id(setup_id: int | str):
    &#34;&#34;&#34;Makes the given Setup ID persistent, so it can be restored upon the next startup.&#34;&#34;&#34;

    last_setup_id_file_path = get_last_setup_id_file_path()
    with last_setup_id_file_path.open(&#39;w&#39;) as fd:
        fd.write(f&#34;{int(setup_id):d}&#34;)


class NavigableDict(dict):
    &#34;&#34;&#34;
    A NavigableDict is a dictionary where all keys in the original dictionary are also accessible
    as attributes to the class instance. So, if the original dictionary (setup) has a key
    &#34;site_id&#34; which is accessible as `setup[&#39;site_id&#39;]`, it will also be accessible as
    `setup.site_id`.

    Examples:
        &gt;&gt;&gt; setup = NavigableDict({&#39;site_id&#39;: &#39;KU Leuven&#39;, &#39;version&#39;: &#34;0.1.0&#34;})
        &gt;&gt;&gt; assert setup[&#39;site_id&#39;] == setup.site_id
        &gt;&gt;&gt; assert setup[&#39;version&#39;] == setup.version

    .. note::
        We always want **all** keys to be accessible as attributes, or none. That means all
        keys of the original dictionary shall be of type `str`.

    &#34;&#34;&#34;

    def __init__(self, head: dict = None):
        &#34;&#34;&#34;
        Args:
            head (dict): the original dictionary
        &#34;&#34;&#34;
        head = head or {}
        super().__init__(head)
        self.__dict__[&#34;_memoized&#34;] = {}

        # By agreement, we only want the keys to be set as attributes if all keys are strings.
        # That way we enforce that always all keys are navigable, or none.

        if any(True for k in head.keys() if not isinstance(k, str)):
            return

        for key, value in head.items():
            if isinstance(value, dict):
                setattr(self, key, NavigableDict(head.__getitem__(key)))
            else:
                setattr(self, key, head.__getitem__(key))

    def add(self, key: str, value: Any):
        &#34;&#34;&#34;Set a value for the given key.

        If the value is a dictionary, it will be converted into a NavigableDict and the keys
        will become available as attributes provided that all the keys are strings.

        Args:
            key (str): the name of the key / attribute to access the value
            value (Any): the value to assign to the key
        &#34;&#34;&#34;
        if isinstance(value, dict) and not isinstance(value, NavigableDict):
            value = NavigableDict(value)
        setattr(self, key, value)

    def clear(self) -&gt; None:
        for key in list(self.keys()):
            self.__delitem__(key)

    def __repr__(self):
        return f&#34;{self.__class__.__name__}({super()!r})&#34;

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        object.__delattr__(self, key)

    def __setattr__(self, key, value):
        # MODULE_LOGGER.info(f&#34;called __setattr__({self!r}, {key}, {value})&#34;)
        if isinstance(value, dict) and not isinstance(value, NavigableDict):
            value = NavigableDict(value)
        self.__dict__[key] = value
        super().__setitem__(key, value)
        try:
            del self.__dict__[&#34;_memoized&#34;][key]
        except KeyError:
            pass

    def __getattribute__(self, key):
        # MODULE_LOGGER.info(f&#34;called __getattribute__({key})&#34;)
        value = object.__getattribute__(self, key)
        if isinstance(value, str) and value.startswith(&#34;class//&#34;):
            try:
                dev_args = object.__getattribute__(self, &#39;device_args&#39;)
            except AttributeError:
                dev_args = ()
            return _load_class(value)(*dev_args)
        if isinstance(value, str) and value.startswith(&#34;factory//&#34;):
            factory_args = _get_attribute(self, f&#39;{key}_args&#39;, {})
            return _load_class(value)().create(**factory_args)
        if isinstance(value, str) and value.startswith(&#34;int_enum//&#34;):
            content = object.__getattribute__(self, &#34;content&#34;)
            return _load_int_enum(value, content)
        if isinstance(value, str) and value.startswith(&#34;csv//&#34;):
            if key in self.__dict__[&#34;_memoized&#34;]:
                return self.__dict__[&#34;_memoized&#34;][key]
            content = _load_csv(value)
            self.__dict__[&#34;_memoized&#34;][key] = content
            return content
        if isinstance(value, str) and value.startswith(&#34;yaml//&#34;):
            if key in self.__dict__[&#34;_memoized&#34;]:
                return self.__dict__[&#34;_memoized&#34;][key]
            content = _load_yaml(value)
            self.__dict__[&#34;_memoized&#34;][key] = content
            return content
        if isinstance(value, str) and value.startswith(&#34;pandas//&#34;):
            separator = object.__getattribute__(self, &#39;separator&#39;)
            return _load_pandas(value, separator)
        else:
            return value

    def __delattr__(self, item):
        # MODULE_LOGGER.info(f&#34;called __delattr__({self!r}, {item})&#34;)
        object.__delattr__(self, item)
        dict.__delitem__(self, item)

    def __setitem__(self, key, value):
        # MODULE_LOGGER.info(f&#34;called __setitem__({self!r}, {key}, {value})&#34;)
        if isinstance(value, dict) and not isinstance(value, NavigableDict):
            value = NavigableDict(value)
        super().__setitem__(key, value)
        self.__dict__[key] = value
        try:
            del self.__dict__[&#34;_memoized&#34;][key]
        except KeyError:
            pass

    def __getitem__(self, key):
        # MODULE_LOGGER.info(f&#34;called __getitem__({self!r}, {key})&#34;)
        value = super().__getitem__(key)
        if isinstance(value, str) and value.startswith(&#34;class//&#34;):
            try:
                dev_args = object.__getattribute__(self, &#39;device_args&#39;)
            except AttributeError:
                dev_args = ()
            return _load_class(value)(*dev_args)
        if isinstance(value, str) and value.startswith(&#34;csv//&#34;):
            return _load_csv(value)
        if isinstance(value, str) and value.startswith(&#34;int_enum//&#34;):
            content = object.__getattribute__(self, &#34;content&#34;)
            return _load_int_enum(value, content)
        else:
            return value

    def set_private_attribute(self, key: str, value) -&gt; None:
        &#34;&#34;&#34;Sets a private attribute for this object.

        The name in key will be accessible as an attribute for this object, but the key will not
        be added to the dictionary and not be returned by methods like keys().

        The idea behind this private attribute is to have the possibility to add status information
        or identifiers to this classes object that can be used by save() or load() methods.

        Args:
            key (str): the name of the private attribute (must start with an underscore character).
            value: the value for this private attribute

        Returns:
            None.

        Examples:
            &gt;&gt;&gt; setup = NavigableDict({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})
            &gt;&gt;&gt; setup.set_private_attribute(&#34;_loaded_from_dict&#34;, True)
            &gt;&gt;&gt; assert &#34;c&#34; in setup
            &gt;&gt;&gt; assert &#34;_loaded_from_dict&#34; not in setup
            &gt;&gt;&gt; assert setup.get_private_attribute(&#34;_loaded_from_dict&#34;) == True

        &#34;&#34;&#34;
        if key in self:
            raise ValueError(
                f&#34;Invalid argument key=&#39;{key}&#39;, this key already exists in dictionary.&#34;
            )
        if not key.startswith(&#34;_&#34;):
            raise ValueError(
                f&#34;Invalid argument key=&#39;{key}&#39;, must start with underscore character &#39;_&#39;.&#34;
            )
        self.__dict__[key] = value

    def get_private_attribute(self, key: str):
        &#34;&#34;&#34;Returns the value of the given private attribute.

        Args:
            key (str): the name of the private attribute (must start with an underscore character).

        Returns:
            the value of the private attribute given in `key`.

        .. note::
            Because of the implementation, this private attribute can also be accessed as a &#39;normal&#39;
            attribute of the object. This use is however discouraged as it will make your code less
            understandable. Use the methods to access these &#39;private&#39; attributes.
        &#34;&#34;&#34;
        if not key.startswith(&#34;_&#34;):
            raise ValueError(
                f&#34;Invalid argument key=&#39;{key}&#39;, must start with underscore character &#39;_&#39;.&#34;
            )
        return self.__dict__[key]

    def has_private_attribute(self, key):
        &#34;&#34;&#34;
        Check if the given key is defined as a private attribute.

        Args:
            key (str): the name of a private attribute (must start with an underscore)
        Returns:
            True if the given key is a known private attribute.
        Raises:
            ValueError: when the key doesn&#39;t start with an underscore.
        &#34;&#34;&#34;
        if not key.startswith(&#34;_&#34;):
            raise ValueError(
                f&#34;Invalid argument key=&#39;{key}&#39;, must start with underscore character &#39;_&#39;.&#34;
            )
        try:
            self.__dict__[key]
            return True
        except KeyError:
            return False

    def get_raw_value(self, key):
        &#34;&#34;&#34;
        Returns the raw value of the given key.

        Some keys have special values that are interpreted by the AtributeDict class. An example is
        a value that starts with &#39;class//&#39;. When you access these values, they are first converted
        from their raw value into their expected value, e.g. the instantiated object in the above
        example. This method allows you to access the raw value before conversion.
        &#34;&#34;&#34;
        try:
            return object.__getattribute__(self, key)
        except AttributeError:
            raise KeyError(f&#34;The key &#39;{key}&#39; is not defined.&#34;)

    def __str__(self):
        return self.pretty_str()

    def pretty_str(self, indent: int = 0):
        &#34;&#34;&#34;
        Returns a pretty string representation of the dictionary.

        Args:
            indent (int): number of indentations (of four spaces)

        .. note::
            The indent argument is intended for the recursive call of this function.
        &#34;&#34;&#34;
        msg = &#34;&#34;

        for k, v in self.items():
            if isinstance(v, NavigableDict):
                msg += f&#34;{&#39;    &#39;*indent}{k}:\n&#34;
                msg += v.pretty_str(indent + 1)
            else:
                msg += f&#34;{&#39;    &#39;*indent}{k}: {v}\n&#34;

        return msg

    def __rich__(self) -&gt; Tree:
        tree = Tree(&#34;NavigableDict&#34;, guide_style=&#34;dim&#34;)
        walk_dict_tree(self, tree, text_style=&#34;dark grey&#34;)
        return tree

    def _save(self, fd, indent: int = 0):
        &#34;&#34;&#34;
        Recursive method to write the dictionary to the file descriptor.

        Indentation is done in steps of four spaces, i.e. `&#39;    &#39;*indent`.

        Args:
            fd: a file descriptor as returned by the open() function
            indent (int): indentation level of each line [default = 0]

        &#34;&#34;&#34;
        from egse.device import DeviceInterface

        # Note that the .items() method returns the actual values of the keys and doesn&#39;t use the
        # __getattribute__ or __getitem__ methods. So the raw value is returned and not the
        # _processed_ value.

        for k, v in self.items():

            # history shall be saved last, skip it for now

            if k == &#34;history&#34;:
                continue

            # make sure to escape a colon in the key name

            if isinstance(k, str) and &#34;:&#34; in k:
                k = &#39;&#34;&#39; + k + &#39;&#34;&#39;

            if isinstance(v, NavigableDict):
                fd.write(f&#34;{&#39;    &#39;*indent}{k}:\n&#34;)
                v._save(fd, indent + 1)
                fd.flush()
                continue

            if isinstance(v, DeviceInterface):
                v = f&#34;class//{v.__module__}.{v.__class__.__name__}&#34;
            if isinstance(v, float):
                v = f&#34;{v:.6E}&#34;
            fd.write(f&#34;{&#39;    &#39;*indent}{k}: {v}\n&#34;)
            fd.flush()

        # now save the history as the last item

        if &#34;history&#34; in self:
            fd.write(f&#34;{&#39;    &#39; * indent}history:\n&#34;)
            self.history._save(fd, indent + 1)

    def get_memoized_keys(self):
        return list(self.__dict__[&#34;_memoized&#34;].keys())


class Setup(NavigableDict):
    &#34;&#34;&#34;The Setup class represents a version of the configuration of the test facility, the
    test setup and the Camera Under Test (CUT).&#34;&#34;&#34;

    def __init__(self, nav_dict: NavigableDict = None):
        super().__init__(nav_dict or {})

    @staticmethod
    def from_dict(my_dict):
        &#34;&#34;&#34;Create a Setup from a given dictionary.

        Remember that all keys in the given dictionary shall be of type &#39;str&#39; in order to be
        accessible as attributes.

        Examples:
            &gt;&gt;&gt; setup = Setup.from_dict({&#34;ID&#34;: &#34;my-setup-001&#34;, &#34;version&#34;: &#34;0.1.0&#34;})
            &gt;&gt;&gt; assert setup[&#34;ID&#34;] == setup.ID == &#34;my-setup-001&#34;

        &#34;&#34;&#34;
        return Setup(my_dict)

    @staticmethod
    def from_yaml_string(yaml_content: str = None):
        &#34;&#34;&#34;Loads a Setup from the given YAML string.

        This method is mainly used for easy creation of Setups from strings during unit tests.

        Args:
            yaml_content (str): a string containing YAML

        Returns:
            a Setup that was loaded from the content of the given string.
        &#34;&#34;&#34;

        if not yaml_content:
            raise ValueError(&#34;Invalid argument to function: No input string or None given.&#34;)

        setup_dict = yaml.safe_load(yaml_content)

        if &#34;Setup&#34; in setup_dict:
            setup_dict = setup_dict[&#34;Setup&#34;]

        return Setup(setup_dict)

    @staticmethod
    @lru_cache
    def from_yaml_file(filename: Union[str, Path] = None):
        &#34;&#34;&#34;Loads a Setup from the given YAML file.

        Args:
            filename (str): the path of the YAML file to be loaded

        Returns:
            a Setup that was loaded from the given location.
        &#34;&#34;&#34;
        from egse.settings import Settings

        if not filename:
            raise ValueError(&#34;Invalid argument to function: No filename or None given.&#34;)

        setup_dict = Settings.load(&#34;Setup&#34;, filename=filename, force=True)

        setup = Setup(setup_dict)
        setup.set_private_attribute(&#34;_filename&#34;, filename)
        if setup_id := _parse_filename_for_setup_id(str(filename)):
            setup.set_private_attribute(&#34;_setup_id&#34;, setup_id)

        return setup

    def to_yaml_file(self, filename=None):
        &#34;&#34;&#34;Saves a NavigableDict to a YAML file.

        When no filename is provided, this method will look for a &#39;private&#39; attribute
        `_filename` and use that to save the data.

        Args:
            filename (str): the path of the YAML file where to save the data

        .. note::
            This method will **overwrite** the original or given YAML file and therefore you might
            lose proper formatting and/or comments.

        &#34;&#34;&#34;
        if not filename:
            try:
                filename = self.get_private_attribute(&#34;_filename&#34;)
            except KeyError:
                raise ValueError(&#34;No filename given or known, can not save Setup.&#34;)

        print(f&#34;Saving Setup to {filename}&#34;)

        with Path(filename).open(&#34;w&#34;) as fd:

            fd.write(
                f&#34;# Setup generated by:\n&#34;
                f&#34;#\n&#34;
                f&#34;#    Setup.to_yaml_file(setup, filename=&#39;{filename}&#39;)\n#\n&#34;
            )
            fd.write(f&#34;# Created on {format_datetime()}\n\n&#34;)
            fd.write(&#34;Setup:\n&#34;)

            self._save(fd, indent=1)

        self.set_private_attribute(&#34;_filename&#34;, filename)

    @staticmethod
    def compare(setup_1: NavigableDict, setup_2: NavigableDict):
        from egse.device import DeviceInterface
        from egse.dpu import DPUSimulator

        return DeepDiff(setup_1, setup_2, exclude_types={DeviceInterface, DPUSimulator})

    # def get_devices(self):
    #     &#34;&#34;&#34;Returns a list of devices for the current setup.

    #     Returns:
    #         - List of devices for the current setup.
    #     &#34;&#34;&#34;

    #     devices = []

    #     Setup.walk(self, &#34;device&#34;, devices)

    #     return devices

    @staticmethod
    def find_devices(node: NavigableDict, devices={}):
        &#34;&#34;&#34;
        Returns a dictionary with the devices that are included in the setup.  The keys
        in the dictionary are taken from the &#34;device_name&#34; entries in the setup file. The
        corresponding values in the dictionary are taken from the &#34;device&#34; entries in the
        setup file.

        Args:
            - node: Dictionary in which to look for the devices (and their names).
            - devices: Dictionary in which to include the devices in the setup.

        Returns:
            - Dictionary with the devices that are included in the setup.
        &#34;&#34;&#34;

        for sub_node in node.values():

            if isinstance(sub_node, NavigableDict):

                if (&#34;device&#34; in sub_node) and (&#34;device_name&#34; in sub_node):

                    device = sub_node.get_raw_value(&#34;device&#34;)

                    if &#34;device_args&#34; in sub_node:
                        device_args = sub_node.get_raw_value(&#34;device_args&#34;)
                    else:
                        device_args = ()

                    devices[sub_node[&#34;device_name&#34;]] = (device, device_args)

                else:

                    Setup.find_devices(sub_node, devices=devices)

        return devices

    @staticmethod
    def walk(node: dict, key_of_interest, leaf_list):

        &#34;&#34;&#34;
        Walk through the given dictionary, in a recursive way, appending the leaf with
        the given keyword to the given list.

        Args:
            - node: Dictionary in which to look for leaves with the given keyword.
            - key_of_interest: Key to look for in the leaves of the given dictionary.
            - leaf_list: List to which to add the leaves with the given keyword.

        Returns:
            - Given list with the leaves (with the given keyword) in the given dictionary
              appended to it.
        &#34;&#34;&#34;

        for key, sub_node in node.items():

            if isinstance(sub_node, dict):

                Setup.walk(sub_node, key_of_interest, leaf_list)

            elif key == key_of_interest:

                leaf_list.append(sub_node)

    def __rich__(self) -&gt; Tree:
        tree = super().__rich__()
        if self.has_private_attribute(&#34;_setup_id&#34;):
            setup_id = self.get_private_attribute(&#39;_setup_id&#39;)
            tree.add(f&#34;Setup ID: {setup_id}&#34;, style=&#34;grey50&#34;)
        if self.has_private_attribute(&#34;_filename&#34;):
            filename = self.get_private_attribute(&#39;_filename&#39;)
            tree.add(f&#34;Loaded from: {filename}&#34;, style=&#34;grey50&#34;)
        return tree

    def get_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Returns the Setup ID (as a string) or None when no setup id could be identified.&#34;&#34;&#34;
        if self.has_private_attribute(&#34;_setup_id&#34;):
            return self.get_private_attribute(&#39;_setup_id&#39;)
        else:
            return None

    def get_filename(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Returns the filename for this Setup or None when no filename could be determined.&#34;&#34;&#34;
        if self.has_private_attribute(&#34;_filename&#34;):
            return self.get_private_attribute(&#39;_filename&#39;)
        else:
            return None


def list_setups(**attr):
    &#34;&#34;&#34;
    This is a function to be used for interactive use, it will print to the terminal (stdout) a
    list of Setups known at the Configuration Manager. This list is sorted with the most recent (
    highest) value last.

    The list can be restricted with key:value pairs (keyword arguments). This _search_ mechanism
    allows us to find all Setups that adhere to the key:value pairs, e.g. to find all Setups for
    CSL at position 2, use:

    &gt;&gt;&gt; list_setups(site_id=&#34;CSL&#34;, position=2)

    To have a nested keyword search (i.e. search by `gse.hexapod.ID`) then pass in
    `gse__hexapod__ID` as the keyword argument. Replace the &#39;.&#39; notation with double underscores
    &#39;__&#39;.

    &gt;&gt;&gt; list_setups(gse__hexapod__ID=4)
    &#34;&#34;&#34;

    from egse.confman import ConfigurationManagerProxy

    try:
        with ConfigurationManagerProxy() as proxy:
            setups = proxy.list_setups(**attr)
        if setups:
            # We want to have the most recent (highest id number) last, but keep the site together
            setups = sorted(setups, key=lambda x: (x[1], x[0]))
            print(&#34;\n&#34;.join(f&#34;{setup}&#34; for setup in setups))
        else:
            print(&#34;no Setups found&#34;)
    except ConnectionError:
        print(&#34;Could not make a connection with the Configuration Manager, no Setup to show you.&#34;)


def get_setup(setup_id: int = None):
    &#34;&#34;&#34;
    Retrieve the currently active Setup from the configuration manager.

    When a setup_id is provided, that setup will be returned, but not loaded in the configuration
    manager. This function does NOT change the configuration manager.

    This function is for interactive use and consults the configuration manager server. Don&#39;t use
    this within the test script, but use the `GlobalState.setup` property instead.
    &#34;&#34;&#34;
    from egse.confman import ConfigurationManagerProxy

    try:
        with ConfigurationManagerProxy() as proxy:
            setup = proxy.get_setup(setup_id)
        return setup
    except ConnectionError as exc:
        print(
            &#34;Could not make a connection with the Configuration Manager, no Setup returned.&#34;
        )


def _check_conditions_for_get_path_of_setup_file(site_id: str) -&gt; Path:
    &#34;&#34;&#34;
    Check some pre-conditions that need to be met before we try to determine the file path for
    the requested Setup file.

    The following checks are performed:

    * if the environment variable &#39;PLATO_CONF_REPO_LOCATION&#39; is set

    * if the directory specified in the env variable actually exists

    * if the folder with the Setups exists for the given site_id


    Args:
        site_id (str): the name of the test house

    Returns:
        The location of the Setup files for the given test house.

    Raises:
        LookupError when the environment variable is not set.

        NotADirectoryError when either the repository folder or the Setups folder doesn&#39;t exist.

    &#34;&#34;&#34;
    repo_location_env = &#39;PLATO_CONF_REPO_LOCATION&#39;
    if not (repo_location := os.environ.get(repo_location_env)):
        raise LookupError(
            f&#34;Environment variable doesn&#39;t exist, please define {repo_location_env} and try again.&#34;
        )

    repo_location = Path(repo_location)
    setup_location = repo_location / &#39;data&#39; / site_id / &#39;conf&#39;

    if not repo_location.is_dir():
        raise NotADirectoryError(
            f&#34;The location of the repository for Setup files doesn&#39;t exist: {repo_location!s}. &#34;
            f&#34;Please check the environment variable {repo_location_env}.&#34;
        )

    if not setup_location.is_dir():
        raise NotADirectoryError(
            f&#34;The location of the Setup files doesn&#39;t exist: {setup_location!s}. &#34;
            f&#34;Please check if the given {site_id=} is correct.&#34;
        )

    return setup_location


def get_path_of_setup_file(setup_id: int, site_id: str) -&gt; Path:
    &#34;&#34;&#34;
    Returns the Path to the last Setup file for the given site_id. The last Setup file is the file
    with the largest setup_id number.

    This function needs the environment variable PLATO_CONF_REPO_LOCATION to be defined as the
    location of the repository &#39;plato-cgse-conf&#39; on your disk.

    Args:
        setup_id (int): the identifier for the requested Setup
        site_id (str): the test house name, one of CSL, SRON, IAS, INTA

    Returns:
        The full path to the requested Setup file.

    Raises:
        LookupError when the environment variable is not set.

        NotADirectoryError when either the repository folder or the Setups folder doesn&#39;t exist.

        FileNotFound when no Setup file can be found for the given arguments.

    &#34;&#34;&#34;

    setup_location = _check_conditions_for_get_path_of_setup_file(site_id)

    if setup_id:
        files = list(setup_location.glob(f&#39;SETUP_{site_id}_{setup_id:05d}_*.yaml&#39;))

        if not files:
            raise FileNotFoundError(f&#34;No Setup found for {setup_id=} and {site_id=}.&#34;)

        file_path = Path(setup_location) / files[-1]
    else:
        files = setup_location.glob(&#39;SETUP*.yaml&#39;)

        last_file_parts = sorted([file.name.split(&#39;_&#39;) for file in files])[-1]
        file_path = Path(setup_location) / &#34;_&#34;.join(last_file_parts)

    sanity_check(file_path.is_file(), f&#34;The expected Setup file doesn&#39;t exist: {file_path!s}&#34;)

    return file_path


def load_setup(
        setup_id: int = None,
        site_id: str = None, from_disk: bool = False):
    &#34;&#34;&#34;
    This function loads the Setup corresponding with the given `setup_id`.

    Loading a Setup means:

    * that this Setup will also be loaded and activated in the configuration manager,
    * that this Setup will be available from the `GlobalState.setup`

    When no setup_id is provided, the current Setup is loaded from the configuration manager.

    Args:
        setup_id (int): the identifier for the Setup
        site_id (str): the name of the test house
        from_disk (bool): True if the Setup needs to be loaded from disk

    Returns:
        The requested Setup or None when the Setup could not be loaded from the
        configuration manager.

    &#34;&#34;&#34;
    from egse.state import GlobalState

    if from_disk:
        if site_id is None:
            raise ValueError(
                &#34;The site_id argument can not be empty when from_disk is given and True&#34;)

        setup_file_path = get_path_of_setup_file(setup_id, site_id)

        rich.print(
            f&#34;Loading {&#39;&#39; if setup_id else &#39;the latest &#39;}Setup {f&#39;{setup_id} &#39; if setup_id else &#39;&#39;}for {site_id}...&#34;
        )

        return Setup.from_yaml_file(setup_file_path)

    # When we arrive here the Setup shall be loaded from the Configuration manager

    from egse.confman import ConfigurationManagerProxy

    if setup_id is not None:
        try:
            with ConfigurationManagerProxy() as proxy:
                proxy.load_setup(setup_id)

        except ConnectionError:
            MODULE_LOGGER.warning(
                &#34;Could not make a connection with the Configuration Manager, no Setup to show you.&#34;
            )
            rich.print(
                &#34;\n&#34;
                &#34;If you are not running this from an operational machine, do not have a CM &#34;
                &#34;running locally or don&#39;t know what this means, then: \n&#34;
                &#34;  (1) define the environment variable &#39;PLATO_CONF_REPO_LOCATION&#39; and \n&#34;
                &#34;      it points to the location of the plato-cgse-conf repository,\n&#34;
                &#34;  (2) try again using the argument &#39;from_disk=True&#39;.\n&#34;
            )

    return GlobalState.load_setup()


def submit_setup(setup: Setup, description: str):
    &#34;&#34;&#34;
    Submit the given Setup to the Configuration Manager.

    When you submit a Setup, the Configuration Manager will save this Setup with the
    next (new) setup id and make this Setup the current Setup in the Configuration manager
    unless you have explicitly set `replace=False` in which case the current Setup will
    not be replaced with the new Setup.

    Args:
        setup (Setup): a (new) Setup to submit to the configuration manager
        description (str): one-liner to help identifying the Setup afterwards
    Returns:
        The Setup ID of the newly created Setup or None.
    &#34;&#34;&#34;
    # We have not yet decided if this option should be made available. Therefore, we
    # leave it here as hardcoded True.

    # replace (bool): True if the current Setup in the configuration manager shall
    #                 be replaced by this new Setup. [default=True]
    replace: bool = True

    from egse.confman import ConfigurationManagerProxy

    try:
        with ConfigurationManagerProxy() as proxy:
            setup = proxy.submit_setup(setup, description, replace)

        if setup is None:
            rich.print(&#34;[red]Submit failed for given Setup, no reason given.[/red]&#34;)
        elif isinstance(setup, Failure):
            rich.print(f&#34;[red]Submit failed for given Setup[/red]: {setup}&#34;)
            setup = None
        elif replace:
            rich.print(textwrap.dedent(
                f&#34;&#34;&#34;\
                [green]
                Your new setup has been submitted and pushed to GitHub. The new setup is also 
                activated in the configuration manager. Load the new setup in your session with:

                    setup = load_setup() 
                [/]
                &#34;&#34;&#34;
            ))
        else:
            rich.print(textwrap.dedent(
                f&#34;&#34;&#34;\
                [dark_orange]
                Your new setup has been submitted and pushed to GitHub, but has not been
                activated in the configuration manager. To activate this setup, use the
                following command: 

                    setup = load_setup({str(setup.get_id())})
                [/]
                &#34;&#34;&#34;)
            )

        return setup.get_id() if setup is not None else None

    except ConnectionError:
        rich.print(&#34;Could not make a connection with the Configuration Manager, no Setup was submitted.&#34;)
    except NotImplementedError:
        rich.print(textwrap.dedent(
            &#34;&#34;&#34;\
            Caught a NotImplementedError. That usually means the configuration manager is not running or 
            can not be reached. Check on the egse-server if the `cm_cs` process is running. If not you will
            need to be restart the core services.
            &#34;&#34;&#34;
        ))


__all__ = [
    &#34;Setup&#34;,
    &#34;list_setups&#34;,
    &#34;load_setup&#34;,
    &#34;get_setup&#34;,
    &#34;submit_setup&#34;,
    &#34;SetupError&#34;,
    &#34;load_last_setup_id&#34;,
    &#34;save_last_setup_id&#34;,
]

if __name__ == &#34;__main__&#34;:

    import sys
    import argparse

    from rich import print

    from egse.config import find_files
    from egse.settings import Settings

    SITE = Settings.load(&#34;SITE&#34;)
    location = os.environ.get(&#34;PLATO_CONF_DATA_LOCATION&#34;)
    parser = argparse.ArgumentParser(
        description=textwrap.dedent(f&#34;&#34;&#34;\
            Print out the Setup for the given setup-id. The Setup will 
            be loaded from the location given by the environment variable 
            PLATO_CONF_DATA_LOCATION. If this env is not set, the Setup 
            will be searched from the current directory.&#34;&#34;&#34;
        ),
        epilog=f&#34;PLATO_CONF_DATA_LOCATION={location}&#34;
    )
    parser.add_argument(
        &#34;--setup-id&#34;, type=int, default=-1,
        help=&#34;the Setup ID. If not given, the last Setup will be selected.&#34;)
    parser.add_argument(&#34;--list&#34;, &#34;-l&#34;, action=&#34;store_true&#34;, help=&#34;list available Setups.&#34;)
    parser.add_argument(&#34;--use-cm&#34;, action=&#34;store_true&#34;, help=&#34;use the configuration manager.&#34;)
    args = parser.parse_args()

    if args.use_cm:
        from egse.confman import ConfigurationManagerProxy

        with ConfigurationManagerProxy() as cm:
            if args.list:
                print(cm.list_setups())
            else:
                print(cm.get_setup())
        sys.exit(0)

    if args.list:
        files = find_files(f&#34;SETUP_{SITE.ID}_*_*.yaml&#34;, root=location)
        files = list(files)
        if files:
            location = files[0].parent.resolve()
        print(sorted([f.name for f in files]))
        print(f&#34;Loaded from [purple]{location}.&#34;)
    else:
        setup_id = args.setup_id
        if setup_id == -1:
            setup_files = find_files(f&#34;SETUP_{SITE.ID}_*_*.yaml&#34;, root=location)
        else:
            setup_files = find_files(f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=location)
        setup_file = sorted(setup_files)[-1]
        setup = Setup.from_yaml_file(setup_file)
        print(setup)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.setup.get_setup"><code class="name flex">
<span>def <span class="ident">get_setup</span></span>(<span>setup_id:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the currently active Setup from the configuration manager.</p>
<p>When a setup_id is provided, that setup will be returned, but not loaded in the configuration
manager. This function does NOT change the configuration manager.</p>
<p>This function is for interactive use and consults the configuration manager server. Don't use
this within the test script, but use the <code>GlobalState.setup</code> property instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_setup(setup_id: int = None):
    &#34;&#34;&#34;
    Retrieve the currently active Setup from the configuration manager.

    When a setup_id is provided, that setup will be returned, but not loaded in the configuration
    manager. This function does NOT change the configuration manager.

    This function is for interactive use and consults the configuration manager server. Don&#39;t use
    this within the test script, but use the `GlobalState.setup` property instead.
    &#34;&#34;&#34;
    from egse.confman import ConfigurationManagerProxy

    try:
        with ConfigurationManagerProxy() as proxy:
            setup = proxy.get_setup(setup_id)
        return setup
    except ConnectionError as exc:
        print(
            &#34;Could not make a connection with the Configuration Manager, no Setup returned.&#34;
        )</code></pre>
</details>
</dd>
<dt id="egse.setup.list_setups"><code class="name flex">
<span>def <span class="ident">list_setups</span></span>(<span>**attr)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a function to be used for interactive use, it will print to the terminal (stdout) a
list of Setups known at the Configuration Manager. This list is sorted with the most recent (
highest) value last.</p>
<p>The list can be restricted with key:value pairs (keyword arguments). This <em>search</em> mechanism
allows us to find all Setups that adhere to the key:value pairs, e.g. to find all Setups for
CSL at position 2, use:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; list_setups(site_id=&quot;CSL&quot;, position=2)
</code></pre>
<p>To have a nested keyword search (i.e. search by <code>gse.hexapod.ID</code>) then pass in
<code>gse__hexapod__ID</code> as the keyword argument. Replace the '.' notation with double underscores
'__'.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; list_setups(gse__hexapod__ID=4)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_setups(**attr):
    &#34;&#34;&#34;
    This is a function to be used for interactive use, it will print to the terminal (stdout) a
    list of Setups known at the Configuration Manager. This list is sorted with the most recent (
    highest) value last.

    The list can be restricted with key:value pairs (keyword arguments). This _search_ mechanism
    allows us to find all Setups that adhere to the key:value pairs, e.g. to find all Setups for
    CSL at position 2, use:

    &gt;&gt;&gt; list_setups(site_id=&#34;CSL&#34;, position=2)

    To have a nested keyword search (i.e. search by `gse.hexapod.ID`) then pass in
    `gse__hexapod__ID` as the keyword argument. Replace the &#39;.&#39; notation with double underscores
    &#39;__&#39;.

    &gt;&gt;&gt; list_setups(gse__hexapod__ID=4)
    &#34;&#34;&#34;

    from egse.confman import ConfigurationManagerProxy

    try:
        with ConfigurationManagerProxy() as proxy:
            setups = proxy.list_setups(**attr)
        if setups:
            # We want to have the most recent (highest id number) last, but keep the site together
            setups = sorted(setups, key=lambda x: (x[1], x[0]))
            print(&#34;\n&#34;.join(f&#34;{setup}&#34; for setup in setups))
        else:
            print(&#34;no Setups found&#34;)
    except ConnectionError:
        print(&#34;Could not make a connection with the Configuration Manager, no Setup to show you.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.setup.load_last_setup_id"><code class="name flex">
<span>def <span class="ident">load_last_setup_id</span></span>(<span>) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ID of the last Setup that was used by the configuration manager.
The file shall only contain the Setup ID which must be an integer on the first line of the file.
If no such ID can be found, the Setup ID = 0 will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_last_setup_id() -&gt; int:
    &#34;&#34;&#34;
    Returns the ID of the last Setup that was used by the configuration manager.
    The file shall only contain the Setup ID which must be an integer on the first line of the file.
    If no such ID can be found, the Setup ID = 0 will be returned.
    &#34;&#34;&#34;

    last_setup_id_file_path = get_last_setup_id_file_path()
    try:
        with last_setup_id_file_path.open(&#39;r&#39;) as fd:
            setup_id = int(fd.read().strip())
    except FileNotFoundError:
        setup_id = 0
        save_last_setup_id(setup_id)

    return setup_id</code></pre>
</details>
</dd>
<dt id="egse.setup.load_setup"><code class="name flex">
<span>def <span class="ident">load_setup</span></span>(<span>setup_id:Â intÂ =Â None, site_id:Â strÂ =Â None, from_disk:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>This function loads the Setup corresponding with the given <code>setup_id</code>.</p>
<p>Loading a Setup means:</p>
<ul>
<li>that this Setup will also be loaded and activated in the configuration manager,</li>
<li>that this Setup will be available from the <code>GlobalState.setup</code></li>
</ul>
<p>When no setup_id is provided, the current Setup is loaded from the configuration manager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>setup_id</code></strong> :&ensp;<code>int</code></dt>
<dd>the identifier for the Setup</dd>
<dt><strong><code>site_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the test house</dd>
<dt><strong><code>from_disk</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the Setup needs to be loaded from disk</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested Setup or None when the Setup could not be loaded from the
configuration manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_setup(
        setup_id: int = None,
        site_id: str = None, from_disk: bool = False):
    &#34;&#34;&#34;
    This function loads the Setup corresponding with the given `setup_id`.

    Loading a Setup means:

    * that this Setup will also be loaded and activated in the configuration manager,
    * that this Setup will be available from the `GlobalState.setup`

    When no setup_id is provided, the current Setup is loaded from the configuration manager.

    Args:
        setup_id (int): the identifier for the Setup
        site_id (str): the name of the test house
        from_disk (bool): True if the Setup needs to be loaded from disk

    Returns:
        The requested Setup or None when the Setup could not be loaded from the
        configuration manager.

    &#34;&#34;&#34;
    from egse.state import GlobalState

    if from_disk:
        if site_id is None:
            raise ValueError(
                &#34;The site_id argument can not be empty when from_disk is given and True&#34;)

        setup_file_path = get_path_of_setup_file(setup_id, site_id)

        rich.print(
            f&#34;Loading {&#39;&#39; if setup_id else &#39;the latest &#39;}Setup {f&#39;{setup_id} &#39; if setup_id else &#39;&#39;}for {site_id}...&#34;
        )

        return Setup.from_yaml_file(setup_file_path)

    # When we arrive here the Setup shall be loaded from the Configuration manager

    from egse.confman import ConfigurationManagerProxy

    if setup_id is not None:
        try:
            with ConfigurationManagerProxy() as proxy:
                proxy.load_setup(setup_id)

        except ConnectionError:
            MODULE_LOGGER.warning(
                &#34;Could not make a connection with the Configuration Manager, no Setup to show you.&#34;
            )
            rich.print(
                &#34;\n&#34;
                &#34;If you are not running this from an operational machine, do not have a CM &#34;
                &#34;running locally or don&#39;t know what this means, then: \n&#34;
                &#34;  (1) define the environment variable &#39;PLATO_CONF_REPO_LOCATION&#39; and \n&#34;
                &#34;      it points to the location of the plato-cgse-conf repository,\n&#34;
                &#34;  (2) try again using the argument &#39;from_disk=True&#39;.\n&#34;
            )

    return GlobalState.load_setup()</code></pre>
</details>
</dd>
<dt id="egse.setup.save_last_setup_id"><code class="name flex">
<span>def <span class="ident">save_last_setup_id</span></span>(<span>setup_id:Â intÂ |Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the given Setup ID persistent, so it can be restored upon the next startup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_last_setup_id(setup_id: int | str):
    &#34;&#34;&#34;Makes the given Setup ID persistent, so it can be restored upon the next startup.&#34;&#34;&#34;

    last_setup_id_file_path = get_last_setup_id_file_path()
    with last_setup_id_file_path.open(&#39;w&#39;) as fd:
        fd.write(f&#34;{int(setup_id):d}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.setup.submit_setup"><code class="name flex">
<span>def <span class="ident">submit_setup</span></span>(<span>setup:Â <a title="egse.setup.Setup" href="#egse.setup.Setup">Setup</a>, description:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Submit the given Setup to the Configuration Manager.</p>
<p>When you submit a Setup, the Configuration Manager will save this Setup with the
next (new) setup id and make this Setup the current Setup in the Configuration manager
unless you have explicitly set <code>replace=False</code> in which case the current Setup will
not be replaced with the new Setup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>setup</code></strong> :&ensp;<code><a title="egse.setup.Setup" href="#egse.setup.Setup">Setup</a></code></dt>
<dd>a (new) Setup to submit to the configuration manager</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>one-liner to help identifying the Setup afterwards</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The Setup ID of the newly created Setup or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_setup(setup: Setup, description: str):
    &#34;&#34;&#34;
    Submit the given Setup to the Configuration Manager.

    When you submit a Setup, the Configuration Manager will save this Setup with the
    next (new) setup id and make this Setup the current Setup in the Configuration manager
    unless you have explicitly set `replace=False` in which case the current Setup will
    not be replaced with the new Setup.

    Args:
        setup (Setup): a (new) Setup to submit to the configuration manager
        description (str): one-liner to help identifying the Setup afterwards
    Returns:
        The Setup ID of the newly created Setup or None.
    &#34;&#34;&#34;
    # We have not yet decided if this option should be made available. Therefore, we
    # leave it here as hardcoded True.

    # replace (bool): True if the current Setup in the configuration manager shall
    #                 be replaced by this new Setup. [default=True]
    replace: bool = True

    from egse.confman import ConfigurationManagerProxy

    try:
        with ConfigurationManagerProxy() as proxy:
            setup = proxy.submit_setup(setup, description, replace)

        if setup is None:
            rich.print(&#34;[red]Submit failed for given Setup, no reason given.[/red]&#34;)
        elif isinstance(setup, Failure):
            rich.print(f&#34;[red]Submit failed for given Setup[/red]: {setup}&#34;)
            setup = None
        elif replace:
            rich.print(textwrap.dedent(
                f&#34;&#34;&#34;\
                [green]
                Your new setup has been submitted and pushed to GitHub. The new setup is also 
                activated in the configuration manager. Load the new setup in your session with:

                    setup = load_setup() 
                [/]
                &#34;&#34;&#34;
            ))
        else:
            rich.print(textwrap.dedent(
                f&#34;&#34;&#34;\
                [dark_orange]
                Your new setup has been submitted and pushed to GitHub, but has not been
                activated in the configuration manager. To activate this setup, use the
                following command: 

                    setup = load_setup({str(setup.get_id())})
                [/]
                &#34;&#34;&#34;)
            )

        return setup.get_id() if setup is not None else None

    except ConnectionError:
        rich.print(&#34;Could not make a connection with the Configuration Manager, no Setup was submitted.&#34;)
    except NotImplementedError:
        rich.print(textwrap.dedent(
            &#34;&#34;&#34;\
            Caught a NotImplementedError. That usually means the configuration manager is not running or 
            can not be reached. Check on the egse-server if the `cm_cs` process is running. If not you will
            need to be restart the core services.
            &#34;&#34;&#34;
        ))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.setup.Setup"><code class="flex name class">
<span>class <span class="ident">Setup</span></span>
<span>(</span><span>nav_dict:Â NavigableDictÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Setup class represents a version of the configuration of the test facility, the
test setup and the Camera Under Test (CUT).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code>dict</code></dt>
<dd>the original dictionary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Setup(NavigableDict):
    &#34;&#34;&#34;The Setup class represents a version of the configuration of the test facility, the
    test setup and the Camera Under Test (CUT).&#34;&#34;&#34;

    def __init__(self, nav_dict: NavigableDict = None):
        super().__init__(nav_dict or {})

    @staticmethod
    def from_dict(my_dict):
        &#34;&#34;&#34;Create a Setup from a given dictionary.

        Remember that all keys in the given dictionary shall be of type &#39;str&#39; in order to be
        accessible as attributes.

        Examples:
            &gt;&gt;&gt; setup = Setup.from_dict({&#34;ID&#34;: &#34;my-setup-001&#34;, &#34;version&#34;: &#34;0.1.0&#34;})
            &gt;&gt;&gt; assert setup[&#34;ID&#34;] == setup.ID == &#34;my-setup-001&#34;

        &#34;&#34;&#34;
        return Setup(my_dict)

    @staticmethod
    def from_yaml_string(yaml_content: str = None):
        &#34;&#34;&#34;Loads a Setup from the given YAML string.

        This method is mainly used for easy creation of Setups from strings during unit tests.

        Args:
            yaml_content (str): a string containing YAML

        Returns:
            a Setup that was loaded from the content of the given string.
        &#34;&#34;&#34;

        if not yaml_content:
            raise ValueError(&#34;Invalid argument to function: No input string or None given.&#34;)

        setup_dict = yaml.safe_load(yaml_content)

        if &#34;Setup&#34; in setup_dict:
            setup_dict = setup_dict[&#34;Setup&#34;]

        return Setup(setup_dict)

    @staticmethod
    @lru_cache
    def from_yaml_file(filename: Union[str, Path] = None):
        &#34;&#34;&#34;Loads a Setup from the given YAML file.

        Args:
            filename (str): the path of the YAML file to be loaded

        Returns:
            a Setup that was loaded from the given location.
        &#34;&#34;&#34;
        from egse.settings import Settings

        if not filename:
            raise ValueError(&#34;Invalid argument to function: No filename or None given.&#34;)

        setup_dict = Settings.load(&#34;Setup&#34;, filename=filename, force=True)

        setup = Setup(setup_dict)
        setup.set_private_attribute(&#34;_filename&#34;, filename)
        if setup_id := _parse_filename_for_setup_id(str(filename)):
            setup.set_private_attribute(&#34;_setup_id&#34;, setup_id)

        return setup

    def to_yaml_file(self, filename=None):
        &#34;&#34;&#34;Saves a NavigableDict to a YAML file.

        When no filename is provided, this method will look for a &#39;private&#39; attribute
        `_filename` and use that to save the data.

        Args:
            filename (str): the path of the YAML file where to save the data

        .. note::
            This method will **overwrite** the original or given YAML file and therefore you might
            lose proper formatting and/or comments.

        &#34;&#34;&#34;
        if not filename:
            try:
                filename = self.get_private_attribute(&#34;_filename&#34;)
            except KeyError:
                raise ValueError(&#34;No filename given or known, can not save Setup.&#34;)

        print(f&#34;Saving Setup to {filename}&#34;)

        with Path(filename).open(&#34;w&#34;) as fd:

            fd.write(
                f&#34;# Setup generated by:\n&#34;
                f&#34;#\n&#34;
                f&#34;#    Setup.to_yaml_file(setup, filename=&#39;{filename}&#39;)\n#\n&#34;
            )
            fd.write(f&#34;# Created on {format_datetime()}\n\n&#34;)
            fd.write(&#34;Setup:\n&#34;)

            self._save(fd, indent=1)

        self.set_private_attribute(&#34;_filename&#34;, filename)

    @staticmethod
    def compare(setup_1: NavigableDict, setup_2: NavigableDict):
        from egse.device import DeviceInterface
        from egse.dpu import DPUSimulator

        return DeepDiff(setup_1, setup_2, exclude_types={DeviceInterface, DPUSimulator})

    # def get_devices(self):
    #     &#34;&#34;&#34;Returns a list of devices for the current setup.

    #     Returns:
    #         - List of devices for the current setup.
    #     &#34;&#34;&#34;

    #     devices = []

    #     Setup.walk(self, &#34;device&#34;, devices)

    #     return devices

    @staticmethod
    def find_devices(node: NavigableDict, devices={}):
        &#34;&#34;&#34;
        Returns a dictionary with the devices that are included in the setup.  The keys
        in the dictionary are taken from the &#34;device_name&#34; entries in the setup file. The
        corresponding values in the dictionary are taken from the &#34;device&#34; entries in the
        setup file.

        Args:
            - node: Dictionary in which to look for the devices (and their names).
            - devices: Dictionary in which to include the devices in the setup.

        Returns:
            - Dictionary with the devices that are included in the setup.
        &#34;&#34;&#34;

        for sub_node in node.values():

            if isinstance(sub_node, NavigableDict):

                if (&#34;device&#34; in sub_node) and (&#34;device_name&#34; in sub_node):

                    device = sub_node.get_raw_value(&#34;device&#34;)

                    if &#34;device_args&#34; in sub_node:
                        device_args = sub_node.get_raw_value(&#34;device_args&#34;)
                    else:
                        device_args = ()

                    devices[sub_node[&#34;device_name&#34;]] = (device, device_args)

                else:

                    Setup.find_devices(sub_node, devices=devices)

        return devices

    @staticmethod
    def walk(node: dict, key_of_interest, leaf_list):

        &#34;&#34;&#34;
        Walk through the given dictionary, in a recursive way, appending the leaf with
        the given keyword to the given list.

        Args:
            - node: Dictionary in which to look for leaves with the given keyword.
            - key_of_interest: Key to look for in the leaves of the given dictionary.
            - leaf_list: List to which to add the leaves with the given keyword.

        Returns:
            - Given list with the leaves (with the given keyword) in the given dictionary
              appended to it.
        &#34;&#34;&#34;

        for key, sub_node in node.items():

            if isinstance(sub_node, dict):

                Setup.walk(sub_node, key_of_interest, leaf_list)

            elif key == key_of_interest:

                leaf_list.append(sub_node)

    def __rich__(self) -&gt; Tree:
        tree = super().__rich__()
        if self.has_private_attribute(&#34;_setup_id&#34;):
            setup_id = self.get_private_attribute(&#39;_setup_id&#39;)
            tree.add(f&#34;Setup ID: {setup_id}&#34;, style=&#34;grey50&#34;)
        if self.has_private_attribute(&#34;_filename&#34;):
            filename = self.get_private_attribute(&#39;_filename&#39;)
            tree.add(f&#34;Loaded from: {filename}&#34;, style=&#34;grey50&#34;)
        return tree

    def get_id(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Returns the Setup ID (as a string) or None when no setup id could be identified.&#34;&#34;&#34;
        if self.has_private_attribute(&#34;_setup_id&#34;):
            return self.get_private_attribute(&#39;_setup_id&#39;)
        else:
            return None

    def get_filename(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Returns the filename for this Setup or None when no filename could be determined.&#34;&#34;&#34;
        if self.has_private_attribute(&#34;_filename&#34;):
            return self.get_private_attribute(&#39;_filename&#39;)
        else:
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>egse.setup.NavigableDict</li>
<li>builtins.dict</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.setup.Setup.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>setup_1:Â NavigableDict, setup_2:Â NavigableDict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def compare(setup_1: NavigableDict, setup_2: NavigableDict):
    from egse.device import DeviceInterface
    from egse.dpu import DPUSimulator

    return DeepDiff(setup_1, setup_2, exclude_types={DeviceInterface, DPUSimulator})</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.find_devices"><code class="name flex">
<span>def <span class="ident">find_devices</span></span>(<span>node:Â NavigableDict, devices={})</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with the devices that are included in the setup.
The keys
in the dictionary are taken from the "device_name" entries in the setup file. The
corresponding values in the dictionary are taken from the "device" entries in the
setup file.</p>
<h2 id="args">Args</h2>
<ul>
<li>node: Dictionary in which to look for the devices (and their names).</li>
<li>devices: Dictionary in which to include the devices in the setup.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Dictionary with the devices that are included in the setup.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def find_devices(node: NavigableDict, devices={}):
    &#34;&#34;&#34;
    Returns a dictionary with the devices that are included in the setup.  The keys
    in the dictionary are taken from the &#34;device_name&#34; entries in the setup file. The
    corresponding values in the dictionary are taken from the &#34;device&#34; entries in the
    setup file.

    Args:
        - node: Dictionary in which to look for the devices (and their names).
        - devices: Dictionary in which to include the devices in the setup.

    Returns:
        - Dictionary with the devices that are included in the setup.
    &#34;&#34;&#34;

    for sub_node in node.values():

        if isinstance(sub_node, NavigableDict):

            if (&#34;device&#34; in sub_node) and (&#34;device_name&#34; in sub_node):

                device = sub_node.get_raw_value(&#34;device&#34;)

                if &#34;device_args&#34; in sub_node:
                    device_args = sub_node.get_raw_value(&#34;device_args&#34;)
                else:
                    device_args = ()

                devices[sub_node[&#34;device_name&#34;]] = (device, device_args)

            else:

                Setup.find_devices(sub_node, devices=devices)

    return devices</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>my_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Setup from a given dictionary.</p>
<p>Remember that all keys in the given dictionary shall be of type 'str' in order to be
accessible as attributes.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; setup = Setup.from_dict({&quot;ID&quot;: &quot;my-setup-001&quot;, &quot;version&quot;: &quot;0.1.0&quot;})
&gt;&gt;&gt; assert setup[&quot;ID&quot;] == setup.ID == &quot;my-setup-001&quot;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(my_dict):
    &#34;&#34;&#34;Create a Setup from a given dictionary.

    Remember that all keys in the given dictionary shall be of type &#39;str&#39; in order to be
    accessible as attributes.

    Examples:
        &gt;&gt;&gt; setup = Setup.from_dict({&#34;ID&#34;: &#34;my-setup-001&#34;, &#34;version&#34;: &#34;0.1.0&#34;})
        &gt;&gt;&gt; assert setup[&#34;ID&#34;] == setup.ID == &#34;my-setup-001&#34;

    &#34;&#34;&#34;
    return Setup(my_dict)</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.from_yaml_file"><code class="name flex">
<span>def <span class="ident">from_yaml_file</span></span>(<span>filename:Â Union[str,Â Path]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a Setup from the given YAML file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the YAML file to be loaded</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a Setup that was loaded from the given location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@lru_cache
def from_yaml_file(filename: Union[str, Path] = None):
    &#34;&#34;&#34;Loads a Setup from the given YAML file.

    Args:
        filename (str): the path of the YAML file to be loaded

    Returns:
        a Setup that was loaded from the given location.
    &#34;&#34;&#34;
    from egse.settings import Settings

    if not filename:
        raise ValueError(&#34;Invalid argument to function: No filename or None given.&#34;)

    setup_dict = Settings.load(&#34;Setup&#34;, filename=filename, force=True)

    setup = Setup(setup_dict)
    setup.set_private_attribute(&#34;_filename&#34;, filename)
    if setup_id := _parse_filename_for_setup_id(str(filename)):
        setup.set_private_attribute(&#34;_setup_id&#34;, setup_id)

    return setup</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.from_yaml_string"><code class="name flex">
<span>def <span class="ident">from_yaml_string</span></span>(<span>yaml_content:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a Setup from the given YAML string.</p>
<p>This method is mainly used for easy creation of Setups from strings during unit tests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>yaml_content</code></strong> :&ensp;<code>str</code></dt>
<dd>a string containing YAML</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a Setup that was loaded from the content of the given string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_yaml_string(yaml_content: str = None):
    &#34;&#34;&#34;Loads a Setup from the given YAML string.

    This method is mainly used for easy creation of Setups from strings during unit tests.

    Args:
        yaml_content (str): a string containing YAML

    Returns:
        a Setup that was loaded from the content of the given string.
    &#34;&#34;&#34;

    if not yaml_content:
        raise ValueError(&#34;Invalid argument to function: No input string or None given.&#34;)

    setup_dict = yaml.safe_load(yaml_content)

    if &#34;Setup&#34; in setup_dict:
        setup_dict = setup_dict[&#34;Setup&#34;]

    return Setup(setup_dict)</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.walk"><code class="name flex">
<span>def <span class="ident">walk</span></span>(<span>node:Â dict, key_of_interest, leaf_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Walk through the given dictionary, in a recursive way, appending the leaf with
the given keyword to the given list.</p>
<h2 id="args">Args</h2>
<ul>
<li>node: Dictionary in which to look for leaves with the given keyword.</li>
<li>key_of_interest: Key to look for in the leaves of the given dictionary.</li>
<li>leaf_list: List to which to add the leaves with the given keyword.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Given list with the leaves (with the given keyword) in the given dictionary
appended to it.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def walk(node: dict, key_of_interest, leaf_list):

    &#34;&#34;&#34;
    Walk through the given dictionary, in a recursive way, appending the leaf with
    the given keyword to the given list.

    Args:
        - node: Dictionary in which to look for leaves with the given keyword.
        - key_of_interest: Key to look for in the leaves of the given dictionary.
        - leaf_list: List to which to add the leaves with the given keyword.

    Returns:
        - Given list with the leaves (with the given keyword) in the given dictionary
          appended to it.
    &#34;&#34;&#34;

    for key, sub_node in node.items():

        if isinstance(sub_node, dict):

            Setup.walk(sub_node, key_of_interest, leaf_list)

        elif key == key_of_interest:

            leaf_list.append(sub_node)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.setup.Setup.get_filename"><code class="name flex">
<span>def <span class="ident">get_filename</span></span>(<span>self) â€‘>Â Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the filename for this Setup or None when no filename could be determined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_filename(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Returns the filename for this Setup or None when no filename could be determined.&#34;&#34;&#34;
    if self.has_private_attribute(&#34;_filename&#34;):
        return self.get_private_attribute(&#39;_filename&#39;)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self) â€‘>Â Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Setup ID (as a string) or None when no setup id could be identified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Returns the Setup ID (as a string) or None when no setup id could be identified.&#34;&#34;&#34;
    if self.has_private_attribute(&#34;_setup_id&#34;):
        return self.get_private_attribute(&#39;_setup_id&#39;)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="egse.setup.Setup.to_yaml_file"><code class="name flex">
<span>def <span class="ident">to_yaml_file</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a NavigableDict to a YAML file.</p>
<p>When no filename is provided, this method will look for a 'private' attribute
<code>_filename</code> and use that to save the data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the YAML file where to save the data</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method will <strong>overwrite</strong> the original or given YAML file and therefore you might
lose proper formatting and/or comments.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_yaml_file(self, filename=None):
    &#34;&#34;&#34;Saves a NavigableDict to a YAML file.

    When no filename is provided, this method will look for a &#39;private&#39; attribute
    `_filename` and use that to save the data.

    Args:
        filename (str): the path of the YAML file where to save the data

    .. note::
        This method will **overwrite** the original or given YAML file and therefore you might
        lose proper formatting and/or comments.

    &#34;&#34;&#34;
    if not filename:
        try:
            filename = self.get_private_attribute(&#34;_filename&#34;)
        except KeyError:
            raise ValueError(&#34;No filename given or known, can not save Setup.&#34;)

    print(f&#34;Saving Setup to {filename}&#34;)

    with Path(filename).open(&#34;w&#34;) as fd:

        fd.write(
            f&#34;# Setup generated by:\n&#34;
            f&#34;#\n&#34;
            f&#34;#    Setup.to_yaml_file(setup, filename=&#39;{filename}&#39;)\n#\n&#34;
        )
        fd.write(f&#34;# Created on {format_datetime()}\n\n&#34;)
        fd.write(&#34;Setup:\n&#34;)

        self._save(fd, indent=1)

    self.set_private_attribute(&#34;_filename&#34;, filename)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.setup.SetupError"><code class="flex name class">
<span>class <span class="ident">SetupError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A setup-specific error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetupError(Exception):
    &#34;&#34;&#34; A setup-specific error.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#special-values">Special Values</a><ul>
<li><a href="#device-classes">Device Classes</a></li>
<li><a href="#data-files">Data Files</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="egse.setup.get_setup" href="#egse.setup.get_setup">get_setup</a></code></li>
<li><code><a title="egse.setup.list_setups" href="#egse.setup.list_setups">list_setups</a></code></li>
<li><code><a title="egse.setup.load_last_setup_id" href="#egse.setup.load_last_setup_id">load_last_setup_id</a></code></li>
<li><code><a title="egse.setup.load_setup" href="#egse.setup.load_setup">load_setup</a></code></li>
<li><code><a title="egse.setup.save_last_setup_id" href="#egse.setup.save_last_setup_id">save_last_setup_id</a></code></li>
<li><code><a title="egse.setup.submit_setup" href="#egse.setup.submit_setup">submit_setup</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.setup.Setup" href="#egse.setup.Setup">Setup</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.setup.Setup.compare" href="#egse.setup.Setup.compare">compare</a></code></li>
<li><code><a title="egse.setup.Setup.find_devices" href="#egse.setup.Setup.find_devices">find_devices</a></code></li>
<li><code><a title="egse.setup.Setup.from_dict" href="#egse.setup.Setup.from_dict">from_dict</a></code></li>
<li><code><a title="egse.setup.Setup.from_yaml_file" href="#egse.setup.Setup.from_yaml_file">from_yaml_file</a></code></li>
<li><code><a title="egse.setup.Setup.from_yaml_string" href="#egse.setup.Setup.from_yaml_string">from_yaml_string</a></code></li>
<li><code><a title="egse.setup.Setup.get_filename" href="#egse.setup.Setup.get_filename">get_filename</a></code></li>
<li><code><a title="egse.setup.Setup.get_id" href="#egse.setup.Setup.get_id">get_id</a></code></li>
<li><code><a title="egse.setup.Setup.to_yaml_file" href="#egse.setup.Setup.to_yaml_file">to_yaml_file</a></code></li>
<li><code><a title="egse.setup.Setup.walk" href="#egse.setup.Setup.walk">walk</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.setup.SetupError" href="#egse.setup.SetupError">SetupError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
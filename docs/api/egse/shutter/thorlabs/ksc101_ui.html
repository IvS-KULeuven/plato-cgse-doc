<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.shutter.thorlabs.ksc101_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.shutter.thorlabs.ksc101_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
import logging
import sys
from pathlib import Path
import pyqtgraph as pg
import numpy as np

from PyQt5.QtWidgets import (QApplication, QMainWindow, QAction, QFrame,
                             QVBoxLayout, QHBoxLayout, QGroupBox, QLabel, QSpinBox, QToolButton, QRadioButton)
from PyQt5.QtCore import Qt, QTimer
from PyQt5.QtGui import QIcon, QPixmap, QPalette, QFont
from QLed import QLed

from egse.settings import Settings
from egse.observer import Observer
from egse.observer import Observable
from egse.state import UnknownStateError
from egse.config import find_file, set_logger_levels

from egse.shutter.thorlabs.ksc101 import ShutterKSC101Proxy, ShutterKSC101Controller, ShutterKSC101Simulator
from egse.gui import show_warning_message

from egse.process import ProcessStatus
from egse.system import do_every

from prometheus_client import Gauge, Summary
from prometheus_client import start_http_server

import threading

MODULE_LOGGER = logging.getLogger(__name__)
SETTINGS = Settings.load(&#34;Shutter KSC101 Controller&#34;)
GUI_SETTINGS = Settings.load(&#34;KSC101 GUI&#34;)
FONT = QFont(&#34;Helvetica&#34;, 18)

logger_levels = [
    (&#34;egse.protocol&#34;, logging.INFO),
    (&#34;egse.command&#34;, logging.INFO),
    (&#34;egse.settings&#34;, logging.INFO),
    (&#34;egse.config&#34;, logging.INFO),
    (&#34;git.cmd&#34;, logging.INFO),
]

set_logger_levels(logger_levels)

class ShutterUIView(QMainWindow, Observable):
    # TODO: on reconnect new values need to be updated
    # TODO: get enable states for interlock and alarm (see ATPServer Help File)
    # TODO: update values enable value when after a &#34;single&#34; or an &#34;automatic&#34; operation

    def __init__(self):
        super().__init__()

        # Define those variables that we will need/use in different methods

        self.state = None
        self.clear_action = None
        self.reconnect_action = None
        self.toolbar = None

        self.setGeometry(0, 0, 300, 500)
        self.setWindowTitle(&#39;Thorlabs Shutter KSC101 Controller&#39;)

        self.init_gui()

    def createToolbar(self):
        image_location = Path(__file__).resolve().parent.parent.parent / &#34;images&#34;

        # The Reconnect action is used to reconnect the device or control server

        connected_pix = QPixmap(str(image_location / &#34;connected-100.png&#34;))
        disconnected_pix = QPixmap(str(image_location / &#34;disconnected-100.png&#34;))
        reconnect_icon = QIcon()
        reconnect_icon.addPixmap(connected_pix, QIcon.Normal, QIcon.On)
        reconnect_icon.addPixmap(disconnected_pix, QIcon.Normal, QIcon.Off)

        self.reconnect_action = QAction(reconnect_icon, &#39;Reconnect&#39;, self)
        self.reconnect_action.setToolTip(&#34;Reconnect&#34;)
        self.reconnect_action.setCheckable(True)
        self.reconnect_action.triggered.connect(self.onClick)

        self.enable = QToolButton()
        self.enable.setArrowType(Qt.RightArrow)
        self.enable.clicked.connect(self.set_enable)
        self.enable.setToolTip(&#34;Enable Solenoid&#34;)

        self.toolbar = self.addToolBar(&#39;MainToolbar&#39;)
        self.toolbar.addAction(self.reconnect_action)
        self.toolbar.addWidget(self.enable)

        return self.toolbar

    def createStatesWidget(self):

        self.states = [
            [QLabel(&#34;Shutter alarm&#34;), QLed(self, offColour = QLed.Green, onColour = QLed.Red), QLed.setBaseSize(self, 1, 1)],
            [QLabel(&#34;Interlock alarm&#34;), QLed(self, offColour = QLed.Green, onColour = QLed.Red)],
            [QLabel(&#34;Enable&#34;), QLed(self, offColour = QLed.Red, onColour = QLed.Green)],
            ]

        vbox = QVBoxLayout()

        for state in self.states:
            hbox = QHBoxLayout()
            hbox.addWidget(state[1])
            hbox.addWidget(state[0])
            state[1].setFixedSize(20, 20)
            hbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
            hbox.setSpacing(5)
            vbox.addLayout(hbox)

        vbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        vbox.setSpacing(0)

        group_box = QGroupBox(&#34;Shutter State&#34;,self)

        group_box.setLayout(vbox)

        return group_box

    def createOperationWidget(self):

        hbox = QHBoxLayout()

        group_mode = QGroupBox(&#34;Control Mode&#34;, self)
        vbox = QVBoxLayout()

        self.operation_modes = [[QRadioButton(&#34;Manual&#34;)],
                                [QRadioButton(&#34;Single&#34;)],
                                [QRadioButton(&#34;Auto&#34;)],
                                [QRadioButton(&#34;Trigger&#34;)]
                                ]

        for mode in self.operation_modes:
            mode[0].clicked.connect(self.set_mode)
            vbox.addWidget(mode[0])

        vbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        vbox.setSpacing(10)

        group_mode.setLayout(vbox)

        group_cycle = QGroupBox(&#34;Cycling Settings&#34;, self)
        vbox_cycle = QVBoxLayout()

        self.cycle = [
                [QLabel(&#34;ON duration (ms):&#34;), QSpinBox(), &#34;ON&#34;, 100, 100000],
                [QLabel(&#34;OFF duration (ms):&#34;), QSpinBox(), &#34;OFF&#34;, 100, 100000],
                [QLabel(&#34;Number of cycles:&#34;), QSpinBox(), &#34;Number&#34;, 0, 100000]
                ]

        for options in self.cycle:
            hbox_cycle = QHBoxLayout()
            hbox_cycle.addWidget(options[0])
            #hbox_cycle.addStretch(2) --&gt; Not needed if fixed width is set
            hbox_cycle.addWidget(options[1])
            options[1].setObjectName(options[2])
            options[1].setMinimum(options[3])
            options[1].setMaximum(options[4])
            options[1].valueChanged.connect(self.set_cycle)
            options[1].setFixedWidth(100)
            options[0].setFixedWidth(120)
            hbox_cycle.setAlignment(Qt.AlignLeft | Qt.AlignTop)
            vbox_cycle.addLayout(hbox_cycle)
            vbox_cycle.setSpacing(10)

        vbox_cycle.addStretch()
        group_cycle.setLayout(vbox_cycle)

        hbox.addWidget(group_mode)
        hbox.addWidget(group_cycle)

        group_operation = QGroupBox(&#34;Shutter operations&#34;, self)
        group_operation.setLayout(hbox)

        return group_operation

    def init_gui(self):

        ## Switch to using white background and black foreground for pyqtgraph stripcharts

        pg.setConfigOption(&#39;background&#39;, &#39;w&#39;)
        pg.setConfigOption(&#39;foreground&#39;, &#39;k&#39;)

        # The main frame in which all the other frames are located, the outer Application frame

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        create_state = self.createStatesWidget()
        create_operation = self.createOperationWidget()

        hbox = QHBoxLayout()
        toolbar_widget = self.createToolbar()
        hbox.addWidget(create_state)
        hbox.addWidget(create_operation)

        app_frame.setLayout(hbox)

        self.setCentralWidget(app_frame)

    def set_style(self):
        &#34;&#34;&#34;
        Set the style for the Shutter Widget when it is connected to a real
        Shutter Controller (hardware).
        This will override the styles that were defined in the styles.qss style file
        that was loaded for the Application.
        &#34;&#34;&#34;
        self.setAutoFillBackground(True)
        self.setBackgroundRole(QPalette.Light)
        self.setStyleSheet(&#34;&#34;&#34;
            QGroupBox {
                border: 1px solid lightGray;
                border-radius: 0px;
                margin-top: 0px;
                padding-top: 10px;
            }
            QGroupBox::title {
                background-color: transparent;
                padding-top: 0px;
                padding-left: 0px;
            } 
        &#34;&#34;&#34;)

    def set_style_simulator(self):
        &#34;&#34;&#34;
        Set the style for the Shutter UI Widget when it is connected to a
        Shutter Simulator.
        This will override the styles that were defined in the styles.qss style file
        that was loaded for the Application.
        &#34;&#34;&#34;
        self.setAutoFillBackground(True)
        self.setBackgroundRole(QPalette.Dark)
        self.setStyleSheet(&#34;&#34;&#34;
            QGroupBox {
                border: 1px solid lightGray;
                border-radius: 0px;
                margin-top: 0px;
                padding-top: 10px;
            }
            QGroupBox::title {
                background-color: transparent;
                padding-top: 0px;
                padding-left: 0px;
            } 
        &#34;&#34;&#34;)

    def initialize_values(self, configuration):
        &#34;gets the parameter values on shutter start up&#34;
        _cycle = configuration[&#34;cycle&#34;]
        _cycle = list(_cycle.values())

        for parameter in range(len(self.cycle)):
            self.cycle[parameter][1].blockSignals(True)                 #avoids to trigger an event on init
            self.cycle[parameter][1].setValue(_cycle[parameter])
            self.cycle[parameter][1].blockSignals(False)

        _mode = configuration[&#34;mode&#34;] - 1
        self.operation_modes[_mode][0].blockSignals(True)
        self.operation_modes[_mode][0].setChecked(True)
        self.operation_modes[_mode][0].blockSignals(False)

        _state = [False, False, configuration[&#34;state&#34;]]

        for state in range(len(self.states)):
            self.states[state][1].blockSignals(True)
            self.states[state][1].setValue(_state[state])
            self.states[state][1].blockSignals(False)

    def onClick(self):

        sender = self.sender()

        MODULE_LOGGER.debug(f&#34;sender.text() = {sender.text()}&#34;)
        MODULE_LOGGER.debug(f&#34;sender.isChecked() = {sender.isChecked()}&#34;)

        self.notifyObservers(sender)

    def set_cycle(self):
        cycle =[]
        for parameter in range(len(self.cycle)):
            cycle.append(self.cycle[parameter][1].value())
        self.actionObservers({&#39;set_cycle&#39;: cycle})

    def set_mode(self):
        _mode=[]
        op_modes = [&#34;manual&#34;, &#34;single&#34;, &#34;auto&#34;, &#34;trigger&#34;]
        for mode in range(len(self.operation_modes)):
            _mode.append(self.operation_modes[mode][0].isChecked())
        self.actionObservers({&#39;set_mode&#39;: op_modes[int(np.where(_mode)[0])]})

    def set_enable(self):
        self.actionObservers({&#39;set_enable&#39;: not self.states[2][1].value})

    def set_connection_state(self, state):

        if state == &#39;connected&#39;:
            self.reconnect_action.setChecked(True)
        elif state == &#39;disconnected&#39;:
            self.reconnect_action.setChecked(False)
        else:
            raise UnknownStateError(
                f&#34;Unknown State ({state}), expected &#39;connected&#39; or &#39;disconnected&#39;.&#34;)

class ShutterUIModel:
    def __init__(self, type_):
        self.type = type_

        if self.type == &#34;proxy&#34;:
            self.sht = ShutterKSC101Proxy()
        elif self.type == &#34;direct&#34;:
            self.sht = ShutterKSC101Controller()
            self.sht.connect()
        elif self.type == &#34;simulator&#34;:
            self.sht = ShutterKSC101Simulator()
        else:
            raise Exception(f&#34;Unknown type of Shutter implementation passed into the model: {type}&#34;)

        if self.sht is not None:
            MODULE_LOGGER.debug(f&#34;ShutterKSC101Controller initialized as {self.sht.__class__.__name__}&#34;)

    def has_commands(self):
        if self.type == &#34;proxy&#34;:
            return self.sht.has_commands()
        return True

    def load_commands(self):
        if self.type == &#34;proxy&#34;:
            self.sht.load_commands()

    def is_simulator(self):
        return self.sht.is_simulator()

    def is_connected(self):
        if self.type == &#34;proxy&#34;:
            return self.sht.is_cs_connected()
        else:
            return self.sht.is_connected()

    def reconnect(self):
        if self.type == &#34;proxy&#34;:
            self.sht.reconnect_cs()
            return self.sht.is_cs_connected()
        else:
            self.sht.reconnect()
            return self.sht.is_connected()
        return False

    def disconnect(self):
        if self.type == &#34;proxy&#34;:
            self.sht.disconnect_cs()
        else:
            self.sht.disconnect()

    def set_mode(self, mode):
        self.sht.set_mode(mode = mode)

    def set_cycle(self, on, off, number):
        self.sht.set_cycle(on, off, number)

    def set_enable(self, status):
        self.sht.set_enable(status)

    def get_configuration(self):
        cycle = self.sht.get_cycle()
        mode = self.sht.get_mode()
        state = self.sht.get_enable()
        configuration = {&#34;cycle&#34;: cycle, &#34;mode&#34;: mode, &#34;state&#34;: state}
        return configuration

class ShutterUIController(Observer):
    def __init__(self, model, view):
        self.model = model
        self.view = view
        self.view.addObserver(self)

        self.create_timer()

        if self.model.is_connected():
            self.initialize_values()

            if self.model.is_simulator():
                self.view.set_style_simulator()
            else:
                self.view.set_style()

            self.view.set_connection_state(&#39;connected&#39;)
            self.start_timer()
        else:
            self.stop_timer()
            self.view.set_connection_state(&#39;disconnected&#39;)

    def create_timer(self):
        &#34;&#34;&#34;Create a Timer that will update the States every second.&#34;&#34;&#34;

        self.states_capture_timer = QTimer()
        # This is only needed when the Timer needs to run in another Thread
        # self.states_capture_timer.moveToThread(self)
        self.states_capture_timer.setInterval(200)
        self.states_capture_timer.timeout.connect(self.initialize_values)

        self.stripchart_timer = QTimer()
#        self.stripchart_timer.timeout.connect(self.update_stripchart)
        self.stripchart_timer.setInterval(200)

    def start_timer(self):
        self.states_capture_timer.start()
        self.stripchart_timer.start()

    def stop_timer(self):
        self.states_capture_timer.stop()
        self.stripchart_timer.stop()

    def initialize_values(self):
        configuration = self.model.get_configuration()
        self.view.initialize_values(configuration)

    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:
            if changed_object.isChecked():
                MODULE_LOGGER.debug(&#34;Reconnecting the Shutter KSC101 model.&#34;)
                if self.model.reconnect():
                    self.view.set_connection_state(&#39;connected&#39;)
                    if not self.model.has_commands():
                        self.model.load_commands()
                    self.start_timer()
                else:
                    self.view.reconnect_action.setChecked(False)
            else:
                MODULE_LOGGER.debug(&#34;Disconnecting the Shutter KSC101 model.&#34;)
                self.stop_timer()
                self.model.disconnect()
                self.view.set_connection_state(&#39;disconnected&#39;)

            return

        if text == &#34;ClearErrors&#34;:
            self.model.clearError()

        if text == &#34;Reset&#34;:
            pass

    def do(self, actions):

        for action, value in actions.items():
            MODULE_LOGGER.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_mode&#34;:
                mode = value
                MODULE_LOGGER.debug(f&#34;do: set_mode({mode}:{type(mode)})&#34;)
                self.model.set_mode(mode)
                self.initialize_values()

            if action == &#34;set_cycle&#34;:
                on, off, number = value
                MODULE_LOGGER.debug(f&#34;do: set_mode({on}:{type(on)}, {off}:{type(off)}, {number}:{type(number)})&#34;)
                self.model.set_cycle(on, off, number)
                self.initialize_values()

            if action == &#34;set_enable&#34;:
                status = value
                MODULE_LOGGER.debug(f&#34;do: set_enable({status}:{type(status)})&#34;)
                self.model.set_enable(status)
                self.initialize_values()

def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;, &#34;direct&#34;},
        help=&#34;Specify the implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )
    parser.add_argument(
        &#34;--profile&#34;,
        default=False,
        action=&#34;store_true&#34;,
        help=&#34;Enable info logging messages with method profile information.&#34;,
    )
    args = parser.parse_args()
    return args

def main():

    STYLES_LOCATION = find_file(&#34;styles.qss&#34;, in_dir=&#34;egse/gui&#34;)

    args = list(sys.argv)
    args[1:1] = [&#34;-stylesheet&#34;, str(STYLES_LOCATION)]

    process_status = ProcessStatus()

    timer_thread = threading.Thread(target=do_every, args=(10, process_status.update))
    timer_thread.daemon = True
    timer_thread.start()

    start_http_server(GUI_SETTINGS.METRICS_PORT)

    app = QApplication(args)

    args = parse_arguments()

    if args.profile:
        Settings.set_profiling(True)

    if args.type == &#34;proxy&#34;:
        proxy = ShutterKSC101Proxy()
        if not proxy.ping():
            description = &#34;Could not connect to Shutter Control Server&#34;
            info_text = (
                    &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
                    &#34;Please check if the Control Server is running and start the server if needed. &#34;
                    &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
                    &#34;Settings.yaml &#34;
                    &#34;configuration file.&#34;
                )

            show_warning_message(description, info_text)

    view = ShutterUIView()
    model = ShutterUIModel(args.type)
    controller = ShutterUIController(model, view)

    view.show()
    return app.exec_()

if __name__ == &#34;__main__&#34;:
    sys.exit(main())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.shutter.thorlabs.ksc101_ui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():

    STYLES_LOCATION = find_file(&#34;styles.qss&#34;, in_dir=&#34;egse/gui&#34;)

    args = list(sys.argv)
    args[1:1] = [&#34;-stylesheet&#34;, str(STYLES_LOCATION)]

    process_status = ProcessStatus()

    timer_thread = threading.Thread(target=do_every, args=(10, process_status.update))
    timer_thread.daemon = True
    timer_thread.start()

    start_http_server(GUI_SETTINGS.METRICS_PORT)

    app = QApplication(args)

    args = parse_arguments()

    if args.profile:
        Settings.set_profiling(True)

    if args.type == &#34;proxy&#34;:
        proxy = ShutterKSC101Proxy()
        if not proxy.ping():
            description = &#34;Could not connect to Shutter Control Server&#34;
            info_text = (
                    &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
                    &#34;Please check if the Control Server is running and start the server if needed. &#34;
                    &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
                    &#34;Settings.yaml &#34;
                    &#34;configuration file.&#34;
                )

            show_warning_message(description, info_text)

    view = ShutterUIView()
    model = ShutterUIModel(args.type)
    controller = ShutterUIController(model, view)

    view.show()
    return app.exec_()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.parse_arguments"><code class="name flex">
<span>def <span class="ident">parse_arguments</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the arguments that are specific for this application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;, &#34;direct&#34;},
        help=&#34;Specify the implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )
    parser.add_argument(
        &#34;--profile&#34;,
        default=False,
        action=&#34;store_true&#34;,
        help=&#34;Enable info logging messages with method profile information.&#34;,
    )
    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController"><code class="flex name class">
<span>class <span class="ident">ShutterUIController</span></span>
<span>(</span><span>model, view)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShutterUIController(Observer):
    def __init__(self, model, view):
        self.model = model
        self.view = view
        self.view.addObserver(self)

        self.create_timer()

        if self.model.is_connected():
            self.initialize_values()

            if self.model.is_simulator():
                self.view.set_style_simulator()
            else:
                self.view.set_style()

            self.view.set_connection_state(&#39;connected&#39;)
            self.start_timer()
        else:
            self.stop_timer()
            self.view.set_connection_state(&#39;disconnected&#39;)

    def create_timer(self):
        &#34;&#34;&#34;Create a Timer that will update the States every second.&#34;&#34;&#34;

        self.states_capture_timer = QTimer()
        # This is only needed when the Timer needs to run in another Thread
        # self.states_capture_timer.moveToThread(self)
        self.states_capture_timer.setInterval(200)
        self.states_capture_timer.timeout.connect(self.initialize_values)

        self.stripchart_timer = QTimer()
#        self.stripchart_timer.timeout.connect(self.update_stripchart)
        self.stripchart_timer.setInterval(200)

    def start_timer(self):
        self.states_capture_timer.start()
        self.stripchart_timer.start()

    def stop_timer(self):
        self.states_capture_timer.stop()
        self.stripchart_timer.stop()

    def initialize_values(self):
        configuration = self.model.get_configuration()
        self.view.initialize_values(configuration)

    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:
            if changed_object.isChecked():
                MODULE_LOGGER.debug(&#34;Reconnecting the Shutter KSC101 model.&#34;)
                if self.model.reconnect():
                    self.view.set_connection_state(&#39;connected&#39;)
                    if not self.model.has_commands():
                        self.model.load_commands()
                    self.start_timer()
                else:
                    self.view.reconnect_action.setChecked(False)
            else:
                MODULE_LOGGER.debug(&#34;Disconnecting the Shutter KSC101 model.&#34;)
                self.stop_timer()
                self.model.disconnect()
                self.view.set_connection_state(&#39;disconnected&#39;)

            return

        if text == &#34;ClearErrors&#34;:
            self.model.clearError()

        if text == &#34;Reset&#34;:
            pass

    def do(self, actions):

        for action, value in actions.items():
            MODULE_LOGGER.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_mode&#34;:
                mode = value
                MODULE_LOGGER.debug(f&#34;do: set_mode({mode}:{type(mode)})&#34;)
                self.model.set_mode(mode)
                self.initialize_values()

            if action == &#34;set_cycle&#34;:
                on, off, number = value
                MODULE_LOGGER.debug(f&#34;do: set_mode({on}:{type(on)}, {off}:{type(off)}, {number}:{type(number)})&#34;)
                self.model.set_cycle(on, off, number)
                self.initialize_values()

            if action == &#34;set_enable&#34;:
                status = value
                MODULE_LOGGER.debug(f&#34;do: set_enable({status}:{type(status)})&#34;)
                self.model.set_enable(status)
                self.initialize_values()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.observer.Observer" href="../../observer.html#egse.observer.Observer">Observer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.create_timer"><code class="name flex">
<span>def <span class="ident">create_timer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Timer that will update the States every second.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def create_timer(self):
        &#34;&#34;&#34;Create a Timer that will update the States every second.&#34;&#34;&#34;

        self.states_capture_timer = QTimer()
        # This is only needed when the Timer needs to run in another Thread
        # self.states_capture_timer.moveToThread(self)
        self.states_capture_timer.setInterval(200)
        self.states_capture_timer.timeout.connect(self.initialize_values)

        self.stripchart_timer = QTimer()
#        self.stripchart_timer.timeout.connect(self.update_stripchart)
        self.stripchart_timer.setInterval(200)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, actions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, actions):

    for action, value in actions.items():
        MODULE_LOGGER.debug(f&#34;do {action} with {value}&#34;)
        if action == &#34;set_mode&#34;:
            mode = value
            MODULE_LOGGER.debug(f&#34;do: set_mode({mode}:{type(mode)})&#34;)
            self.model.set_mode(mode)
            self.initialize_values()

        if action == &#34;set_cycle&#34;:
            on, off, number = value
            MODULE_LOGGER.debug(f&#34;do: set_mode({on}:{type(on)}, {off}:{type(off)}, {number}:{type(number)})&#34;)
            self.model.set_cycle(on, off, number)
            self.initialize_values()

        if action == &#34;set_enable&#34;:
            status = value
            MODULE_LOGGER.debug(f&#34;do: set_enable({status}:{type(status)})&#34;)
            self.model.set_enable(status)
            self.initialize_values()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.initialize_values"><code class="name flex">
<span>def <span class="ident">initialize_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_values(self):
    configuration = self.model.get_configuration()
    self.view.initialize_values(configuration)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.start_timer"><code class="name flex">
<span>def <span class="ident">start_timer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_timer(self):
    self.states_capture_timer.start()
    self.stripchart_timer.start()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.stop_timer"><code class="name flex">
<span>def <span class="ident">stop_timer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_timer(self):
    self.states_capture_timer.stop()
    self.stripchart_timer.stop()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, changed_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, changed_object):

    text = changed_object.text()

    if text == &#34;Reconnect&#34;:
        if changed_object.isChecked():
            MODULE_LOGGER.debug(&#34;Reconnecting the Shutter KSC101 model.&#34;)
            if self.model.reconnect():
                self.view.set_connection_state(&#39;connected&#39;)
                if not self.model.has_commands():
                    self.model.load_commands()
                self.start_timer()
            else:
                self.view.reconnect_action.setChecked(False)
        else:
            MODULE_LOGGER.debug(&#34;Disconnecting the Shutter KSC101 model.&#34;)
            self.stop_timer()
            self.model.disconnect()
            self.view.set_connection_state(&#39;disconnected&#39;)

        return

    if text == &#34;ClearErrors&#34;:
        self.model.clearError()

    if text == &#34;Reset&#34;:
        pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel"><code class="flex name class">
<span>class <span class="ident">ShutterUIModel</span></span>
<span>(</span><span>type_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShutterUIModel:
    def __init__(self, type_):
        self.type = type_

        if self.type == &#34;proxy&#34;:
            self.sht = ShutterKSC101Proxy()
        elif self.type == &#34;direct&#34;:
            self.sht = ShutterKSC101Controller()
            self.sht.connect()
        elif self.type == &#34;simulator&#34;:
            self.sht = ShutterKSC101Simulator()
        else:
            raise Exception(f&#34;Unknown type of Shutter implementation passed into the model: {type}&#34;)

        if self.sht is not None:
            MODULE_LOGGER.debug(f&#34;ShutterKSC101Controller initialized as {self.sht.__class__.__name__}&#34;)

    def has_commands(self):
        if self.type == &#34;proxy&#34;:
            return self.sht.has_commands()
        return True

    def load_commands(self):
        if self.type == &#34;proxy&#34;:
            self.sht.load_commands()

    def is_simulator(self):
        return self.sht.is_simulator()

    def is_connected(self):
        if self.type == &#34;proxy&#34;:
            return self.sht.is_cs_connected()
        else:
            return self.sht.is_connected()

    def reconnect(self):
        if self.type == &#34;proxy&#34;:
            self.sht.reconnect_cs()
            return self.sht.is_cs_connected()
        else:
            self.sht.reconnect()
            return self.sht.is_connected()
        return False

    def disconnect(self):
        if self.type == &#34;proxy&#34;:
            self.sht.disconnect_cs()
        else:
            self.sht.disconnect()

    def set_mode(self, mode):
        self.sht.set_mode(mode = mode)

    def set_cycle(self, on, off, number):
        self.sht.set_cycle(on, off, number)

    def set_enable(self, status):
        self.sht.set_enable(status)

    def get_configuration(self):
        cycle = self.sht.get_cycle()
        mode = self.sht.get_mode()
        state = self.sht.get_enable()
        configuration = {&#34;cycle&#34;: cycle, &#34;mode&#34;: mode, &#34;state&#34;: state}
        return configuration</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    if self.type == &#34;proxy&#34;:
        self.sht.disconnect_cs()
    else:
        self.sht.disconnect()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.get_configuration"><code class="name flex">
<span>def <span class="ident">get_configuration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_configuration(self):
    cycle = self.sht.get_cycle()
    mode = self.sht.get_mode()
    state = self.sht.get_enable()
    configuration = {&#34;cycle&#34;: cycle, &#34;mode&#34;: mode, &#34;state&#34;: state}
    return configuration</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.has_commands"><code class="name flex">
<span>def <span class="ident">has_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_commands(self):
    if self.type == &#34;proxy&#34;:
        return self.sht.has_commands()
    return True</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    if self.type == &#34;proxy&#34;:
        return self.sht.is_cs_connected()
    else:
        return self.sht.is_connected()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.is_simulator"><code class="name flex">
<span>def <span class="ident">is_simulator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulator(self):
    return self.sht.is_simulator()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(self):
    if self.type == &#34;proxy&#34;:
        self.sht.load_commands()</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    if self.type == &#34;proxy&#34;:
        self.sht.reconnect_cs()
        return self.sht.is_cs_connected()
    else:
        self.sht.reconnect()
        return self.sht.is_connected()
    return False</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_cycle"><code class="name flex">
<span>def <span class="ident">set_cycle</span></span>(<span>self, on, off, number)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cycle(self, on, off, number):
    self.sht.set_cycle(on, off, number)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_enable"><code class="name flex">
<span>def <span class="ident">set_enable</span></span>(<span>self, status)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable(self, status):
    self.sht.set_enable(status)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_mode"><code class="name flex">
<span>def <span class="ident">set_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mode(self, mode):
    self.sht.set_mode(mode = mode)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView"><code class="flex name class">
<span>class <span class="ident">ShutterUIView</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShutterUIView(QMainWindow, Observable):
    # TODO: on reconnect new values need to be updated
    # TODO: get enable states for interlock and alarm (see ATPServer Help File)
    # TODO: update values enable value when after a &#34;single&#34; or an &#34;automatic&#34; operation

    def __init__(self):
        super().__init__()

        # Define those variables that we will need/use in different methods

        self.state = None
        self.clear_action = None
        self.reconnect_action = None
        self.toolbar = None

        self.setGeometry(0, 0, 300, 500)
        self.setWindowTitle(&#39;Thorlabs Shutter KSC101 Controller&#39;)

        self.init_gui()

    def createToolbar(self):
        image_location = Path(__file__).resolve().parent.parent.parent / &#34;images&#34;

        # The Reconnect action is used to reconnect the device or control server

        connected_pix = QPixmap(str(image_location / &#34;connected-100.png&#34;))
        disconnected_pix = QPixmap(str(image_location / &#34;disconnected-100.png&#34;))
        reconnect_icon = QIcon()
        reconnect_icon.addPixmap(connected_pix, QIcon.Normal, QIcon.On)
        reconnect_icon.addPixmap(disconnected_pix, QIcon.Normal, QIcon.Off)

        self.reconnect_action = QAction(reconnect_icon, &#39;Reconnect&#39;, self)
        self.reconnect_action.setToolTip(&#34;Reconnect&#34;)
        self.reconnect_action.setCheckable(True)
        self.reconnect_action.triggered.connect(self.onClick)

        self.enable = QToolButton()
        self.enable.setArrowType(Qt.RightArrow)
        self.enable.clicked.connect(self.set_enable)
        self.enable.setToolTip(&#34;Enable Solenoid&#34;)

        self.toolbar = self.addToolBar(&#39;MainToolbar&#39;)
        self.toolbar.addAction(self.reconnect_action)
        self.toolbar.addWidget(self.enable)

        return self.toolbar

    def createStatesWidget(self):

        self.states = [
            [QLabel(&#34;Shutter alarm&#34;), QLed(self, offColour = QLed.Green, onColour = QLed.Red), QLed.setBaseSize(self, 1, 1)],
            [QLabel(&#34;Interlock alarm&#34;), QLed(self, offColour = QLed.Green, onColour = QLed.Red)],
            [QLabel(&#34;Enable&#34;), QLed(self, offColour = QLed.Red, onColour = QLed.Green)],
            ]

        vbox = QVBoxLayout()

        for state in self.states:
            hbox = QHBoxLayout()
            hbox.addWidget(state[1])
            hbox.addWidget(state[0])
            state[1].setFixedSize(20, 20)
            hbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
            hbox.setSpacing(5)
            vbox.addLayout(hbox)

        vbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        vbox.setSpacing(0)

        group_box = QGroupBox(&#34;Shutter State&#34;,self)

        group_box.setLayout(vbox)

        return group_box

    def createOperationWidget(self):

        hbox = QHBoxLayout()

        group_mode = QGroupBox(&#34;Control Mode&#34;, self)
        vbox = QVBoxLayout()

        self.operation_modes = [[QRadioButton(&#34;Manual&#34;)],
                                [QRadioButton(&#34;Single&#34;)],
                                [QRadioButton(&#34;Auto&#34;)],
                                [QRadioButton(&#34;Trigger&#34;)]
                                ]

        for mode in self.operation_modes:
            mode[0].clicked.connect(self.set_mode)
            vbox.addWidget(mode[0])

        vbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        vbox.setSpacing(10)

        group_mode.setLayout(vbox)

        group_cycle = QGroupBox(&#34;Cycling Settings&#34;, self)
        vbox_cycle = QVBoxLayout()

        self.cycle = [
                [QLabel(&#34;ON duration (ms):&#34;), QSpinBox(), &#34;ON&#34;, 100, 100000],
                [QLabel(&#34;OFF duration (ms):&#34;), QSpinBox(), &#34;OFF&#34;, 100, 100000],
                [QLabel(&#34;Number of cycles:&#34;), QSpinBox(), &#34;Number&#34;, 0, 100000]
                ]

        for options in self.cycle:
            hbox_cycle = QHBoxLayout()
            hbox_cycle.addWidget(options[0])
            #hbox_cycle.addStretch(2) --&gt; Not needed if fixed width is set
            hbox_cycle.addWidget(options[1])
            options[1].setObjectName(options[2])
            options[1].setMinimum(options[3])
            options[1].setMaximum(options[4])
            options[1].valueChanged.connect(self.set_cycle)
            options[1].setFixedWidth(100)
            options[0].setFixedWidth(120)
            hbox_cycle.setAlignment(Qt.AlignLeft | Qt.AlignTop)
            vbox_cycle.addLayout(hbox_cycle)
            vbox_cycle.setSpacing(10)

        vbox_cycle.addStretch()
        group_cycle.setLayout(vbox_cycle)

        hbox.addWidget(group_mode)
        hbox.addWidget(group_cycle)

        group_operation = QGroupBox(&#34;Shutter operations&#34;, self)
        group_operation.setLayout(hbox)

        return group_operation

    def init_gui(self):

        ## Switch to using white background and black foreground for pyqtgraph stripcharts

        pg.setConfigOption(&#39;background&#39;, &#39;w&#39;)
        pg.setConfigOption(&#39;foreground&#39;, &#39;k&#39;)

        # The main frame in which all the other frames are located, the outer Application frame

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        create_state = self.createStatesWidget()
        create_operation = self.createOperationWidget()

        hbox = QHBoxLayout()
        toolbar_widget = self.createToolbar()
        hbox.addWidget(create_state)
        hbox.addWidget(create_operation)

        app_frame.setLayout(hbox)

        self.setCentralWidget(app_frame)

    def set_style(self):
        &#34;&#34;&#34;
        Set the style for the Shutter Widget when it is connected to a real
        Shutter Controller (hardware).
        This will override the styles that were defined in the styles.qss style file
        that was loaded for the Application.
        &#34;&#34;&#34;
        self.setAutoFillBackground(True)
        self.setBackgroundRole(QPalette.Light)
        self.setStyleSheet(&#34;&#34;&#34;
            QGroupBox {
                border: 1px solid lightGray;
                border-radius: 0px;
                margin-top: 0px;
                padding-top: 10px;
            }
            QGroupBox::title {
                background-color: transparent;
                padding-top: 0px;
                padding-left: 0px;
            } 
        &#34;&#34;&#34;)

    def set_style_simulator(self):
        &#34;&#34;&#34;
        Set the style for the Shutter UI Widget when it is connected to a
        Shutter Simulator.
        This will override the styles that were defined in the styles.qss style file
        that was loaded for the Application.
        &#34;&#34;&#34;
        self.setAutoFillBackground(True)
        self.setBackgroundRole(QPalette.Dark)
        self.setStyleSheet(&#34;&#34;&#34;
            QGroupBox {
                border: 1px solid lightGray;
                border-radius: 0px;
                margin-top: 0px;
                padding-top: 10px;
            }
            QGroupBox::title {
                background-color: transparent;
                padding-top: 0px;
                padding-left: 0px;
            } 
        &#34;&#34;&#34;)

    def initialize_values(self, configuration):
        &#34;gets the parameter values on shutter start up&#34;
        _cycle = configuration[&#34;cycle&#34;]
        _cycle = list(_cycle.values())

        for parameter in range(len(self.cycle)):
            self.cycle[parameter][1].blockSignals(True)                 #avoids to trigger an event on init
            self.cycle[parameter][1].setValue(_cycle[parameter])
            self.cycle[parameter][1].blockSignals(False)

        _mode = configuration[&#34;mode&#34;] - 1
        self.operation_modes[_mode][0].blockSignals(True)
        self.operation_modes[_mode][0].setChecked(True)
        self.operation_modes[_mode][0].blockSignals(False)

        _state = [False, False, configuration[&#34;state&#34;]]

        for state in range(len(self.states)):
            self.states[state][1].blockSignals(True)
            self.states[state][1].setValue(_state[state])
            self.states[state][1].blockSignals(False)

    def onClick(self):

        sender = self.sender()

        MODULE_LOGGER.debug(f&#34;sender.text() = {sender.text()}&#34;)
        MODULE_LOGGER.debug(f&#34;sender.isChecked() = {sender.isChecked()}&#34;)

        self.notifyObservers(sender)

    def set_cycle(self):
        cycle =[]
        for parameter in range(len(self.cycle)):
            cycle.append(self.cycle[parameter][1].value())
        self.actionObservers({&#39;set_cycle&#39;: cycle})

    def set_mode(self):
        _mode=[]
        op_modes = [&#34;manual&#34;, &#34;single&#34;, &#34;auto&#34;, &#34;trigger&#34;]
        for mode in range(len(self.operation_modes)):
            _mode.append(self.operation_modes[mode][0].isChecked())
        self.actionObservers({&#39;set_mode&#39;: op_modes[int(np.where(_mode)[0])]})

    def set_enable(self):
        self.actionObservers({&#39;set_enable&#39;: not self.states[2][1].value})

    def set_connection_state(self, state):

        if state == &#39;connected&#39;:
            self.reconnect_action.setChecked(True)
        elif state == &#39;disconnected&#39;:
            self.reconnect_action.setChecked(False)
        else:
            raise UnknownStateError(
                f&#34;Unknown State ({state}), expected &#39;connected&#39; or &#39;disconnected&#39;.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li><a title="egse.observer.Observable" href="../../observer.html#egse.observer.Observable">Observable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createOperationWidget"><code class="name flex">
<span>def <span class="ident">createOperationWidget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createOperationWidget(self):

    hbox = QHBoxLayout()

    group_mode = QGroupBox(&#34;Control Mode&#34;, self)
    vbox = QVBoxLayout()

    self.operation_modes = [[QRadioButton(&#34;Manual&#34;)],
                            [QRadioButton(&#34;Single&#34;)],
                            [QRadioButton(&#34;Auto&#34;)],
                            [QRadioButton(&#34;Trigger&#34;)]
                            ]

    for mode in self.operation_modes:
        mode[0].clicked.connect(self.set_mode)
        vbox.addWidget(mode[0])

    vbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
    vbox.setSpacing(10)

    group_mode.setLayout(vbox)

    group_cycle = QGroupBox(&#34;Cycling Settings&#34;, self)
    vbox_cycle = QVBoxLayout()

    self.cycle = [
            [QLabel(&#34;ON duration (ms):&#34;), QSpinBox(), &#34;ON&#34;, 100, 100000],
            [QLabel(&#34;OFF duration (ms):&#34;), QSpinBox(), &#34;OFF&#34;, 100, 100000],
            [QLabel(&#34;Number of cycles:&#34;), QSpinBox(), &#34;Number&#34;, 0, 100000]
            ]

    for options in self.cycle:
        hbox_cycle = QHBoxLayout()
        hbox_cycle.addWidget(options[0])
        #hbox_cycle.addStretch(2) --&gt; Not needed if fixed width is set
        hbox_cycle.addWidget(options[1])
        options[1].setObjectName(options[2])
        options[1].setMinimum(options[3])
        options[1].setMaximum(options[4])
        options[1].valueChanged.connect(self.set_cycle)
        options[1].setFixedWidth(100)
        options[0].setFixedWidth(120)
        hbox_cycle.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        vbox_cycle.addLayout(hbox_cycle)
        vbox_cycle.setSpacing(10)

    vbox_cycle.addStretch()
    group_cycle.setLayout(vbox_cycle)

    hbox.addWidget(group_mode)
    hbox.addWidget(group_cycle)

    group_operation = QGroupBox(&#34;Shutter operations&#34;, self)
    group_operation.setLayout(hbox)

    return group_operation</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createStatesWidget"><code class="name flex">
<span>def <span class="ident">createStatesWidget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createStatesWidget(self):

    self.states = [
        [QLabel(&#34;Shutter alarm&#34;), QLed(self, offColour = QLed.Green, onColour = QLed.Red), QLed.setBaseSize(self, 1, 1)],
        [QLabel(&#34;Interlock alarm&#34;), QLed(self, offColour = QLed.Green, onColour = QLed.Red)],
        [QLabel(&#34;Enable&#34;), QLed(self, offColour = QLed.Red, onColour = QLed.Green)],
        ]

    vbox = QVBoxLayout()

    for state in self.states:
        hbox = QHBoxLayout()
        hbox.addWidget(state[1])
        hbox.addWidget(state[0])
        state[1].setFixedSize(20, 20)
        hbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        hbox.setSpacing(5)
        vbox.addLayout(hbox)

    vbox.setAlignment(Qt.AlignLeft | Qt.AlignTop)
    vbox.setSpacing(0)

    group_box = QGroupBox(&#34;Shutter State&#34;,self)

    group_box.setLayout(vbox)

    return group_box</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createToolbar"><code class="name flex">
<span>def <span class="ident">createToolbar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createToolbar(self):
    image_location = Path(__file__).resolve().parent.parent.parent / &#34;images&#34;

    # The Reconnect action is used to reconnect the device or control server

    connected_pix = QPixmap(str(image_location / &#34;connected-100.png&#34;))
    disconnected_pix = QPixmap(str(image_location / &#34;disconnected-100.png&#34;))
    reconnect_icon = QIcon()
    reconnect_icon.addPixmap(connected_pix, QIcon.Normal, QIcon.On)
    reconnect_icon.addPixmap(disconnected_pix, QIcon.Normal, QIcon.Off)

    self.reconnect_action = QAction(reconnect_icon, &#39;Reconnect&#39;, self)
    self.reconnect_action.setToolTip(&#34;Reconnect&#34;)
    self.reconnect_action.setCheckable(True)
    self.reconnect_action.triggered.connect(self.onClick)

    self.enable = QToolButton()
    self.enable.setArrowType(Qt.RightArrow)
    self.enable.clicked.connect(self.set_enable)
    self.enable.setToolTip(&#34;Enable Solenoid&#34;)

    self.toolbar = self.addToolBar(&#39;MainToolbar&#39;)
    self.toolbar.addAction(self.reconnect_action)
    self.toolbar.addWidget(self.enable)

    return self.toolbar</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.init_gui"><code class="name flex">
<span>def <span class="ident">init_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_gui(self):

    ## Switch to using white background and black foreground for pyqtgraph stripcharts

    pg.setConfigOption(&#39;background&#39;, &#39;w&#39;)
    pg.setConfigOption(&#39;foreground&#39;, &#39;k&#39;)

    # The main frame in which all the other frames are located, the outer Application frame

    app_frame = QFrame()
    app_frame.setObjectName(&#34;AppFrame&#34;)

    create_state = self.createStatesWidget()
    create_operation = self.createOperationWidget()

    hbox = QHBoxLayout()
    toolbar_widget = self.createToolbar()
    hbox.addWidget(create_state)
    hbox.addWidget(create_operation)

    app_frame.setLayout(hbox)

    self.setCentralWidget(app_frame)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.initialize_values"><code class="name flex">
<span>def <span class="ident">initialize_values</span></span>(<span>self, configuration)</span>
</code></dt>
<dd>
<div class="desc"><p>gets the parameter values on shutter start up</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_values(self, configuration):
    &#34;gets the parameter values on shutter start up&#34;
    _cycle = configuration[&#34;cycle&#34;]
    _cycle = list(_cycle.values())

    for parameter in range(len(self.cycle)):
        self.cycle[parameter][1].blockSignals(True)                 #avoids to trigger an event on init
        self.cycle[parameter][1].setValue(_cycle[parameter])
        self.cycle[parameter][1].blockSignals(False)

    _mode = configuration[&#34;mode&#34;] - 1
    self.operation_modes[_mode][0].blockSignals(True)
    self.operation_modes[_mode][0].setChecked(True)
    self.operation_modes[_mode][0].blockSignals(False)

    _state = [False, False, configuration[&#34;state&#34;]]

    for state in range(len(self.states)):
        self.states[state][1].blockSignals(True)
        self.states[state][1].setValue(_state[state])
        self.states[state][1].blockSignals(False)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.onClick"><code class="name flex">
<span>def <span class="ident">onClick</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onClick(self):

    sender = self.sender()

    MODULE_LOGGER.debug(f&#34;sender.text() = {sender.text()}&#34;)
    MODULE_LOGGER.debug(f&#34;sender.isChecked() = {sender.isChecked()}&#34;)

    self.notifyObservers(sender)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_connection_state"><code class="name flex">
<span>def <span class="ident">set_connection_state</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_connection_state(self, state):

    if state == &#39;connected&#39;:
        self.reconnect_action.setChecked(True)
    elif state == &#39;disconnected&#39;:
        self.reconnect_action.setChecked(False)
    else:
        raise UnknownStateError(
            f&#34;Unknown State ({state}), expected &#39;connected&#39; or &#39;disconnected&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_cycle"><code class="name flex">
<span>def <span class="ident">set_cycle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cycle(self):
    cycle =[]
    for parameter in range(len(self.cycle)):
        cycle.append(self.cycle[parameter][1].value())
    self.actionObservers({&#39;set_cycle&#39;: cycle})</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_enable"><code class="name flex">
<span>def <span class="ident">set_enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable(self):
    self.actionObservers({&#39;set_enable&#39;: not self.states[2][1].value})</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_mode"><code class="name flex">
<span>def <span class="ident">set_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mode(self):
    _mode=[]
    op_modes = [&#34;manual&#34;, &#34;single&#34;, &#34;auto&#34;, &#34;trigger&#34;]
    for mode in range(len(self.operation_modes)):
        _mode.append(self.operation_modes[mode][0].isChecked())
    self.actionObservers({&#39;set_mode&#39;: op_modes[int(np.where(_mode)[0])]})</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the style for the Shutter Widget when it is connected to a real
Shutter Controller (hardware).
This will override the styles that were defined in the styles.qss style file
that was loaded for the Application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_style(self):
    &#34;&#34;&#34;
    Set the style for the Shutter Widget when it is connected to a real
    Shutter Controller (hardware).
    This will override the styles that were defined in the styles.qss style file
    that was loaded for the Application.
    &#34;&#34;&#34;
    self.setAutoFillBackground(True)
    self.setBackgroundRole(QPalette.Light)
    self.setStyleSheet(&#34;&#34;&#34;
        QGroupBox {
            border: 1px solid lightGray;
            border-radius: 0px;
            margin-top: 0px;
            padding-top: 10px;
        }
        QGroupBox::title {
            background-color: transparent;
            padding-top: 0px;
            padding-left: 0px;
        } 
    &#34;&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_style_simulator"><code class="name flex">
<span>def <span class="ident">set_style_simulator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the style for the Shutter UI Widget when it is connected to a
Shutter Simulator.
This will override the styles that were defined in the styles.qss style file
that was loaded for the Application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_style_simulator(self):
    &#34;&#34;&#34;
    Set the style for the Shutter UI Widget when it is connected to a
    Shutter Simulator.
    This will override the styles that were defined in the styles.qss style file
    that was loaded for the Application.
    &#34;&#34;&#34;
    self.setAutoFillBackground(True)
    self.setBackgroundRole(QPalette.Dark)
    self.setStyleSheet(&#34;&#34;&#34;
        QGroupBox {
            border: 1px solid lightGray;
            border-radius: 0px;
            margin-top: 0px;
            padding-top: 10px;
        }
        QGroupBox::title {
            background-color: transparent;
            padding-top: 0px;
            padding-left: 0px;
        } 
    &#34;&#34;&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.shutter.thorlabs" href="index.html">egse.shutter.thorlabs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.main" href="#egse.shutter.thorlabs.ksc101_ui.main">main</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.parse_arguments" href="#egse.shutter.thorlabs.ksc101_ui.parse_arguments">parse_arguments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController">ShutterUIController</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.create_timer" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController.create_timer">create_timer</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.do" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController.do">do</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.initialize_values" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController.initialize_values">initialize_values</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.start_timer" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController.start_timer">start_timer</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.stop_timer" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController.stop_timer">stop_timer</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIController.update" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIController.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel">ShutterUIModel</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.disconnect" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.disconnect">disconnect</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.get_configuration" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.has_commands" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.has_commands">has_commands</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.is_connected" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.is_connected">is_connected</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.is_simulator" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.load_commands" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.load_commands">load_commands</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.reconnect" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.reconnect">reconnect</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_cycle" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_cycle">set_cycle</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_enable" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_enable">set_enable</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_mode" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIModel.set_mode">set_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView">ShutterUIView</a></code></h4>
<ul class="">
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createOperationWidget" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createOperationWidget">createOperationWidget</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createStatesWidget" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createStatesWidget">createStatesWidget</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createToolbar" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.createToolbar">createToolbar</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.init_gui" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.init_gui">init_gui</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.initialize_values" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.initialize_values">initialize_values</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.onClick" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.onClick">onClick</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_connection_state" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_connection_state">set_connection_state</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_cycle" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_cycle">set_cycle</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_enable" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_enable">set_enable</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_mode" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_mode">set_mode</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_style" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_style">set_style</a></code></li>
<li><code><a title="egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_style_simulator" href="#egse.shutter.thorlabs.ksc101_ui.ShutterUIView.set_style_simulator">set_style_simulator</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
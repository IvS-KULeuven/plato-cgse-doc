<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.hexapod.symetrie.zonda_devif API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.hexapod.symetrie.zonda_devif</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import socket
import threading
from telnetlib import Telnet
from typing import List

import paramiko
import time
from time import sleep

from egse.device import DeviceTransport
from egse.settings import Settings
from egse.system import wait_until

logger = logging.getLogger(__name__)
ctrl_settings = Settings.load(&#34;ZONDA Controller&#34;)

RETURN_CODES = {
    0: &#34;Success.&#34;,
    -1: &#34;Undefined error.&#34;,
    -10: &#34;Wrong value for parameter at index 0.&#34;,
    -11: &#34;Wrong value for parameter at index 1.&#34;,
    -12: &#34;Wrong value for parameter at index 2.&#34;,
    -13: &#34;Wrong value for parameter at index 3.&#34;,
    -14: &#34;Wrong value for parameter at index 4.&#34;,
    -15: &#34;Wrong value for parameter at index 5.&#34;,
    -16: &#34;Wrong value for parameter at index 6.&#34;,
    -17: &#34;Wrong value for parameter at index 7.&#34;,
    -18: &#34;Wrong value for parameter at index 8.&#34;,
    -19: &#34;Wrong value for parameter at index 9.&#34;,
    -20: &#34;Wrong value for parameter at index 10.&#34;,
    -21: &#34;Wrong value for parameter at index 11.&#34;,
    -22: &#34;Wrong value for parameter at index 12.&#34;,
    -23: &#34;Wrong value for parameter at index 13.&#34;,
    -24: &#34;Wrong value for parameter at index 14.&#34;,
    -25: &#34;Wrong value for parameter at index 15.&#34;,
    -26: &#34;Wrong value for parameter at index 16.&#34;,
    -27: &#34;Wrong value for parameter at index 17.&#34;,
    -28: &#34;Wrong value for parameter at index 18.&#34;,
    -29: &#34;Wrong value for parameter at index 19.&#34;,
    -30: &#34;Unknown command number.&#34;,
    -31: &#34;This configuration command is a &#39;get&#39; only type.&#34;,
    -32: &#34;This configuration command is a &#39;set&#39; only type.&#34;,
    -33: &#34;The axis number do not correspond to an axis defined on the controller.&#34;,
    -34: &#34;A stop task is running.&#34;,
    -35: &#34;All motors need to be control on.&#34;,
    -36: &#34;All motors need to be control off.&#34;,
    -37: &#34;Emergency stop is pressed.&#34;,
    -38: &#34;A motion task is running.&#34;,
    -39: &#34;A home task is running.&#34;,
    -40: &#34;Requested move is not feasible.&#34;,
    -41: &#34;Power supply of limit switches is off.&#34;,
    -42: &#34;Power supply of encoders is off.&#34;,
    -43: &#34;A fatal error is present. This type of error needs a controller restart to be removed.&#34;,
    -44: &#34;An error is present, error reset is required.&#34;,
    -45: &#34;Home is not completed.&#34;,
    -46: &#34;Software option not available (can be linked to hardware configuration).&#34;,
    -47: &#34;Virtual home: file was created on another controller (different MAC address).&#34;,
    -48: &#34;Virtual home: some positions read in file are out of software limits.&#34;,
    -49: &#34;Virtual home: file data were stored while hexapod was moving.&#34;,
    -50: &#34;Virtual home: no data available.&#34;,
    -51: &#34;Command has been rejected because another action is running.&#34;,
    -52: &#34;Timeout waiting for home complete status.&#34;,
    -53: &#34;Timeout waiting for control on status.&#34;,
    -54: &#34;Timeout on motion program start.&#34;,
    -55: &#34;Timeout on home task start.&#34;,
    -56: &#34;Timeout on virtual home write file task.&#34;,
    -57: &#34;Timeout on virtual home delete file task.&#34;,
    -58: &#34;Timeout on virtual home read file task.&#34;,
    -59: &#34;Timeout on disk access verification task.&#34;,
    -60: &#34;Configuration file: save process failed.&#34;,
    -61: &#34;Configuration file: loaded file is empty.&#34;,
    -62: &#34;Configuration file: loaded data are corrupted.&#34;,
    -63: &#34;No access to the memory disk.&#34;,
    -64: &#34;File does not exist.&#34;,
    -65: &#34;Folder access failed.&#34;,
    -66: &#34;Creation of folder tree on the memory disk failed.&#34;,
    -67: &#34;Generation or write of the checksum failed.&#34;,
    -68: &#34;File read: no data or wrong data size.&#34;,
    -69: &#34;File read: no checksum.&#34;,
    -70: &#34;File read: incorrect checksum.&#34;,
    -71: &#34;File write: failed.&#34;,
    -72: &#34;File open: failed.&#34;,
    -73: &#34;File delete: failed.&#34;,
    -74: &#34;Get MAC address failed.&#34;,
    -75: &#34;NaN (Not a Number) or infinite value found.&#34;,
    -76: &#34;The coordinate system transformations are not initialized.&#34;,
    -77: &#34;A kinematic error is present.&#34;,
    -78: &#34;The motor phase process failed (phase search or phase set from position offset).&#34;,
    -79: &#34;The motor phase is not found.&#34;,
    -80: &#34;Timeout waiting for control off status.&#34;,
    -81: &#34;The requested kinematic mode (number) is not defined for the machine.&#34;,
    -82: &#34;Timeout waiting for phase found status.&#34;,
    -1000: &#34;Internal error: &#39;RET_Dev_CfS_NaNReturned&#39;.&#34;,
    -1001: &#34;Internal error: &#39;RET_Dev_CfS_FctNotAvailableInKernel&#39;.&#34;,
    -1002: &#34;Internal error: &#39;RET_Dev_CfS_UndefinedCfSType&#39;.&#34;,
    -1003: &#34;Internal error: &#39;RET_Dev_CfS_FIO_UndefinedFioType&#39;.&#34;,
    -1004: &#34;Internal error: &#39;RET_Dev_CfS_FIO_HomeFile_UndefinedAction&#39;.&#34;,
    -1005: &#34;Internal error: &#39;RET_Dev_UndefinedEnumValue&#39;.&#34;,
    -1006: &#34;Internal error: &#39;RET_Dev_LdataCmdStatusIsNegative&#39;.&#34;,
    -1007: &#34;Internal error: &#39;RET_Dev_NumMotorsInCoord_Sup_DEF_aGrQ_SIZE&#39;.&#34;,
    -1008: &#34;Internal error: &#39;RET_Dev_NumMotorsInCoord_WrongNumber&#39;.&#34;,
    -1009: &#34;Internal error: &#39;RET_String_StrCat_DestSizeReached&#39;.&#34;,
    -1010: &#34;Internal error: &#39;RET_String_LengthOverStringSize&#39;.&#34;,
    -1011: &#34;Internal error: &#39;RET_String_AllCharShouldIntBetween_0_255&#39;.&#34;,
    -1012: &#34;Internal error: &#39;RET_String_StrCpy_DestSizeReached&#39;.&#34;,
    -1013: &#34;Internal error: &#39;RET_ErrAction_HomeReset&#39;.&#34;,
    -1014: &#34;Internal error: &#39;RET_Home_StopReceivedWhileRunning&#39;.&#34;,
    -1015: &#34;Internal error: &#39;RET_UndefinedKinAssembly&#39;.&#34;,
    -1016: &#34;Internal error: &#39;RET_WrongPmcConfig&#39;.&#34;,
}


class ZondaError(Exception):
    pass


class ZondaSSHInterface(object):
    def __init__(self):
        self.client = None
        self.gpascii_client = None
        self.connected = False
        self.ssh_output = None
        self.ssh_error = None
        self.verbose = False
        self.ip = ctrl_settings.IP

        self.semaphore = threading.Semaphore()

        self.CommandReturns = RETURN_CODES

    # Etablish the SSH connection with the controller and open gpascii
    def connect(self, ip):
        try:
            # Paramiko.SSHClient can be used to make connections to the remote server and
            # transfer files
            logger.info(&#34;Establishing ssh connection with {}...&#34;.format(ip))
            self.client = paramiko.SSHClient()
            # Parsing an instance of the AutoAddPolicy to set_missing_host_key_policy() changes
            # it to allow any host.
            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.client.connect(hostname=ip, port=22, username=&#34;root&#34;, password=&#34;deltatau&#34;,
                                timeout=5,
                                allow_agent=False, look_for_keys=False)
            logger.warning(&#34;Connected to the server: {}&#34;.format(ip))
            self.connected = True
        except paramiko.AuthenticationException:
            logger.warning(&#34;Authentication failed, please verify your credentials.&#34;)
            return False
        except paramiko.SSHException as sshException:
            logger.warning(&#34;Could not establish SSH connection: %s&#34; % sshException)
            return False
        except socket.timeout as e:
            logger.warning(&#34;Connection timed out.&#34;)
            return False
        except Exception as e:
            logger.warning(&#34;Exception in connecting to the server.&#34;)
            logger.warning(&#34;Python says:&#34;, e)
            self.client.close()
            return False

        self.gpascii_client = self.client.invoke_shell(term=&#34;vt100&#34;)
        self.sendcommand(&#34;gpascii -2&#34;, 0.5)
        self.sendcommand(&#34;echo7&#34;)

    def is_connected(self):
        return self.connected

    # send a command through gpascii
    def sendcommand(self, command, wait=0):
        self.gpascii_client.send(command + &#34;\r\n&#34;)
        if self.verbose == True:
            pass  # print(&#34;Command send: {}&#34;.format(command))

        if wait &gt; 0:
            sleep(wait)

        # wait for response from gpascii
        step = 0.1
        time = 0

        while True:
            if self.gpascii_client.recv_ready():
                break
            if time &gt; 2.0:
                logger.warning(&#34;Command response timed out!&#34;)
                return &#34;&#34;
            sleep(step)
            time += step

        # get and clean response
        response = self.gpascii_client.recv(2048)
        response = response.decode()
        response = response.replace(command, &#34;&#34;)
        response = response.replace(&#34;\r&#34;, &#34;&#34;)
        # response = response.replace(&#34;\n&#34;,&#34; &#34;)
        response = response.replace(&#34;\x06&#34;, &#34;&#34;)

        # remove empty elements
        cleaned = &#34;&#34;
        lines = response.split(&#34;\n&#34;)
        for line in lines:
            if line == &#34;&#34; or line == &#34; &#34;:
                lines.remove(line)
            else:
                cleaned += line + &#34;\n&#34;

        # if self.verbose is True:
        # print(&#34;Command rcv: {}&#34;.format(cleaned))
        return cleaned

    def cmd_decode(self, name, arguments=list()):
        command = &#34;&#34;

        if &#34;JOG&#34; in name:
            command += &#34;c_ax={} &#34;.format(arguments[0])
            arguments.pop(0)

        # set cfg part
        cfg = 1
        if &#34;?&#34; in name:
            cfg = 0
            name = name.replace(&#34;?&#34;, &#34;&#34;)
        if &#34;CFG_&#34; in name:
            command += &#34;c_cfg={} &#34;.format(cfg)

        # create the parameters part of a command using the given arguments
        for index in range(0, len(arguments)):
            command += &#34;c_par({})={} &#34;.format(index, arguments[index])

        # finish command line
        command += &#34;c_cmd=C_{}&#34;.format(name)

        # logger.debug(&#34;command sent: &#34;, command)
        return command

    def cmd_check(self):
        # sends &#34;c_cmd&#34; and returns the state of the command that has been previously sent.
        Timer = 0
        last = time.process_time()

        # For a maximum of 5 sec
        while Timer &lt; 5:

            # wait and count
            time.sleep(0.1)
            Timer += time.process_time() - last
            last = time.process_time()

            # ask for command state
            response = self.sendcommand(&#34;c_cmd&#34;)
            response.replace(&#34;\n&#34;, &#34;&#34;)

            if &#34;=&#34; in response:
                # get value
                elements = response.split(&#34;=&#34;, 1)
                element = elements[1]

                # exit if command is completed
                if int(element) &lt;= 0:
                    response = element

            code = int(response)

            if code &lt; 0:
                message = self.CommandReturns[code]
                logger.warning(&#34;Command Error return: {} : {}&#34;.format(code, message))
            elif code == 0:
                message = &#34;Command successful: 0, execution time {} sec&#34;.format(Timer)
                # logger.info(message)
            return [code, message]
        logger.warning(&#34;Error: Order timed out !&#34;)
        return [-1, &#34;Error: Order timed out !&#34;]

    def p_check(self, number=20):
        # ask the value of the command parameters
        command = &#34;c_par(0)&#34;
        if number &gt; 1:
            command += &#34;,{},1&#34;.format(number)

        answer = self.sendcommand(command)
        return answer

    def disconnect(self):
        try:
            logger.info(&#34;Closing ssh connection with {}...&#34;)
            self.client.close()
            self.gpascii_client.close()
            self.connected = False
            logger.warning(&#34;...disconnected from ssh&#34;.format(self.ip))
        except Exception as e_exc:
            raise ZondaError(f&#34;Could not close socket to &#34;) from e_exc


class ZondaTelnetInterface(DeviceTransport):
    &#34;&#34;&#34;
    The ZONDA Hexapod device interface based on the telnet protocol.
    &#34;&#34;&#34;

    TELNET_TIMEOUT = 0.5

    def __init__(self):
        self.telnet = Telnet()
        self._is_connected = False

    def connect(self, hostname: str):
        self.telnet.open(hostname, 23)
        self.telnet.read_until(b&#34;login: &#34;, timeout=self.TELNET_TIMEOUT)
        self.telnet.write(b&#34;root\r\n&#34;)
        self.telnet.read_until(b&#34;Password: &#34;, timeout=self.TELNET_TIMEOUT)
        self.telnet.write(b&#34;deltatau\r\n&#34;)
        self.telnet.read_until(b&#34;ppmac# &#34;, timeout=self.TELNET_TIMEOUT)
        self.telnet.write(b&#34;gpascii -2\r\n&#34;)
        self.telnet.write(b&#34;echo7\r\n&#34;)
        self.telnet.read_until(b&#39;\x06&#39;, timeout=self.TELNET_TIMEOUT)
        self.telnet.read_very_eager()
        self._is_connected = True

    def is_connected(self):
        return self._is_connected

    def disconnect(self):
        self.telnet.read_very_eager()
        self.telnet.close()
        self._is_connected = False

    def check_command_status(self):

        if wait_until(lambda: self.trans(&#39;c_cmd&#39;)[0] == &#39;0&#39;, interval=0.01):
            rc = int(self.trans(&#39;c_cmd&#39;)[0])
            logger.warning(f&#34;Command check: {RETURN_CODES[rc]} [{rc}]&#34;)
        else:
            rc = 0

        return rc, RETURN_CODES[rc]

    def get_pars(self, count: int = 20):
        # ask the value of the command parameters
        command = &#34;c_par(0)&#34;
        if count &gt; 1:
            command += f&#34;,{count},1&#34;

        return self.trans(command)

    def trans(self, cmd: str) -&gt; List:
        self.write(cmd)
        response = self.read()
        if response and response[0] == cmd:
            return response[1:]
        else:
            return response

    def read(self) -&gt; List:
        response = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
        response = response.decode()
        parts = response.split(&#34;\r\n&#34;)
        if len(parts) == 1:
            return []
        if parts[-2] == &#39;\x06&#39;:
            return parts[:-2]
        logger.warning(&#34;Expected ACK at the end of the response&#34;)
        return parts

    def write(self, cmd: str):
        self.telnet.write(cmd.encode() + b&#34;\r\n&#34;)


def decode_command(cmd_name: str, *args):

    args = list(args)
    cmd_name = cmd_name.upper()

    full_command = &#34;&#34;

    if &#34;JOG&#34; in cmd_name:
        arg = args.pop(0)
        full_command += f&#34;c_ax={arg} &#34;

    # set cfg part

    if &#34;?&#34; in cmd_name:
        cmd_name = cmd_name.replace(&#34;?&#34;, &#34;&#34;)
        cfg = 0
    else:
        cfg = 1

    if &#34;CFG_&#34; in cmd_name:
        full_command += f&#34;c_cfg={cfg} &#34;

    # create the parameters part of a full_command using the given arguments

    for index, arg in enumerate(args):
        full_command += f&#34;c_par({index})={arg} &#34;

    # finish full_command line

    full_command += f&#34;c_cmd=C_{cmd_name}&#34;

    return full_command


if __name__ == &#34;__main__&#34;:
    import rich

    zonda = ZondaTelnetInterface()
    zonda.connect(&#34;192.168.56.10&#34;)
    rich.print(zonda.trans(&#34;s_hexa,50,1&#34;))
    rich.print(zonda.trans(&#34;s_ax_1,6,1&#34;))
    rich.print(zonda.trans(&#34;s_pos_ax_1,6,1&#34;))
    rich.print(zonda.read())
    zonda.disconnect()

    print(decode_command(&#34;CFG_LIMIT?&#34;, 0))
    print(decode_command(&#34;CFG_LIMIT&#34;, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.hexapod.symetrie.zonda_devif.decode_command"><code class="name flex">
<span>def <span class="ident">decode_command</span></span>(<span>cmd_name: str, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_command(cmd_name: str, *args):

    args = list(args)
    cmd_name = cmd_name.upper()

    full_command = &#34;&#34;

    if &#34;JOG&#34; in cmd_name:
        arg = args.pop(0)
        full_command += f&#34;c_ax={arg} &#34;

    # set cfg part

    if &#34;?&#34; in cmd_name:
        cmd_name = cmd_name.replace(&#34;?&#34;, &#34;&#34;)
        cfg = 0
    else:
        cfg = 1

    if &#34;CFG_&#34; in cmd_name:
        full_command += f&#34;c_cfg={cfg} &#34;

    # create the parameters part of a full_command using the given arguments

    for index, arg in enumerate(args):
        full_command += f&#34;c_par({index})={arg} &#34;

    # finish full_command line

    full_command += f&#34;c_cmd=C_{cmd_name}&#34;

    return full_command</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaError"><code class="flex name class">
<span>class <span class="ident">ZondaError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZondaError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface"><code class="flex name class">
<span>class <span class="ident">ZondaSSHInterface</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZondaSSHInterface(object):
    def __init__(self):
        self.client = None
        self.gpascii_client = None
        self.connected = False
        self.ssh_output = None
        self.ssh_error = None
        self.verbose = False
        self.ip = ctrl_settings.IP

        self.semaphore = threading.Semaphore()

        self.CommandReturns = RETURN_CODES

    # Etablish the SSH connection with the controller and open gpascii
    def connect(self, ip):
        try:
            # Paramiko.SSHClient can be used to make connections to the remote server and
            # transfer files
            logger.info(&#34;Establishing ssh connection with {}...&#34;.format(ip))
            self.client = paramiko.SSHClient()
            # Parsing an instance of the AutoAddPolicy to set_missing_host_key_policy() changes
            # it to allow any host.
            self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.client.connect(hostname=ip, port=22, username=&#34;root&#34;, password=&#34;deltatau&#34;,
                                timeout=5,
                                allow_agent=False, look_for_keys=False)
            logger.warning(&#34;Connected to the server: {}&#34;.format(ip))
            self.connected = True
        except paramiko.AuthenticationException:
            logger.warning(&#34;Authentication failed, please verify your credentials.&#34;)
            return False
        except paramiko.SSHException as sshException:
            logger.warning(&#34;Could not establish SSH connection: %s&#34; % sshException)
            return False
        except socket.timeout as e:
            logger.warning(&#34;Connection timed out.&#34;)
            return False
        except Exception as e:
            logger.warning(&#34;Exception in connecting to the server.&#34;)
            logger.warning(&#34;Python says:&#34;, e)
            self.client.close()
            return False

        self.gpascii_client = self.client.invoke_shell(term=&#34;vt100&#34;)
        self.sendcommand(&#34;gpascii -2&#34;, 0.5)
        self.sendcommand(&#34;echo7&#34;)

    def is_connected(self):
        return self.connected

    # send a command through gpascii
    def sendcommand(self, command, wait=0):
        self.gpascii_client.send(command + &#34;\r\n&#34;)
        if self.verbose == True:
            pass  # print(&#34;Command send: {}&#34;.format(command))

        if wait &gt; 0:
            sleep(wait)

        # wait for response from gpascii
        step = 0.1
        time = 0

        while True:
            if self.gpascii_client.recv_ready():
                break
            if time &gt; 2.0:
                logger.warning(&#34;Command response timed out!&#34;)
                return &#34;&#34;
            sleep(step)
            time += step

        # get and clean response
        response = self.gpascii_client.recv(2048)
        response = response.decode()
        response = response.replace(command, &#34;&#34;)
        response = response.replace(&#34;\r&#34;, &#34;&#34;)
        # response = response.replace(&#34;\n&#34;,&#34; &#34;)
        response = response.replace(&#34;\x06&#34;, &#34;&#34;)

        # remove empty elements
        cleaned = &#34;&#34;
        lines = response.split(&#34;\n&#34;)
        for line in lines:
            if line == &#34;&#34; or line == &#34; &#34;:
                lines.remove(line)
            else:
                cleaned += line + &#34;\n&#34;

        # if self.verbose is True:
        # print(&#34;Command rcv: {}&#34;.format(cleaned))
        return cleaned

    def cmd_decode(self, name, arguments=list()):
        command = &#34;&#34;

        if &#34;JOG&#34; in name:
            command += &#34;c_ax={} &#34;.format(arguments[0])
            arguments.pop(0)

        # set cfg part
        cfg = 1
        if &#34;?&#34; in name:
            cfg = 0
            name = name.replace(&#34;?&#34;, &#34;&#34;)
        if &#34;CFG_&#34; in name:
            command += &#34;c_cfg={} &#34;.format(cfg)

        # create the parameters part of a command using the given arguments
        for index in range(0, len(arguments)):
            command += &#34;c_par({})={} &#34;.format(index, arguments[index])

        # finish command line
        command += &#34;c_cmd=C_{}&#34;.format(name)

        # logger.debug(&#34;command sent: &#34;, command)
        return command

    def cmd_check(self):
        # sends &#34;c_cmd&#34; and returns the state of the command that has been previously sent.
        Timer = 0
        last = time.process_time()

        # For a maximum of 5 sec
        while Timer &lt; 5:

            # wait and count
            time.sleep(0.1)
            Timer += time.process_time() - last
            last = time.process_time()

            # ask for command state
            response = self.sendcommand(&#34;c_cmd&#34;)
            response.replace(&#34;\n&#34;, &#34;&#34;)

            if &#34;=&#34; in response:
                # get value
                elements = response.split(&#34;=&#34;, 1)
                element = elements[1]

                # exit if command is completed
                if int(element) &lt;= 0:
                    response = element

            code = int(response)

            if code &lt; 0:
                message = self.CommandReturns[code]
                logger.warning(&#34;Command Error return: {} : {}&#34;.format(code, message))
            elif code == 0:
                message = &#34;Command successful: 0, execution time {} sec&#34;.format(Timer)
                # logger.info(message)
            return [code, message]
        logger.warning(&#34;Error: Order timed out !&#34;)
        return [-1, &#34;Error: Order timed out !&#34;]

    def p_check(self, number=20):
        # ask the value of the command parameters
        command = &#34;c_par(0)&#34;
        if number &gt; 1:
            command += &#34;,{},1&#34;.format(number)

        answer = self.sendcommand(command)
        return answer

    def disconnect(self):
        try:
            logger.info(&#34;Closing ssh connection with {}...&#34;)
            self.client.close()
            self.gpascii_client.close()
            self.connected = False
            logger.warning(&#34;...disconnected from ssh&#34;.format(self.ip))
        except Exception as e_exc:
            raise ZondaError(f&#34;Could not close socket to &#34;) from e_exc</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.cmd_check"><code class="name flex">
<span>def <span class="ident">cmd_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmd_check(self):
    # sends &#34;c_cmd&#34; and returns the state of the command that has been previously sent.
    Timer = 0
    last = time.process_time()

    # For a maximum of 5 sec
    while Timer &lt; 5:

        # wait and count
        time.sleep(0.1)
        Timer += time.process_time() - last
        last = time.process_time()

        # ask for command state
        response = self.sendcommand(&#34;c_cmd&#34;)
        response.replace(&#34;\n&#34;, &#34;&#34;)

        if &#34;=&#34; in response:
            # get value
            elements = response.split(&#34;=&#34;, 1)
            element = elements[1]

            # exit if command is completed
            if int(element) &lt;= 0:
                response = element

        code = int(response)

        if code &lt; 0:
            message = self.CommandReturns[code]
            logger.warning(&#34;Command Error return: {} : {}&#34;.format(code, message))
        elif code == 0:
            message = &#34;Command successful: 0, execution time {} sec&#34;.format(Timer)
            # logger.info(message)
        return [code, message]
    logger.warning(&#34;Error: Order timed out !&#34;)
    return [-1, &#34;Error: Order timed out !&#34;]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.cmd_decode"><code class="name flex">
<span>def <span class="ident">cmd_decode</span></span>(<span>self, name, arguments=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmd_decode(self, name, arguments=list()):
    command = &#34;&#34;

    if &#34;JOG&#34; in name:
        command += &#34;c_ax={} &#34;.format(arguments[0])
        arguments.pop(0)

    # set cfg part
    cfg = 1
    if &#34;?&#34; in name:
        cfg = 0
        name = name.replace(&#34;?&#34;, &#34;&#34;)
    if &#34;CFG_&#34; in name:
        command += &#34;c_cfg={} &#34;.format(cfg)

    # create the parameters part of a command using the given arguments
    for index in range(0, len(arguments)):
        command += &#34;c_par({})={} &#34;.format(index, arguments[index])

    # finish command line
    command += &#34;c_cmd=C_{}&#34;.format(name)

    # logger.debug(&#34;command sent: &#34;, command)
    return command</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, ip)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, ip):
    try:
        # Paramiko.SSHClient can be used to make connections to the remote server and
        # transfer files
        logger.info(&#34;Establishing ssh connection with {}...&#34;.format(ip))
        self.client = paramiko.SSHClient()
        # Parsing an instance of the AutoAddPolicy to set_missing_host_key_policy() changes
        # it to allow any host.
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.client.connect(hostname=ip, port=22, username=&#34;root&#34;, password=&#34;deltatau&#34;,
                            timeout=5,
                            allow_agent=False, look_for_keys=False)
        logger.warning(&#34;Connected to the server: {}&#34;.format(ip))
        self.connected = True
    except paramiko.AuthenticationException:
        logger.warning(&#34;Authentication failed, please verify your credentials.&#34;)
        return False
    except paramiko.SSHException as sshException:
        logger.warning(&#34;Could not establish SSH connection: %s&#34; % sshException)
        return False
    except socket.timeout as e:
        logger.warning(&#34;Connection timed out.&#34;)
        return False
    except Exception as e:
        logger.warning(&#34;Exception in connecting to the server.&#34;)
        logger.warning(&#34;Python says:&#34;, e)
        self.client.close()
        return False

    self.gpascii_client = self.client.invoke_shell(term=&#34;vt100&#34;)
    self.sendcommand(&#34;gpascii -2&#34;, 0.5)
    self.sendcommand(&#34;echo7&#34;)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    try:
        logger.info(&#34;Closing ssh connection with {}...&#34;)
        self.client.close()
        self.gpascii_client.close()
        self.connected = False
        logger.warning(&#34;...disconnected from ssh&#34;.format(self.ip))
    except Exception as e_exc:
        raise ZondaError(f&#34;Could not close socket to &#34;) from e_exc</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    return self.connected</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.p_check"><code class="name flex">
<span>def <span class="ident">p_check</span></span>(<span>self, number=20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def p_check(self, number=20):
    # ask the value of the command parameters
    command = &#34;c_par(0)&#34;
    if number &gt; 1:
        command += &#34;,{},1&#34;.format(number)

    answer = self.sendcommand(command)
    return answer</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.sendcommand"><code class="name flex">
<span>def <span class="ident">sendcommand</span></span>(<span>self, command, wait=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendcommand(self, command, wait=0):
    self.gpascii_client.send(command + &#34;\r\n&#34;)
    if self.verbose == True:
        pass  # print(&#34;Command send: {}&#34;.format(command))

    if wait &gt; 0:
        sleep(wait)

    # wait for response from gpascii
    step = 0.1
    time = 0

    while True:
        if self.gpascii_client.recv_ready():
            break
        if time &gt; 2.0:
            logger.warning(&#34;Command response timed out!&#34;)
            return &#34;&#34;
        sleep(step)
        time += step

    # get and clean response
    response = self.gpascii_client.recv(2048)
    response = response.decode()
    response = response.replace(command, &#34;&#34;)
    response = response.replace(&#34;\r&#34;, &#34;&#34;)
    # response = response.replace(&#34;\n&#34;,&#34; &#34;)
    response = response.replace(&#34;\x06&#34;, &#34;&#34;)

    # remove empty elements
    cleaned = &#34;&#34;
    lines = response.split(&#34;\n&#34;)
    for line in lines:
        if line == &#34;&#34; or line == &#34; &#34;:
            lines.remove(line)
        else:
            cleaned += line + &#34;\n&#34;

    # if self.verbose is True:
    # print(&#34;Command rcv: {}&#34;.format(cleaned))
    return cleaned</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface"><code class="flex name class">
<span>class <span class="ident">ZondaTelnetInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>The ZONDA Hexapod device interface based on the telnet protocol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZondaTelnetInterface(DeviceTransport):
    &#34;&#34;&#34;
    The ZONDA Hexapod device interface based on the telnet protocol.
    &#34;&#34;&#34;

    TELNET_TIMEOUT = 0.5

    def __init__(self):
        self.telnet = Telnet()
        self._is_connected = False

    def connect(self, hostname: str):
        self.telnet.open(hostname, 23)
        self.telnet.read_until(b&#34;login: &#34;, timeout=self.TELNET_TIMEOUT)
        self.telnet.write(b&#34;root\r\n&#34;)
        self.telnet.read_until(b&#34;Password: &#34;, timeout=self.TELNET_TIMEOUT)
        self.telnet.write(b&#34;deltatau\r\n&#34;)
        self.telnet.read_until(b&#34;ppmac# &#34;, timeout=self.TELNET_TIMEOUT)
        self.telnet.write(b&#34;gpascii -2\r\n&#34;)
        self.telnet.write(b&#34;echo7\r\n&#34;)
        self.telnet.read_until(b&#39;\x06&#39;, timeout=self.TELNET_TIMEOUT)
        self.telnet.read_very_eager()
        self._is_connected = True

    def is_connected(self):
        return self._is_connected

    def disconnect(self):
        self.telnet.read_very_eager()
        self.telnet.close()
        self._is_connected = False

    def check_command_status(self):

        if wait_until(lambda: self.trans(&#39;c_cmd&#39;)[0] == &#39;0&#39;, interval=0.01):
            rc = int(self.trans(&#39;c_cmd&#39;)[0])
            logger.warning(f&#34;Command check: {RETURN_CODES[rc]} [{rc}]&#34;)
        else:
            rc = 0

        return rc, RETURN_CODES[rc]

    def get_pars(self, count: int = 20):
        # ask the value of the command parameters
        command = &#34;c_par(0)&#34;
        if count &gt; 1:
            command += f&#34;,{count},1&#34;

        return self.trans(command)

    def trans(self, cmd: str) -&gt; List:
        self.write(cmd)
        response = self.read()
        if response and response[0] == cmd:
            return response[1:]
        else:
            return response

    def read(self) -&gt; List:
        response = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
        response = response.decode()
        parts = response.split(&#34;\r\n&#34;)
        if len(parts) == 1:
            return []
        if parts[-2] == &#39;\x06&#39;:
            return parts[:-2]
        logger.warning(&#34;Expected ACK at the end of the response&#34;)
        return parts

    def write(self, cmd: str):
        self.telnet.write(cmd.encode() + b&#34;\r\n&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.TELNET_TIMEOUT"><code class="name">var <span class="ident">TELNET_TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.check_command_status"><code class="name flex">
<span>def <span class="ident">check_command_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_command_status(self):

    if wait_until(lambda: self.trans(&#39;c_cmd&#39;)[0] == &#39;0&#39;, interval=0.01):
        rc = int(self.trans(&#39;c_cmd&#39;)[0])
        logger.warning(f&#34;Command check: {RETURN_CODES[rc]} [{rc}]&#34;)
    else:
        rc = 0

    return rc, RETURN_CODES[rc]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, hostname: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, hostname: str):
    self.telnet.open(hostname, 23)
    self.telnet.read_until(b&#34;login: &#34;, timeout=self.TELNET_TIMEOUT)
    self.telnet.write(b&#34;root\r\n&#34;)
    self.telnet.read_until(b&#34;Password: &#34;, timeout=self.TELNET_TIMEOUT)
    self.telnet.write(b&#34;deltatau\r\n&#34;)
    self.telnet.read_until(b&#34;ppmac# &#34;, timeout=self.TELNET_TIMEOUT)
    self.telnet.write(b&#34;gpascii -2\r\n&#34;)
    self.telnet.write(b&#34;echo7\r\n&#34;)
    self.telnet.read_until(b&#39;\x06&#39;, timeout=self.TELNET_TIMEOUT)
    self.telnet.read_very_eager()
    self._is_connected = True</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    self.telnet.read_very_eager()
    self.telnet.close()
    self._is_connected = False</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.get_pars"><code class="name flex">
<span>def <span class="ident">get_pars</span></span>(<span>self, count: int = 20)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pars(self, count: int = 20):
    # ask the value of the command parameters
    command = &#34;c_par(0)&#34;
    if count &gt; 1:
        command += f&#34;,{count},1&#34;

    return self.trans(command)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    return self._is_connected</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.query" href="../../device.html#egse.device.DeviceTransport.query">query</a></code></li>
<li><code><a title="egse.device.DeviceTransport.read" href="../../device.html#egse.device.DeviceTransport.read">read</a></code></li>
<li><code><a title="egse.device.DeviceTransport.trans" href="../../device.html#egse.device.DeviceTransport.trans">trans</a></code></li>
<li><code><a title="egse.device.DeviceTransport.write" href="../../device.html#egse.device.DeviceTransport.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.hexapod.symetrie" href="index.html">egse.hexapod.symetrie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.zonda_devif.decode_command" href="#egse.hexapod.symetrie.zonda_devif.decode_command">decode_command</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaError" href="#egse.hexapod.symetrie.zonda_devif.ZondaError">ZondaError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface">ZondaSSHInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.cmd_check" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.cmd_check">cmd_check</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.cmd_decode" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.cmd_decode">cmd_decode</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.connect" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.disconnect" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.is_connected" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.p_check" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.p_check">p_check</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.sendcommand" href="#egse.hexapod.symetrie.zonda_devif.ZondaSSHInterface.sendcommand">sendcommand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface">ZondaTelnetInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.TELNET_TIMEOUT" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.TELNET_TIMEOUT">TELNET_TIMEOUT</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.check_command_status" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.check_command_status">check_command_status</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.connect" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.disconnect" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.get_pars" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.get_pars">get_pars</a></code></li>
<li><code><a title="egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.is_connected" href="#egse.hexapod.symetrie.zonda_devif.ZondaTelnetInterface.is_connected">is_connected</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
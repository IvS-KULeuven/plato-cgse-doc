<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.hexapod.symetrie.puna API documentation</title>
<meta name="description" content="This module defines the device classes to be used to connect to and control the Hexapod PUNA from
Symétrie." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.hexapod.symetrie.puna</code></h1>
</header>
<section id="section-intro">
<p>This module defines the device classes to be used to connect to and control the Hexapod PUNA from
Symétrie.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the device classes to be used to connect to and control the Hexapod PUNA from
Symétrie.

&#34;&#34;&#34;
import logging
import math
import time
from datetime import datetime
from datetime import timedelta

import numpy as np

from egse.bits import set_bit
from egse.coordinates.referenceFrame import ReferenceFrame
from egse.device import DeviceConnectionState
from egse.device import DeviceInterface
from egse.hexapod import HexapodError
from egse.hexapod.symetrie import pmac
from egse.hexapod.symetrie.alpha import AlphaControllerInterface
from egse.hexapod.symetrie.pmac import PMACError
from egse.hexapod.symetrie.pmac import PmacEthernetInterface
from egse.hexapod.symetrie.pmac import decode_Q29
from egse.hexapod.symetrie.pmac import decode_Q36
from egse.proxy import Proxy
from egse.settings import Settings
from egse.zmq_ser import connect_address

logger = logging.getLogger(__name__)

PUNA_SETTINGS = Settings.load(&#34;PMAC Controller&#34;)
CTRL_SETTINGS = Settings.load(&#34;Hexapod PUNA Control Server&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;puna.yaml&#34;)

NUM_OF_DECIMALS = 6  # used for rounding numbers before sending to PMAC


class PunaInterface(AlphaControllerInterface, DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the PunaController, the PunaProxy and the PunaSimulator.
    &#34;&#34;&#34;


class PunaController(PunaInterface):
    &#34;&#34;&#34;
    The PunaController class allows controlling a Symétrie PUNA Hexapod through an Ethernet
    interface that is connecting a Symétrie Controller.

    The Symétrie Controller can be either in simulation mode or have a real Hexapod
    connected.

    **Synopsis**

        from egse.hexapod.symetrie.puna import PunaController
        hexapod = PunaController(hostname=&#34;10.33.178.145&#34;, port=1025)
        try:
            hexapod.connect()

            # do some useful things here with the hexapod

        except HexapodError as exc:
            print(exc)
        finally:
            hexapod.disconnect()

    The constructor also sets the connection parameters and tries to connect
    to the controller. Make sure that you explicitly use the hexapod.disconnect()
    command when no connection is needed anymore.

    The controller can also be used as a context manager, in which case the `connect()`
    and `disconnect()` methods should not be called:

        with PunaController() as puna:
            puna.info()

    &#34;&#34;&#34;

    SPEC_POS_MAINTENANCE = 0
    &#34;&#34;&#34;Hexapod specific position, for maintenance or Jog only.&#34;&#34;&#34;
    SPEC_POS_ZERO = 1
    &#34;&#34;&#34;Hexapod zero position.&#34;&#34;&#34;
    SPEC_POS_RETRACTED = 2
    &#34;&#34;&#34;Hexapod retracted position.&#34;&#34;&#34;

    def __init__(self, hostname=None, port=None):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the Hexapod PUNA Hardware Controller.

        Args:
            hostname (str): the IP address or fully qualified hostname of the Hexapod hardware
            controller.
                The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the ``settings.yaml``
            configuration file.

        Raises:
            HexapodError: when the connection could not be established for some reason.
        &#34;&#34;&#34;

        super().__init__()

        if hostname is None or port is None:
            raise ValueError(f&#34;Please provide both hostname and port for the PunaController, {hostname=}, {port=}&#34;)

        logger.debug(f&#34;Initializing PunaController with hostname={hostname} on port={port}&#34;)

        try:
            self.pmac = PmacEthernetInterface()
            self.pmac.setConnectionParameters(hostname, port)
        except PMACError as exc:
            logger.warning(
                f&#34;HexapodError: Couldn&#39;t establish connection with the Hexapod PUNA Hardware &#34;
                f&#34;Controller: ({exc})&#34;
            )

    def is_simulator(self):
        return False

    def is_connected(self):
        return self.pmac.isConnected()

    def connect(self):
        try:
            self.pmac.connect()
        except PMACError as exc:
            logger.warning(f&#34;PMACError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the Hexapod.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        try:
            self.pmac.disconnect()
        except PMACError as exc:
            raise ConnectionError(&#34;Couldn&#39;t disconnect from Hexapod.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_in_position(self):
        try:
            out = self.pmac.getQVars(36, [0], int)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t retrieve information from Hexapod PUNA Hardware Controller.&#34;) from exc
        return bool(out[0] &amp; 0x04)

    def info(self):
        try:
            msg = &#34;Info about the Hexapod PUNA:\n&#34;
            msg += f&#34;model   = {self.pmac.getPmacModel()}\n&#34;
            msg += f&#34;CID     = {self.pmac.getCID()}\n&#34;
            msg += f&#34;version = {self.pmac.getVersion()}\n&#34;
            msg += f&#34;cpu     = {self.pmac.getCPU()}\n&#34;
            msg += f&#34;type    = {self.pmac.getType()}\n&#34;
            msg += f&#34;vendorID= {self.pmac.getVID()}\n&#34;
            msg += f&#34;date    = {self.pmac.getDate()}\n&#34;
            msg += f&#34;time    = {self.pmac.getTime()}\n&#34;
            msg += f&#34;today   = {self.pmac.getToday()}\n&#34;
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t retrieve information from Hexapod PUNA Hardware Controller.&#34;
            ) from exc

        return msg

    def stop(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_STOP)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t complete the STOP command.&#34;) from exc

        return rc

    def homing(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_HOMING)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t complete the HOMING command.&#34;) from exc

        logger.info(&#34;Homing: Command was successful&#34;)

        return rc

    def is_homing_done(self):
        try:
            rc = self.pmac.getQVars(26, [0], int)[0]
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return False

        msg = {  # noqa: F841
            0: &#34;Homing status is undefined.&#34;,
            1: &#34;Homing is in progress&#34;,
            2: &#34;Homing is done&#34;,
            3: &#34;An error occurred during the Homing process.&#34;,
        }

        if rc == 2:
            return True

        return False

    def set_virtual_homing(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.pmac.sendCommand(
                pmac.CMD_VIRTUAL_HOMING, tx=tx, ty=ty, tz=tz, rx=rx, ry=ry, rz=rz
            )
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the virtual homing command.&#34;) from exc

        logger.warning(
            f&#34;Virtual Homing successfully set to {tx:.6f}, {ty:.6f}, {tz:.6f}, {rx:.6f}, &#34;
            f&#34;{ry:.6f}, {rz:.6f}.&#34;
        )

        return rc

    def activate_control_loop(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CONTROLON)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t activate the control loop.&#34;) from exc

        msg = {  # noqa: F841
            0: &#34;Command was successful&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Control of the servo motors has failed&#34;,
        }

        return rc

    def deactivate_control_loop(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CONTROLOFF)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t de-activate the control loop.&#34;) from exc

        return rc

    def __move(self, cm, tx, ty, tz, rx, ry, rz):
        &#34;&#34;&#34;
        Ask the controller to perform the movement defined by the arguments.

        For all control modes cm, the rotation centre coincides with the Object
        Coordinates System origin and the movements are controlled with translation
        components at first (Tx, Ty, tZ) and then the rotation components (Rx, Ry, Rz).

        Control mode cm:
            * 0 = absolute control, object coordinate system position and orientation
                    expressed in the invariant user coordinate system
            * 1 = object relative, motion expressed in the Object Coordinate System
            * 2 = user relative, motion expressed in the User Coordinate System

        Args:
            cm (int): control mode
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            0 on success, -1 when ignored, -2 on error.

        Raises:
            PMACError: when the arguments do not match up or when there is a time out or when
            there is a socket
            communication error.

        .. note:: When the command was not successful, this method will query the ``POSVALID?``
                  using the checkAbsolutePosition() and print a summary of the error messages
                  to the log file.
        &#34;&#34;&#34;

        rc = self.pmac.sendCommand(pmac.CMD_MOVE, cm=cm, tx=tx, ty=ty, tz=tz, rx=rx, ry=ry, rz=rz)

        error_code_msg = {
            0: &#34;Command was successful&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Command was invalid, check with POSVALID?&#34;,
        }

        if rc &lt; 0:
            msg = f&#34;Move command returned ({rc}: {error_code_msg[rc]}).&#34;

            if rc == -2:
                Q29, errors = self.__check_movement(cm, tx, ty, tz, rx, ry, rz)

                msg += &#34;\nError messages returned from POSVALID?:\n&#34;
                for key, value in errors.items():
                    msg += f&#34;  bit {key:&lt;2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def __check_movement(self, cm, tx, ty, tz, rx, ry, rz):
        &#34;&#34;&#34;
        Ask the controller if the movement defined by the arguments is feasible.

        Returns a tuple where the first element is an integer that represents the
        bitfield encoding the errors. The second element is a dictionary with the
        bit numbers that were (on) and the corresponding error description.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        &#34;&#34;&#34;
        out = self.pmac.sendCommand(
            pmac.CMD_POSVALID_GET, cm=cm, tx=tx, ty=ty, tz=tz, rx=rx, ry=ry, rz=rz
        )
        Q29 = decode_Q29(out[0])
        return out[0], Q29

    def move_absolute(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.__move(0, tx, ty, tz, rx, ry, rz)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the moveAbsolute command.&#34;) from exc

        return rc

    def check_absolute_movement(self, tx, ty, tz, rx, ry, rz):
        return self.__check_movement(0, tx, ty, tz, rx, ry, rz)

    def move_relative_object(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.__move(1, tx, ty, tz, rx, ry, rz)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the relative movement [object] command.&#34;) from exc

        return rc

    def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz):
        return self.__check_movement(1, tx, ty, tz, rx, ry, rz)

    def move_relative_user(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.__move(2, tx, ty, tz, rx, ry, rz)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the relative movement [user] command.&#34;) from exc

        return rc

    def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz):
        return self.__check_movement(2, tx, ty, tz, rx, ry, rz)

    def perform_maintenance(self, axis):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_MAINTENANCE, axis=axis)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t perform maintenance cycle.&#34;) from exc

        msg = {0: &#34;Command was successfully executed&#34;, -1: &#34;Command was ignored&#34;}  # noqa: F841

        return rc

    def goto_specific_position(self, pos):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_SPECIFICPOS, pos=pos)
        except PMACError as exc:
            raise HexapodError(f&#34;Couldn&#39;t goto specific position [pos={pos}].&#34;) from exc

        msg = {
            0: &#34;Command was successfully executed&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Invalid movement command&#34;,
        }

        logger.info(f&#34;Goto Specific Position [{pos}]: {msg[rc]}&#34;)

        if rc &lt; 0:
            try:
                out = self.pmac.getQVars(0, [29], int)
            except PMACError as exc:
                raise HexapodError(&#34;Couldn&#39;t get a response from the Hexapod controller.&#34;) from exc
            Q29 = decode_Q29(out[0])

            msg = &#34;Error messages returned in Q29:\n&#34;
            for key, value in Q29.items():
                msg += f&#34;  {key:2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def goto_retracted_position(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_SPECIFICPOS, pos=self.SPEC_POS_RETRACTED)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t goto retracted position.&#34;) from exc

        msg = {
            0: &#34;Command was successfully executed&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Invalid movement command&#34;,
        }

        logger.info(f&#34;Goto Retracted Position [2]: {msg[rc]}&#34;)

        if rc &lt; 0:
            try:
                out = self.pmac.getQVars(0, [29], int)
            except PMACError as exc:
                raise HexapodError(&#34;Couldn&#39;t get a response from the Hexapod controller.&#34;) from exc
            Q29 = decode_Q29(out[0])

            msg = &#34;Error messages returned in Q29:\n&#34;
            for key, value in Q29.items():
                msg += f&#34;  {key:2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def goto_zero_position(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_SPECIFICPOS, pos=self.SPEC_POS_ZERO)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t goto zero position.&#34;) from exc

        msg = {
            0: &#34;Command was successfully executed&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Invalid movement command&#34;,
        }

        logger.info(f&#34;Goto Zero Position [1]: {msg[rc]}&#34;)

        if rc &lt; 0:
            try:
                out = self.pmac.getQVars(0, [29], int)
            except PMACError as exc:
                raise HexapodError(&#34;Couldn&#39;t get a response from the Hexapod controller.&#34;) from exc
            Q29 = decode_Q29(out[0])

            msg = &#34;Error messages returned in Q29:\n&#34;
            for key, value in Q29.items():
                msg += f&#34;  {key:2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def get_buffer(self):
        return_string = self.pmac.getBuffer()
        return return_string

    def clear_error(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CLEARERROR)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t clear errors in the controller software.&#34;) from exc

        return rc

    def jog(self, axis: int, inc: float) -&gt; int:
        if not (1 &lt;= axis &lt;= 6):
            logger.error(f&#34;The axis argument must be 1 &lt;= axis &lt;= 6, given {axis}.&#34;)
            raise HexapodError(&#34;Illegal Argument Value: axis is {axis}, should be 1 &lt;= axis &lt;= 6.&#34;)

        try:
            rc = self.pmac.sendCommand(pmac.CMD_JOG, axis=axis, inc=inc)
        except PMACError as exc:
            raise HexapodError(
                f&#34;Couldn&#39;t execute the jog command for axis={axis} with inc={inc} [mm].&#34;
            ) from exc

        msg = {0: &#34;Command was successfully executed&#34;, -1: &#34;Command was ignored&#34;}

        logger.info(f&#34;JOG on axis [{axis}] of {inc} mm: {msg[rc]}&#34;)

        return rc

    def configure_coordinates_systems(
        self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
    ):
        try:

            rc = self.pmac.sendCommand(
                pmac.CMD_CFG_CS,
                tx_u=round(tx_u, NUM_OF_DECIMALS),
                ty_u=round(ty_u, NUM_OF_DECIMALS),
                tz_u=round(tz_u, NUM_OF_DECIMALS),
                rx_u=round(rx_u, NUM_OF_DECIMALS),
                ry_u=round(ry_u, NUM_OF_DECIMALS),
                rz_u=round(rz_u, NUM_OF_DECIMALS),
                tx_o=round(tx_o, NUM_OF_DECIMALS),
                ty_o=round(ty_o, NUM_OF_DECIMALS),
                tz_o=round(tz_o, NUM_OF_DECIMALS),
                rx_o=round(rx_o, NUM_OF_DECIMALS),
                ry_o=round(ry_o, NUM_OF_DECIMALS),
                rz_o=round(rz_o, NUM_OF_DECIMALS),
            )
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t configure coordinate systems on the hexapod controller.&#34;
            ) from exc

        return rc

    def get_coordinates_systems(self):
        try:
            out = self.pmac.sendCommand(pmac.CMD_CFG_CS_GET)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t get the coordinate systems information from the hexapod controller.&#34;
            ) from exc

        return out

    def get_debug_info(self):
        try:
            out = self.pmac.sendCommand(pmac.CMD_STATE_DEBUG_GET)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t get the debugging information from the hexapod controller.&#34;
            ) from exc

        return out

    def set_speed(self, vt, vr):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CFG_SPEED, vt=vt, vr=vr)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t set the speed for translation [{vt} mm/s] or rotation [{vr} deg/s].&#34;
            ) from exc

        return rc

    def get_speed(self):
        try:
            out = self.pmac.sendCommand(pmac.CMD_CFG_SPEED_GET)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t get the speed settings from the hexapod controller.&#34;
            ) from exc

        return out

    def get_general_state(self):
        try:
            out = self.pmac.getQVars(36, [0], int)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out[0], pmac.decode_Q36(out[0])

    def get_actuator_state(self):
        try:
            out = self.pmac.getQVars(30, [0, 1, 2, 3, 4, 5], int)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return [pmac.decode_Q30(value) for value in out]

    def get_user_positions(self):
        try:
            # out = self.pmac.getQVars(53, [0, 1, 2, 3, 4, 5], float)
            out = self.pmac.sendCommand(pmac.CMD_POSUSER_GET)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out

    def get_machine_positions(self):
        try:
            out = self.pmac.getQVars(47, [0, 1, 2, 3, 4, 5], float)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out

    def get_actuator_length(self):
        try:
            out = self.pmac.getQVars(41, [0, 1, 2, 3, 4, 5], float)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out

    def reset(self, wait=True, verbose=False):
        try:
            self.pmac.sendCommand(pmac.CMD_RESETSOFT)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t (soft) reset the hexapod controller.&#34;) from exc

        # How do I know when the RESETSOFT has finished and we can send further commands?

        if wait:
            logger.info(&#34;Sent a soft reset, this will take about 30 seconds to complete.&#34;)
            self.__wait(30, verbose=verbose)

    def __wait(self, duration, verbose=False):
        &#34;&#34;&#34;
        Wait for a specific duration in seconds.
        &#34;&#34;&#34;
        _timeout = timedelta(seconds=duration)
        _start = datetime.now()

        _rate = timedelta(seconds=5)  # every _rate seconds print a message
        _count = 0

        logger.info(f&#34;Just waiting {duration} seconds ...&#34;)

        while datetime.now() - _start &lt; _timeout:

            if verbose and (datetime.now() - _start &gt; _count * _rate):
                _count += 1
                logger.info(f&#34;waited for {_count * _rate} of {_timeout} seconds, &#34;)
                print(f&#34;waited for {_count * _rate} of {_timeout} seconds, &#34;)

            time.sleep(0.01)


class PunaSimulator(PunaInterface):
    &#34;&#34;&#34;
    HexapodSimulator simulates the Symétrie Hexapod PUNA. The class is heavily based on the
    ReferenceFrames in the `egse.coordinates` package.

    The simulator implements the same methods as the HexapodController class which acts on the
    real hardware controller in either simulation mode or with a real Hexapod PUNA connected.

    Therefore, the HexapodSimulator can be used instead of the Hexapod class in test harnesses
    and when the hardware is not available.

    This class simulates all the movements and status of the Hexapod.
    &#34;&#34;&#34;

    def __init__(self):

        identity = np.identity(4)

        # Rotation around static axis, and around x, y and z in that order
        self.rot_config = &#34;sxyz&#34;

        # Configure the Master Reference Frame
        self.cs_master = ReferenceFrame.createMaster()

        # Configure the Machine Coordinate System, i.e. cs_mec [ref:cs_master]
        self.cs_machine = ReferenceFrame(
            transformation=identity,
            ref=self.cs_master,
            name=&#34;Machine[Master]&#34;,
            rot_config=self.rot_config,
        )

        # Configure the Platform Coordinate System, i.e. cs_platform [ref:cs_machine]
        # default after homing: PLATFORM = MACHINE

        self.cs_platform = ReferenceFrame(
            transformation=identity,
            ref=self.cs_machine,
            name=&#34;Platform[Machine]&#34;,
            rot_config=self.rot_config,
        )

        # Configure the User Coordinate System, i.e. cs_user [ref:cs_machine]
        self.cs_user = ReferenceFrame(
            transformation=identity,
            ref=self.cs_machine,
            name=&#34;User[Machine]&#34;,
            rot_config=self.rot_config,
        )

        # Configure the Object Coordinate System, i.e. cs_object [ref:cs_platform]
        self.cs_object = ReferenceFrame(
            transformation=identity,
            ref=self.cs_platform,
            name=&#34;Object[Platform]&#34;,
            rot_config=self.rot_config,
        )

        # We use a CS called cs_object_in_user, i.e. Object as defined in the User CS,
        # and we define this
        # from the transformation user -&gt; object.

        tf_user_to_object = self.cs_user.getActiveTransformationTo(self.cs_object)
        self.cs_object_in_user = ReferenceFrame(
            tf_user_to_object, rot_config=self.rot_config, ref=self.cs_user, name=&#34;Object[User]&#34;
        )

        # Define the invariant links within the system, i.e. some systems are bound with an
        # invariant transformation
        # matrix and those links shall be preserved throughout the movement within the system.

        # We link this cs_object_in_user to cs_object with the identity transformation,
        # which connects them together

        self.cs_object_in_user.addLink(self.cs_object, transformation=identity)

        # The User Coordinate System is linked to the Machine Coordinate System

        self.cs_machine.addLink(self.cs_user, transformation=self.cs_user.transformation)

        # The Object Coordinate System is linked to the Platform Coordinate System

        self.cs_platform.addLink(self.cs_object, transformation=self.cs_object.transformation)

        # Keep a record if the homing() command has been executed.

        self.homing_done = False
        self.control_loop = False
        self._virtual_homing = False
        self._virtual_homing_position = None

        # Just keep the speed settings, no used in movement currently

        self._speed = [1.0, 1.0, 0.01, 0.001, 4.0, 2.0]

        # Print out some debugging information

        logger.debug(
            f&#34;Linked to cs_object_in_user  {[i.name for i in self.cs_object_in_user.linkedTo]}&#34;
        )
        logger.debug(f&#34;Linked to cs_object          {[i.name for i in self.cs_object.linkedTo]}&#34;)
        logger.debug(f&#34;Linked to cs_platform        {[i.name for i in self.cs_platform.linkedTo]}&#34;)
        logger.debug(
            f&#34;Linked to cs_machine         {[i.name for i in self.cs_machine.linkedTo or {}]}&#34;
        )

    def is_simulator(self):
        return True

    def connect(self):
        pass

    def reconnect(self):
        pass

    def disconnect(self):
        # TODO:
        #   Should I keep state in this class to check if it has been disconnected?
        #
        # TODO:
        #   What happens when I re-connect to this Simulator? Shall it be in Homing position or
        #   do I have to keep state via a persistency mechanism?
        pass

    def is_connected(self):
        return True

    def reset(self, wait=True, verbose=False):
        # TODO:
        #   Find out what exactly a reset() should be doing. Does it bring back the Hexapod
        #   in it&#39;s original state, loosing all definitions of coordinate systems? Or does it
        #   do a clearError() and a homing()?
        pass

    def homing(self):
        self.goto_zero_position()
        self.homing_done = True
        self._virtual_homing = False
        self._virtual_homing_position = None
        return 0

    def is_homing_done(self):
        return self.homing_done

    def set_virtual_homing(self, tx, ty, tz, rx, ry, rz):
        self._virtual_homing_position = [tx, ty, tz, rx, ry, rz]
        self._virtual_homing = True
        return 0

    def stop(self):
        pass

    def clear_error(self):
        return 0

    def activate_control_loop(self):
        self.control_loop = True
        return self.control_loop

    def deactivate_control_loop(self):
        self.control_loop = False
        return self.control_loop

    def configure_coordinates_systems(
        self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
    ):
        identity = np.identity(4)

        # Redefine the User Coordinate System

        translation = np.array([tx_u, ty_u, tz_u])
        rotation = np.array([rx_u, ry_u, rz_u])
        degrees = True

        # Remove the old links between user and machine CS, and between Object in User and Object CS

        self.cs_machine.removeLink(self.cs_user)
        self.cs_object_in_user.removeLink(self.cs_object)

        # Redefine the User Coordinate System

        self.cs_user = ReferenceFrame.fromTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            ref=self.cs_machine,
            name=&#34;User[Machine]&#34;,
            degrees=degrees,
        )

        # Redefine the Object in User Coordinate System

        tf_user_to_object = self.cs_user.getActiveTransformationTo(self.cs_object)
        self.cs_object_in_user = ReferenceFrame(
            tf_user_to_object, rot_config=self.rot_config, ref=self.cs_user, name=&#34;Object[User]&#34;
        )

        # Define the invariant links within the system, i.e. some systems are bound with an
        # invariant transformation
        # matrix and those links shall be preserved throughout the movement within the system.

        # User and Machine CS are invariant, reset the transformation. User in Object is
        # identical to Object

        self.cs_machine.addLink(self.cs_user, transformation=self.cs_user.transformation)
        self.cs_object_in_user.addLink(self.cs_object, transformation=identity)

        # Redefine the Object Coordinates System

        translation = np.array([tx_o, ty_o, tz_o])
        rotation = np.array([rx_o, ry_o, rz_o])
        degrees = True

        # Remove the old links between user and machine CS, and between Object in User and Object CS

        self.cs_platform.removeLink(self.cs_object)
        self.cs_object_in_user.removeLink(self.cs_object)

        self.cs_object = ReferenceFrame.fromTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            ref=self.cs_platform,
            name=&#34;Object[Platform]&#34;,
            degrees=degrees,
        )

        # Redefine the Object in User Coordinate System

        tf_user_to_object = self.cs_user.getActiveTransformationTo(self.cs_object)
        self.cs_object_in_user = ReferenceFrame(
            tf_user_to_object, rot_config=self.rot_config, ref=self.cs_user, name=&#34;Object[User]&#34;
        )

        # Object CS and Platform CS are invariant, reset the transformation. User in Object is
        # identical to Object

        self.cs_platform.addLink(self.cs_object, transformation=self.cs_object.transformation)
        self.cs_object_in_user.addLink(self.cs_object, transformation=identity)

        return 0

    def get_coordinates_systems(self):

        degrees = True

        t_user, r_user = self.cs_user.getTranslationRotationVectors(degrees=degrees)
        t_object, r_object = self.cs_object.getTranslationRotationVectors(degrees=degrees)

        return list(np.concatenate((t_user, r_user, t_object, r_object)))

    def move_absolute(self, tx, ty, tz, rx, ry, rz):
        # FIXME:
        #  to really simulate the behavior of the Hexapod, this method should implement limit
        #  checking
        #  and other condition or error checking, e.g. argument matching, etc.

        logger.debug(f&#34;moveAbsolute with {tx}, {ty}, {tz}, {rx}, {ry}, {rz}&#34;)

        translation = np.array([tx, ty, tz])
        rotation = np.array([rx, ry, rz])

        # We set a new transformation for cs_object_in_user which will update our model,
        # because cs_object and cs_object_in_user are linked.

        self.cs_object_in_user.setTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

        return 0

    def move_relative_object(self, tx, ty, tz, rx, ry, rz):

        tr_rel = np.array([tx, ty, tz])
        rot_rel = np.array([rx, ry, rz])

        self.cs_object.applyTranslationRotation(
            tr_rel,
            rot_rel,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

    def move_relative_user(self, tx, ty, tz, rx, ry, rz):

        # The Symétrie Hexapod definition of moveRelativeUser
        #
        # - Translation and rotations are expressed in USER reference frame
        #
        # - Actually,
        #     - the translations happen parallel to the USER reference frame
        #     - the rotations are applied after the translations, on the OBJ ReferenceFrame
        #
        # To achieve this,
        #
        #     * OBUSR is &#34;de-rotated&#34;, to become parallel to USR
        #     * the requested translation is applied
        #     * OBUSR is &#34;re-rotated&#34; to its original orientation
        #     * the requested rotation is applied

        # Derotation of cs_object --&gt; cs_user

        derotation = self.cs_object.getActiveTransformationTo(self.cs_user)
        derotation[:3, 3] = [0, 0, 0]

        # Reverse rotation

        rerotation = derotation.T

        # Requested translation matrix

        translation = np.identity(4)
        translation[:3, 3] = [tx, ty, tz]

        # Requested rotation matrix

        import egse.coordinates.transform3d_addon as t3add

        rotation = t3add.translationRotationToTransformation(
            [0, 0, 0], [rx, ry, rz], rot_config=self.rot_config
        )

        transformation = derotation @ translation @ rerotation @ rotation

        # Adapt our model

        self.cs_object.applyTransformation(transformation)

    def check_absolute_movement(self, tx, ty, tz, rx, ry, rz):
        rc = 0
        rc_dict = {}
        if not -30.0 &lt;= tx &lt;= 30.0:
            rc += 1
            rc_dict.update({1: &#34;Tx should be in range ±30.0 mm&#34;})
        if not -30.0 &lt;= ty &lt;= 30.0:
            rc += 1
            rc_dict.update({2: &#34;Ty should be in range ±30.0 mm&#34;})
        if not -20.0 &lt;= tz &lt;= 20.0:
            rc += 1
            rc_dict.update({3: &#34;Tz should be in range ±20.0 mm&#34;})
        if not -11.0 &lt;= rx &lt;= 11.0:
            rc += 1
            rc_dict.update({4: &#34;Rx should be in range ±11.0 mm&#34;})
        if not -11.0 &lt;= ry &lt;= 11.0:
            rc += 1
            rc_dict.update({5: &#34;Ry should be in range ±11.0 mm&#34;})
        if not -20.0 &lt;= rz &lt;= 20.0:
            rc += 1
            rc_dict.update({6: &#34;Rz should be in range ±20.0 mm&#34;})
        return rc, rc_dict

    def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz):
        return 0, {}

    def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz):
        return 0, {}

    def get_user_positions(self):
        t, r = self.cs_user.getActiveTranslationRotationVectorsTo(self.cs_object_in_user)

        pos = list(np.concatenate((t, r)))

        return pos

    def get_machine_positions(self):
        t, r = self.cs_platform.getTranslationRotationVectors()
        t, r = self.cs_machine.getActiveTranslationRotationVectorsTo(self.cs_platform)

        pos = list(np.concatenate((t, r)))

        return pos

    def get_actuator_length(self):
        alen = [math.nan for _ in range(6)]

        return alen

    def get_general_state(self):
        state = 0
        state = set_bit(state, 1)  # System Initialized
        state = set_bit(state, 2)  # In Position
        if self.homing_done:
            state = set_bit(state, 4)
        if self.control_loop:
            state = set_bit(state, 3)
        if self._virtual_homing:
            state = set_bit(state, 18)
        return state, decode_Q36(state)

    def goto_specific_position(self, pos):
        return 0

    def goto_retracted_position(self):
        translation = np.array([0, 0, -20])
        rotation = np.array([0, 0, 0])

        self.cs_platform.setTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

        return 0

    def goto_zero_position(self):
        # We set a new transformation for cs_platform which will update our model.
        # See issue #58: updating the cs_platform is currently not a good idea because that will
        # not properly update the chain/path upwards, i.e. the chain/path is followed in the
        # direction of the references that are defined, not in the other direction.
        #
        translation = np.array([0, 0, 0])
        rotation = np.array([0, 0, 0])

        self.cs_platform.setTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

        # As a work around for the bug in issue #58, we determine the transformation from
        # cs_object as it is
        # invariantly linked with cs_platform. Updating cs_object_in_user with that
        # transformation will
        # properly update all the reference frames.

        # tr_abs, rot_abs = self.cs_object.getTranslationRotationVectors()
        #
        # self.cs_object_in_user.setTranslationRotation(
        #     tr_abs,
        #     rot_abs,
        #     rot_config=self.rot_config,
        #     active=True,
        #     degrees=True,
        #     preserveLinks=True,
        # )

        return 0

    def is_in_position(self):
        return True

    def jog(self, axis: int, inc: float) -&gt; int:
        pass

    def get_debug_info(self):
        pass

    def set_speed(self, vt, vr):
        self._speed[0] = vt
        self._speed[1] = vr

    def get_speed(self):
        return tuple(self._speed)

    def get_actuator_state(self):
        return [({0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                  4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                  6: &#39;Brake control output&#39;},
                 [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])]

    def perform_maintenance(self, axis):
        pass

    def info(self):

        msg = &#34;Info about the PunaSimulator:\n&#34;
        msg += &#34;\n&#34;
        msg += &#34;This Hexapod PUNA Simulator works with several reference frames:\n&#34;
        msg += &#34;  * The machine reference frame\n&#34;
        msg += &#34;  * The platform reference frame\n&#34;
        msg += &#34;  * The object reference frame\n&#34;
        msg += &#34;  * The user reference frame\n\n&#34;
        msg += (
            &#34;Any movement commands result in a transformation of the appropriate coordinate &#34;
            &#34;systems.&#34;
        )

        logger.info(msg)

        return msg


class PunaProxy(Proxy, PunaInterface):
    &#34;&#34;&#34;The PunaProxy class is used to connect to the control server and send commands to the
    Hexapod PUNA remotely.&#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address) [default is taken from settings
            file]
            port: TCP port on which the control server is listening for commands [default is
            taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.hexapod.symetrie.puna.PunaController"><code class="flex name class">
<span>class <span class="ident">PunaController</span></span>
<span>(</span><span>hostname=None, port=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The PunaController class allows controlling a Symétrie PUNA Hexapod through an Ethernet
interface that is connecting a Symétrie Controller.</p>
<p>The Symétrie Controller can be either in simulation mode or have a real Hexapod
connected.</p>
<p><strong>Synopsis</strong></p>
<pre><code>from egse.hexapod.symetrie.puna import PunaController
hexapod = PunaController(hostname="10.33.178.145", port=1025)
try:
    hexapod.connect()

    # do some useful things here with the hexapod

except HexapodError as exc:
    print(exc)
finally:
    hexapod.disconnect()
</code></pre>
<p>The constructor also sets the connection parameters and tries to connect
to the controller. Make sure that you explicitly use the hexapod.disconnect()
command when no connection is needed anymore.</p>
<p>The controller can also be used as a context manager, in which case the <code>connect()</code>
and <code>disconnect()</code> methods should not be called:</p>
<pre><code>with PunaController() as puna:
    puna.info()
</code></pre>
<p>Opens a TCP/IP socket connection with the Hexapod PUNA Hardware Controller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the Hexapod hardware</dd>
</dl>
<p>controller.
The default is defined in the <code>settings.yaml</code> configuration file.</p>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to, by default set in the <code>settings.yaml</code></dd>
</dl>
<p>configuration file.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>HexapodError</code></dt>
<dd>when the connection could not be established for some reason.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PunaController(PunaInterface):
    &#34;&#34;&#34;
    The PunaController class allows controlling a Symétrie PUNA Hexapod through an Ethernet
    interface that is connecting a Symétrie Controller.

    The Symétrie Controller can be either in simulation mode or have a real Hexapod
    connected.

    **Synopsis**

        from egse.hexapod.symetrie.puna import PunaController
        hexapod = PunaController(hostname=&#34;10.33.178.145&#34;, port=1025)
        try:
            hexapod.connect()

            # do some useful things here with the hexapod

        except HexapodError as exc:
            print(exc)
        finally:
            hexapod.disconnect()

    The constructor also sets the connection parameters and tries to connect
    to the controller. Make sure that you explicitly use the hexapod.disconnect()
    command when no connection is needed anymore.

    The controller can also be used as a context manager, in which case the `connect()`
    and `disconnect()` methods should not be called:

        with PunaController() as puna:
            puna.info()

    &#34;&#34;&#34;

    SPEC_POS_MAINTENANCE = 0
    &#34;&#34;&#34;Hexapod specific position, for maintenance or Jog only.&#34;&#34;&#34;
    SPEC_POS_ZERO = 1
    &#34;&#34;&#34;Hexapod zero position.&#34;&#34;&#34;
    SPEC_POS_RETRACTED = 2
    &#34;&#34;&#34;Hexapod retracted position.&#34;&#34;&#34;

    def __init__(self, hostname=None, port=None):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the Hexapod PUNA Hardware Controller.

        Args:
            hostname (str): the IP address or fully qualified hostname of the Hexapod hardware
            controller.
                The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the ``settings.yaml``
            configuration file.

        Raises:
            HexapodError: when the connection could not be established for some reason.
        &#34;&#34;&#34;

        super().__init__()

        if hostname is None or port is None:
            raise ValueError(f&#34;Please provide both hostname and port for the PunaController, {hostname=}, {port=}&#34;)

        logger.debug(f&#34;Initializing PunaController with hostname={hostname} on port={port}&#34;)

        try:
            self.pmac = PmacEthernetInterface()
            self.pmac.setConnectionParameters(hostname, port)
        except PMACError as exc:
            logger.warning(
                f&#34;HexapodError: Couldn&#39;t establish connection with the Hexapod PUNA Hardware &#34;
                f&#34;Controller: ({exc})&#34;
            )

    def is_simulator(self):
        return False

    def is_connected(self):
        return self.pmac.isConnected()

    def connect(self):
        try:
            self.pmac.connect()
        except PMACError as exc:
            logger.warning(f&#34;PMACError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the Hexapod.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        try:
            self.pmac.disconnect()
        except PMACError as exc:
            raise ConnectionError(&#34;Couldn&#39;t disconnect from Hexapod.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_in_position(self):
        try:
            out = self.pmac.getQVars(36, [0], int)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t retrieve information from Hexapod PUNA Hardware Controller.&#34;) from exc
        return bool(out[0] &amp; 0x04)

    def info(self):
        try:
            msg = &#34;Info about the Hexapod PUNA:\n&#34;
            msg += f&#34;model   = {self.pmac.getPmacModel()}\n&#34;
            msg += f&#34;CID     = {self.pmac.getCID()}\n&#34;
            msg += f&#34;version = {self.pmac.getVersion()}\n&#34;
            msg += f&#34;cpu     = {self.pmac.getCPU()}\n&#34;
            msg += f&#34;type    = {self.pmac.getType()}\n&#34;
            msg += f&#34;vendorID= {self.pmac.getVID()}\n&#34;
            msg += f&#34;date    = {self.pmac.getDate()}\n&#34;
            msg += f&#34;time    = {self.pmac.getTime()}\n&#34;
            msg += f&#34;today   = {self.pmac.getToday()}\n&#34;
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t retrieve information from Hexapod PUNA Hardware Controller.&#34;
            ) from exc

        return msg

    def stop(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_STOP)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t complete the STOP command.&#34;) from exc

        return rc

    def homing(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_HOMING)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t complete the HOMING command.&#34;) from exc

        logger.info(&#34;Homing: Command was successful&#34;)

        return rc

    def is_homing_done(self):
        try:
            rc = self.pmac.getQVars(26, [0], int)[0]
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return False

        msg = {  # noqa: F841
            0: &#34;Homing status is undefined.&#34;,
            1: &#34;Homing is in progress&#34;,
            2: &#34;Homing is done&#34;,
            3: &#34;An error occurred during the Homing process.&#34;,
        }

        if rc == 2:
            return True

        return False

    def set_virtual_homing(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.pmac.sendCommand(
                pmac.CMD_VIRTUAL_HOMING, tx=tx, ty=ty, tz=tz, rx=rx, ry=ry, rz=rz
            )
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the virtual homing command.&#34;) from exc

        logger.warning(
            f&#34;Virtual Homing successfully set to {tx:.6f}, {ty:.6f}, {tz:.6f}, {rx:.6f}, &#34;
            f&#34;{ry:.6f}, {rz:.6f}.&#34;
        )

        return rc

    def activate_control_loop(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CONTROLON)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t activate the control loop.&#34;) from exc

        msg = {  # noqa: F841
            0: &#34;Command was successful&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Control of the servo motors has failed&#34;,
        }

        return rc

    def deactivate_control_loop(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CONTROLOFF)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t de-activate the control loop.&#34;) from exc

        return rc

    def __move(self, cm, tx, ty, tz, rx, ry, rz):
        &#34;&#34;&#34;
        Ask the controller to perform the movement defined by the arguments.

        For all control modes cm, the rotation centre coincides with the Object
        Coordinates System origin and the movements are controlled with translation
        components at first (Tx, Ty, tZ) and then the rotation components (Rx, Ry, Rz).

        Control mode cm:
            * 0 = absolute control, object coordinate system position and orientation
                    expressed in the invariant user coordinate system
            * 1 = object relative, motion expressed in the Object Coordinate System
            * 2 = user relative, motion expressed in the User Coordinate System

        Args:
            cm (int): control mode
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            0 on success, -1 when ignored, -2 on error.

        Raises:
            PMACError: when the arguments do not match up or when there is a time out or when
            there is a socket
            communication error.

        .. note:: When the command was not successful, this method will query the ``POSVALID?``
                  using the checkAbsolutePosition() and print a summary of the error messages
                  to the log file.
        &#34;&#34;&#34;

        rc = self.pmac.sendCommand(pmac.CMD_MOVE, cm=cm, tx=tx, ty=ty, tz=tz, rx=rx, ry=ry, rz=rz)

        error_code_msg = {
            0: &#34;Command was successful&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Command was invalid, check with POSVALID?&#34;,
        }

        if rc &lt; 0:
            msg = f&#34;Move command returned ({rc}: {error_code_msg[rc]}).&#34;

            if rc == -2:
                Q29, errors = self.__check_movement(cm, tx, ty, tz, rx, ry, rz)

                msg += &#34;\nError messages returned from POSVALID?:\n&#34;
                for key, value in errors.items():
                    msg += f&#34;  bit {key:&lt;2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def __check_movement(self, cm, tx, ty, tz, rx, ry, rz):
        &#34;&#34;&#34;
        Ask the controller if the movement defined by the arguments is feasible.

        Returns a tuple where the first element is an integer that represents the
        bitfield encoding the errors. The second element is a dictionary with the
        bit numbers that were (on) and the corresponding error description.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        &#34;&#34;&#34;
        out = self.pmac.sendCommand(
            pmac.CMD_POSVALID_GET, cm=cm, tx=tx, ty=ty, tz=tz, rx=rx, ry=ry, rz=rz
        )
        Q29 = decode_Q29(out[0])
        return out[0], Q29

    def move_absolute(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.__move(0, tx, ty, tz, rx, ry, rz)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the moveAbsolute command.&#34;) from exc

        return rc

    def check_absolute_movement(self, tx, ty, tz, rx, ry, rz):
        return self.__check_movement(0, tx, ty, tz, rx, ry, rz)

    def move_relative_object(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.__move(1, tx, ty, tz, rx, ry, rz)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the relative movement [object] command.&#34;) from exc

        return rc

    def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz):
        return self.__check_movement(1, tx, ty, tz, rx, ry, rz)

    def move_relative_user(self, tx, ty, tz, rx, ry, rz):
        try:
            rc = self.__move(2, tx, ty, tz, rx, ry, rz)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t execute the relative movement [user] command.&#34;) from exc

        return rc

    def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz):
        return self.__check_movement(2, tx, ty, tz, rx, ry, rz)

    def perform_maintenance(self, axis):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_MAINTENANCE, axis=axis)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t perform maintenance cycle.&#34;) from exc

        msg = {0: &#34;Command was successfully executed&#34;, -1: &#34;Command was ignored&#34;}  # noqa: F841

        return rc

    def goto_specific_position(self, pos):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_SPECIFICPOS, pos=pos)
        except PMACError as exc:
            raise HexapodError(f&#34;Couldn&#39;t goto specific position [pos={pos}].&#34;) from exc

        msg = {
            0: &#34;Command was successfully executed&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Invalid movement command&#34;,
        }

        logger.info(f&#34;Goto Specific Position [{pos}]: {msg[rc]}&#34;)

        if rc &lt; 0:
            try:
                out = self.pmac.getQVars(0, [29], int)
            except PMACError as exc:
                raise HexapodError(&#34;Couldn&#39;t get a response from the Hexapod controller.&#34;) from exc
            Q29 = decode_Q29(out[0])

            msg = &#34;Error messages returned in Q29:\n&#34;
            for key, value in Q29.items():
                msg += f&#34;  {key:2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def goto_retracted_position(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_SPECIFICPOS, pos=self.SPEC_POS_RETRACTED)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t goto retracted position.&#34;) from exc

        msg = {
            0: &#34;Command was successfully executed&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Invalid movement command&#34;,
        }

        logger.info(f&#34;Goto Retracted Position [2]: {msg[rc]}&#34;)

        if rc &lt; 0:
            try:
                out = self.pmac.getQVars(0, [29], int)
            except PMACError as exc:
                raise HexapodError(&#34;Couldn&#39;t get a response from the Hexapod controller.&#34;) from exc
            Q29 = decode_Q29(out[0])

            msg = &#34;Error messages returned in Q29:\n&#34;
            for key, value in Q29.items():
                msg += f&#34;  {key:2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def goto_zero_position(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_SPECIFICPOS, pos=self.SPEC_POS_ZERO)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t goto zero position.&#34;) from exc

        msg = {
            0: &#34;Command was successfully executed&#34;,
            -1: &#34;Command was ignored&#34;,
            -2: &#34;Invalid movement command&#34;,
        }

        logger.info(f&#34;Goto Zero Position [1]: {msg[rc]}&#34;)

        if rc &lt; 0:
            try:
                out = self.pmac.getQVars(0, [29], int)
            except PMACError as exc:
                raise HexapodError(&#34;Couldn&#39;t get a response from the Hexapod controller.&#34;) from exc
            Q29 = decode_Q29(out[0])

            msg = &#34;Error messages returned in Q29:\n&#34;
            for key, value in Q29.items():
                msg += f&#34;  {key:2d}: {value}\n&#34;

            logger.debug(msg)

        return rc

    def get_buffer(self):
        return_string = self.pmac.getBuffer()
        return return_string

    def clear_error(self):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CLEARERROR)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t clear errors in the controller software.&#34;) from exc

        return rc

    def jog(self, axis: int, inc: float) -&gt; int:
        if not (1 &lt;= axis &lt;= 6):
            logger.error(f&#34;The axis argument must be 1 &lt;= axis &lt;= 6, given {axis}.&#34;)
            raise HexapodError(&#34;Illegal Argument Value: axis is {axis}, should be 1 &lt;= axis &lt;= 6.&#34;)

        try:
            rc = self.pmac.sendCommand(pmac.CMD_JOG, axis=axis, inc=inc)
        except PMACError as exc:
            raise HexapodError(
                f&#34;Couldn&#39;t execute the jog command for axis={axis} with inc={inc} [mm].&#34;
            ) from exc

        msg = {0: &#34;Command was successfully executed&#34;, -1: &#34;Command was ignored&#34;}

        logger.info(f&#34;JOG on axis [{axis}] of {inc} mm: {msg[rc]}&#34;)

        return rc

    def configure_coordinates_systems(
        self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
    ):
        try:

            rc = self.pmac.sendCommand(
                pmac.CMD_CFG_CS,
                tx_u=round(tx_u, NUM_OF_DECIMALS),
                ty_u=round(ty_u, NUM_OF_DECIMALS),
                tz_u=round(tz_u, NUM_OF_DECIMALS),
                rx_u=round(rx_u, NUM_OF_DECIMALS),
                ry_u=round(ry_u, NUM_OF_DECIMALS),
                rz_u=round(rz_u, NUM_OF_DECIMALS),
                tx_o=round(tx_o, NUM_OF_DECIMALS),
                ty_o=round(ty_o, NUM_OF_DECIMALS),
                tz_o=round(tz_o, NUM_OF_DECIMALS),
                rx_o=round(rx_o, NUM_OF_DECIMALS),
                ry_o=round(ry_o, NUM_OF_DECIMALS),
                rz_o=round(rz_o, NUM_OF_DECIMALS),
            )
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t configure coordinate systems on the hexapod controller.&#34;
            ) from exc

        return rc

    def get_coordinates_systems(self):
        try:
            out = self.pmac.sendCommand(pmac.CMD_CFG_CS_GET)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t get the coordinate systems information from the hexapod controller.&#34;
            ) from exc

        return out

    def get_debug_info(self):
        try:
            out = self.pmac.sendCommand(pmac.CMD_STATE_DEBUG_GET)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t get the debugging information from the hexapod controller.&#34;
            ) from exc

        return out

    def set_speed(self, vt, vr):
        try:
            rc = self.pmac.sendCommand(pmac.CMD_CFG_SPEED, vt=vt, vr=vr)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t set the speed for translation [{vt} mm/s] or rotation [{vr} deg/s].&#34;
            ) from exc

        return rc

    def get_speed(self):
        try:
            out = self.pmac.sendCommand(pmac.CMD_CFG_SPEED_GET)
        except PMACError as exc:
            raise HexapodError(
                &#34;Couldn&#39;t get the speed settings from the hexapod controller.&#34;
            ) from exc

        return out

    def get_general_state(self):
        try:
            out = self.pmac.getQVars(36, [0], int)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out[0], pmac.decode_Q36(out[0])

    def get_actuator_state(self):
        try:
            out = self.pmac.getQVars(30, [0, 1, 2, 3, 4, 5], int)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return [pmac.decode_Q30(value) for value in out]

    def get_user_positions(self):
        try:
            # out = self.pmac.getQVars(53, [0, 1, 2, 3, 4, 5], float)
            out = self.pmac.sendCommand(pmac.CMD_POSUSER_GET)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out

    def get_machine_positions(self):
        try:
            out = self.pmac.getQVars(47, [0, 1, 2, 3, 4, 5], float)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out

    def get_actuator_length(self):
        try:
            out = self.pmac.getQVars(41, [0, 1, 2, 3, 4, 5], float)
        except PMACError as pmac_exc:
            logger.error(f&#34;PMAC Exception: {pmac_exc}&#34;, exc_info=True)
            return None

        return out

    def reset(self, wait=True, verbose=False):
        try:
            self.pmac.sendCommand(pmac.CMD_RESETSOFT)
        except PMACError as exc:
            raise HexapodError(&#34;Couldn&#39;t (soft) reset the hexapod controller.&#34;) from exc

        # How do I know when the RESETSOFT has finished and we can send further commands?

        if wait:
            logger.info(&#34;Sent a soft reset, this will take about 30 seconds to complete.&#34;)
            self.__wait(30, verbose=verbose)

    def __wait(self, duration, verbose=False):
        &#34;&#34;&#34;
        Wait for a specific duration in seconds.
        &#34;&#34;&#34;
        _timeout = timedelta(seconds=duration)
        _start = datetime.now()

        _rate = timedelta(seconds=5)  # every _rate seconds print a message
        _count = 0

        logger.info(f&#34;Just waiting {duration} seconds ...&#34;)

        while datetime.now() - _start &lt; _timeout:

            if verbose and (datetime.now() - _start &gt; _count * _rate):
                _count += 1
                logger.info(f&#34;waited for {_count * _rate} of {_timeout} seconds, &#34;)
                print(f&#34;waited for {_count * _rate} of {_timeout} seconds, &#34;)

            time.sleep(0.01)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></li>
<li><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface">AlphaControllerInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.hexapod.symetrie.puna.PunaController.SPEC_POS_MAINTENANCE"><code class="name">var <span class="ident">SPEC_POS_MAINTENANCE</span></code></dt>
<dd>
<div class="desc"><p>Hexapod specific position, for maintenance or Jog only.</p></div>
</dd>
<dt id="egse.hexapod.symetrie.puna.PunaController.SPEC_POS_RETRACTED"><code class="name">var <span class="ident">SPEC_POS_RETRACTED</span></code></dt>
<dd>
<div class="desc"><p>Hexapod retracted position.</p></div>
</dd>
<dt id="egse.hexapod.symetrie.puna.PunaController.SPEC_POS_ZERO"><code class="name">var <span class="ident">SPEC_POS_ZERO</span></code></dt>
<dd>
<div class="desc"><p>Hexapod zero position.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.hexapod.symetrie.puna.PunaController.get_buffer"><code class="name flex">
<span>def <span class="ident">get_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer(self):
    return_string = self.pmac.getBuffer()
    return return_string</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.activate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_absolute_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_relative_object_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_object_movement">check_relative_object_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_relative_user_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_user_movement">check_relative_user_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.clear_error" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.configure_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.configure_coordinates_systems">configure_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.deactivate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_actuator_length" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_actuator_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_state">get_actuator_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_coordinates_systems">get_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_debug_info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_debug_info">get_debug_info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_general_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_machine_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_machine_positions">get_machine_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_user_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_user_positions">get_user_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_retracted_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_retracted_position">goto_retracted_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_specific_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_specific_position">goto_specific_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_zero_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_zero_position">goto_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_homing_done" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_in_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.jog" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.jog">jog</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.log_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.log_positions">log_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_absolute" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_absolute">move_absolute</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_relative_object" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_object">move_relative_object</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_relative_user" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_user">move_relative_user</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.perform_maintenance" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.perform_maintenance">perform_maintenance</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.reset" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.reset">reset</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.set_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.set_virtual_homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_virtual_homing">set_virtual_homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.stop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.hexapod.symetrie.puna.PunaInterface"><code class="flex name class">
<span>class <span class="ident">PunaInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the PunaController, the PunaProxy and the PunaSimulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PunaInterface(AlphaControllerInterface, DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the PunaController, the PunaProxy and the PunaSimulator.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface">AlphaControllerInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.puna.PunaController" href="#egse.hexapod.symetrie.puna.PunaController">PunaController</a></li>
<li><a title="egse.hexapod.symetrie.puna.PunaProxy" href="#egse.hexapod.symetrie.puna.PunaProxy">PunaProxy</a></li>
<li><a title="egse.hexapod.symetrie.puna.PunaSimulator" href="#egse.hexapod.symetrie.puna.PunaSimulator">PunaSimulator</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface">AlphaControllerInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.activate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_absolute_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_object_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_object_movement">check_relative_object_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_user_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_user_movement">check_relative_user_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.clear_error" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.configure_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.configure_coordinates_systems">configure_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_length" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_state">get_actuator_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_coordinates_systems">get_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_debug_info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_debug_info">get_debug_info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_general_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_machine_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_machine_positions">get_machine_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_user_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_user_positions">get_user_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_retracted_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_retracted_position">goto_retracted_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_specific_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_specific_position">goto_specific_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_zero_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_zero_position">goto_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_homing_done" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_in_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.jog" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.jog">jog</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.log_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.log_positions">log_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_absolute" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_absolute">move_absolute</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_object" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_object">move_relative_object</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_user" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_user">move_relative_user</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.perform_maintenance" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.perform_maintenance">perform_maintenance</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.reset" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.reset">reset</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_virtual_homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_virtual_homing">set_virtual_homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface.stop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.stop">stop</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.hexapod.symetrie.puna.PunaProxy"><code class="flex name class">
<span>class <span class="ident">PunaProxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6700)</span>
</code></dt>
<dd>
<div class="desc"><p>The PunaProxy class is used to connect to the control server and send commands to the
Hexapod PUNA remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol [default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address) [default is taken from settings</dd>
<dt>file]</dt>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands [default is</dd>
</dl>
<p>taken from settings file]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PunaProxy(Proxy, PunaInterface):
    &#34;&#34;&#34;The PunaProxy class is used to connect to the control server and send commands to the
    Hexapod PUNA remotely.&#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address) [default is taken from settings
            file]
            port: TCP port on which the control server is listening for commands [default is
            taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></li>
<li><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface">AlphaControllerInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.activate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_absolute_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_relative_object_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_object_movement">check_relative_object_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_relative_user_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_user_movement">check_relative_user_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.clear_error" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.configure_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.configure_coordinates_systems">configure_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.deactivate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_actuator_length" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_actuator_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_state">get_actuator_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_coordinates_systems">get_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_debug_info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_debug_info">get_debug_info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_general_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_machine_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_machine_positions">get_machine_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_user_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_user_positions">get_user_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_retracted_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_retracted_position">goto_retracted_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_specific_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_specific_position">goto_specific_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_zero_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_zero_position">goto_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_homing_done" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_in_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.jog" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.jog">jog</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.log_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.log_positions">log_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_absolute" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_absolute">move_absolute</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_relative_object" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_object">move_relative_object</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_relative_user" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_user">move_relative_user</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.perform_maintenance" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.perform_maintenance">perform_maintenance</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.reset" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.reset">reset</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.set_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.set_virtual_homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_virtual_homing">set_virtual_homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.stop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.hexapod.symetrie.puna.PunaSimulator"><code class="flex name class">
<span>class <span class="ident">PunaSimulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>HexapodSimulator simulates the Symétrie Hexapod PUNA. The class is heavily based on the
ReferenceFrames in the <code><a title="egse.coordinates" href="../../coordinates/index.html">egse.coordinates</a></code> package.</p>
<p>The simulator implements the same methods as the HexapodController class which acts on the
real hardware controller in either simulation mode or with a real Hexapod PUNA connected.</p>
<p>Therefore, the HexapodSimulator can be used instead of the Hexapod class in test harnesses
and when the hardware is not available.</p>
<p>This class simulates all the movements and status of the Hexapod.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PunaSimulator(PunaInterface):
    &#34;&#34;&#34;
    HexapodSimulator simulates the Symétrie Hexapod PUNA. The class is heavily based on the
    ReferenceFrames in the `egse.coordinates` package.

    The simulator implements the same methods as the HexapodController class which acts on the
    real hardware controller in either simulation mode or with a real Hexapod PUNA connected.

    Therefore, the HexapodSimulator can be used instead of the Hexapod class in test harnesses
    and when the hardware is not available.

    This class simulates all the movements and status of the Hexapod.
    &#34;&#34;&#34;

    def __init__(self):

        identity = np.identity(4)

        # Rotation around static axis, and around x, y and z in that order
        self.rot_config = &#34;sxyz&#34;

        # Configure the Master Reference Frame
        self.cs_master = ReferenceFrame.createMaster()

        # Configure the Machine Coordinate System, i.e. cs_mec [ref:cs_master]
        self.cs_machine = ReferenceFrame(
            transformation=identity,
            ref=self.cs_master,
            name=&#34;Machine[Master]&#34;,
            rot_config=self.rot_config,
        )

        # Configure the Platform Coordinate System, i.e. cs_platform [ref:cs_machine]
        # default after homing: PLATFORM = MACHINE

        self.cs_platform = ReferenceFrame(
            transformation=identity,
            ref=self.cs_machine,
            name=&#34;Platform[Machine]&#34;,
            rot_config=self.rot_config,
        )

        # Configure the User Coordinate System, i.e. cs_user [ref:cs_machine]
        self.cs_user = ReferenceFrame(
            transformation=identity,
            ref=self.cs_machine,
            name=&#34;User[Machine]&#34;,
            rot_config=self.rot_config,
        )

        # Configure the Object Coordinate System, i.e. cs_object [ref:cs_platform]
        self.cs_object = ReferenceFrame(
            transformation=identity,
            ref=self.cs_platform,
            name=&#34;Object[Platform]&#34;,
            rot_config=self.rot_config,
        )

        # We use a CS called cs_object_in_user, i.e. Object as defined in the User CS,
        # and we define this
        # from the transformation user -&gt; object.

        tf_user_to_object = self.cs_user.getActiveTransformationTo(self.cs_object)
        self.cs_object_in_user = ReferenceFrame(
            tf_user_to_object, rot_config=self.rot_config, ref=self.cs_user, name=&#34;Object[User]&#34;
        )

        # Define the invariant links within the system, i.e. some systems are bound with an
        # invariant transformation
        # matrix and those links shall be preserved throughout the movement within the system.

        # We link this cs_object_in_user to cs_object with the identity transformation,
        # which connects them together

        self.cs_object_in_user.addLink(self.cs_object, transformation=identity)

        # The User Coordinate System is linked to the Machine Coordinate System

        self.cs_machine.addLink(self.cs_user, transformation=self.cs_user.transformation)

        # The Object Coordinate System is linked to the Platform Coordinate System

        self.cs_platform.addLink(self.cs_object, transformation=self.cs_object.transformation)

        # Keep a record if the homing() command has been executed.

        self.homing_done = False
        self.control_loop = False
        self._virtual_homing = False
        self._virtual_homing_position = None

        # Just keep the speed settings, no used in movement currently

        self._speed = [1.0, 1.0, 0.01, 0.001, 4.0, 2.0]

        # Print out some debugging information

        logger.debug(
            f&#34;Linked to cs_object_in_user  {[i.name for i in self.cs_object_in_user.linkedTo]}&#34;
        )
        logger.debug(f&#34;Linked to cs_object          {[i.name for i in self.cs_object.linkedTo]}&#34;)
        logger.debug(f&#34;Linked to cs_platform        {[i.name for i in self.cs_platform.linkedTo]}&#34;)
        logger.debug(
            f&#34;Linked to cs_machine         {[i.name for i in self.cs_machine.linkedTo or {}]}&#34;
        )

    def is_simulator(self):
        return True

    def connect(self):
        pass

    def reconnect(self):
        pass

    def disconnect(self):
        # TODO:
        #   Should I keep state in this class to check if it has been disconnected?
        #
        # TODO:
        #   What happens when I re-connect to this Simulator? Shall it be in Homing position or
        #   do I have to keep state via a persistency mechanism?
        pass

    def is_connected(self):
        return True

    def reset(self, wait=True, verbose=False):
        # TODO:
        #   Find out what exactly a reset() should be doing. Does it bring back the Hexapod
        #   in it&#39;s original state, loosing all definitions of coordinate systems? Or does it
        #   do a clearError() and a homing()?
        pass

    def homing(self):
        self.goto_zero_position()
        self.homing_done = True
        self._virtual_homing = False
        self._virtual_homing_position = None
        return 0

    def is_homing_done(self):
        return self.homing_done

    def set_virtual_homing(self, tx, ty, tz, rx, ry, rz):
        self._virtual_homing_position = [tx, ty, tz, rx, ry, rz]
        self._virtual_homing = True
        return 0

    def stop(self):
        pass

    def clear_error(self):
        return 0

    def activate_control_loop(self):
        self.control_loop = True
        return self.control_loop

    def deactivate_control_loop(self):
        self.control_loop = False
        return self.control_loop

    def configure_coordinates_systems(
        self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
    ):
        identity = np.identity(4)

        # Redefine the User Coordinate System

        translation = np.array([tx_u, ty_u, tz_u])
        rotation = np.array([rx_u, ry_u, rz_u])
        degrees = True

        # Remove the old links between user and machine CS, and between Object in User and Object CS

        self.cs_machine.removeLink(self.cs_user)
        self.cs_object_in_user.removeLink(self.cs_object)

        # Redefine the User Coordinate System

        self.cs_user = ReferenceFrame.fromTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            ref=self.cs_machine,
            name=&#34;User[Machine]&#34;,
            degrees=degrees,
        )

        # Redefine the Object in User Coordinate System

        tf_user_to_object = self.cs_user.getActiveTransformationTo(self.cs_object)
        self.cs_object_in_user = ReferenceFrame(
            tf_user_to_object, rot_config=self.rot_config, ref=self.cs_user, name=&#34;Object[User]&#34;
        )

        # Define the invariant links within the system, i.e. some systems are bound with an
        # invariant transformation
        # matrix and those links shall be preserved throughout the movement within the system.

        # User and Machine CS are invariant, reset the transformation. User in Object is
        # identical to Object

        self.cs_machine.addLink(self.cs_user, transformation=self.cs_user.transformation)
        self.cs_object_in_user.addLink(self.cs_object, transformation=identity)

        # Redefine the Object Coordinates System

        translation = np.array([tx_o, ty_o, tz_o])
        rotation = np.array([rx_o, ry_o, rz_o])
        degrees = True

        # Remove the old links between user and machine CS, and between Object in User and Object CS

        self.cs_platform.removeLink(self.cs_object)
        self.cs_object_in_user.removeLink(self.cs_object)

        self.cs_object = ReferenceFrame.fromTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            ref=self.cs_platform,
            name=&#34;Object[Platform]&#34;,
            degrees=degrees,
        )

        # Redefine the Object in User Coordinate System

        tf_user_to_object = self.cs_user.getActiveTransformationTo(self.cs_object)
        self.cs_object_in_user = ReferenceFrame(
            tf_user_to_object, rot_config=self.rot_config, ref=self.cs_user, name=&#34;Object[User]&#34;
        )

        # Object CS and Platform CS are invariant, reset the transformation. User in Object is
        # identical to Object

        self.cs_platform.addLink(self.cs_object, transformation=self.cs_object.transformation)
        self.cs_object_in_user.addLink(self.cs_object, transformation=identity)

        return 0

    def get_coordinates_systems(self):

        degrees = True

        t_user, r_user = self.cs_user.getTranslationRotationVectors(degrees=degrees)
        t_object, r_object = self.cs_object.getTranslationRotationVectors(degrees=degrees)

        return list(np.concatenate((t_user, r_user, t_object, r_object)))

    def move_absolute(self, tx, ty, tz, rx, ry, rz):
        # FIXME:
        #  to really simulate the behavior of the Hexapod, this method should implement limit
        #  checking
        #  and other condition or error checking, e.g. argument matching, etc.

        logger.debug(f&#34;moveAbsolute with {tx}, {ty}, {tz}, {rx}, {ry}, {rz}&#34;)

        translation = np.array([tx, ty, tz])
        rotation = np.array([rx, ry, rz])

        # We set a new transformation for cs_object_in_user which will update our model,
        # because cs_object and cs_object_in_user are linked.

        self.cs_object_in_user.setTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

        return 0

    def move_relative_object(self, tx, ty, tz, rx, ry, rz):

        tr_rel = np.array([tx, ty, tz])
        rot_rel = np.array([rx, ry, rz])

        self.cs_object.applyTranslationRotation(
            tr_rel,
            rot_rel,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

    def move_relative_user(self, tx, ty, tz, rx, ry, rz):

        # The Symétrie Hexapod definition of moveRelativeUser
        #
        # - Translation and rotations are expressed in USER reference frame
        #
        # - Actually,
        #     - the translations happen parallel to the USER reference frame
        #     - the rotations are applied after the translations, on the OBJ ReferenceFrame
        #
        # To achieve this,
        #
        #     * OBUSR is &#34;de-rotated&#34;, to become parallel to USR
        #     * the requested translation is applied
        #     * OBUSR is &#34;re-rotated&#34; to its original orientation
        #     * the requested rotation is applied

        # Derotation of cs_object --&gt; cs_user

        derotation = self.cs_object.getActiveTransformationTo(self.cs_user)
        derotation[:3, 3] = [0, 0, 0]

        # Reverse rotation

        rerotation = derotation.T

        # Requested translation matrix

        translation = np.identity(4)
        translation[:3, 3] = [tx, ty, tz]

        # Requested rotation matrix

        import egse.coordinates.transform3d_addon as t3add

        rotation = t3add.translationRotationToTransformation(
            [0, 0, 0], [rx, ry, rz], rot_config=self.rot_config
        )

        transformation = derotation @ translation @ rerotation @ rotation

        # Adapt our model

        self.cs_object.applyTransformation(transformation)

    def check_absolute_movement(self, tx, ty, tz, rx, ry, rz):
        rc = 0
        rc_dict = {}
        if not -30.0 &lt;= tx &lt;= 30.0:
            rc += 1
            rc_dict.update({1: &#34;Tx should be in range ±30.0 mm&#34;})
        if not -30.0 &lt;= ty &lt;= 30.0:
            rc += 1
            rc_dict.update({2: &#34;Ty should be in range ±30.0 mm&#34;})
        if not -20.0 &lt;= tz &lt;= 20.0:
            rc += 1
            rc_dict.update({3: &#34;Tz should be in range ±20.0 mm&#34;})
        if not -11.0 &lt;= rx &lt;= 11.0:
            rc += 1
            rc_dict.update({4: &#34;Rx should be in range ±11.0 mm&#34;})
        if not -11.0 &lt;= ry &lt;= 11.0:
            rc += 1
            rc_dict.update({5: &#34;Ry should be in range ±11.0 mm&#34;})
        if not -20.0 &lt;= rz &lt;= 20.0:
            rc += 1
            rc_dict.update({6: &#34;Rz should be in range ±20.0 mm&#34;})
        return rc, rc_dict

    def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz):
        return 0, {}

    def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz):
        return 0, {}

    def get_user_positions(self):
        t, r = self.cs_user.getActiveTranslationRotationVectorsTo(self.cs_object_in_user)

        pos = list(np.concatenate((t, r)))

        return pos

    def get_machine_positions(self):
        t, r = self.cs_platform.getTranslationRotationVectors()
        t, r = self.cs_machine.getActiveTranslationRotationVectorsTo(self.cs_platform)

        pos = list(np.concatenate((t, r)))

        return pos

    def get_actuator_length(self):
        alen = [math.nan for _ in range(6)]

        return alen

    def get_general_state(self):
        state = 0
        state = set_bit(state, 1)  # System Initialized
        state = set_bit(state, 2)  # In Position
        if self.homing_done:
            state = set_bit(state, 4)
        if self.control_loop:
            state = set_bit(state, 3)
        if self._virtual_homing:
            state = set_bit(state, 18)
        return state, decode_Q36(state)

    def goto_specific_position(self, pos):
        return 0

    def goto_retracted_position(self):
        translation = np.array([0, 0, -20])
        rotation = np.array([0, 0, 0])

        self.cs_platform.setTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

        return 0

    def goto_zero_position(self):
        # We set a new transformation for cs_platform which will update our model.
        # See issue #58: updating the cs_platform is currently not a good idea because that will
        # not properly update the chain/path upwards, i.e. the chain/path is followed in the
        # direction of the references that are defined, not in the other direction.
        #
        translation = np.array([0, 0, 0])
        rotation = np.array([0, 0, 0])

        self.cs_platform.setTranslationRotation(
            translation,
            rotation,
            rot_config=self.rot_config,
            active=True,
            degrees=True,
            preserveLinks=True,
        )

        # As a work around for the bug in issue #58, we determine the transformation from
        # cs_object as it is
        # invariantly linked with cs_platform. Updating cs_object_in_user with that
        # transformation will
        # properly update all the reference frames.

        # tr_abs, rot_abs = self.cs_object.getTranslationRotationVectors()
        #
        # self.cs_object_in_user.setTranslationRotation(
        #     tr_abs,
        #     rot_abs,
        #     rot_config=self.rot_config,
        #     active=True,
        #     degrees=True,
        #     preserveLinks=True,
        # )

        return 0

    def is_in_position(self):
        return True

    def jog(self, axis: int, inc: float) -&gt; int:
        pass

    def get_debug_info(self):
        pass

    def set_speed(self, vt, vr):
        self._speed[0] = vt
        self._speed[1] = vr

    def get_speed(self):
        return tuple(self._speed)

    def get_actuator_state(self):
        return [({0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                  4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                  6: &#39;Brake control output&#39;},
                 [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), (
                {0: &#39;In position&#39;, 1: &#39;Control loop on servo motors active&#39;, 2: &#39;Homing done&#39;,
                 4: &#39;Input &#34;Positive limit switch&#34;&#39;, 5: &#39;Input &#34;Negative limit switch&#34;&#39;,
                 6: &#39;Brake control output&#39;},
                [1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])]

    def perform_maintenance(self, axis):
        pass

    def info(self):

        msg = &#34;Info about the PunaSimulator:\n&#34;
        msg += &#34;\n&#34;
        msg += &#34;This Hexapod PUNA Simulator works with several reference frames:\n&#34;
        msg += &#34;  * The machine reference frame\n&#34;
        msg += &#34;  * The platform reference frame\n&#34;
        msg += &#34;  * The object reference frame\n&#34;
        msg += &#34;  * The user reference frame\n\n&#34;
        msg += (
            &#34;Any movement commands result in a transformation of the appropriate coordinate &#34;
            &#34;systems.&#34;
        )

        logger.info(msg)

        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></li>
<li><a title="egse.hexapod.symetrie.alpha.AlphaControllerInterface" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface">AlphaControllerInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.activate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_absolute_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_relative_object_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_object_movement">check_relative_object_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.check_relative_user_movement" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.check_relative_user_movement">check_relative_user_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.clear_error" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.configure_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.configure_coordinates_systems">configure_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.deactivate_control_loop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_actuator_length" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_actuator_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_actuator_state">get_actuator_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_coordinates_systems" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_coordinates_systems">get_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_debug_info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_debug_info">get_debug_info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_general_state" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_machine_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_machine_positions">get_machine_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.get_user_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.get_user_positions">get_user_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_retracted_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_retracted_position">goto_retracted_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_specific_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_specific_position">goto_specific_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.goto_zero_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.goto_zero_position">goto_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.info" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_homing_done" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_in_position" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.jog" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.jog">jog</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.log_positions" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.log_positions">log_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_absolute" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_absolute">move_absolute</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_relative_object" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_object">move_relative_object</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.move_relative_user" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.move_relative_user">move_relative_user</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.perform_maintenance" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.perform_maintenance">perform_maintenance</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.reset" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.reset">reset</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.set_speed" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.set_virtual_homing" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.set_virtual_homing">set_virtual_homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaInterface.stop" href="alpha.html#egse.hexapod.symetrie.alpha.AlphaControllerInterface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.hexapod.symetrie" href="index.html">egse.hexapod.symetrie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.hexapod.symetrie.puna.PunaController" href="#egse.hexapod.symetrie.puna.PunaController">PunaController</a></code></h4>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.puna.PunaController.SPEC_POS_MAINTENANCE" href="#egse.hexapod.symetrie.puna.PunaController.SPEC_POS_MAINTENANCE">SPEC_POS_MAINTENANCE</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaController.SPEC_POS_RETRACTED" href="#egse.hexapod.symetrie.puna.PunaController.SPEC_POS_RETRACTED">SPEC_POS_RETRACTED</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaController.SPEC_POS_ZERO" href="#egse.hexapod.symetrie.puna.PunaController.SPEC_POS_ZERO">SPEC_POS_ZERO</a></code></li>
<li><code><a title="egse.hexapod.symetrie.puna.PunaController.get_buffer" href="#egse.hexapod.symetrie.puna.PunaController.get_buffer">get_buffer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.puna.PunaInterface" href="#egse.hexapod.symetrie.puna.PunaInterface">PunaInterface</a></code></h4>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.puna.PunaProxy" href="#egse.hexapod.symetrie.puna.PunaProxy">PunaProxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.puna.PunaSimulator" href="#egse.hexapod.symetrie.puna.PunaSimulator">PunaSimulator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
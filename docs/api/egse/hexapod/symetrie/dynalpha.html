<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.hexapod.symetrie.dynalpha API documentation</title>
<meta name="description" content="This module provides the implementation of the commanding interfaces for the Alpha and Alpha+
controller using the new dynamic commanding scheme. The â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.hexapod.symetrie.dynalpha</code></h1>
</header>
<section id="section-intro">
<p>This module provides the implementation of the commanding interfaces for the Alpha and Alpha+
controller using the new dynamic commanding scheme. The three main classes are the <code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface">AlphaPlusTelnetInterface</a></code>,
the <code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface">AlphaControllerInterface</a></code> and the <code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface">AlphaPlusControllerInterface</a></code>.</p>
<p>The <code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface">AlphaPlusTelnetInterface</a></code> directly talks to the device through the telnet protocol on port 23.</p>
<p>The <code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface">AlphaControllerInterface</a></code> provides an interface with methods that are compatible with both the Alpha controller
and the AlphaPlusController. This interface shall be sub-classed for proxy and controller classes that use the
alpha controller, like the PUNA Hexapod.</p>
<p>The <code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface">AlphaPlusControllerInterface</a></code> inherits from the <code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface">AlphaControllerInterface</a></code> and provides additional methods
that are specific for the alpha+ controllers. This class should be sub-classed for proxy and controller classes
that use the alpha+ controller, like the ZONDA hexapod.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides the implementation of the commanding interfaces for the Alpha and Alpha+
controller using the new dynamic commanding scheme. The three main classes are the `AlphaPlusTelnetInterface`,
the `AlphaControllerInterface` and the `AlphaPlusControllerInterface`.

The `AlphaPlusTelnetInterface` directly talks to the device through the telnet protocol on port 23.

The `AlphaControllerInterface` provides an interface with methods that are compatible with both the Alpha controller
and the AlphaPlusController. This interface shall be sub-classed for proxy and controller classes that use the
alpha controller, like the PUNA Hexapod.

The `AlphaPlusControllerInterface` inherits from the `AlphaControllerInterface` and provides additional methods
that are specific for the alpha+ controllers. This class should be sub-classed for proxy and controller classes
that use the alpha+ controller, like the ZONDA hexapod.

&#34;&#34;&#34;
from __future__ import annotations

import logging
from functools import partial
from telnetlib import Telnet
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Tuple

import egse.logger
from egse.control import Failure
from egse.control import Success
from egse.device import DeviceConnectionError
from egse.device import DeviceConnectionInterface
from egse.device import DeviceInterface
from egse.device import DeviceTransport
from egse.mixin import add_cr_lf
from egse.mixin import dynamic_command
from egse.settings import Settings
from egse.system import Timer
from egse.system import wait_until

LOGGER = logging.getLogger(__name__)
PUNA_PLUS = Settings.load(&#34;PUNA Alpha+ Controller&#34;)

# The following constants represent the index into the GENERAL_STATE list and are used in the code
# to match the name of a flag in the general_state.

HOME_COMPLETE = 6
IN_POSITION = 3
IN_MOTION = 4

GENERAL_STATE = [
    &#34;Error&#34;,
    &#34;System initialized&#34;,
    &#34;Control on&#34;,
    &#34;In position&#34;,
    &#34;Motion task running&#34;,
    &#34;Home task running&#34;,
    &#34;Home complete&#34;,
    &#34;Home virtual&#34;,
    &#34;Phase found&#34;,
    &#34;Brake on&#34;,
    &#34;Motion restricted&#34;,
    &#34;Power on encoders&#34;,
    &#34;Power on limit switches&#34;,
    &#34;Power on drives&#34;,
    &#34;Emergency stop&#34;,
]


ACTUATOR_STATE = [
    &#34;Error&#34;,
    &#34;Control on&#34;,
    &#34;In position&#34;,
    &#34;Motion task running&#34;,
    &#34;Home task running&#34;,
    &#34;Home complete&#34;,
    &#34;Phase found&#34;,
    &#34;Brake on&#34;,
    &#34;Home hardware input&#34;,
    &#34;Negative hardware limit switch&#34;,
    &#34;Positive hardware limit switch&#34;,
    &#34;Software limit reached&#34;,
    &#34;Following error&#34;,
    &#34;Drive fault&#34;,
    &#34;Encoder error&#34;,
]


ERROR_CODES = {
    1: &#34;An emergency stop has been pressed.&#34;,
    2: &#34;A safety input has been triggered. The status of the inputs is given in the DATA field.&#34;,
    3: &#34;A temperature sensor has exceeded the limit threshold. Sensor number is given in DATA field.&#34;,
    4: &#34;Controller system status error (Sys.Status).&#34;,
    5: &#34;Controller â€˜abort allâ€™ input has been triggered. (Sys.AbortAll).&#34;,
    6: &#34;Controller watchdog error (Sys.WDTFault).&#34;,
    7: &#34;Configuration load error.&#34;,
    8: &#34;Configuration failed: a wrong hexapod ID has been detected. Detected ID is given in DATA field.&#34;,
    9: &#34;Home task has failed.&#34;,
    10: &#34;Virtual home write task has failed.&#34;,
    11: &#34;The motion program did not start in the defined timeout.&#34;,
    12: &#34;The home task did not start in the defined timeout.&#34;,
    13: &#34;A kinematic error has occurred. Kinematic error number is given in DATA field.&#34;,
    14: &#34;Controller coordinate error status (Coord.ErrorStatus). Error number is given in DATA field.&#34;,
    15: &#34;An error has been detected on encoder.&#34;,
    16: &#34;Brake should have been engaged as the motor control was off.&#34;,
    17: &#34;Controller motor status: Auxiliary fault (AuxFault).&#34;,
    18: &#34;Controller motor status: Encoder loss (EncLoss).&#34;,
    19: &#34;Controller motor status: Amplifier warning (AmpWarn).&#34;,
    20: &#34;Controller motor status: Trigger not found (TriggerNotFound).&#34;,
    21: &#34;Controller motor status: Integrated current &#39;I2T&#39; fault (I2tFault).&#34;,
    22: &#34;Controller motor status: Software positive limit reach (SoftPlusLimit).&#34;,
    23: &#34;Controller motor status: Software negative limit reach (SoftMinusLimit).&#34;,
    24: &#34;Controller motor status: Amplifier fault (AmpFault).&#34;,
    25: &#34;Controller motor status: Stopped on hardware limit (LimitStop).&#34;,
    26: &#34;Controller motor status: Fatal following error (FeFatal).&#34;,
    27: &#34;Controller motor status: Warning following error (FeWarn).&#34;,
    28: &#34;Controller motor status: Hardware positive limit reach (PlusLimit).&#34;,
    29: &#34;Controller motor status: Hardware negative limit reach (MinusLimit).&#34;,
}


RETURN_CODES = {
    0: &#34;Success.&#34;,
    -1: &#34;Undefined error.&#34;,
    -10: &#34;Wrong value for parameter at index 0.&#34;,
    -11: &#34;Wrong value for parameter at index 1.&#34;,
    -12: &#34;Wrong value for parameter at index 2.&#34;,
    -13: &#34;Wrong value for parameter at index 3.&#34;,
    -14: &#34;Wrong value for parameter at index 4.&#34;,
    -15: &#34;Wrong value for parameter at index 5.&#34;,
    -16: &#34;Wrong value for parameter at index 6.&#34;,
    -17: &#34;Wrong value for parameter at index 7.&#34;,
    -18: &#34;Wrong value for parameter at index 8.&#34;,
    -19: &#34;Wrong value for parameter at index 9.&#34;,
    -20: &#34;Wrong value for parameter at index 10.&#34;,
    -21: &#34;Wrong value for parameter at index 11.&#34;,
    -22: &#34;Wrong value for parameter at index 12.&#34;,
    -23: &#34;Wrong value for parameter at index 13.&#34;,
    -24: &#34;Wrong value for parameter at index 14.&#34;,
    -25: &#34;Wrong value for parameter at index 15.&#34;,
    -26: &#34;Wrong value for parameter at index 16.&#34;,
    -27: &#34;Wrong value for parameter at index 17.&#34;,
    -28: &#34;Wrong value for parameter at index 18.&#34;,
    -29: &#34;Wrong value for parameter at index 19.&#34;,
    -30: &#34;Unknown command number.&#34;,
    -31: &#34;This configuration command is a &#39;get&#39; only type.&#34;,
    -32: &#34;This configuration command is a &#39;set&#39; only type.&#34;,
    -33: &#34;The axis number do not correspond to an axis defined on the controller.&#34;,
    -34: &#34;A stop task is running.&#34;,
    -35: &#34;All motors need to be control on.&#34;,
    -36: &#34;All motors need to be control off.&#34;,
    -37: &#34;Emergency stop is pressed.&#34;,
    -38: &#34;A motion task is running.&#34;,
    -39: &#34;A home task is running.&#34;,
    -40: &#34;Requested move is not feasible.&#34;,
    -41: &#34;Power supply of limit switches is off.&#34;,
    -42: &#34;Power supply of encoders is off.&#34;,
    -43: &#34;A fatal error is present. This type of error needs a controller restart to be removed.&#34;,
    -44: &#34;An error is present, error reset is required.&#34;,
    -45: &#34;Home is not completed.&#34;,
    -46: &#34;Software option not available (can be linked to hardware configuration).&#34;,
    -47: &#34;Virtual home: file was created on another controller (different MAC address).&#34;,
    -48: &#34;Virtual home: some positions read in file are out of software limits.&#34;,
    -49: &#34;Virtual home: file data were stored while hexapod was moving.&#34;,
    -50: &#34;Virtual home: no data available.&#34;,
    -51: &#34;Command has been rejected because another action is running.&#34;,
    -52: &#34;Timeout waiting for home complete status.&#34;,
    -53: &#34;Timeout waiting for control on status.&#34;,
    -54: &#34;Timeout on motion program start.&#34;,
    -55: &#34;Timeout on home task start.&#34;,
    -56: &#34;Timeout on virtual home write file task.&#34;,
    -57: &#34;Timeout on virtual home delete file task.&#34;,
    -58: &#34;Timeout on virtual home read file task.&#34;,
    -59: &#34;Timeout on disk access verification task.&#34;,
    -60: &#34;Configuration file: save process failed.&#34;,
    -61: &#34;Configuration file: loaded file is empty.&#34;,
    -62: &#34;Configuration file: loaded data are corrupted.&#34;,
    -63: &#34;No access to the memory disk.&#34;,
    -64: &#34;File does not exist.&#34;,
    -65: &#34;Folder access failed.&#34;,
    -66: &#34;Creation of folder tree on the memory disk failed.&#34;,
    -67: &#34;Generation or write of the checksum failed.&#34;,
    -68: &#34;File read: no data or wrong data size.&#34;,
    -69: &#34;File read: no checksum.&#34;,
    -70: &#34;File read: incorrect checksum.&#34;,
    -71: &#34;File write: failed.&#34;,
    -72: &#34;File open: failed.&#34;,
    -73: &#34;File delete: failed.&#34;,
    -74: &#34;Get MAC address failed.&#34;,
    -75: &#34;NaN (Not a Number) or infinite value found.&#34;,
    -76: &#34;The coordinate system transformations are not initialized.&#34;,
    -77: &#34;A kinematic error is present.&#34;,
    -78: &#34;The motor phase process failed (phase search or phase set from position offset).&#34;,
    -79: &#34;The motor phase is not found.&#34;,
    -80: &#34;Timeout waiting for control off status.&#34;,
    -81: &#34;The requested kinematic mode (number) is not defined for the machine.&#34;,
    -82: &#34;Timeout waiting for phase found status.&#34;,
    -1000: &#34;Internal error: &#39;RET_Dev_CfS_NaNReturned&#39;.&#34;,
    -1001: &#34;Internal error: &#39;RET_Dev_CfS_FctNotAvailableInKernel&#39;.&#34;,
    -1002: &#34;Internal error: &#39;RET_Dev_CfS_UndefinedCfSType&#39;.&#34;,
    -1003: &#34;Internal error: &#39;RET_Dev_CfS_FIO_UndefinedFioType&#39;.&#34;,
    -1004: &#34;Internal error: &#39;RET_Dev_CfS_FIO_HomeFile_UndefinedAction&#39;.&#34;,
    -1005: &#34;Internal error: &#39;RET_Dev_UndefinedEnumValue&#39;.&#34;,
    -1006: &#34;Internal error: &#39;RET_Dev_LdataCmdStatusIsNegative&#39;.&#34;,
    -1007: &#34;Internal error: &#39;RET_Dev_NumMotorsInCoord_Sup_DEF_aGrQ_SIZE&#39;.&#34;,
    -1008: &#34;Internal error: &#39;RET_Dev_NumMotorsInCoord_WrongNumber&#39;.&#34;,
    -1009: &#34;Internal error: &#39;RET_String_StrCat_DestSizeReached&#39;.&#34;,
    -1010: &#34;Internal error: &#39;RET_String_LengthOverStringSize&#39;.&#34;,
    -1011: &#34;Internal error: &#39;RET_String_AllCharShouldIntBetween_0_255&#39;.&#34;,
    -1012: &#34;Internal error: &#39;RET_String_StrCpy_DestSizeReached&#39;.&#34;,
    -1013: &#34;Internal error: &#39;RET_ErrAction_HomeReset&#39;.&#34;,
    -1014: &#34;Internal error: &#39;RET_Home_StopReceivedWhileRunning&#39;.&#34;,
    -1015: &#34;Internal error: &#39;RET_UndefinedKinAssembly&#39;.&#34;,
    -1016: &#34;Internal error: &#39;RET_WrongPmcConfig&#39;.&#34;,
}


VALIDATION_LIMITS = [
    &#34;Factory workspace limits&#34;,
    &#34;Machine workspace limits&#34;,
    &#34;User workspace limits&#34;,
    &#34;Actuator limits&#34;,
    &#34;Joints limits&#34;,
    &#34;Due to backlash compensation&#34;,
]


def process_cmd_string(command: str) -&gt; str:
    &#34;&#34;&#34;
    Prepares the command string for sending to the controller.
    A carriage return and newline is appended to the command.
    &#34;&#34;&#34;

    return add_cr_lf(command)


def wait_until_cmd_is_zero(transport: DeviceTransport, timeout: float = 1.0, interval: float = 0.01):
    &#34;&#34;&#34;
    Waits until the `cmd` register is 0 (zero) and returns successfully if it does.
    When the `cmd` register doesn&#39;t turn zero within the given timeout, a Failure is returned.
    &#34;&#34;&#34;
    rc = 0

    def c_cmd():
        nonlocal rc
        rc_s = transport.query(&#39;c_cmd\r\n&#39;).decode()
        LOGGER.debug(f&#34;{rc_s = } &lt;- c_cmd in get_pars&#34;)
        if not rc_s.startswith(&#39;c_cmd&#39;):
            LOGGER.warning(f&#34;{rc_s = }&#34;)
            return -1
        rc = int(rc_s.split(&#39;\r\n&#39;)[1])
        return rc

    if wait_until(lambda: c_cmd() == 0, interval=interval, timeout=timeout):
        try:
            LOGGER.warning(f&#34;Command check timed out: {RETURN_CODES[rc]} [{rc=}]&#34;)
            return Failure(f&#34;Command check resulted in the following error: {RETURN_CODES[rc]}&#34;)
        except KeyError:
            return Failure(f&#34;Command check resulted in an unknown error code: {rc = }.&#34;)

    return Success(&#34;Command finished successfully&#34;)


def get_pars(
        transport: DeviceTransport = None, response: bytes = None,
        index: int = 0, count: int = 1, increment: int = 1, timeout: float = 1.0, interval: float = 0.01
) -&gt; bytes | Failure:
    &#34;&#34;&#34;
    Retrieve the response from a given command from the `c_par` array. The `c_par` array will
    contain the correct values only after the `cmd` register is 0 (zero). So, we will wait until
    `cmd` becomes 0, then retrieve the requested parameters from the `c_par` array and return
    them as a normal response to be processed.

    This function is intended to be used as a `post_cmd` function in the dynamic command decorator.

    Args:
        transport: the transport interface to communicate with the device
        response: the response from the actual command that was sent
        index: starting index for the `c_par` array
        count: the number of c_par values to retrieve
        increment: the increment in the c_par array
        timeout: the timeout period while waiting for the `cmd` to become 0
        interval: the sampling interval for the `cmd`

    Returns:
        The requested values from the `c_par` array as a string. This string can be decoded with
        the `decode_pars()` function.
    &#34;&#34;&#34;

    if transport is None:
        raise RuntimeError(&#34;no device transport was passed into the function!&#34;)

    rc = wait_until_cmd_is_zero(transport=transport, interval=interval, timeout=timeout)
    if isinstance(rc, Failure):
        return rc

    # The string &#39;c_par(0),1,1&#39; is considered illegal.

    if count == 1 and increment == 1:
        query = f&#34;c_par({index})&#34;
    else:
        query = f&#34;c_par({index}),{count},{increment}&#34;

    response = transport.query(f&#39;{query}\r\n&#39;)

    LOGGER.debug(f&#34;{response = } &lt;- {query} in get_pars&#34;)

    return response


def return_command_status(transport: DeviceTransport = None, response: bytes = None,
                          timeout: float = 1.0, interval: float = 0.01) -&gt; Tuple[int, str] | Failure:
    &#34;&#34;&#34;
    Check the status of last sent command. When the status is zero (0) the command was successfully executed.
    When the status is not zero before timeout seconds, the status check will be aborted and the function
    will then return the latest status code from the `c_cmd` variable.

    Note: This function shall be used as a `post_cmd` callable in the dynamic_command decorator and the process_response
          shall not be used in conjunction with this command.

    Args:
        transport: the device transport that can be used send additional commands to the device
        response: The response from the command that was sent to the device (ignored by this function)
        timeout: number of seconds before a timeout will occur
        interval: sleep time between checks for the status condition

    Returns:
        The status of the last sent command as a tuple (status code, description).

    Raises:
        A RuntimeError is raised when no device transport is passed into this function.
    &#34;&#34;&#34;

    # The response argument is ignored in this function as it generates a new response from the
    # command return code.

    if transport is None:
        raise RuntimeError(&#34;no device transport was passed into the function!&#34;)

    rc = 0

    def c_cmd():
        nonlocal rc
        rc_s = transport.query(&#39;c_cmd\r\n&#39;).decode()
        LOGGER.debug(f&#34;{rc_s = } &lt;- c_cmd in check_command_status&#34;)
        if not rc_s.startswith(&#39;c_cmd&#39;):
            LOGGER.warning(f&#34;{rc_s = }&#34;)
            return -1
        rc = int(rc_s.split(&#39;\r\n&#39;)[1])
        return rc

    if wait_until(lambda: c_cmd() == 0, interval=interval, timeout=timeout):
        LOGGER.warning(f&#34;Command check: {RETURN_CODES[rc]} [{rc}]&#34;)
    else:
        LOGGER.debug(&#34;Success!&#34;)
        rc = 0

    return rc, RETURN_CODES[rc]


def check_command_status(transport: DeviceTransport = None, response: bytes = None,
                         timeout: float = 1.0, interval: float = 0.01) -&gt; Any:
    &#34;&#34;&#34;
    Check the state of last sent command. When the state is zero (0) the command was successfully executed. When the
    status is not zero before timeout seconds, the status check will be aborted and a warning message will be issued.
    This function will then return a Failure containing the latest status code from the `c_cmd` variable.

    The status can take the following values:

    * &gt; 1: a new command has been written but has not yet been interpreted by the communication application
    * = 1: the last written command is currently under execution
    * = 0: the last command was successfully executed
    * &lt; 0: the last command failed. This status code can be used to determine the cause of the error from
      the RETURN_CODES variable in this module.

    Note: This function shall be used as a `post_cmd` callable in the dynamic_command decorator.

    Args:
        transport: the device transport that can be used send additional commands to the device
        response: The response from the command that was sent to the device
        timeout: number of seconds before a timeout will occur
        interval: sleep time between checks for the status condition

    Returns:
        This function passes through the response without change. When the status check timed out
        a Failure will be returned with an associated error message.

    Raises:
        A RuntimeError is raised when no device transport is passed into this function.
    &#34;&#34;&#34;
    if transport is None:
        raise RuntimeError(&#34;no device transport was passed into the function!&#34;)

    rc = wait_until_cmd_is_zero(transport=transport, interval=interval, timeout=timeout)
    return rc if isinstance(rc, Failure) else response


def decode_response(response: bytes) -&gt; str | Failure:
    &#34;&#34;&#34;Decodes the bytes object, strips off the trailing &#39;CRLF&#39;.&#34;&#34;&#34;

    LOGGER.debug(f&#34;{response = } &lt;- decode_response&#34;)

    return response.decode().rstrip()


def validate_response(response: str, cmd: str = None) -&gt; List[str] | Failure:
    &#34;&#34;&#34;
    Performs a number of checks on the response string and returns the response as a list of strings.
    The command string (which is the first part of the device response) is removed from the returned list.

    Args:
        response: decoded response from the device
        cmd: the command string that is returned by the device

    Returns:
        A list of strings containing the split response without the first item (which was the command string).
        If the response contains the string &#39;error #&#39;, a Failure will be returned with the error message.
        If the response doesn&#39;t start with the given command string (when cmd != None), a Failure is returned.
    &#34;&#34;&#34;
    if &#34;error #&#34; in response:
        msg = response.split(&#34;\r\n&#34;)[-1]  # this will strip off the cmd part of the response
        return Failure(msg)

    if cmd is not None and not response.startswith(cmd):
        return Failure(f&#34;Unexpected response from &#39;{cmd}&#39; command: {response}&#34;)

    LOGGER.debug(f&#34;{response = } &lt;- validate_response&#34;)

    return response.split(&#34;\r\n&#34;)[1:]


def process_response(response: bytes, cmd: str = None) -&gt; List[str] | Failure:
    &#34;&#34;&#34;This function is a shortcut for decode_response() and validate_response().&#34;&#34;&#34;

    # You might think this shortcut is really useless and doesn&#39;t give us anything,
    # the thing is that this function is used in the decorator, which is not possible
    # for each function individually.

    return validate_response(decode_response(response), cmd)


def process_validate_ptp(response: bytes) -&gt; Tuple[int, Dict[int, str]] | Failure:
    &#34;&#34;&#34;
    The response is in this case the value of &#39;c_par(0)&#39; which is returned by the `post_cmd` function `get_pars`.

    Args:
        response:

    Returns:

    &#34;&#34;&#34;
    response = process_response(response)

    if isinstance(response, Failure):
        return response

    response = int(response[0])

    if response == 0:
        return 0, {}

    if response &gt; 0:
        description = decode_validation_error(response)
        return response, description

    # When response is negative, the validation failed, and we extract the command return code

    msg = f&#34;{RETURN_CODES.get(response, &#39;unknown error code&#39;)}&#34;

    LOGGER.error(f&#34;Validate position: error code={response} - {msg}&#34;)

    return response, {response: msg}


def issue_warning(*, response, msg: str):
    LOGGER.warning(f&#34;{msg} {response}&#34;)
    return response


from typing import TypeVar

T = TypeVar(&#39;T&#39;, float, int)      # Declare type variable


def decode_pars(response: bytes = None, index: int = 0, count: int = 1, func: Callable = float) -&gt; List[T] | Failure:
    response = process_response(response)

    if isinstance(response, Failure):
        return response

    return [func(x) for x in response[index:index+count]]


def decode_info(response: bytes) -&gt; str | Failure:
    response = process_response(response)

    if isinstance(response, Failure):
        return response

    LOGGER.debug(f&#34;{response = } &lt;- decode_info&#34;)

    return (
        f&#34;Info about the Hexapod Alpha+ Controller:\n&#34;
        f&#34;  Software version = {response[1]}.{response[2]}.{response[3]}.{response[4]}\n&#34;
        f&#34;  API version = {response[5]}.{response[6]}.{response[7]}.{response[8]}\n&#34;
        f&#34;  System Configuration version = {response[11]}&#34;
    )


def decode_version(response: bytes) -&gt; str | Failure:
    response = validate_response(decode_response(response))

    if isinstance(response, Failure):
        return response

    return f&#34;{response[5]}.{response[6]}.{response[7]}.{response[8]}&#34;


def decode_uto(response: bytes) -&gt; List[float] | Failure:
    response = validate_response(decode_response(response), &#34;s_uto&#34;)

    if isinstance(response, Failure):
        return response

    return [float(x) for x in response]


def decode_mtp(response: bytes) -&gt; List[float] | Failure:
    response = validate_response(decode_response(response), &#34;s_mtp&#34;)

    if isinstance(response, Failure):
        return response

    return [float(x) for x in response]


def decode_general_state(response: bytes) -&gt; Tuple[Dict, List] | Failure:
    response = validate_response(decode_response(response), &#34;s_hexa&#34;)

    if isinstance(response, Failure):
        return response

    response = int(response[0])

    LOGGER.debug(f&#34;{response = } &lt;- decode_general_state&#34;)

    s_hexa = [int(x) for x in f&#39;{response:015b}&#39;[::-1]]
    state = dict(zip(GENERAL_STATE, s_hexa))

    return state, list(state.values())


def decode_actuator_state(response: bytes) -&gt; Tuple[Tuple[Dict, List]] | Failure:
    response = validate_response(decode_response(response), &#34;s_ax&#34;)

    if isinstance(response, Failure):
        return response

    def decode_state(state: int) -&gt; Tuple[Dict, List]:
        state_bits = [int(x) for x in f&#39;{state:015b}&#39;[::-1]]
        state_dict = dict(zip(ACTUATOR_STATE, state_bits))
        return state_dict, state_bits

    actuator_states = [int(x) for x in response]

    return tuple(decode_state(state) for state in actuator_states)


def decode_validation_error(value) -&gt; Dict:
    &#34;&#34;&#34;
    Decode the bitfield variable that is returned by the VALID_PTP command.

    Each bit in this variable represents a particular error in the validation of a movement.
    Several errors can be combined into the given variable.

    Returns a dictionary with the bit numbers that were (on) and the corresponding error description.
    &#34;&#34;&#34;

    return {bit: VALIDATION_LIMITS[bit] for bit in range(6) if value &gt;&gt; bit &amp; 0b01}


class AlphaPlusTelnetInterface(DeviceTransport, DeviceConnectionInterface):
    &#34;&#34;&#34;
    The Hexapod controller device interface based on the telnet protocol. This class implements the
    DeviceTransport protocol which provides the `read()`, `write()`, `trans()`, and `query()` methods.
    &#34;&#34;&#34;

    TELNET_TIMEOUT = 1.0

    def __init__(self, hostname: str = &#39;localhost&#39;, port: int = 23):
        &#34;&#34;&#34;
        Args:
            hostname (str): the IP address or fully qualified hostname of the OGSE hardware
                controller. The default is &#39;localhost&#39;.
            port (int): the IP port number to connect to. The default is 23.
        &#34;&#34;&#34;
        super().__init__()
        self.telnet = Telnet()
        self._is_connected = False
        self.hostname = hostname
        self.port = port

    def connect(self) -&gt; None:
        &#34;&#34;&#34;
        Connects to the Alpha+ Controller using the Telnet protocol. After connection
        the telnet session logs in with the username provided in the Settings under
        the `PUNA Alpha+ Controller` group. The password for this login is also provided
        in the Settings under the same group. Make sure their values are only given in
        the local settings file, not the global settings.

        After login, the `gpascii` command is started with the option `-2` as instructed
        in the software manual of the controller. The first command sent then is the
        `echo7` command, which configures the system to return variable numbers only,
        not their variable names.
        &#34;&#34;&#34;
        try:
            self.telnet.open(self.hostname, self.port)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                device_name=&#34;Alpha+ Controller&#34;,
                message=f&#34;Connection refused to {self.hostname} port {self.port}&#34;
            ) from exc

        try:
            rc = self.telnet.read_until(b&#34;login: &#34;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(f&#34;{PUNA_PLUS.user_name}\r\n&#34;.encode())
            rc = self.telnet.read_until(b&#34;Password: &#34;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(f&#34;{PUNA_PLUS.password}\r\n&#34;.encode())
            rc = self.telnet.read_until(b&#34;ppmac# &#34;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(b&#34;gpascii -2\r\n&#34;)
            rc = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(b&#34;echo7\r\n&#34;)
            rc = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
        except EOFError as exc:
            raise DeviceConnectionError(
                device_name=&#34;Alpha+ Controller&#34;,
                message=f&#34;Telnet connection closed for {self.hostname} port {self.port}&#34;
            ) from exc

        self._is_connected = True

    def is_connected(self):
        return self._is_connected

    def disconnect(self):
        rc = self.telnet.read_very_eager()
        print(rc.decode(), flush=True, end=&#34;&#34;)
        self.telnet.close()
        self._is_connected = False

    def reconnect(self):

        if self._is_connected:
            self.disconnect()
        self.connect()

    def trans(self, cmd: str) -&gt; bytes:
        &#34;&#34;&#34;
        Send a command to the Aplha+ Controller and waits for a response.
        The response is returned after the ACK is stripped off (see `read()` method).

        Args:
            cmd: a valid command string for the Alpha+ Controller

        Returns:
            The response from the controller on the command that was sent.
        &#34;&#34;&#34;
        self.write(cmd)
        response = self.read()

        LOGGER.debug(f&#34;trans: {response = }&#34;)

        return response

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Reads a response from the controller.

        Note: The acknowledgement `\x06\r\n` is stripped from the response before it is
              returned. If no ACK is present, a warning message will be logged.

        Returns:
            The response from the controller on a previously sent command.
        &#34;&#34;&#34;

        response = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)

        LOGGER.debug(f&#34;read: {response = }&#34;)

        if not response.endswith(b&#39;\x06\r\n&#39;):
            LOGGER.warning(f&#34;Expected ACK at the end of the response, {response = }&#34;)
            return response

        return response[:-3]  # strip off the ACK

    def write(self, cmd: str):
        &#34;&#34;&#34;
        Sends a command string to the Alpha+ Controller.
        The command string shall not end with a CRLF, that is automatically appended
        by this function.

        Args:
            cmd: a valid command string for the Alpha+ Controller

        Returns:
            Nothing is returned.
        &#34;&#34;&#34;
        LOGGER.debug(f&#34;Executing: {cmd.rstrip()}&#34;)
        self.telnet.write(cmd.encode())


class AlphaControllerInterface(DeviceInterface):

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_STOP&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(issue_warning, msg=&#34;STOP command has been executed.&#34;),
        post_cmd=return_command_status,
    )
    def stop(self) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Stop the current motion. This command can be sent during a motion of the Hexapod
        and is executed with high priority.

        Returns:
            A tuple (return code, description). Return code = 0 on success.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CONTROLON&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def activate_control_loop(self):
        &#34;&#34;&#34;
        Activates the control loop on motors.

        It activates the power on the motors and releases the brakes if present.
        The hexapod status &#39;Control On&#39; will switch to true when the command is successful.

        This command should be used before starting a movement.

        Note: it is possible to activate the control loop on motors even if the home is not complete.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CONTROLOFF&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def deactivate_control_loop(self):
        &#34;&#34;&#34;
        Disables the control loop on the servo motors.

        It is advisable to disable the servo motors if the system is not used for
        a long period (more than 1 hour for example). However, this recommendation
        depends on the application for which the system is being used.

        This command is performed only if the following conditions are met:
          * there is no motion task running
          * there is no action running
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_HOME&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def homing(self):
        &#34;&#34;&#34;
        Starts the homing task on the hexapod.

        Homing needs to be completed before performing any movement. When the hexapod
        is equipped with absolute encoders, this cycle is executed automatically during
        the controller initialization. When the hexapod is not equipped with absolute
        encoders, the homing request movements: homing cycle will search actuators
        reference sensors.

        Homing is required before performing a control movement. Without absolute encoders,
        the homing is performed with a hexapod movement until detecting the reference sensor
        on each of the actuators. The Hexapod will go to a position were the sensors are
        reached that signal a known calibrated position and then returns to the zero position.

        Whenever a homing is performed, the method will return before the actual movement
        is finished.

        The homing cycle takes about two minutes to complete, but the ``homing()`` method
        returns almost immediately. Therefore, to check if the homing is finished, use
        the is_homing_done() method.

        This command is performed only if the following conditions are met:
          * there is no motion task running
          * the emergency stop button is not engaged (not applicable for absolute encoders)

        &#34;&#34;&#34;
        raise NotImplementedError

    def is_homing_done(self) -&gt; bool | Failure:
        &#34;&#34;&#34;
        Checks if Homing is done.

        When this variable indicates &#39;Homing is done&#39; it means the command has been properly
        executed, but it doesn&#39;t mean the Hexapod is in position. The hexapod might still be
        moving to its zero position.

        Returns:
            True when the homing is done, False otherwise.
        &#34;&#34;&#34;
        general_state = self.get_general_state()
        if isinstance(general_state, Failure):
            return general_state

        return bool(general_state[1][HOME_COMPLETE])

    def is_in_position(self) -&gt; bool | Failure:
        &#34;&#34;&#34;
        Checks if the hexapod is in position.

        Returns:
            True when in position, False otherwise.
        &#34;&#34;&#34;
        general_state = self.get_general_state()
        if isinstance(general_state, Failure):
            return general_state

        return bool(general_state[1][IN_POSITION]) and not bool(general_state[1][IN_MOTION])

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CLEARERROR&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def clear_error(self) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Clear all errors in the controller software.

        This command clears the error list on the controller and automatically removes the error bit of the hexapod
        state. After this command, errors might automatically be regenerated if they are still present. For example,
        if an encoder is disconnected, the encoder error will be re-generated after the command because error reason
        is not corrected.

        Returns:
            The command status is returned as a tuple with (return code, message).
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=1 &#34;
                                           &#34;c_par(0)=${tx_u} c_par(1)=${ty_u} c_par(2)=${tz_u} &#34;
                                           &#34;c_par(3)=${rx_u} c_par(4)=${ry_u} c_par(5)=${rz_u} &#34;
                                           &#34;c_par(6)=${tx_o} c_par(7)=${ty_o} c_par(8)=${tz_o} &#34;
                                           &#34;c_par(9)=${rx_o} c_par(10)=${ry_o} c_par(11)=${rz_o} &#34;
                                           &#34;c_cmd=C_CFG_CS&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def configure_coordinates_systems(
            self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
    ) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Change the definition of the User Coordinate System and the Object Coordinate System.

        The parameters tx_u, ty_u, tz_u, rx_u, ry_u, rz_u are used to define the user coordinate
        system relative to the Machine Coordinate System and the parameters tx_o, ty_o, tz_o, rx_o,
        ry_o, rz_o are used to define the Object Coordinate System relative to the Platform
        Coordinate System.

        Args:
            tx_u (float): translation parameter that define the user coordinate system relative
                          to the machine coordinate system [in mm]
            ty_u (float): translation parameter that define the user coordinate system relative
                          to the machine coordinate system [in mm]
            tz_u (float): translation parameter that define the user coordinate system relative
                          to the machine coordinate system [in mm]

            rx_u (float): rotation parameter that define the user coordinate system relative to
                          the machine coordinate system [in deg]
            ry_u (float): rotation parameter that define the user coordinate system relative to
                          the machine coordinate system [in deg]
            rz_u (float): rotation parameter that define the user coordinate system relative to
                          the machine coordinate system [in deg]

            tx_o (float): translation parameter that define the object coordinate system relative
                          to the platform coordinate system [in mm]
            ty_o (float): translation parameter that define the object coordinate system relative
                          to the platform coordinate system [in mm]
            tz_o (float): translation parameter that define the object coordinate system relative
                          to the platform coordinate system [in mm]

            rx_o (float): rotation parameter that define the object coordinate system relative to
                          the platform coordinate system [in deg]
            ry_o (float): rotation parameter that define the object coordinate system relative to
                          the platform coordinate system [in deg]
            rz_o (float): rotation parameter that define the object coordinate system relative to
                          the platform coordinate system [in deg]

        Returns:
            A tuple with the command status return code and a description.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cfg=0 c_cmd=C_CFG_CS&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, count=12),
        post_cmd=partial(get_pars, count=12),
    )
    def get_coordinates_systems(self):
        &#34;&#34;&#34;
        Retrieve the definition of the User Coordinate System and the Object Coordinate System.

        Returns:
            tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o where the
            translation parameters are in [mm] and the rotation parameters are in [deg].
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${cm} &#34;
                                           &#34;c_par(1)=${tx} c_par(2)=${ty} c_par(3)=${tz} &#34;
                                           &#34;c_par(4)=${rx} c_par(5)=${ry} c_par(6)=${rz} &#34;
                                           &#34;c_cmd=C_MOVE_PTP&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def move_ptp(self, cm: int,
                 tx: float, ty: float, tz: float, rx: float, ry: float, rz: float) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Start the movement as defined by the arguments.

        Args:
            cm: control mode, 0=absolute, 1=object relative, 2=user relative
            tx: position on X-axis [mm]
            ty: position on Y-axis [mm]
            tz: position on Z-axis [mm]
            rx: rotation around the X-axis [deg]
            ry: rotation around the Y-axis [deg]
            rz: rotation around the Z-axis [deg]

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError

    def move_absolute(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
        return self.move_ptp(0, tx, ty, tz, rx, ry, rz)

    def move_relative_object(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
        return self.move_ptp(1, tx, ty, tz, rx, ry, rz)

    def move_relative_user(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
        return self.move_ptp(2, tx, ty, tz, rx, ry, rz)

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${pos} c_cmd=C_MOVE_SPECIFICPOS&#34;,
        process_cmd_string=process_cmd_string,
        # process_response=process_response,
        post_cmd=return_command_status,
    )
    def goto_specific_position(self, pos: int):
        raise NotImplementedError

    def goto_user_zero_position(self):
        return self.goto_specific_position(pos=1)

    def goto_retracted_position(self):
        return self.goto_specific_position(pos=2)

    def goto_machine_zero_position(self):
        return self.goto_specific_position(pos=3)

    goto_zero_position = goto_user_zero_position

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_uto_tx,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_uto,
    )
    def get_user_positions(self):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_mtp_tx,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_mtp,
    )
    def get_machine_positions(self) -&gt; List[float] | Failure:
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cmd=C_VERSION&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_info,
        post_cmd=partial(get_pars, count=12),
    )
    def info(self) -&gt; str:
        &#34;&#34;&#34;Returns basic information about the hexapod and the controller.

        Returns:
            a multiline response message containing the device info.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cmd=C_VERSION&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_version,
        post_cmd=partial(get_pars, count=12),
    )
    def version(self) -&gt; str:
        &#34;&#34;&#34;Returns the version of the firmware running on the hexapod aplha+ controller.

        Returns:
            A version number as a string.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_hexa&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_general_state
    )
    def get_general_state(self) -&gt; Tuple[Dict, List] | Failure:
        &#34;&#34;&#34;
        Asks the general state of the hexapod on all the motors following the bits definition
        presented below.

        GENERAL_STATE =
            0: &#34;Error&#34;,
            1: &#34;System initialized&#34;,
            2: &#34;Control on&#34;,
            3: &#34;In position&#34;,
            4: &#34;Motion task running&#34;,
            5: &#34;Home task running&#34;,
            6: &#34;Home complete&#34;,
            7: &#34;Home virtual&#34;,
            8: &#34;Phase found&#34;,
            9: &#34;Brake on&#34;,
            10:&#34;Motion restricted&#34;,
            11:&#34;Power on encoders&#34;,
            12:&#34;Power on limit switches&#34;,
            13:&#34;Power on drives&#34;,
            14:&#34;Emergency stop&#34;

        Returns:
            A dictionary with the bits value of each parameter.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_ax_1,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_actuator_state,
    )
    def get_actuator_state(self) -&gt; Tuple[Dict, List] | Failure:
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;s_pos_ax_1,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, count=6, func=float),
    )
    def get_actuator_length(self):
        &#34;&#34;&#34;
        Retrieve the current length of the hexapod actuators.

        Returns:
            array: an array of six float values for actuator length L1 to L6 in [mm], and \
            None: when an Exception was raised and logs the error message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cfg=0 c_cmd=C_CFG_SPEED&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, count=6),
        post_cmd=partial(get_pars, count=6),
    )
    def get_speed(self) -&gt; List[float]:
        &#34;&#34;&#34;
        Returns the positional speed of movements.

        Returns a list of floating point numbers [vt, vr, vt-, vr-, vt+, vr+] where vt and vr are the translation and
        angular speed respectively, the &#39;-&#39; and &#39;+&#39; are the minimum and maximum speeds.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=1 c_par(0)=${vt} c_par(1)=${vr} c_cmd=C_CFG_SPEED&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def set_speed(self, vt: float, vr: float):
        &#34;&#34;&#34;
        Set the positioning speed of movements.

        Args:
            vt: translational speed, unit = mm per second
            vr: angular speed, unit = deg per second
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${vm} c_par(1)=${cm} &#34;
                                           &#34;c_par(2)=${tx} c_par(3)=${ty} c_par(4)=${tz} &#34;
                                           &#34;c_par(5)=${rx} c_par(6)=${ry} c_par(7)=${rz} &#34;
                                           &#34;c_cmd=C_VALID_PTP&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_validate_ptp,
        post_cmd=get_pars,
    )
    def validate_position(self, vm, cm, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Ask the controller if the movement defined by the arguments is feasible.

        Returns a tuple where the first element is an integer that represents the
        bitfield encoding the errors. The second element is a dictionary with the
        bit numbers that were (on) and the corresponding error description as
        defined by VALIDATION_LIMITS.

        Args:
            vm (int): validation mode [only vm=1 is currently implemented by SymÃ©trie]
            cm (int): control mode (0 = absolute, 1 = object relative, 2 = user relative)
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        &#34;&#34;&#34;
        raise NotImplementedError

    def check_absolute_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Check if the requested object movement is valid.

        The absolute movement is expressed in the user coordinate system.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.
        &#34;&#34;&#34;
        # Currently only the vm=1 mode is developed by SymÃ©trie
        # Parameter cm = 0 for absolute
        return self.validate_position(1, 0, tx, ty, tz, rx, ry, rz)

    def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Check if the requested object movement is valid.

        The relative motion is expressed in the object coordinate system.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.
        &#34;&#34;&#34;
        # Currently only the vm=1 mode is developed by SymÃ©trie
        # Parameter cm = 1 for object relative
        return self.validate_position(1, 1, tx, ty, tz, rx, ry, rz)

    def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Check if the requested object movement is valid.

        The relative motion is expressed in the user coordinate system.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.
        &#34;&#34;&#34;
        # Currently only the vm=1 mode is developed by SymÃ©trie
        # Parameter cm = 2 for user relative
        return self.validate_position(1, 2, tx, ty, tz, rx, ry, rz)


class AlphaPlusControllerInterface(AlphaControllerInterface):
    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_variable(self, name: str) -&gt; str:
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name},${count},${increment}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_variables(self, name: str, count: int, increment: int = 1):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name}(${idx})&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_array(self, name: str, idx: int):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name}(${idx}),${count},${increment}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_array_values(self, name: str, idx: int, count: int, increment: int = 1):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=0 c_par(0)=${lim} c_cmd=C_CFG_LIMIT&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, index=1, count=12),
        post_cmd=partial(get_pars, count=13),
    )
    def get_limits_value(self, lim):
        &#34;&#34;&#34;
        Three different and independent operational workspace limits are defined on the controller:

            * Factory limits: are expressed in machine coordinate system limits. Those parameters cannot be modified.
            * Machine coordinate system limits: they are expressed in the Machine coordinate system. It can be used to
              secure the hexapod (and/or object) from its environment.
            * User coordinate system limits: they are expressed in the User coordinate system. It can be used to limits
              the movements of the object mounted on hexapod.

        Remark: operational workspace limits must be understood as limits in terms of amplitude of movement. Those
        limits are defined for each operational axis with a negative and positive value and are used in the validation
        process. Position on each operational axis must be within those two values.

        Args:
            lim (int): 0 = factory (GET only), 1 = machine cs limit, 2 = user cs limit

        Returns:
            A list of 12 float values: tx-, ty-, tz-, rx-, ry-, rz-, tx+, ty+, tz+, rx+, ry+, rz+
            The first six values are the negative limits for translation and rotation, the last six numbers are the
            positive limits for translation and rotation.

        &#34;&#34;&#34;
        raise NotImplementedError


if __name__ == &#34;__main__&#34;:

    from rich import print as rp

    from egse.hexapod.symetrie.punaplus import PunaPlusController

    egse.logger.set_all_logger_levels(logging.INFO)

    # Thie IP address for the emulator running in VirtualBox is 192.168.56.10
    # When you run the emulator in Parallels, the IP address is 10.37.129.10

    puna = PunaPlusController(hostname=&#34;10.37.129.10&#34;, port=23)
    puna.connect()

    with Timer(&#34;PunaPlusController&#34;):
        rp(puna.info())
        rp(puna.version())
        rp(puna.is_homing_done())
        rp(puna.homing())
        if wait_until(puna.is_homing_done, interval=1, timeout=300):
            rp(&#34;[red]Task puna.is_homing_done() timed out after 30s.[/red]&#34;)
        rp(puna.is_homing_done())
        rp(puna.is_in_position())
        rp(puna.activate_control_loop())
        rp(puna.get_general_state())
        rp(puna.get_actuator_state())
        rp(puna.deactivate_control_loop())
        rp(puna.get_general_state())
        rp(puna.get_actuator_state())
        rp(puna.stop())
        rp(puna.get_limits_value(0))
        rp(puna.get_limits_value(1))
        rp(puna.check_absolute_movement(1, 1, 1, 1, 1, 1))
        rp(puna.check_absolute_movement(51, 51, 51, 1, 1, 1))
        rp(puna.get_speed())
        rp(puna.set_speed(2.0, 1.0))
        rp(speed := puna.get_speed())

        if speed[:2] != [2.0, 1.0]:
            rp(f&#34;[red]Expected {speed[:2]} == [2.0, 1.0][/red&#34;)

        input(&#34;Check speed parameters in GUI&#34;)

        rp(puna.set_speed(1.2, 1.1))

        rp(speed := puna.get_speed())

        if speed[:2] != [1.2, 1.1]:
            rp(f&#34;[red]Expected {speed[:2]} == [1.2, 1.1][/red&#34;)

        rp(puna.get_actuator_length())

        # rp(puna.machine_limit_enable(0))
        # rp(puna.machine_limit_enable(1))
        # rp(puna.get_limits_state())
        rp(puna.get_coordinates_systems())
        rp(puna.configure_coordinates_systems(
                0.033000, -0.238000, 230.205000, 0.003282, 0.005671, 0.013930,
                0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000))
        rp(puna.get_coordinates_systems())
        rp(puna.get_machine_positions())
        rp(puna.get_user_positions())

        input(&#34;Check configuration in GUI&#34;)

        rp(puna.configure_coordinates_systems(
                0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
                0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000))

        rp(puna.validate_position(1, 0, 0, 0, 0, 0, 0, 0))
        rp(puna.validate_position(1, 0, 0, 0, 50, 0, 0, 0))

        rp(puna.goto_zero_position())
        rp(puna.is_in_position())
        if wait_until(puna.is_in_position, interval=1, timeout=300):
            rp(&#34;[red]Task puna.is_in_position() timed out after 30s.[/red]&#34;)
        rp(puna.is_in_position())

        rp(puna.get_machine_positions())
        rp(puna.get_user_positions())

        rp(puna.move_absolute(0, 0, 12, 0, 0, 10))

        rp(puna.is_in_position())
        if wait_until(puna.is_in_position, interval=1, timeout=300):
            rp(&#34;[red]Task puna.is_in_position() timed out after 30s.[/red]&#34;)
        rp(puna.is_in_position())

        rp(puna.get_machine_positions())
        rp(puna.get_user_positions())

        rp(puna.move_absolute(0, 0, 0, 0, 0, 0))

        rp(puna.is_in_position())
        if wait_until(puna.is_in_position, interval=1, timeout=300):
            rp(&#34;[red]Task puna.is_in_position() timed out after 30s.[/red]&#34;)
        rp(puna.is_in_position())

        rp(puna.get_machine_positions())
        rp(puna.get_user_positions())

        # # puna.reset()
        puna.disconnect()

        # rp(0, decode_validation_error(0))
        # rp(11, decode_validation_error(11))
        # rp(8, decode_validation_error(8))
        # rp(24, decode_validation_error(24))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.hexapod.symetrie.dynalpha.check_command_status"><code class="name flex">
<span>def <span class="ident">check_command_status</span></span>(<span>transport:Â DeviceTransportÂ =Â None, response:Â bytesÂ =Â None, timeout:Â floatÂ =Â 1.0, interval:Â floatÂ =Â 0.01) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Check the state of last sent command. When the state is zero (0) the command was successfully executed. When the
status is not zero before timeout seconds, the status check will be aborted and a warning message will be issued.
This function will then return a Failure containing the latest status code from the <code>c_cmd</code> variable.</p>
<p>The status can take the following values:</p>
<ul>
<li>
<blockquote>
<p>1: a new command has been written but has not yet been interpreted by the communication application</p>
</blockquote>
</li>
<li>= 1: the last written command is currently under execution</li>
<li>= 0: the last command was successfully executed</li>
<li>&lt; 0: the last command failed. This status code can be used to determine the cause of the error from
the RETURN_CODES variable in this module.</li>
</ul>
<p>Note: This function shall be used as a <code>post_cmd</code> callable in the dynamic_command decorator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>the device transport that can be used send additional commands to the device</dd>
<dt><strong><code>response</code></strong></dt>
<dd>The response from the command that was sent to the device</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>number of seconds before a timeout will occur</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>sleep time between checks for the status condition</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This function passes through the response without change. When the status check timed out
a Failure will be returned with an associated error message.</p>
<h2 id="raises">Raises</h2>
<p>A RuntimeError is raised when no device transport is passed into this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_command_status(transport: DeviceTransport = None, response: bytes = None,
                         timeout: float = 1.0, interval: float = 0.01) -&gt; Any:
    &#34;&#34;&#34;
    Check the state of last sent command. When the state is zero (0) the command was successfully executed. When the
    status is not zero before timeout seconds, the status check will be aborted and a warning message will be issued.
    This function will then return a Failure containing the latest status code from the `c_cmd` variable.

    The status can take the following values:

    * &gt; 1: a new command has been written but has not yet been interpreted by the communication application
    * = 1: the last written command is currently under execution
    * = 0: the last command was successfully executed
    * &lt; 0: the last command failed. This status code can be used to determine the cause of the error from
      the RETURN_CODES variable in this module.

    Note: This function shall be used as a `post_cmd` callable in the dynamic_command decorator.

    Args:
        transport: the device transport that can be used send additional commands to the device
        response: The response from the command that was sent to the device
        timeout: number of seconds before a timeout will occur
        interval: sleep time between checks for the status condition

    Returns:
        This function passes through the response without change. When the status check timed out
        a Failure will be returned with an associated error message.

    Raises:
        A RuntimeError is raised when no device transport is passed into this function.
    &#34;&#34;&#34;
    if transport is None:
        raise RuntimeError(&#34;no device transport was passed into the function!&#34;)

    rc = wait_until_cmd_is_zero(transport=transport, interval=interval, timeout=timeout)
    return rc if isinstance(rc, Failure) else response</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_actuator_state"><code class="name flex">
<span>def <span class="ident">decode_actuator_state</span></span>(<span>response:Â bytes) â€‘>Â Tuple[Tuple[Dict,Â List]]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_actuator_state(response: bytes) -&gt; Tuple[Tuple[Dict, List]] | Failure:
    response = validate_response(decode_response(response), &#34;s_ax&#34;)

    if isinstance(response, Failure):
        return response

    def decode_state(state: int) -&gt; Tuple[Dict, List]:
        state_bits = [int(x) for x in f&#39;{state:015b}&#39;[::-1]]
        state_dict = dict(zip(ACTUATOR_STATE, state_bits))
        return state_dict, state_bits

    actuator_states = [int(x) for x in response]

    return tuple(decode_state(state) for state in actuator_states)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_general_state"><code class="name flex">
<span>def <span class="ident">decode_general_state</span></span>(<span>response:Â bytes) â€‘>Â Tuple[Dict,Â List]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_general_state(response: bytes) -&gt; Tuple[Dict, List] | Failure:
    response = validate_response(decode_response(response), &#34;s_hexa&#34;)

    if isinstance(response, Failure):
        return response

    response = int(response[0])

    LOGGER.debug(f&#34;{response = } &lt;- decode_general_state&#34;)

    s_hexa = [int(x) for x in f&#39;{response:015b}&#39;[::-1]]
    state = dict(zip(GENERAL_STATE, s_hexa))

    return state, list(state.values())</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_info"><code class="name flex">
<span>def <span class="ident">decode_info</span></span>(<span>response:Â bytes) â€‘>Â strÂ |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_info(response: bytes) -&gt; str | Failure:
    response = process_response(response)

    if isinstance(response, Failure):
        return response

    LOGGER.debug(f&#34;{response = } &lt;- decode_info&#34;)

    return (
        f&#34;Info about the Hexapod Alpha+ Controller:\n&#34;
        f&#34;  Software version = {response[1]}.{response[2]}.{response[3]}.{response[4]}\n&#34;
        f&#34;  API version = {response[5]}.{response[6]}.{response[7]}.{response[8]}\n&#34;
        f&#34;  System Configuration version = {response[11]}&#34;
    )</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_mtp"><code class="name flex">
<span>def <span class="ident">decode_mtp</span></span>(<span>response:Â bytes) â€‘>Â List[float]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_mtp(response: bytes) -&gt; List[float] | Failure:
    response = validate_response(decode_response(response), &#34;s_mtp&#34;)

    if isinstance(response, Failure):
        return response

    return [float(x) for x in response]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_pars"><code class="name flex">
<span>def <span class="ident">decode_pars</span></span>(<span>response:Â bytesÂ =Â None, index:Â intÂ =Â 0, count:Â intÂ =Â 1, func:Â CallableÂ =Â builtins.float) â€‘>Â List[T]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_pars(response: bytes = None, index: int = 0, count: int = 1, func: Callable = float) -&gt; List[T] | Failure:
    response = process_response(response)

    if isinstance(response, Failure):
        return response

    return [func(x) for x in response[index:index+count]]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_response"><code class="name flex">
<span>def <span class="ident">decode_response</span></span>(<span>response:Â bytes) â€‘>Â strÂ |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the bytes object, strips off the trailing 'CRLF'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_response(response: bytes) -&gt; str | Failure:
    &#34;&#34;&#34;Decodes the bytes object, strips off the trailing &#39;CRLF&#39;.&#34;&#34;&#34;

    LOGGER.debug(f&#34;{response = } &lt;- decode_response&#34;)

    return response.decode().rstrip()</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_uto"><code class="name flex">
<span>def <span class="ident">decode_uto</span></span>(<span>response:Â bytes) â€‘>Â List[float]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_uto(response: bytes) -&gt; List[float] | Failure:
    response = validate_response(decode_response(response), &#34;s_uto&#34;)

    if isinstance(response, Failure):
        return response

    return [float(x) for x in response]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_validation_error"><code class="name flex">
<span>def <span class="ident">decode_validation_error</span></span>(<span>value) â€‘>Â Dict[~KT,Â ~VT]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the bitfield variable that is returned by the VALID_PTP command.</p>
<p>Each bit in this variable represents a particular error in the validation of a movement.
Several errors can be combined into the given variable.</p>
<p>Returns a dictionary with the bit numbers that were (on) and the corresponding error description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_validation_error(value) -&gt; Dict:
    &#34;&#34;&#34;
    Decode the bitfield variable that is returned by the VALID_PTP command.

    Each bit in this variable represents a particular error in the validation of a movement.
    Several errors can be combined into the given variable.

    Returns a dictionary with the bit numbers that were (on) and the corresponding error description.
    &#34;&#34;&#34;

    return {bit: VALIDATION_LIMITS[bit] for bit in range(6) if value &gt;&gt; bit &amp; 0b01}</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.decode_version"><code class="name flex">
<span>def <span class="ident">decode_version</span></span>(<span>response:Â bytes) â€‘>Â strÂ |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_version(response: bytes) -&gt; str | Failure:
    response = validate_response(decode_response(response))

    if isinstance(response, Failure):
        return response

    return f&#34;{response[5]}.{response[6]}.{response[7]}.{response[8]}&#34;</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.get_pars"><code class="name flex">
<span>def <span class="ident">get_pars</span></span>(<span>transport:Â DeviceTransportÂ =Â None, response:Â bytesÂ =Â None, index:Â intÂ =Â 0, count:Â intÂ =Â 1, increment:Â intÂ =Â 1, timeout:Â floatÂ =Â 1.0, interval:Â floatÂ =Â 0.01) â€‘>Â bytesÂ |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the response from a given command from the <code>c_par</code> array. The <code>c_par</code> array will
contain the correct values only after the <code>cmd</code> register is 0 (zero). So, we will wait until
<code>cmd</code> becomes 0, then retrieve the requested parameters from the <code>c_par</code> array and return
them as a normal response to be processed.</p>
<p>This function is intended to be used as a <code>post_cmd</code> function in the dynamic command decorator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>the transport interface to communicate with the device</dd>
<dt><strong><code>response</code></strong></dt>
<dd>the response from the actual command that was sent</dd>
<dt><strong><code>index</code></strong></dt>
<dd>starting index for the <code>c_par</code> array</dd>
<dt><strong><code>count</code></strong></dt>
<dd>the number of c_par values to retrieve</dd>
<dt><strong><code>increment</code></strong></dt>
<dd>the increment in the c_par array</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>the timeout period while waiting for the <code>cmd</code> to become 0</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>the sampling interval for the <code>cmd</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested values from the <code>c_par</code> array as a string. This string can be decoded with
the <code><a title="egse.hexapod.symetrie.dynalpha.decode_pars" href="#egse.hexapod.symetrie.dynalpha.decode_pars">decode_pars()</a></code> function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pars(
        transport: DeviceTransport = None, response: bytes = None,
        index: int = 0, count: int = 1, increment: int = 1, timeout: float = 1.0, interval: float = 0.01
) -&gt; bytes | Failure:
    &#34;&#34;&#34;
    Retrieve the response from a given command from the `c_par` array. The `c_par` array will
    contain the correct values only after the `cmd` register is 0 (zero). So, we will wait until
    `cmd` becomes 0, then retrieve the requested parameters from the `c_par` array and return
    them as a normal response to be processed.

    This function is intended to be used as a `post_cmd` function in the dynamic command decorator.

    Args:
        transport: the transport interface to communicate with the device
        response: the response from the actual command that was sent
        index: starting index for the `c_par` array
        count: the number of c_par values to retrieve
        increment: the increment in the c_par array
        timeout: the timeout period while waiting for the `cmd` to become 0
        interval: the sampling interval for the `cmd`

    Returns:
        The requested values from the `c_par` array as a string. This string can be decoded with
        the `decode_pars()` function.
    &#34;&#34;&#34;

    if transport is None:
        raise RuntimeError(&#34;no device transport was passed into the function!&#34;)

    rc = wait_until_cmd_is_zero(transport=transport, interval=interval, timeout=timeout)
    if isinstance(rc, Failure):
        return rc

    # The string &#39;c_par(0),1,1&#39; is considered illegal.

    if count == 1 and increment == 1:
        query = f&#34;c_par({index})&#34;
    else:
        query = f&#34;c_par({index}),{count},{increment}&#34;

    response = transport.query(f&#39;{query}\r\n&#39;)

    LOGGER.debug(f&#34;{response = } &lt;- {query} in get_pars&#34;)

    return response</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.issue_warning"><code class="name flex">
<span>def <span class="ident">issue_warning</span></span>(<span>*, response, msg:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issue_warning(*, response, msg: str):
    LOGGER.warning(f&#34;{msg} {response}&#34;)
    return response</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.process_cmd_string"><code class="name flex">
<span>def <span class="ident">process_cmd_string</span></span>(<span>command:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares the command string for sending to the controller.
A carriage return and newline is appended to the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_cmd_string(command: str) -&gt; str:
    &#34;&#34;&#34;
    Prepares the command string for sending to the controller.
    A carriage return and newline is appended to the command.
    &#34;&#34;&#34;

    return add_cr_lf(command)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.process_response"><code class="name flex">
<span>def <span class="ident">process_response</span></span>(<span>response:Â bytes, cmd:Â strÂ =Â None) â€‘>Â List[str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>This function is a shortcut for decode_response() and validate_response().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_response(response: bytes, cmd: str = None) -&gt; List[str] | Failure:
    &#34;&#34;&#34;This function is a shortcut for decode_response() and validate_response().&#34;&#34;&#34;

    # You might think this shortcut is really useless and doesn&#39;t give us anything,
    # the thing is that this function is used in the decorator, which is not possible
    # for each function individually.

    return validate_response(decode_response(response), cmd)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.process_validate_ptp"><code class="name flex">
<span>def <span class="ident">process_validate_ptp</span></span>(<span>response:Â bytes) â€‘>Â Tuple[int,Â Dict[int,Â str]]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>The response is in this case the value of 'c_par(0)' which is returned by the <code>post_cmd</code> function <code><a title="egse.hexapod.symetrie.dynalpha.get_pars" href="#egse.hexapod.symetrie.dynalpha.get_pars">get_pars()</a></code>.</p>
<h2 id="args">Args</h2>
<p>response:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_validate_ptp(response: bytes) -&gt; Tuple[int, Dict[int, str]] | Failure:
    &#34;&#34;&#34;
    The response is in this case the value of &#39;c_par(0)&#39; which is returned by the `post_cmd` function `get_pars`.

    Args:
        response:

    Returns:

    &#34;&#34;&#34;
    response = process_response(response)

    if isinstance(response, Failure):
        return response

    response = int(response[0])

    if response == 0:
        return 0, {}

    if response &gt; 0:
        description = decode_validation_error(response)
        return response, description

    # When response is negative, the validation failed, and we extract the command return code

    msg = f&#34;{RETURN_CODES.get(response, &#39;unknown error code&#39;)}&#34;

    LOGGER.error(f&#34;Validate position: error code={response} - {msg}&#34;)

    return response, {response: msg}</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.return_command_status"><code class="name flex">
<span>def <span class="ident">return_command_status</span></span>(<span>transport:Â DeviceTransportÂ =Â None, response:Â bytesÂ =Â None, timeout:Â floatÂ =Â 1.0, interval:Â floatÂ =Â 0.01) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Check the status of last sent command. When the status is zero (0) the command was successfully executed.
When the status is not zero before timeout seconds, the status check will be aborted and the function
will then return the latest status code from the <code>c_cmd</code> variable.</p>
<p>Note: This function shall be used as a <code>post_cmd</code> callable in the dynamic_command decorator and the process_response
shall not be used in conjunction with this command.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>the device transport that can be used send additional commands to the device</dd>
<dt><strong><code>response</code></strong></dt>
<dd>The response from the command that was sent to the device (ignored by this function)</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>number of seconds before a timeout will occur</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>sleep time between checks for the status condition</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The status of the last sent command as a tuple (status code, description).</p>
<h2 id="raises">Raises</h2>
<p>A RuntimeError is raised when no device transport is passed into this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_command_status(transport: DeviceTransport = None, response: bytes = None,
                          timeout: float = 1.0, interval: float = 0.01) -&gt; Tuple[int, str] | Failure:
    &#34;&#34;&#34;
    Check the status of last sent command. When the status is zero (0) the command was successfully executed.
    When the status is not zero before timeout seconds, the status check will be aborted and the function
    will then return the latest status code from the `c_cmd` variable.

    Note: This function shall be used as a `post_cmd` callable in the dynamic_command decorator and the process_response
          shall not be used in conjunction with this command.

    Args:
        transport: the device transport that can be used send additional commands to the device
        response: The response from the command that was sent to the device (ignored by this function)
        timeout: number of seconds before a timeout will occur
        interval: sleep time between checks for the status condition

    Returns:
        The status of the last sent command as a tuple (status code, description).

    Raises:
        A RuntimeError is raised when no device transport is passed into this function.
    &#34;&#34;&#34;

    # The response argument is ignored in this function as it generates a new response from the
    # command return code.

    if transport is None:
        raise RuntimeError(&#34;no device transport was passed into the function!&#34;)

    rc = 0

    def c_cmd():
        nonlocal rc
        rc_s = transport.query(&#39;c_cmd\r\n&#39;).decode()
        LOGGER.debug(f&#34;{rc_s = } &lt;- c_cmd in check_command_status&#34;)
        if not rc_s.startswith(&#39;c_cmd&#39;):
            LOGGER.warning(f&#34;{rc_s = }&#34;)
            return -1
        rc = int(rc_s.split(&#39;\r\n&#39;)[1])
        return rc

    if wait_until(lambda: c_cmd() == 0, interval=interval, timeout=timeout):
        LOGGER.warning(f&#34;Command check: {RETURN_CODES[rc]} [{rc}]&#34;)
    else:
        LOGGER.debug(&#34;Success!&#34;)
        rc = 0

    return rc, RETURN_CODES[rc]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.validate_response"><code class="name flex">
<span>def <span class="ident">validate_response</span></span>(<span>response:Â str, cmd:Â strÂ =Â None) â€‘>Â List[str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a number of checks on the response string and returns the response as a list of strings.
The command string (which is the first part of the device response) is removed from the returned list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong></dt>
<dd>decoded response from the device</dd>
<dt><strong><code>cmd</code></strong></dt>
<dd>the command string that is returned by the device</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of strings containing the split response without the first item (which was the command string).
If the response contains the string 'error #', a Failure will be returned with the error message.
If the response doesn't start with the given command string (when cmd != None), a Failure is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_response(response: str, cmd: str = None) -&gt; List[str] | Failure:
    &#34;&#34;&#34;
    Performs a number of checks on the response string and returns the response as a list of strings.
    The command string (which is the first part of the device response) is removed from the returned list.

    Args:
        response: decoded response from the device
        cmd: the command string that is returned by the device

    Returns:
        A list of strings containing the split response without the first item (which was the command string).
        If the response contains the string &#39;error #&#39;, a Failure will be returned with the error message.
        If the response doesn&#39;t start with the given command string (when cmd != None), a Failure is returned.
    &#34;&#34;&#34;
    if &#34;error #&#34; in response:
        msg = response.split(&#34;\r\n&#34;)[-1]  # this will strip off the cmd part of the response
        return Failure(msg)

    if cmd is not None and not response.startswith(cmd):
        return Failure(f&#34;Unexpected response from &#39;{cmd}&#39; command: {response}&#34;)

    LOGGER.debug(f&#34;{response = } &lt;- validate_response&#34;)

    return response.split(&#34;\r\n&#34;)[1:]</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.wait_until_cmd_is_zero"><code class="name flex">
<span>def <span class="ident">wait_until_cmd_is_zero</span></span>(<span>transport:Â DeviceTransport, timeout:Â floatÂ =Â 1.0, interval:Â floatÂ =Â 0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits until the <code>cmd</code> register is 0 (zero) and returns successfully if it does.
When the <code>cmd</code> register doesn't turn zero within the given timeout, a Failure is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until_cmd_is_zero(transport: DeviceTransport, timeout: float = 1.0, interval: float = 0.01):
    &#34;&#34;&#34;
    Waits until the `cmd` register is 0 (zero) and returns successfully if it does.
    When the `cmd` register doesn&#39;t turn zero within the given timeout, a Failure is returned.
    &#34;&#34;&#34;
    rc = 0

    def c_cmd():
        nonlocal rc
        rc_s = transport.query(&#39;c_cmd\r\n&#39;).decode()
        LOGGER.debug(f&#34;{rc_s = } &lt;- c_cmd in get_pars&#34;)
        if not rc_s.startswith(&#39;c_cmd&#39;):
            LOGGER.warning(f&#34;{rc_s = }&#34;)
            return -1
        rc = int(rc_s.split(&#39;\r\n&#39;)[1])
        return rc

    if wait_until(lambda: c_cmd() == 0, interval=interval, timeout=timeout):
        try:
            LOGGER.warning(f&#34;Command check timed out: {RETURN_CODES[rc]} [{rc=}]&#34;)
            return Failure(f&#34;Command check resulted in the following error: {RETURN_CODES[rc]}&#34;)
        except KeyError:
            return Failure(f&#34;Command check resulted in an unknown error code: {rc = }.&#34;)

    return Success(&#34;Command finished successfully&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface"><code class="flex name class">
<span>class <span class="ident">AlphaControllerInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Generic interface for all device classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphaControllerInterface(DeviceInterface):

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_STOP&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(issue_warning, msg=&#34;STOP command has been executed.&#34;),
        post_cmd=return_command_status,
    )
    def stop(self) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Stop the current motion. This command can be sent during a motion of the Hexapod
        and is executed with high priority.

        Returns:
            A tuple (return code, description). Return code = 0 on success.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CONTROLON&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def activate_control_loop(self):
        &#34;&#34;&#34;
        Activates the control loop on motors.

        It activates the power on the motors and releases the brakes if present.
        The hexapod status &#39;Control On&#39; will switch to true when the command is successful.

        This command should be used before starting a movement.

        Note: it is possible to activate the control loop on motors even if the home is not complete.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CONTROLOFF&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def deactivate_control_loop(self):
        &#34;&#34;&#34;
        Disables the control loop on the servo motors.

        It is advisable to disable the servo motors if the system is not used for
        a long period (more than 1 hour for example). However, this recommendation
        depends on the application for which the system is being used.

        This command is performed only if the following conditions are met:
          * there is no motion task running
          * there is no action running
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_HOME&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def homing(self):
        &#34;&#34;&#34;
        Starts the homing task on the hexapod.

        Homing needs to be completed before performing any movement. When the hexapod
        is equipped with absolute encoders, this cycle is executed automatically during
        the controller initialization. When the hexapod is not equipped with absolute
        encoders, the homing request movements: homing cycle will search actuators
        reference sensors.

        Homing is required before performing a control movement. Without absolute encoders,
        the homing is performed with a hexapod movement until detecting the reference sensor
        on each of the actuators. The Hexapod will go to a position were the sensors are
        reached that signal a known calibrated position and then returns to the zero position.

        Whenever a homing is performed, the method will return before the actual movement
        is finished.

        The homing cycle takes about two minutes to complete, but the ``homing()`` method
        returns almost immediately. Therefore, to check if the homing is finished, use
        the is_homing_done() method.

        This command is performed only if the following conditions are met:
          * there is no motion task running
          * the emergency stop button is not engaged (not applicable for absolute encoders)

        &#34;&#34;&#34;
        raise NotImplementedError

    def is_homing_done(self) -&gt; bool | Failure:
        &#34;&#34;&#34;
        Checks if Homing is done.

        When this variable indicates &#39;Homing is done&#39; it means the command has been properly
        executed, but it doesn&#39;t mean the Hexapod is in position. The hexapod might still be
        moving to its zero position.

        Returns:
            True when the homing is done, False otherwise.
        &#34;&#34;&#34;
        general_state = self.get_general_state()
        if isinstance(general_state, Failure):
            return general_state

        return bool(general_state[1][HOME_COMPLETE])

    def is_in_position(self) -&gt; bool | Failure:
        &#34;&#34;&#34;
        Checks if the hexapod is in position.

        Returns:
            True when in position, False otherwise.
        &#34;&#34;&#34;
        general_state = self.get_general_state()
        if isinstance(general_state, Failure):
            return general_state

        return bool(general_state[1][IN_POSITION]) and not bool(general_state[1][IN_MOTION])

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CLEARERROR&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def clear_error(self) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Clear all errors in the controller software.

        This command clears the error list on the controller and automatically removes the error bit of the hexapod
        state. After this command, errors might automatically be regenerated if they are still present. For example,
        if an encoder is disconnected, the encoder error will be re-generated after the command because error reason
        is not corrected.

        Returns:
            The command status is returned as a tuple with (return code, message).
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=1 &#34;
                                           &#34;c_par(0)=${tx_u} c_par(1)=${ty_u} c_par(2)=${tz_u} &#34;
                                           &#34;c_par(3)=${rx_u} c_par(4)=${ry_u} c_par(5)=${rz_u} &#34;
                                           &#34;c_par(6)=${tx_o} c_par(7)=${ty_o} c_par(8)=${tz_o} &#34;
                                           &#34;c_par(9)=${rx_o} c_par(10)=${ry_o} c_par(11)=${rz_o} &#34;
                                           &#34;c_cmd=C_CFG_CS&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def configure_coordinates_systems(
            self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
    ) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Change the definition of the User Coordinate System and the Object Coordinate System.

        The parameters tx_u, ty_u, tz_u, rx_u, ry_u, rz_u are used to define the user coordinate
        system relative to the Machine Coordinate System and the parameters tx_o, ty_o, tz_o, rx_o,
        ry_o, rz_o are used to define the Object Coordinate System relative to the Platform
        Coordinate System.

        Args:
            tx_u (float): translation parameter that define the user coordinate system relative
                          to the machine coordinate system [in mm]
            ty_u (float): translation parameter that define the user coordinate system relative
                          to the machine coordinate system [in mm]
            tz_u (float): translation parameter that define the user coordinate system relative
                          to the machine coordinate system [in mm]

            rx_u (float): rotation parameter that define the user coordinate system relative to
                          the machine coordinate system [in deg]
            ry_u (float): rotation parameter that define the user coordinate system relative to
                          the machine coordinate system [in deg]
            rz_u (float): rotation parameter that define the user coordinate system relative to
                          the machine coordinate system [in deg]

            tx_o (float): translation parameter that define the object coordinate system relative
                          to the platform coordinate system [in mm]
            ty_o (float): translation parameter that define the object coordinate system relative
                          to the platform coordinate system [in mm]
            tz_o (float): translation parameter that define the object coordinate system relative
                          to the platform coordinate system [in mm]

            rx_o (float): rotation parameter that define the object coordinate system relative to
                          the platform coordinate system [in deg]
            ry_o (float): rotation parameter that define the object coordinate system relative to
                          the platform coordinate system [in deg]
            rz_o (float): rotation parameter that define the object coordinate system relative to
                          the platform coordinate system [in deg]

        Returns:
            A tuple with the command status return code and a description.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cfg=0 c_cmd=C_CFG_CS&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, count=12),
        post_cmd=partial(get_pars, count=12),
    )
    def get_coordinates_systems(self):
        &#34;&#34;&#34;
        Retrieve the definition of the User Coordinate System and the Object Coordinate System.

        Returns:
            tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o where the
            translation parameters are in [mm] and the rotation parameters are in [deg].
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${cm} &#34;
                                           &#34;c_par(1)=${tx} c_par(2)=${ty} c_par(3)=${tz} &#34;
                                           &#34;c_par(4)=${rx} c_par(5)=${ry} c_par(6)=${rz} &#34;
                                           &#34;c_cmd=C_MOVE_PTP&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def move_ptp(self, cm: int,
                 tx: float, ty: float, tz: float, rx: float, ry: float, rz: float) -&gt; Tuple[int, str] | Failure:
        &#34;&#34;&#34;
        Start the movement as defined by the arguments.

        Args:
            cm: control mode, 0=absolute, 1=object relative, 2=user relative
            tx: position on X-axis [mm]
            ty: position on Y-axis [mm]
            tz: position on Z-axis [mm]
            rx: rotation around the X-axis [deg]
            ry: rotation around the Y-axis [deg]
            rz: rotation around the Z-axis [deg]

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError

    def move_absolute(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
        return self.move_ptp(0, tx, ty, tz, rx, ry, rz)

    def move_relative_object(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
        return self.move_ptp(1, tx, ty, tz, rx, ry, rz)

    def move_relative_user(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
        return self.move_ptp(2, tx, ty, tz, rx, ry, rz)

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${pos} c_cmd=C_MOVE_SPECIFICPOS&#34;,
        process_cmd_string=process_cmd_string,
        # process_response=process_response,
        post_cmd=return_command_status,
    )
    def goto_specific_position(self, pos: int):
        raise NotImplementedError

    def goto_user_zero_position(self):
        return self.goto_specific_position(pos=1)

    def goto_retracted_position(self):
        return self.goto_specific_position(pos=2)

    def goto_machine_zero_position(self):
        return self.goto_specific_position(pos=3)

    goto_zero_position = goto_user_zero_position

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_uto_tx,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_uto,
    )
    def get_user_positions(self):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_mtp_tx,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_mtp,
    )
    def get_machine_positions(self) -&gt; List[float] | Failure:
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cmd=C_VERSION&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_info,
        post_cmd=partial(get_pars, count=12),
    )
    def info(self) -&gt; str:
        &#34;&#34;&#34;Returns basic information about the hexapod and the controller.

        Returns:
            a multiline response message containing the device info.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cmd=C_VERSION&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_version,
        post_cmd=partial(get_pars, count=12),
    )
    def version(self) -&gt; str:
        &#34;&#34;&#34;Returns the version of the firmware running on the hexapod aplha+ controller.

        Returns:
            A version number as a string.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_hexa&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_general_state
    )
    def get_general_state(self) -&gt; Tuple[Dict, List] | Failure:
        &#34;&#34;&#34;
        Asks the general state of the hexapod on all the motors following the bits definition
        presented below.

        GENERAL_STATE =
            0: &#34;Error&#34;,
            1: &#34;System initialized&#34;,
            2: &#34;Control on&#34;,
            3: &#34;In position&#34;,
            4: &#34;Motion task running&#34;,
            5: &#34;Home task running&#34;,
            6: &#34;Home complete&#34;,
            7: &#34;Home virtual&#34;,
            8: &#34;Phase found&#34;,
            9: &#34;Brake on&#34;,
            10:&#34;Motion restricted&#34;,
            11:&#34;Power on encoders&#34;,
            12:&#34;Power on limit switches&#34;,
            13:&#34;Power on drives&#34;,
            14:&#34;Emergency stop&#34;

        Returns:
            A dictionary with the bits value of each parameter.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_ax_1,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_actuator_state,
    )
    def get_actuator_state(self) -&gt; Tuple[Dict, List] | Failure:
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;s_pos_ax_1,6,1&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, count=6, func=float),
    )
    def get_actuator_length(self):
        &#34;&#34;&#34;
        Retrieve the current length of the hexapod actuators.

        Returns:
            array: an array of six float values for actuator length L1 to L6 in [mm], and \
            None: when an Exception was raised and logs the error message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;c_cfg=0 c_cmd=C_CFG_SPEED&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, count=6),
        post_cmd=partial(get_pars, count=6),
    )
    def get_speed(self) -&gt; List[float]:
        &#34;&#34;&#34;
        Returns the positional speed of movements.

        Returns a list of floating point numbers [vt, vr, vt-, vr-, vt+, vr+] where vt and vr are the translation and
        angular speed respectively, the &#39;-&#39; and &#39;+&#39; are the minimum and maximum speeds.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=1 c_par(0)=${vt} c_par(1)=${vr} c_cmd=C_CFG_SPEED&#34;,
        process_cmd_string=process_cmd_string,
        post_cmd=return_command_status,
    )
    def set_speed(self, vt: float, vr: float):
        &#34;&#34;&#34;
        Set the positioning speed of movements.

        Args:
            vt: translational speed, unit = mm per second
            vr: angular speed, unit = deg per second
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${vm} c_par(1)=${cm} &#34;
                                           &#34;c_par(2)=${tx} c_par(3)=${ty} c_par(4)=${tz} &#34;
                                           &#34;c_par(5)=${rx} c_par(6)=${ry} c_par(7)=${rz} &#34;
                                           &#34;c_cmd=C_VALID_PTP&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_validate_ptp,
        post_cmd=get_pars,
    )
    def validate_position(self, vm, cm, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Ask the controller if the movement defined by the arguments is feasible.

        Returns a tuple where the first element is an integer that represents the
        bitfield encoding the errors. The second element is a dictionary with the
        bit numbers that were (on) and the corresponding error description as
        defined by VALIDATION_LIMITS.

        Args:
            vm (int): validation mode [only vm=1 is currently implemented by SymÃ©trie]
            cm (int): control mode (0 = absolute, 1 = object relative, 2 = user relative)
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        &#34;&#34;&#34;
        raise NotImplementedError

    def check_absolute_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Check if the requested object movement is valid.

        The absolute movement is expressed in the user coordinate system.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.
        &#34;&#34;&#34;
        # Currently only the vm=1 mode is developed by SymÃ©trie
        # Parameter cm = 0 for absolute
        return self.validate_position(1, 0, tx, ty, tz, rx, ry, rz)

    def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Check if the requested object movement is valid.

        The relative motion is expressed in the object coordinate system.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.
        &#34;&#34;&#34;
        # Currently only the vm=1 mode is developed by SymÃ©trie
        # Parameter cm = 1 for object relative
        return self.validate_position(1, 1, tx, ty, tz, rx, ry, rz)

    def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
        &#34;&#34;&#34;
        Check if the requested object movement is valid.

        The relative motion is expressed in the user coordinate system.

        Args:
            tx (float): position on the X-axis [mm]
            ty (float): position on the Y-axis [mm]
            tz (float): position on the Z-axis [mm]
            rx (float): rotation around the X-axis [deg]
            ry (float): rotation around the Y-axis [deg]
            rz (float): rotation around the Z-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.
        &#34;&#34;&#34;
        # Currently only the vm=1 mode is developed by SymÃ©trie
        # Parameter cm = 2 for user relative
        return self.validate_position(1, 2, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface">AlphaPlusControllerInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.activate_control_loop"><code class="name flex">
<span>def <span class="ident">activate_control_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Activates the control loop on motors.</p>
<p>It activates the power on the motors and releases the brakes if present.
The hexapod status 'Control On' will switch to true when the command is successful.</p>
<p>This command should be used before starting a movement.</p>
<p>Note: it is possible to activate the control loop on motors even if the home is not complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CONTROLON&#34;,
    process_cmd_string=process_cmd_string,
    post_cmd=return_command_status,
)
def activate_control_loop(self):
    &#34;&#34;&#34;
    Activates the control loop on motors.

    It activates the power on the motors and releases the brakes if present.
    The hexapod status &#39;Control On&#39; will switch to true when the command is successful.

    This command should be used before starting a movement.

    Note: it is possible to activate the control loop on motors even if the home is not complete.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_absolute_movement"><code class="name flex">
<span>def <span class="ident">check_absolute_movement</span></span>(<span>self, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â Dict[int,Â str]]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the requested object movement is valid.</p>
<p>The absolute movement is expressed in the user coordinate system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the X-axis [mm]</dd>
<dt><strong><code>ty</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Y-axis [mm]</dd>
<dt><strong><code>tz</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Z-axis [mm]</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
<dt><strong><code>rz</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Z-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>where the first element is an integer that represents the
bitfield encoding the errors. The second element is a dictionary
with the bit numbers that were (on) and the corresponding error
description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_absolute_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
    &#34;&#34;&#34;
    Check if the requested object movement is valid.

    The absolute movement is expressed in the user coordinate system.

    Args:
        tx (float): position on the X-axis [mm]
        ty (float): position on the Y-axis [mm]
        tz (float): position on the Z-axis [mm]
        rx (float): rotation around the X-axis [deg]
        ry (float): rotation around the Y-axis [deg]
        rz (float): rotation around the Z-axis [deg]

    Returns:
        tuple: where the first element is an integer that represents the
            bitfield encoding the errors. The second element is a dictionary
            with the bit numbers that were (on) and the corresponding error
            description.
    &#34;&#34;&#34;
    # Currently only the vm=1 mode is developed by SymÃ©trie
    # Parameter cm = 0 for absolute
    return self.validate_position(1, 0, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_object_movement"><code class="name flex">
<span>def <span class="ident">check_relative_object_movement</span></span>(<span>self, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â Dict[int,Â str]]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the requested object movement is valid.</p>
<p>The relative motion is expressed in the object coordinate system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the X-axis [mm]</dd>
<dt><strong><code>ty</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Y-axis [mm]</dd>
<dt><strong><code>tz</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Z-axis [mm]</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
<dt><strong><code>rz</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Z-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>where the first element is an integer that represents the
bitfield encoding the errors. The second element is a dictionary
with the bit numbers that were (on) and the corresponding error
description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_relative_object_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
    &#34;&#34;&#34;
    Check if the requested object movement is valid.

    The relative motion is expressed in the object coordinate system.

    Args:
        tx (float): position on the X-axis [mm]
        ty (float): position on the Y-axis [mm]
        tz (float): position on the Z-axis [mm]
        rx (float): rotation around the X-axis [deg]
        ry (float): rotation around the Y-axis [deg]
        rz (float): rotation around the Z-axis [deg]

    Returns:
        tuple: where the first element is an integer that represents the
            bitfield encoding the errors. The second element is a dictionary
            with the bit numbers that were (on) and the corresponding error
            description.
    &#34;&#34;&#34;
    # Currently only the vm=1 mode is developed by SymÃ©trie
    # Parameter cm = 1 for object relative
    return self.validate_position(1, 1, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_user_movement"><code class="name flex">
<span>def <span class="ident">check_relative_user_movement</span></span>(<span>self, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â Dict[int,Â str]]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the requested object movement is valid.</p>
<p>The relative motion is expressed in the user coordinate system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the X-axis [mm]</dd>
<dt><strong><code>ty</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Y-axis [mm]</dd>
<dt><strong><code>tz</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Z-axis [mm]</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
<dt><strong><code>rz</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Z-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>where the first element is an integer that represents the
bitfield encoding the errors. The second element is a dictionary
with the bit numbers that were (on) and the corresponding error
description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_relative_user_movement(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
    &#34;&#34;&#34;
    Check if the requested object movement is valid.

    The relative motion is expressed in the user coordinate system.

    Args:
        tx (float): position on the X-axis [mm]
        ty (float): position on the Y-axis [mm]
        tz (float): position on the Z-axis [mm]
        rx (float): rotation around the X-axis [deg]
        ry (float): rotation around the Y-axis [deg]
        rz (float): rotation around the Z-axis [deg]

    Returns:
        tuple: where the first element is an integer that represents the
            bitfield encoding the errors. The second element is a dictionary
            with the bit numbers that were (on) and the corresponding error
            description.
    &#34;&#34;&#34;
    # Currently only the vm=1 mode is developed by SymÃ©trie
    # Parameter cm = 2 for user relative
    return self.validate_position(1, 2, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.clear_error"><code class="name flex">
<span>def <span class="ident">clear_error</span></span>(<span>self) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all errors in the controller software.</p>
<p>This command clears the error list on the controller and automatically removes the error bit of the hexapod
state. After this command, errors might automatically be regenerated if they are still present. For example,
if an encoder is disconnected, the encoder error will be re-generated after the command because error reason
is not corrected.</p>
<h2 id="returns">Returns</h2>
<p>The command status is returned as a tuple with (return code, message).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CLEARERROR&#34;,
    process_cmd_string=process_cmd_string,
    post_cmd=return_command_status,
)
def clear_error(self) -&gt; Tuple[int, str] | Failure:
    &#34;&#34;&#34;
    Clear all errors in the controller software.

    This command clears the error list on the controller and automatically removes the error bit of the hexapod
    state. After this command, errors might automatically be regenerated if they are still present. For example,
    if an encoder is disconnected, the encoder error will be re-generated after the command because error reason
    is not corrected.

    Returns:
        The command status is returned as a tuple with (return code, message).
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.configure_coordinates_systems"><code class="name flex">
<span>def <span class="ident">configure_coordinates_systems</span></span>(<span>self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Change the definition of the User Coordinate System and the Object Coordinate System.</p>
<p>The parameters tx_u, ty_u, tz_u, rx_u, ry_u, rz_u are used to define the user coordinate
system relative to the Machine Coordinate System and the parameters tx_o, ty_o, tz_o, rx_o,
ry_o, rz_o are used to define the Object Coordinate System relative to the Platform
Coordinate System.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx_u</code></strong> :&ensp;<code>float</code></dt>
<dd>translation parameter that define the user coordinate system relative
to the machine coordinate system [in mm]</dd>
<dt><strong><code>ty_u</code></strong> :&ensp;<code>float</code></dt>
<dd>translation parameter that define the user coordinate system relative
to the machine coordinate system [in mm]</dd>
<dt><strong><code>tz_u</code></strong> :&ensp;<code>float</code></dt>
<dd>translation parameter that define the user coordinate system relative
to the machine coordinate system [in mm]</dd>
<dt><strong><code>rx_u</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation parameter that define the user coordinate system relative to
the machine coordinate system [in deg]</dd>
<dt><strong><code>ry_u</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation parameter that define the user coordinate system relative to
the machine coordinate system [in deg]</dd>
<dt><strong><code>rz_u</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation parameter that define the user coordinate system relative to
the machine coordinate system [in deg]</dd>
<dt><strong><code>tx_o</code></strong> :&ensp;<code>float</code></dt>
<dd>translation parameter that define the object coordinate system relative
to the platform coordinate system [in mm]</dd>
<dt><strong><code>ty_o</code></strong> :&ensp;<code>float</code></dt>
<dd>translation parameter that define the object coordinate system relative
to the platform coordinate system [in mm]</dd>
<dt><strong><code>tz_o</code></strong> :&ensp;<code>float</code></dt>
<dd>translation parameter that define the object coordinate system relative
to the platform coordinate system [in mm]</dd>
<dt><strong><code>rx_o</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation parameter that define the object coordinate system relative to
the platform coordinate system [in deg]</dd>
<dt><strong><code>ry_o</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation parameter that define the object coordinate system relative to
the platform coordinate system [in deg]</dd>
<dt><strong><code>rz_o</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation parameter that define the object coordinate system relative to
the platform coordinate system [in deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with the command status return code and a description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=1 &#34;
                                       &#34;c_par(0)=${tx_u} c_par(1)=${ty_u} c_par(2)=${tz_u} &#34;
                                       &#34;c_par(3)=${rx_u} c_par(4)=${ry_u} c_par(5)=${rz_u} &#34;
                                       &#34;c_par(6)=${tx_o} c_par(7)=${ty_o} c_par(8)=${tz_o} &#34;
                                       &#34;c_par(9)=${rx_o} c_par(10)=${ry_o} c_par(11)=${rz_o} &#34;
                                       &#34;c_cmd=C_CFG_CS&#34;,
    process_cmd_string=process_cmd_string,
    post_cmd=return_command_status,
)
def configure_coordinates_systems(
        self, tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o
) -&gt; Tuple[int, str] | Failure:
    &#34;&#34;&#34;
    Change the definition of the User Coordinate System and the Object Coordinate System.

    The parameters tx_u, ty_u, tz_u, rx_u, ry_u, rz_u are used to define the user coordinate
    system relative to the Machine Coordinate System and the parameters tx_o, ty_o, tz_o, rx_o,
    ry_o, rz_o are used to define the Object Coordinate System relative to the Platform
    Coordinate System.

    Args:
        tx_u (float): translation parameter that define the user coordinate system relative
                      to the machine coordinate system [in mm]
        ty_u (float): translation parameter that define the user coordinate system relative
                      to the machine coordinate system [in mm]
        tz_u (float): translation parameter that define the user coordinate system relative
                      to the machine coordinate system [in mm]

        rx_u (float): rotation parameter that define the user coordinate system relative to
                      the machine coordinate system [in deg]
        ry_u (float): rotation parameter that define the user coordinate system relative to
                      the machine coordinate system [in deg]
        rz_u (float): rotation parameter that define the user coordinate system relative to
                      the machine coordinate system [in deg]

        tx_o (float): translation parameter that define the object coordinate system relative
                      to the platform coordinate system [in mm]
        ty_o (float): translation parameter that define the object coordinate system relative
                      to the platform coordinate system [in mm]
        tz_o (float): translation parameter that define the object coordinate system relative
                      to the platform coordinate system [in mm]

        rx_o (float): rotation parameter that define the object coordinate system relative to
                      the platform coordinate system [in deg]
        ry_o (float): rotation parameter that define the object coordinate system relative to
                      the platform coordinate system [in deg]
        rz_o (float): rotation parameter that define the object coordinate system relative to
                      the platform coordinate system [in deg]

    Returns:
        A tuple with the command status return code and a description.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.deactivate_control_loop"><code class="name flex">
<span>def <span class="ident">deactivate_control_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the control loop on the servo motors.</p>
<p>It is advisable to disable the servo motors if the system is not used for
a long period (more than 1 hour for example). However, this recommendation
depends on the application for which the system is being used.</p>
<p>This command is performed only if the following conditions are met:
* there is no motion task running
* there is no action running</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_CONTROLOFF&#34;,
    process_cmd_string=process_cmd_string,
    post_cmd=return_command_status,
)
def deactivate_control_loop(self):
    &#34;&#34;&#34;
    Disables the control loop on the servo motors.

    It is advisable to disable the servo motors if the system is not used for
    a long period (more than 1 hour for example). However, this recommendation
    depends on the application for which the system is being used.

    This command is performed only if the following conditions are met:
      * there is no motion task running
      * there is no action running
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_length"><code class="name flex">
<span>def <span class="ident">get_actuator_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the current length of the hexapod actuators.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>an array of six float values for actuator length L1 to L6 in [mm], and
None: when an Exception was raised and logs the error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;s_pos_ax_1,6,1&#34;,
    process_cmd_string=process_cmd_string,
    process_response=partial(decode_pars, count=6, func=float),
)
def get_actuator_length(self):
    &#34;&#34;&#34;
    Retrieve the current length of the hexapod actuators.

    Returns:
        array: an array of six float values for actuator length L1 to L6 in [mm], and \
        None: when an Exception was raised and logs the error message.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_state"><code class="name flex">
<span>def <span class="ident">get_actuator_state</span></span>(<span>self) â€‘>Â Tuple[Dict,Â List]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_ax_1,6,1&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_actuator_state,
)
def get_actuator_state(self) -&gt; Tuple[Dict, List] | Failure:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_coordinates_systems"><code class="name flex">
<span>def <span class="ident">get_coordinates_systems</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the definition of the User Coordinate System and the Object Coordinate System.</p>
<h2 id="returns">Returns</h2>
<p>tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o where the
translation parameters are in [mm] and the rotation parameters are in [deg].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;c_cfg=0 c_cmd=C_CFG_CS&#34;,
    process_cmd_string=process_cmd_string,
    process_response=partial(decode_pars, count=12),
    post_cmd=partial(get_pars, count=12),
)
def get_coordinates_systems(self):
    &#34;&#34;&#34;
    Retrieve the definition of the User Coordinate System and the Object Coordinate System.

    Returns:
        tx_u, ty_u, tz_u, rx_u, ry_u, rz_u, tx_o, ty_o, tz_o, rx_o, ry_o, rz_o where the
        translation parameters are in [mm] and the rotation parameters are in [deg].
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_general_state"><code class="name flex">
<span>def <span class="ident">get_general_state</span></span>(<span>self) â€‘>Â Tuple[Dict,Â List]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Asks the general state of the hexapod on all the motors following the bits definition
presented below.</p>
<p>GENERAL_STATE =
0: "Error",
1: "System initialized",
2: "Control on",
3: "In position",
4: "Motion task running",
5: "Home task running",
6: "Home complete",
7: "Home virtual",
8: "Phase found",
9: "Brake on",
10:"Motion restricted",
11:"Power on encoders",
12:"Power on limit switches",
13:"Power on drives",
14:"Emergency stop"</p>
<h2 id="returns">Returns</h2>
<p>A dictionary with the bits value of each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_hexa&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_general_state
)
def get_general_state(self) -&gt; Tuple[Dict, List] | Failure:
    &#34;&#34;&#34;
    Asks the general state of the hexapod on all the motors following the bits definition
    presented below.

    GENERAL_STATE =
        0: &#34;Error&#34;,
        1: &#34;System initialized&#34;,
        2: &#34;Control on&#34;,
        3: &#34;In position&#34;,
        4: &#34;Motion task running&#34;,
        5: &#34;Home task running&#34;,
        6: &#34;Home complete&#34;,
        7: &#34;Home virtual&#34;,
        8: &#34;Phase found&#34;,
        9: &#34;Brake on&#34;,
        10:&#34;Motion restricted&#34;,
        11:&#34;Power on encoders&#34;,
        12:&#34;Power on limit switches&#34;,
        13:&#34;Power on drives&#34;,
        14:&#34;Emergency stop&#34;

    Returns:
        A dictionary with the bits value of each parameter.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_machine_positions"><code class="name flex">
<span>def <span class="ident">get_machine_positions</span></span>(<span>self) â€‘>Â List[float]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_mtp_tx,6,1&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_mtp,
)
def get_machine_positions(self) -&gt; List[float] | Failure:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_speed"><code class="name flex">
<span>def <span class="ident">get_speed</span></span>(<span>self) â€‘>Â List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the positional speed of movements.</p>
<p>Returns a list of floating point numbers [vt, vr, vt-, vr-, vt+, vr+] where vt and vr are the translation and
angular speed respectively, the '-' and '+' are the minimum and maximum speeds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;c_cfg=0 c_cmd=C_CFG_SPEED&#34;,
    process_cmd_string=process_cmd_string,
    process_response=partial(decode_pars, count=6),
    post_cmd=partial(get_pars, count=6),
)
def get_speed(self) -&gt; List[float]:
    &#34;&#34;&#34;
    Returns the positional speed of movements.

    Returns a list of floating point numbers [vt, vr, vt-, vr-, vt+, vr+] where vt and vr are the translation and
    angular speed respectively, the &#39;-&#39; and &#39;+&#39; are the minimum and maximum speeds.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_user_positions"><code class="name flex">
<span>def <span class="ident">get_user_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;s_uto_tx,6,1&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_uto,
)
def get_user_positions(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_machine_zero_position"><code class="name flex">
<span>def <span class="ident">goto_machine_zero_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_machine_zero_position(self):
    return self.goto_specific_position(pos=3)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_retracted_position"><code class="name flex">
<span>def <span class="ident">goto_retracted_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_retracted_position(self):
    return self.goto_specific_position(pos=2)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_specific_position"><code class="name flex">
<span>def <span class="ident">goto_specific_position</span></span>(<span>self, pos:Â int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${pos} c_cmd=C_MOVE_SPECIFICPOS&#34;,
    process_cmd_string=process_cmd_string,
    # process_response=process_response,
    post_cmd=return_command_status,
)
def goto_specific_position(self, pos: int):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_user_zero_position"><code class="name flex">
<span>def <span class="ident">goto_user_zero_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_user_zero_position(self):
    return self.goto_specific_position(pos=1)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_zero_position"><code class="name flex">
<span>def <span class="ident">goto_zero_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_user_zero_position(self):
    return self.goto_specific_position(pos=1)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.homing"><code class="name flex">
<span>def <span class="ident">homing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the homing task on the hexapod.</p>
<p>Homing needs to be completed before performing any movement. When the hexapod
is equipped with absolute encoders, this cycle is executed automatically during
the controller initialization. When the hexapod is not equipped with absolute
encoders, the homing request movements: homing cycle will search actuators
reference sensors.</p>
<p>Homing is required before performing a control movement. Without absolute encoders,
the homing is performed with a hexapod movement until detecting the reference sensor
on each of the actuators. The Hexapod will go to a position were the sensors are
reached that signal a known calibrated position and then returns to the zero position.</p>
<p>Whenever a homing is performed, the method will return before the actual movement
is finished.</p>
<p>The homing cycle takes about two minutes to complete, but the <code>homing()</code> method
returns almost immediately. Therefore, to check if the homing is finished, use
the is_homing_done() method.</p>
<p>This command is performed only if the following conditions are met:
* there is no motion task running
* the emergency stop button is not engaged (not applicable for absolute encoders)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_HOME&#34;,
    process_cmd_string=process_cmd_string,
    process_response=process_response,
)
def homing(self):
    &#34;&#34;&#34;
    Starts the homing task on the hexapod.

    Homing needs to be completed before performing any movement. When the hexapod
    is equipped with absolute encoders, this cycle is executed automatically during
    the controller initialization. When the hexapod is not equipped with absolute
    encoders, the homing request movements: homing cycle will search actuators
    reference sensors.

    Homing is required before performing a control movement. Without absolute encoders,
    the homing is performed with a hexapod movement until detecting the reference sensor
    on each of the actuators. The Hexapod will go to a position were the sensors are
    reached that signal a known calibrated position and then returns to the zero position.

    Whenever a homing is performed, the method will return before the actual movement
    is finished.

    The homing cycle takes about two minutes to complete, but the ``homing()`` method
    returns almost immediately. Therefore, to check if the homing is finished, use
    the is_homing_done() method.

    This command is performed only if the following conditions are met:
      * there is no motion task running
      * the emergency stop button is not engaged (not applicable for absolute encoders)

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns basic information about the hexapod and the controller.</p>
<h2 id="returns">Returns</h2>
<p>a multiline response message containing the device info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;c_cmd=C_VERSION&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_info,
    post_cmd=partial(get_pars, count=12),
)
def info(self) -&gt; str:
    &#34;&#34;&#34;Returns basic information about the hexapod and the controller.

    Returns:
        a multiline response message containing the device info.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_homing_done"><code class="name flex">
<span>def <span class="ident">is_homing_done</span></span>(<span>self) â€‘>Â boolÂ |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if Homing is done.</p>
<p>When this variable indicates 'Homing is done' it means the command has been properly
executed, but it doesn't mean the Hexapod is in position. The hexapod might still be
moving to its zero position.</p>
<h2 id="returns">Returns</h2>
<p>True when the homing is done, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_homing_done(self) -&gt; bool | Failure:
    &#34;&#34;&#34;
    Checks if Homing is done.

    When this variable indicates &#39;Homing is done&#39; it means the command has been properly
    executed, but it doesn&#39;t mean the Hexapod is in position. The hexapod might still be
    moving to its zero position.

    Returns:
        True when the homing is done, False otherwise.
    &#34;&#34;&#34;
    general_state = self.get_general_state()
    if isinstance(general_state, Failure):
        return general_state

    return bool(general_state[1][HOME_COMPLETE])</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_in_position"><code class="name flex">
<span>def <span class="ident">is_in_position</span></span>(<span>self) â€‘>Â boolÂ |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the hexapod is in position.</p>
<h2 id="returns">Returns</h2>
<p>True when in position, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_position(self) -&gt; bool | Failure:
    &#34;&#34;&#34;
    Checks if the hexapod is in position.

    Returns:
        True when in position, False otherwise.
    &#34;&#34;&#34;
    general_state = self.get_general_state()
    if isinstance(general_state, Failure):
        return general_state

    return bool(general_state[1][IN_POSITION]) and not bool(general_state[1][IN_MOTION])</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_absolute"><code class="name flex">
<span>def <span class="ident">move_absolute</span></span>(<span>self, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_absolute(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
    return self.move_ptp(0, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_ptp"><code class="name flex">
<span>def <span class="ident">move_ptp</span></span>(<span>self, cm:Â int, tx:Â float, ty:Â float, tz:Â float, rx:Â float, ry:Â float, rz:Â float) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Start the movement as defined by the arguments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cm</code></strong></dt>
<dd>control mode, 0=absolute, 1=object relative, 2=user relative</dd>
<dt><strong><code>tx</code></strong></dt>
<dd>position on X-axis [mm]</dd>
<dt><strong><code>ty</code></strong></dt>
<dd>position on Y-axis [mm]</dd>
<dt><strong><code>tz</code></strong></dt>
<dd>position on Z-axis [mm]</dd>
<dt><strong><code>rx</code></strong></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>ry</code></strong></dt>
<dd>rotation around the Y-axis [deg]</dd>
<dt><strong><code>rz</code></strong></dt>
<dd>rotation around the Z-axis [deg]</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${cm} &#34;
                                       &#34;c_par(1)=${tx} c_par(2)=${ty} c_par(3)=${tz} &#34;
                                       &#34;c_par(4)=${rx} c_par(5)=${ry} c_par(6)=${rz} &#34;
                                       &#34;c_cmd=C_MOVE_PTP&#34;,
    process_cmd_string=process_cmd_string,
    post_cmd=return_command_status,
)
def move_ptp(self, cm: int,
             tx: float, ty: float, tz: float, rx: float, ry: float, rz: float) -&gt; Tuple[int, str] | Failure:
    &#34;&#34;&#34;
    Start the movement as defined by the arguments.

    Args:
        cm: control mode, 0=absolute, 1=object relative, 2=user relative
        tx: position on X-axis [mm]
        ty: position on Y-axis [mm]
        tz: position on Z-axis [mm]
        rx: rotation around the X-axis [deg]
        ry: rotation around the Y-axis [deg]
        rz: rotation around the Z-axis [deg]

    Returns:

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_relative_object"><code class="name flex">
<span>def <span class="ident">move_relative_object</span></span>(<span>self, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_relative_object(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
    return self.move_ptp(1, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_relative_user"><code class="name flex">
<span>def <span class="ident">move_relative_user</span></span>(<span>self, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_relative_user(self, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, str] | Failure:
    return self.move_ptp(2, tx, ty, tz, rx, ry, rz)</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.set_speed"><code class="name flex">
<span>def <span class="ident">set_speed</span></span>(<span>self, vt:Â float, vr:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the positioning speed of movements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vt</code></strong></dt>
<dd>translational speed, unit = mm per second</dd>
<dt><strong><code>vr</code></strong></dt>
<dd>angular speed, unit = deg per second</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=1 c_par(0)=${vt} c_par(1)=${vr} c_cmd=C_CFG_SPEED&#34;,
    process_cmd_string=process_cmd_string,
    post_cmd=return_command_status,
)
def set_speed(self, vt: float, vr: float):
    &#34;&#34;&#34;
    Set the positioning speed of movements.

    Args:
        vt: translational speed, unit = mm per second
        vr: angular speed, unit = deg per second
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) â€‘>Â Tuple[int,Â str]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the current motion. This command can be sent during a motion of the Hexapod
and is executed with high priority.</p>
<h2 id="returns">Returns</h2>
<p>A tuple (return code, description). Return code = 0 on success.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cmd=C_STOP&#34;,
    process_cmd_string=process_cmd_string,
    process_response=partial(issue_warning, msg=&#34;STOP command has been executed.&#34;),
    post_cmd=return_command_status,
)
def stop(self) -&gt; Tuple[int, str] | Failure:
    &#34;&#34;&#34;
    Stop the current motion. This command can be sent during a motion of the Hexapod
    and is executed with high priority.

    Returns:
        A tuple (return code, description). Return code = 0 on success.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.validate_position"><code class="name flex">
<span>def <span class="ident">validate_position</span></span>(<span>self, vm, cm, tx, ty, tz, rx, ry, rz) â€‘>Â Tuple[int,Â Dict[int,Â str]]Â |Â Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Ask the controller if the movement defined by the arguments is feasible.</p>
<p>Returns a tuple where the first element is an integer that represents the
bitfield encoding the errors. The second element is a dictionary with the
bit numbers that were (on) and the corresponding error description as
defined by VALIDATION_LIMITS.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vm</code></strong> :&ensp;<code>int</code></dt>
<dd>validation mode [only vm=1 is currently implemented by SymÃ©trie]</dd>
<dt><strong><code>cm</code></strong> :&ensp;<code>int</code></dt>
<dd>control mode (0 = absolute, 1 = object relative, 2 = user relative)</dd>
<dt><strong><code>tx</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the X-axis [mm]</dd>
<dt><strong><code>ty</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Y-axis [mm]</dd>
<dt><strong><code>tz</code></strong> :&ensp;<code>float</code></dt>
<dd>position on the Z-axis [mm]</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
<dt><strong><code>rz</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Z-axis [deg]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_par(0)=${vm} c_par(1)=${cm} &#34;
                                       &#34;c_par(2)=${tx} c_par(3)=${ty} c_par(4)=${tz} &#34;
                                       &#34;c_par(5)=${rx} c_par(6)=${ry} c_par(7)=${rz} &#34;
                                       &#34;c_cmd=C_VALID_PTP&#34;,
    process_cmd_string=process_cmd_string,
    process_response=process_validate_ptp,
    post_cmd=get_pars,
)
def validate_position(self, vm, cm, tx, ty, tz, rx, ry, rz) -&gt; Tuple[int, Dict[int, str]] | Failure:
    &#34;&#34;&#34;
    Ask the controller if the movement defined by the arguments is feasible.

    Returns a tuple where the first element is an integer that represents the
    bitfield encoding the errors. The second element is a dictionary with the
    bit numbers that were (on) and the corresponding error description as
    defined by VALIDATION_LIMITS.

    Args:
        vm (int): validation mode [only vm=1 is currently implemented by SymÃ©trie]
        cm (int): control mode (0 = absolute, 1 = object relative, 2 = user relative)
        tx (float): position on the X-axis [mm]
        ty (float): position on the Y-axis [mm]
        tz (float): position on the Z-axis [mm]
        rx (float): rotation around the X-axis [deg]
        ry (float): rotation around the Y-axis [deg]
        rz (float): rotation around the Z-axis [deg]

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.version"><code class="name flex">
<span>def <span class="ident">version</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the version of the firmware running on the hexapod aplha+ controller.</p>
<h2 id="returns">Returns</h2>
<p>A version number as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;c_cmd=C_VERSION&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_version,
    post_cmd=partial(get_pars, count=12),
)
def version(self) -&gt; str:
    &#34;&#34;&#34;Returns the version of the firmware running on the hexapod aplha+ controller.

    Returns:
        A version number as a string.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface"><code class="flex name class">
<span>class <span class="ident">AlphaPlusControllerInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Generic interface for all device classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphaPlusControllerInterface(AlphaControllerInterface):
    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_variable(self, name: str) -&gt; str:
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name},${count},${increment}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_variables(self, name: str, count: int, increment: int = 1):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name}(${idx})&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_array(self, name: str, idx: int):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;${name}(${idx}),${count},${increment}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=process_response,
    )
    def query_array_values(self, name: str, idx: int, count: int, increment: int = 1):
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=0 c_par(0)=${lim} c_cmd=C_CFG_LIMIT&#34;,
        process_cmd_string=process_cmd_string,
        process_response=partial(decode_pars, index=1, count=12),
        post_cmd=partial(get_pars, count=13),
    )
    def get_limits_value(self, lim):
        &#34;&#34;&#34;
        Three different and independent operational workspace limits are defined on the controller:

            * Factory limits: are expressed in machine coordinate system limits. Those parameters cannot be modified.
            * Machine coordinate system limits: they are expressed in the Machine coordinate system. It can be used to
              secure the hexapod (and/or object) from its environment.
            * User coordinate system limits: they are expressed in the User coordinate system. It can be used to limits
              the movements of the object mounted on hexapod.

        Remark: operational workspace limits must be understood as limits in terms of amplitude of movement. Those
        limits are defined for each operational axis with a negative and positive value and are used in the validation
        process. Position on each operational axis must be within those two values.

        Args:
            lim (int): 0 = factory (GET only), 1 = machine cs limit, 2 = user cs limit

        Returns:
            A list of 12 float values: tx-, ty-, tz-, rx-, ry-, rz-, tx+, ty+, tz+, rx+, ry+, rz+
            The first six values are the negative limits for translation and rotation, the last six numbers are the
            positive limits for translation and rotation.

        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface">AlphaControllerInterface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.hexapod.symetrie.punaplus.PunaPlusInterface" href="punaplus.html#egse.hexapod.symetrie.punaplus.PunaPlusInterface">PunaPlusInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.get_limits_value"><code class="name flex">
<span>def <span class="ident">get_limits_value</span></span>(<span>self, lim)</span>
</code></dt>
<dd>
<div class="desc"><p>Three different and independent operational workspace limits are defined on the controller:</p>
<pre><code>* Factory limits: are expressed in machine coordinate system limits. Those parameters cannot be modified.
* Machine coordinate system limits: they are expressed in the Machine coordinate system. It can be used to
  secure the hexapod (and/or object) from its environment.
* User coordinate system limits: they are expressed in the User coordinate system. It can be used to limits
  the movements of the object mounted on hexapod.
</code></pre>
<p>Remark: operational workspace limits must be understood as limits in terms of amplitude of movement. Those
limits are defined for each operational axis with a negative and positive value and are used in the validation
process. Position on each operational axis must be within those two values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lim</code></strong> :&ensp;<code>int</code></dt>
<dd>0 = factory (GET only), 1 = machine cs limit, 2 = user cs limit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code> of <code>12 float values</code></dt>
<dd>tx-, ty-, tz-, rx-, ry-, rz-, tx+, ty+, tz+, rx+, ry+, rz+</dd>
</dl>
<p>The first six values are the negative limits for translation and rotation, the last six numbers are the
positive limits for translation and rotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;, cmd_string=&#34;c_cfg=0 c_par(0)=${lim} c_cmd=C_CFG_LIMIT&#34;,
    process_cmd_string=process_cmd_string,
    process_response=partial(decode_pars, index=1, count=12),
    post_cmd=partial(get_pars, count=13),
)
def get_limits_value(self, lim):
    &#34;&#34;&#34;
    Three different and independent operational workspace limits are defined on the controller:

        * Factory limits: are expressed in machine coordinate system limits. Those parameters cannot be modified.
        * Machine coordinate system limits: they are expressed in the Machine coordinate system. It can be used to
          secure the hexapod (and/or object) from its environment.
        * User coordinate system limits: they are expressed in the User coordinate system. It can be used to limits
          the movements of the object mounted on hexapod.

    Remark: operational workspace limits must be understood as limits in terms of amplitude of movement. Those
    limits are defined for each operational axis with a negative and positive value and are used in the validation
    process. Position on each operational axis must be within those two values.

    Args:
        lim (int): 0 = factory (GET only), 1 = machine cs limit, 2 = user cs limit

    Returns:
        A list of 12 float values: tx-, ty-, tz-, rx-, ry-, rz-, tx+, ty+, tz+, rx+, ry+, rz+
        The first six values are the negative limits for translation and rotation, the last six numbers are the
        positive limits for translation and rotation.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_array"><code class="name flex">
<span>def <span class="ident">query_array</span></span>(<span>self, name:Â str, idx:Â int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;${name}(${idx})&#34;,
    process_cmd_string=process_cmd_string,
    process_response=process_response,
)
def query_array(self, name: str, idx: int):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_array_values"><code class="name flex">
<span>def <span class="ident">query_array_values</span></span>(<span>self, name:Â str, idx:Â int, count:Â int, increment:Â intÂ =Â 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;${name}(${idx}),${count},${increment}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=process_response,
)
def query_array_values(self, name: str, idx: int, count: int, increment: int = 1):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_variable"><code class="name flex">
<span>def <span class="ident">query_variable</span></span>(<span>self, name:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;${name}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=process_response,
)
def query_variable(self, name: str) -&gt; str:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_variables"><code class="name flex">
<span>def <span class="ident">query_variables</span></span>(<span>self, name:Â str, count:Â int, increment:Â intÂ =Â 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;${name},${count},${increment}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=process_response,
)
def query_variables(self, name: str, count: int, increment: int = 1):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface">AlphaControllerInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.activate_control_loop" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_absolute_movement" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_object_movement" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_object_movement">check_relative_object_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_user_movement" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_user_movement">check_relative_user_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.clear_error" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.configure_coordinates_systems" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.configure_coordinates_systems">configure_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.deactivate_control_loop" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_length" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_coordinates_systems" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_coordinates_systems">get_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_general_state" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_speed" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.homing" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.info" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_homing_done" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_in_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_ptp" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_ptp">move_ptp</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.set_speed" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.stop" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.stop">stop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.validate_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.validate_position">validate_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.version" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.version">version</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface"><code class="flex name class">
<span>class <span class="ident">AlphaPlusTelnetInterface</span></span>
<span>(</span><span>hostname:Â strÂ =Â 'localhost', port:Â intÂ =Â 23)</span>
</code></dt>
<dd>
<div class="desc"><p>The Hexapod controller device interface based on the telnet protocol. This class implements the
DeviceTransport protocol which provides the <code>read()</code>, <code>write()</code>, <code>trans()</code>, and <code>query()</code> methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the OGSE hardware
controller. The default is 'localhost'.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to. The default is 23.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphaPlusTelnetInterface(DeviceTransport, DeviceConnectionInterface):
    &#34;&#34;&#34;
    The Hexapod controller device interface based on the telnet protocol. This class implements the
    DeviceTransport protocol which provides the `read()`, `write()`, `trans()`, and `query()` methods.
    &#34;&#34;&#34;

    TELNET_TIMEOUT = 1.0

    def __init__(self, hostname: str = &#39;localhost&#39;, port: int = 23):
        &#34;&#34;&#34;
        Args:
            hostname (str): the IP address or fully qualified hostname of the OGSE hardware
                controller. The default is &#39;localhost&#39;.
            port (int): the IP port number to connect to. The default is 23.
        &#34;&#34;&#34;
        super().__init__()
        self.telnet = Telnet()
        self._is_connected = False
        self.hostname = hostname
        self.port = port

    def connect(self) -&gt; None:
        &#34;&#34;&#34;
        Connects to the Alpha+ Controller using the Telnet protocol. After connection
        the telnet session logs in with the username provided in the Settings under
        the `PUNA Alpha+ Controller` group. The password for this login is also provided
        in the Settings under the same group. Make sure their values are only given in
        the local settings file, not the global settings.

        After login, the `gpascii` command is started with the option `-2` as instructed
        in the software manual of the controller. The first command sent then is the
        `echo7` command, which configures the system to return variable numbers only,
        not their variable names.
        &#34;&#34;&#34;
        try:
            self.telnet.open(self.hostname, self.port)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                device_name=&#34;Alpha+ Controller&#34;,
                message=f&#34;Connection refused to {self.hostname} port {self.port}&#34;
            ) from exc

        try:
            rc = self.telnet.read_until(b&#34;login: &#34;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(f&#34;{PUNA_PLUS.user_name}\r\n&#34;.encode())
            rc = self.telnet.read_until(b&#34;Password: &#34;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(f&#34;{PUNA_PLUS.password}\r\n&#34;.encode())
            rc = self.telnet.read_until(b&#34;ppmac# &#34;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(b&#34;gpascii -2\r\n&#34;)
            rc = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
            self.telnet.write(b&#34;echo7\r\n&#34;)
            rc = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
            # print(rc.decode(), flush=True, end=&#34;&#34;)
        except EOFError as exc:
            raise DeviceConnectionError(
                device_name=&#34;Alpha+ Controller&#34;,
                message=f&#34;Telnet connection closed for {self.hostname} port {self.port}&#34;
            ) from exc

        self._is_connected = True

    def is_connected(self):
        return self._is_connected

    def disconnect(self):
        rc = self.telnet.read_very_eager()
        print(rc.decode(), flush=True, end=&#34;&#34;)
        self.telnet.close()
        self._is_connected = False

    def reconnect(self):

        if self._is_connected:
            self.disconnect()
        self.connect()

    def trans(self, cmd: str) -&gt; bytes:
        &#34;&#34;&#34;
        Send a command to the Aplha+ Controller and waits for a response.
        The response is returned after the ACK is stripped off (see `read()` method).

        Args:
            cmd: a valid command string for the Alpha+ Controller

        Returns:
            The response from the controller on the command that was sent.
        &#34;&#34;&#34;
        self.write(cmd)
        response = self.read()

        LOGGER.debug(f&#34;trans: {response = }&#34;)

        return response

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Reads a response from the controller.

        Note: The acknowledgement `\x06\r\n` is stripped from the response before it is
              returned. If no ACK is present, a warning message will be logged.

        Returns:
            The response from the controller on a previously sent command.
        &#34;&#34;&#34;

        response = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)

        LOGGER.debug(f&#34;read: {response = }&#34;)

        if not response.endswith(b&#39;\x06\r\n&#39;):
            LOGGER.warning(f&#34;Expected ACK at the end of the response, {response = }&#34;)
            return response

        return response[:-3]  # strip off the ACK

    def write(self, cmd: str):
        &#34;&#34;&#34;
        Sends a command string to the Alpha+ Controller.
        The command string shall not end with a CRLF, that is automatically appended
        by this function.

        Args:
            cmd: a valid command string for the Alpha+ Controller

        Returns:
            Nothing is returned.
        &#34;&#34;&#34;
        LOGGER.debug(f&#34;Executing: {cmd.rstrip()}&#34;)
        self.telnet.write(cmd.encode())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.TELNET_TIMEOUT"><code class="name">var <span class="ident">TELNET_TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Connects to the Alpha+ Controller using the Telnet protocol. After connection
the telnet session logs in with the username provided in the Settings under
the <code>PUNA Alpha+ Controller</code> group. The password for this login is also provided
in the Settings under the same group. Make sure their values are only given in
the local settings file, not the global settings.</p>
<p>After login, the <code>gpascii</code> command is started with the option <code>-2</code> as instructed
in the software manual of the controller. The first command sent then is the
<code>echo7</code> command, which configures the system to return variable numbers only,
not their variable names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self) -&gt; None:
    &#34;&#34;&#34;
    Connects to the Alpha+ Controller using the Telnet protocol. After connection
    the telnet session logs in with the username provided in the Settings under
    the `PUNA Alpha+ Controller` group. The password for this login is also provided
    in the Settings under the same group. Make sure their values are only given in
    the local settings file, not the global settings.

    After login, the `gpascii` command is started with the option `-2` as instructed
    in the software manual of the controller. The first command sent then is the
    `echo7` command, which configures the system to return variable numbers only,
    not their variable names.
    &#34;&#34;&#34;
    try:
        self.telnet.open(self.hostname, self.port)
    except ConnectionRefusedError as exc:
        raise DeviceConnectionError(
            device_name=&#34;Alpha+ Controller&#34;,
            message=f&#34;Connection refused to {self.hostname} port {self.port}&#34;
        ) from exc

    try:
        rc = self.telnet.read_until(b&#34;login: &#34;, timeout=self.TELNET_TIMEOUT)
        # print(rc.decode(), flush=True, end=&#34;&#34;)
        self.telnet.write(f&#34;{PUNA_PLUS.user_name}\r\n&#34;.encode())
        rc = self.telnet.read_until(b&#34;Password: &#34;, timeout=self.TELNET_TIMEOUT)
        # print(rc.decode(), flush=True, end=&#34;&#34;)
        self.telnet.write(f&#34;{PUNA_PLUS.password}\r\n&#34;.encode())
        rc = self.telnet.read_until(b&#34;ppmac# &#34;, timeout=self.TELNET_TIMEOUT)
        # print(rc.decode(), flush=True, end=&#34;&#34;)
        self.telnet.write(b&#34;gpascii -2\r\n&#34;)
        rc = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
        # print(rc.decode(), flush=True, end=&#34;&#34;)
        self.telnet.write(b&#34;echo7\r\n&#34;)
        rc = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)
        # print(rc.decode(), flush=True, end=&#34;&#34;)
    except EOFError as exc:
        raise DeviceConnectionError(
            device_name=&#34;Alpha+ Controller&#34;,
            message=f&#34;Telnet connection closed for {self.hostname} port {self.port}&#34;
        ) from exc

    self._is_connected = True</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a response from the controller.</p>
<pre><code>    Note: The acknowledgement `
</code></pre>
<p>` is stripped from the response before it is
returned. If no ACK is present, a warning message will be logged.</p>
<pre><code>    Returns:
        The response from the controller on a previously sent command.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; bytes:
    &#34;&#34;&#34;
    Reads a response from the controller.

    Note: The acknowledgement `\x06\r\n` is stripped from the response before it is
          returned. If no ACK is present, a warning message will be logged.

    Returns:
        The response from the controller on a previously sent command.
    &#34;&#34;&#34;

    response = self.telnet.read_until(b&#39;\x06\r\n&#39;, timeout=self.TELNET_TIMEOUT)

    LOGGER.debug(f&#34;read: {response = }&#34;)

    if not response.endswith(b&#39;\x06\r\n&#39;):
        LOGGER.warning(f&#34;Expected ACK at the end of the response, {response = }&#34;)
        return response

    return response[:-3]  # strip off the ACK</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.trans"><code class="name flex">
<span>def <span class="ident">trans</span></span>(<span>self, cmd:Â str) â€‘>Â bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Send a command to the Aplha+ Controller and waits for a response.
The response is returned after the ACK is stripped off (see <code>read()</code> method).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>a valid command string for the Alpha+ Controller</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The response from the controller on the command that was sent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trans(self, cmd: str) -&gt; bytes:
    &#34;&#34;&#34;
    Send a command to the Aplha+ Controller and waits for a response.
    The response is returned after the ACK is stripped off (see `read()` method).

    Args:
        cmd: a valid command string for the Alpha+ Controller

    Returns:
        The response from the controller on the command that was sent.
    &#34;&#34;&#34;
    self.write(cmd)
    response = self.read()

    LOGGER.debug(f&#34;trans: {response = }&#34;)

    return response</code></pre>
</details>
</dd>
<dt id="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, cmd:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a command string to the Alpha+ Controller.
The command string shall not end with a CRLF, that is automatically appended
by this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>a valid command string for the Alpha+ Controller</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, cmd: str):
    &#34;&#34;&#34;
    Sends a command string to the Alpha+ Controller.
    The command string shall not end with a CRLF, that is automatically appended
    by this function.

    Args:
        cmd: a valid command string for the Alpha+ Controller

    Returns:
        Nothing is returned.
    &#34;&#34;&#34;
    LOGGER.debug(f&#34;Executing: {cmd.rstrip()}&#34;)
    self.telnet.write(cmd.encode())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.query" href="../../device.html#egse.device.DeviceTransport.query">query</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.hexapod.symetrie" href="index.html">egse.hexapod.symetrie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.dynalpha.check_command_status" href="#egse.hexapod.symetrie.dynalpha.check_command_status">check_command_status</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_actuator_state" href="#egse.hexapod.symetrie.dynalpha.decode_actuator_state">decode_actuator_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_general_state" href="#egse.hexapod.symetrie.dynalpha.decode_general_state">decode_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_info" href="#egse.hexapod.symetrie.dynalpha.decode_info">decode_info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_mtp" href="#egse.hexapod.symetrie.dynalpha.decode_mtp">decode_mtp</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_pars" href="#egse.hexapod.symetrie.dynalpha.decode_pars">decode_pars</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_response" href="#egse.hexapod.symetrie.dynalpha.decode_response">decode_response</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_uto" href="#egse.hexapod.symetrie.dynalpha.decode_uto">decode_uto</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_validation_error" href="#egse.hexapod.symetrie.dynalpha.decode_validation_error">decode_validation_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.decode_version" href="#egse.hexapod.symetrie.dynalpha.decode_version">decode_version</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.get_pars" href="#egse.hexapod.symetrie.dynalpha.get_pars">get_pars</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.issue_warning" href="#egse.hexapod.symetrie.dynalpha.issue_warning">issue_warning</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.process_cmd_string" href="#egse.hexapod.symetrie.dynalpha.process_cmd_string">process_cmd_string</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.process_response" href="#egse.hexapod.symetrie.dynalpha.process_response">process_response</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.process_validate_ptp" href="#egse.hexapod.symetrie.dynalpha.process_validate_ptp">process_validate_ptp</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.return_command_status" href="#egse.hexapod.symetrie.dynalpha.return_command_status">return_command_status</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.validate_response" href="#egse.hexapod.symetrie.dynalpha.validate_response">validate_response</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.wait_until_cmd_is_zero" href="#egse.hexapod.symetrie.dynalpha.wait_until_cmd_is_zero">wait_until_cmd_is_zero</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface">AlphaControllerInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.activate_control_loop" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_absolute_movement" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_object_movement" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_object_movement">check_relative_object_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_user_movement" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.check_relative_user_movement">check_relative_user_movement</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.clear_error" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.configure_coordinates_systems" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.configure_coordinates_systems">configure_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.deactivate_control_loop" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_length" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_state" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_actuator_state">get_actuator_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_coordinates_systems" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_coordinates_systems">get_coordinates_systems</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_general_state" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_machine_positions" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_machine_positions">get_machine_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_speed" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_user_positions" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.get_user_positions">get_user_positions</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_machine_zero_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_machine_zero_position">goto_machine_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_retracted_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_retracted_position">goto_retracted_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_specific_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_specific_position">goto_specific_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_user_zero_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_user_zero_position">goto_user_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_zero_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.goto_zero_position">goto_zero_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.homing" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.info" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_homing_done" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_in_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_absolute" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_absolute">move_absolute</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_ptp" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_ptp">move_ptp</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_relative_object" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_relative_object">move_relative_object</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_relative_user" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.move_relative_user">move_relative_user</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.set_speed" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.stop" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.stop">stop</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.validate_position" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.validate_position">validate_position</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.version" href="#egse.hexapod.symetrie.dynalpha.AlphaControllerInterface.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface">AlphaPlusControllerInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.get_limits_value" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.get_limits_value">get_limits_value</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_array" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_array">query_array</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_array_values" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_array_values">query_array_values</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_variable" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_variable">query_variable</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_variables" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusControllerInterface.query_variables">query_variables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface">AlphaPlusTelnetInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.TELNET_TIMEOUT" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.TELNET_TIMEOUT">TELNET_TIMEOUT</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.connect" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.connect">connect</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.read" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.read">read</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.trans" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.trans">trans</a></code></li>
<li><code><a title="egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.write" href="#egse.hexapod.symetrie.dynalpha.AlphaPlusTelnetInterface.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
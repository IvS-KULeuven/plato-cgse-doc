<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.procman API documentation</title>
<meta name="description" content="This module provides Process Management functionality for the Common-EGSE." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.procman</code></h1>
</header>
<section id="section-intro">
<p>This module provides Process Management functionality for the Common-EGSE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides Process Management functionality for the Common-EGSE.
&#34;&#34;&#34;
import importlib
import logging
import pickle
import sys

import zmq

from egse.command import ClientServerCommand
from egse.confman import ConfigurationManagerProxy
from egse.confman import is_configuration_manager_active
from egse.control import ControlServer
from egse.decorators import dynamic_interface
from egse.dpu import DPUProxy
from egse.dpu.dpu_cs import is_dpu_cs_active
from egse.process import SubProcess
from egse.protocol import CommandProtocol
from egse.proxy import Proxy
from egse.settings import Settings
from egse.setup import Setup, load_setup
from egse.storage import is_storage_manager_active
from egse.system import find_class
from egse.system import format_datetime
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

CTRL_SETTINGS = Settings.load(&#34;Process Manager Control Server&#34;)
COMMAND_SETTINGS = Settings.load(filename=&#34;procman.yaml&#34;)

LOGGER = logging.getLogger(__name__)


def is_process_manager_cs_active(timeout: float = 0.5):
    &#34;&#34;&#34;Checks if the Process Manager Control Server is active.

    To check whether the Control Server is active, a &#34;Ping&#34; command is sent.
    If a &#34;Pong&#34; reply is received before timeout, the Control Server is said
    to be active (and True will be returned).  If no reply is received before
    timeout or if the reply is not &#34;Pong&#34;, the Control Server is said to be
    inactive (and False will be returned).

    Args:
        - timeout (float): Timeout when waiting for a reply [s].

    Returns:
        True if the Process Manager Control Server is active; False otherwise.
    &#34;&#34;&#34;

    # Create a socket and connect it to the commanding port of the CS

    socket = zmq.Context.instance().socket(zmq.REQ)
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket.connect(endpoint)

    # Send a &#34;Ping&#34; command and wait for a reply
    # (but not beyond timeout)

    data = pickle.dumps(&#34;Ping&#34;)
    socket.send(data)
    rlist, _, _ = zmq.select([socket], [], [], timeout=timeout)

    # Reply received before timeout
    # (should be &#34;Pong&#34;)

    status = False

    if socket in rlist:

        # Only if the reply is &#34;Pong&#34;, the CS is active

        data = socket.recv()
        response = pickle.loads(data)

        status = response == &#34;Pong&#34;

    # No reply received -&gt; inactive

    socket.close(linger=0)

    return status


class ProcessManagerProtocol(CommandProtocol):

    &#34;&#34;&#34;
    Command Protocol for Process Management.
    &#34;&#34;&#34;

    def __init__(self, control_server: ControlServer):
        &#34;&#34;&#34;Initialisation of a new Protocol for Process Management.

        The initialisation of this Protocol consists of the following steps:

            - create a Controller to which the given Control Server should send commands;
            - load the commands;
            - build a look-up table for the commands.

        Args:
            - control_server: Control Server via which commands should be sent
                              to the Controller.
        &#34;&#34;&#34;

        super().__init__()

        # Control Server for Process Management

        self.control_server = control_server

        # Create a new Controller for Process Management

        self.controller = ProcessManagerController()

        # Load the commands (for commanding of the PM Controller) from the
        # YAML file into a dictionary, stored in the PM Protocol

        self.load_commands(
            COMMAND_SETTINGS.Commands, ProcessManagerCommand, ProcessManagerController
        )

        # Build a look-up table for the methods

        self.build_device_method_lookup_table(self.controller)

    def get_bind_address(self):
        &#34;&#34;&#34;Returns the address to bind a socket to.

        This bind address is a properly formatted URL, based on the
        communication protocol and the commanding port.

        Returns:
            - Properly formatted URL to bind a socket to.
        &#34;&#34;&#34;

        return bind_address(
            self.control_server.get_communication_protocol(),
            self.control_server.get_commanding_port(),
        )

    def get_status(self) -&gt; dict:
        &#34;&#34;&#34;Returns the status information for the Control Server.

        This status information is returned in the form of a dictionary that
        contains the following information about the Control Server for
        Process Management:

            - timestamp (str): string representation of the current datetime;
            - PID (int): process ID for the Control Server;
            - Up (float): uptime of the Control Server [s];
            - UUID (uuid1): Universally Unique Identifier for the Control
                            Server;
            - RSS (int): &#39;Resident Set Size&#39;, this is the non-swapped physical
                         memory a process has used [byte];
            - USS (int): &#39;Unique Set Size&#39;, this is the memory which is unique
                         to a process [byte];
            - CPU User (float): time spent in user mode [s];
            - CPU System (float): time spent in kernel mode [s];
            - CPU count: number of CPU cores in use by the process;
            - CPU% (float): process CPU utilization as a percentage [%].

        Returns:
            - Dictionary with status information for the Control Server for
              Process Management.
        &#34;&#34;&#34;

        return super().get_status()

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34;Returns the housekeeping data for the Control Server.

        This housekeeping data is returns in the form of a dictionary that
        contains the following information about the Control Server for
        Process Management:

            - timestamp (str): string representation of the current datetime.

        Returns:
            - Dictionary with housekeeping data for the Control Server for
              Process Management.
        &#34;&#34;&#34;

        return {&#34;timestamp&#34;: format_datetime()}

    def quit(self):
        self.controller.quit()


class ProcessManagerCommand(ClientServerCommand):

    &#34;&#34;&#34;
    Command (client-server) for Process Management.
    &#34;&#34;&#34;

    pass


class ProcessManagerInterface:

    &#34;&#34;&#34;
    Interface for dynamic loading of the commands for Process Management.
    &#34;&#34;&#34;

    @dynamic_interface
    def get_cm_proxy(self):
        &#34;&#34;&#34;
        Returns the Proxy for Configuration Management.

        Returns:
            - Proxy for Configuration Management.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_cs(self, process_name, sim_mode):
        &#34;&#34;&#34;Start the device Control Server with the given process name.

        This method can only be used to start the Control Server of a device
        that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be started with
        this method.

        The Control Server can either be started in simulator mode (without
        H/W controller available) or in operational mode (with H/W controller
        available).

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            started.
            - sim_mode: Whether or not to start the Control Server in
                        simulator mode.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_egse(self):
        &#34;&#34;&#34;Start all device Control Servers in the current setup in operational mode.

        This method can only be used to start the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be
        started with this method.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def shut_down_egse(self, process_name):
        &#34;&#34;&#34;Shut down the device Control Server with the given process name.

        This method can only be used to shut down the Control Server of a
        device that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be shut down with
        this method.

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            shut down.
        &#34;&#34;&#34;

    @dynamic_interface
    def shut_down_egse(self):
        &#34;&#34;&#34;Shut down all device Control Servers in the current setup.

        This method can only be used to shut down the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be shut
        down with this method.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_fitsgen(self):
        &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def stop_fitsgen(self):
        &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_fov_hk(self):
        &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def stop_fov_hk(self):
        &#34;&#34;&#34; Stop the generation of FOV HK.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_n_fee_hk(self):
        &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def stop_n_fee_hk(self):
        &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

        raise NotImplementedError


class ProcessManagerController(ProcessManagerInterface):

    &#34;&#34;&#34;
    Controller for Process Management.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialisation for the Process Manager Controller.

        Bother the Configuration Manager and the Storage manager should be running.
        &#34;&#34;&#34;

        # Configuration Manager must be active

        if is_configuration_manager_active():

            self._configuration = ConfigurationManagerProxy()

        else:

            self._configuration = None
            LOGGER.error(&#34;No Configuration Manager available!!!!&#34;)

        # Storage Manager must be active

        if not is_storage_manager_active():

            LOGGER.error(&#34;No Storage Manager available!!!!&#34;)

    def quit(self):
        if self._configuration:
            self._configuration.disconnect_cs()

    def get_cm_proxy(self):
        &#34;&#34;&#34;
        Returns the Proxy for Configuration Management.

        Returns:
            - Proxy for Configuration Management.
        &#34;&#34;&#34;

        return self._configuration

    def get_devices(self):
        &#34;&#34;&#34;Returns a dictionary with the device processes.

        The devices processes that are listed in this dictionary are the ones
        that are included in the current setup.

        The keys in the dictionary are taken from the &#34;device_name&#34; entries in
        the setup file. The corresponding values in the dictionary are taken
        from the &#34;device&#34; entries in the setup file (and should be Proxy classes).

        Returns:
            - Dictionary with the devices that are included in the setup.
        &#34;&#34;&#34;

        try:

            setup = self.get_cm_proxy().get_setup()

            devices = {}
            devices = Setup.find_devices(setup, devices=devices)

            return devices

        except AttributeError:

            return {}

    def get_core(self):
        &#34;&#34;&#34;Returns a dictionary with the core EGSE processes.

        The core EGSE processes are:

            - the Storage Manager,
            - the Configuration Manager,
            - the Process Manager,
            - and the Synoptics Manager.

        These processes should be running at all times, and can neither be
        started nor shut down from within the Process Manager.

        The keys in the dictionary are the names of the core processes.  The
        values are the Proxy classes.

        Returns:
            - Dictionary with the core EGSE processes.

        &#34;&#34;&#34;

        storage_proxy_class = &#34;class//egse.storage.StorageProxy&#34;
        confman_proxy_class = &#34;class//egse.confman.ConfigurationManagerProxy&#34;
        procman_proxy_class = &#34;class//egse.procman.ProcessManagerProxy&#34;
        syn_proxy_class = &#34;class//egse.synoptics.SynopticsManagerProxy&#34;

        return {
            &#34;Storage&#34;: (storage_proxy_class, ()),
            &#34;Configuration Manager&#34;: (confman_proxy_class, ()),
            &#34;Process Manager&#34;: (procman_proxy_class, ()),
            &#34;Synoptics Manager&#34;: (syn_proxy_class, ()),
        }

    def start_egse(self):
        &#34;&#34;&#34;Start all device Control Servers in the current setup in operational mode.

        This method can only be used to start the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be
        started with this method.
        &#34;&#34;&#34;

        LOGGER.debug(&#34;Starting EGSE&#34;)

        devices = self.get_devices()

        for process_name, process_info in devices.items():

            proxy_type = process_info[0]
            device_args = process_info[1]

            try:

                with find_class(proxy_type)(*device_args):

                    # The CS is already running

                    LOGGER.info(f&#34;{process_name} was already running&#34;)

            except ConnectionError:

                try:

                    module_name = proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
                    module = importlib.import_module(module_name)

                    cs_type = module.DEVICE_SETTINGS.ControlServer

                    # Operational mode

                    if str.startswith(proxy_type, &#34;class//egse.aeu.aeu.CRIO&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-crio-cs&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.PSU&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-psu-cs&#34;, str(device_args[0])])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.AWG&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-awg-cs&#34;, str(device_args[0])])

                    else:
                        if len(device_args) == 0:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;])
                        else:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;, str(device_args[0])])

                    LOGGER.info(f&#34;Starting Control Server for {process_name} in operational mode&#34;)
                    cs.execute(detach_from_parent=True)

                    if process_name == &#34;DAQ6510&#34;:
                        setup = load_setup()
                        das_delay = setup.gse.DAQ6510.route.delay
                        das_count = setup.gse.DAQ6510.route.scan.COUNT.SCAN
                        das_interval = setup.gse.DAQ6510.route.scan.INTERVAL

                        das = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.das&#34;, &#34;daq6510&#34;, &#34;--count&#34;,
                                                   str(das_count), &#34;--interval&#34;, str(das_interval), &#34;--delay&#34;,
                                                   str(das_delay)])
                        das.execute(detach_from_parent=&#34;True&#34;)

                    # Check to see the CS actually started

                    try:
                        with find_class(proxy_type)(*device_args):
                            pass
                    except ConnectionError:
                        LOGGER.warning(f&#34;Could not start Control Server for {process_name}&#34;)

                except AttributeError:

                    LOGGER.debug(f&#34;Cannot start Control Server for {process_name}&#34;)

        LOGGER.debug(&#34;EGSE started&#34;)

    def start_cs(self, process_name, sim_mode):
        &#34;&#34;&#34;Start the device Control Server with the given process name.

        This method can only be used to start the Control Server of a device
        that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be started with
        this method.

        The Control Server can either be started in simulator mode (without
        H/W controller available) or in operational mode (with H/W controller
        available).

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            started.
            - sim_mode: Whether or not to start the Control Server in
                        simulator mode.
        &#34;&#34;&#34;

        LOGGER.debug(f&#34;Starting {process_name}&#34;)

        process_info = self.get_devices()[process_name]
        proxy_type = process_info[0]
        device_args = process_info[1]

        try:

            with find_class(proxy_type)(*device_args):

                # The CS is already running

                LOGGER.info(f&#34;{process_name} was already running&#34;)

        except ConnectionError:

            try:

                module_name = proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
                module = importlib.import_module(module_name)

                if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;ControlServer&#34;):
                    cs_type = module.DEVICE_SETTINGS.ControlServer
                else:
                    raise AttributeError(f&#34;DEVICE_SETTINGS (or ControlServer therein) not defined in {module_name}&#34;)

                # Simulator mode

                if sim_mode:

                    mode = &#34;simulator mode&#34;

                    if str.startswith(proxy_type, &#34;class//egse.aeu.aeu.CRIO&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-crio-cs&#34;, &#34;--sim&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.PSU&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-psu-cs&#34;, str(device_args[0]), &#34;--sim&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.AWG&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-awg-cs&#34;, str(device_args[0]), &#34;--sim&#34;])

                    else:

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;, &#34;--sim&#34;])

                # Operational mode

                else:

                    mode = &#34;operational mode&#34;

                    if str.startswith(proxy_type, &#34;class//egse.aeu.aeu.CRIO&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-crio-cs&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.PSU&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-psu-cs&#34;, str(device_args[0])])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.AWG&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-awg-cs&#34;, str(device_args[0])])

                    else:
                        if len(device_args) == 0:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;])
                        else:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;, str(device_args[0])])
                    # os.system(sys.executable + &#34; -m &#34; + cs_type + &#34; start&#34;)

                LOGGER.info(f&#34;Starting Control Server for {process_name} in {mode}&#34;)
                cs.execute(detach_from_parent=True)

                if process_name == &#34;DAQ6510&#34;:

                    setup = load_setup()
                    das_delay = setup.gse.DAQ6510.route.delay
                    das_count = setup.gse.DAQ6510.route.scan.COUNT.SCAN
                    das_interval = setup.gse.DAQ6510.route.scan.INTERVAL

                    das = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.das&#34;, &#34;daq6510&#34;, &#34;--count&#34;, str(das_count),
                                               &#34;--interval&#34;, str(das_interval), &#34;--delay&#34;, str(das_delay)])
                    das.execute(detach_from_parent=&#34;True&#34;)

                # Check to see the CS actually started
                
                try:
                    with find_class(proxy_type)(*device_args):
                        pass
                except ConnectionError as exc:
                    LOGGER.warning(f&#34;Could not start Control Server for {process_name}&#34;, exc_info=True)

            except AttributeError as exc:

                LOGGER.error(f&#34;Cannot start Control Server for {process_name}&#34;, exc_info=True)

        # with find_class(proxy_type)(*device_args):
        #         pass

    def shut_down_egse(self):
        &#34;&#34;&#34;Shut down all device Control Servers in the current setup.

        This method can only be used to shut down the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be shut
        down with this method.
        &#34;&#34;&#34;

        LOGGER.debug(&#34;Shutting down EGSE&#34;)

        devices = self.get_devices()

        for key, process_info in reversed(devices.items()):

            LOGGER.debug(f&#34;Shutting down {key}&#34;)

            proxy_type = process_info[0]
            device_args = process_info[1]

            try:

                with find_class(proxy_type)(*device_args) as process_proxy:

                    with process_proxy.get_service_proxy() as service_proxy:

                        service_proxy.quit_server()

            except ConnectionError:

                pass

        LOGGER.debug(&#34;EGSE shut down&#34;)

    def shut_down_cs(self, process_name):
        &#34;&#34;&#34;Shut down the device Control Server with the given process name.

        This method can only be used to shut down the Control Server of a
        device that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be shut down with
        this method.

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            shut down.
        &#34;&#34;&#34;

        LOGGER.debug(f&#34;Shutting down {process_name}&#34;)

        try:

            process_info = self.get_devices()[process_name]
            proxy_type = process_info[0]
            device_args = process_info[1]

            with find_class(proxy_type)(*device_args) as process_proxy:

                with process_proxy.get_service_proxy() as service_proxy:

                    LOGGER.debug(&#34;Shutting down CS&#34;)

                    service_proxy.quit_server()

        except ConnectionError:

            # The CS is already down

            LOGGER.info(f&#34;{process_name} was already down&#34;)

    def start_fitsgen(self):
        &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

        # TODO Think about potential conditions for the FITS generator to be started:
        #   - FITS generator should not be running yet
        #   - FEE simulator must be running?
        #   - DPU CS must be running?

        # Check whether the DPU CS is running

        if not is_dpu_cs_active():

            LOGGER.critical(&#34;DPU Control Server must be running to be able to start the FITS generator.&#34;)
            return

        LOGGER.info(&#34;Starting the FITS generation&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen&#34;, &#34;start&#34;])
        fg.execute(detach_from_parent=True)

    def stop_fitsgen(self):
        &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

        LOGGER.info(&#34;Stopping the FITS generation&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen&#34;, &#34;stop&#34;])
        fg.execute(detach_from_parent=True)

    def start_fov_hk(self):
        &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Starting the generation of FOV HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fov.fov_hk&#34;, &#34;start&#34;])
        fg.execute(detach_from_parent=True)

    def stop_fov_hk(self):
        &#34;&#34;&#34; Stop the generation of FOV HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Stopping the generation of FOV HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fov.fov_hk&#34;, &#34;stop&#34;])
        fg.execute(detach_from_parent=True)

    def start_n_fee_hk(self):
        &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Starting the generation of N-FEE HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fee.n_fee_hk&#34;, &#34;start&#34;])
        fg.execute(detach_from_parent=True)

    def stop_n_fee_hk(self):
        &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Stopping the generation of N-FEE HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fee.n_fee_hk&#34;, &#34;stop&#34;])
        fg.execute(detach_from_parent=True)


class ProcessManagerProxy(Proxy, ProcessManagerInterface):

    &#34;&#34;&#34;
    Proxy for Process Managements, used to connect to the Process Manager
    Control Server and send commands remotely.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;Initialisation of a new Proxy for Process Management.

        If no connection details (transport protocol, hostname, and port) are
        not provided, these are taken from the settings file.

        Args:
            - protocol: Transport protocol [default is taken from settings
                        file].
            - hostname: Location of the control server (IP address) [default
                        is taken from settings file].
            - port: TCP port on which the Control Server is listening for
                    commands [default is taken from settings file].
        &#34;&#34;&#34;

        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="egse.procman.procman_cs" href="procman_cs.html">egse.procman.procman_cs</a></code></dt>
<dd>
<div class="desc"><p>The Process Manager Control Server is the service that handles all Common-EGSE
processes.
The list of processes to handle, is taken from the …</p></div>
</dd>
<dt><code class="name"><a title="egse.procman.procman_ui" href="procman_ui.html">egse.procman.procman_ui</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.procman.is_process_manager_cs_active"><code class="name flex">
<span>def <span class="ident">is_process_manager_cs_active</span></span>(<span>timeout: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Process Manager Control Server is active.</p>
<p>To check whether the Control Server is active, a "Ping" command is sent.
If a "Pong" reply is received before timeout, the Control Server is said
to be active (and True will be returned).
If no reply is received before
timeout or if the reply is not "Pong", the Control Server is said to be
inactive (and False will be returned).</p>
<h2 id="args">Args</h2>
<ul>
<li>timeout (float): Timeout when waiting for a reply [s].</li>
</ul>
<h2 id="returns">Returns</h2>
<p>True if the Process Manager Control Server is active; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_process_manager_cs_active(timeout: float = 0.5):
    &#34;&#34;&#34;Checks if the Process Manager Control Server is active.

    To check whether the Control Server is active, a &#34;Ping&#34; command is sent.
    If a &#34;Pong&#34; reply is received before timeout, the Control Server is said
    to be active (and True will be returned).  If no reply is received before
    timeout or if the reply is not &#34;Pong&#34;, the Control Server is said to be
    inactive (and False will be returned).

    Args:
        - timeout (float): Timeout when waiting for a reply [s].

    Returns:
        True if the Process Manager Control Server is active; False otherwise.
    &#34;&#34;&#34;

    # Create a socket and connect it to the commanding port of the CS

    socket = zmq.Context.instance().socket(zmq.REQ)
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket.connect(endpoint)

    # Send a &#34;Ping&#34; command and wait for a reply
    # (but not beyond timeout)

    data = pickle.dumps(&#34;Ping&#34;)
    socket.send(data)
    rlist, _, _ = zmq.select([socket], [], [], timeout=timeout)

    # Reply received before timeout
    # (should be &#34;Pong&#34;)

    status = False

    if socket in rlist:

        # Only if the reply is &#34;Pong&#34;, the CS is active

        data = socket.recv()
        response = pickle.loads(data)

        status = response == &#34;Pong&#34;

    # No reply received -&gt; inactive

    socket.close(linger=0)

    return status</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.procman.ProcessManagerCommand"><code class="flex name class">
<span>class <span class="ident">ProcessManagerCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Command (client-server) for Process Management.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerCommand(ClientServerCommand):

    &#34;&#34;&#34;
    Command (client-server) for Process Management.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.ProcessManagerController"><code class="flex name class">
<span>class <span class="ident">ProcessManagerController</span></span>
</code></dt>
<dd>
<div class="desc"><p>Controller for Process Management.</p>
<p>Initialisation for the Process Manager Controller.</p>
<p>Bother the Configuration Manager and the Storage manager should be running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerController(ProcessManagerInterface):

    &#34;&#34;&#34;
    Controller for Process Management.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialisation for the Process Manager Controller.

        Bother the Configuration Manager and the Storage manager should be running.
        &#34;&#34;&#34;

        # Configuration Manager must be active

        if is_configuration_manager_active():

            self._configuration = ConfigurationManagerProxy()

        else:

            self._configuration = None
            LOGGER.error(&#34;No Configuration Manager available!!!!&#34;)

        # Storage Manager must be active

        if not is_storage_manager_active():

            LOGGER.error(&#34;No Storage Manager available!!!!&#34;)

    def quit(self):
        if self._configuration:
            self._configuration.disconnect_cs()

    def get_cm_proxy(self):
        &#34;&#34;&#34;
        Returns the Proxy for Configuration Management.

        Returns:
            - Proxy for Configuration Management.
        &#34;&#34;&#34;

        return self._configuration

    def get_devices(self):
        &#34;&#34;&#34;Returns a dictionary with the device processes.

        The devices processes that are listed in this dictionary are the ones
        that are included in the current setup.

        The keys in the dictionary are taken from the &#34;device_name&#34; entries in
        the setup file. The corresponding values in the dictionary are taken
        from the &#34;device&#34; entries in the setup file (and should be Proxy classes).

        Returns:
            - Dictionary with the devices that are included in the setup.
        &#34;&#34;&#34;

        try:

            setup = self.get_cm_proxy().get_setup()

            devices = {}
            devices = Setup.find_devices(setup, devices=devices)

            return devices

        except AttributeError:

            return {}

    def get_core(self):
        &#34;&#34;&#34;Returns a dictionary with the core EGSE processes.

        The core EGSE processes are:

            - the Storage Manager,
            - the Configuration Manager,
            - the Process Manager,
            - and the Synoptics Manager.

        These processes should be running at all times, and can neither be
        started nor shut down from within the Process Manager.

        The keys in the dictionary are the names of the core processes.  The
        values are the Proxy classes.

        Returns:
            - Dictionary with the core EGSE processes.

        &#34;&#34;&#34;

        storage_proxy_class = &#34;class//egse.storage.StorageProxy&#34;
        confman_proxy_class = &#34;class//egse.confman.ConfigurationManagerProxy&#34;
        procman_proxy_class = &#34;class//egse.procman.ProcessManagerProxy&#34;
        syn_proxy_class = &#34;class//egse.synoptics.SynopticsManagerProxy&#34;

        return {
            &#34;Storage&#34;: (storage_proxy_class, ()),
            &#34;Configuration Manager&#34;: (confman_proxy_class, ()),
            &#34;Process Manager&#34;: (procman_proxy_class, ()),
            &#34;Synoptics Manager&#34;: (syn_proxy_class, ()),
        }

    def start_egse(self):
        &#34;&#34;&#34;Start all device Control Servers in the current setup in operational mode.

        This method can only be used to start the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be
        started with this method.
        &#34;&#34;&#34;

        LOGGER.debug(&#34;Starting EGSE&#34;)

        devices = self.get_devices()

        for process_name, process_info in devices.items():

            proxy_type = process_info[0]
            device_args = process_info[1]

            try:

                with find_class(proxy_type)(*device_args):

                    # The CS is already running

                    LOGGER.info(f&#34;{process_name} was already running&#34;)

            except ConnectionError:

                try:

                    module_name = proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
                    module = importlib.import_module(module_name)

                    cs_type = module.DEVICE_SETTINGS.ControlServer

                    # Operational mode

                    if str.startswith(proxy_type, &#34;class//egse.aeu.aeu.CRIO&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-crio-cs&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.PSU&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-psu-cs&#34;, str(device_args[0])])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.AWG&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-awg-cs&#34;, str(device_args[0])])

                    else:
                        if len(device_args) == 0:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;])
                        else:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;, str(device_args[0])])

                    LOGGER.info(f&#34;Starting Control Server for {process_name} in operational mode&#34;)
                    cs.execute(detach_from_parent=True)

                    if process_name == &#34;DAQ6510&#34;:
                        setup = load_setup()
                        das_delay = setup.gse.DAQ6510.route.delay
                        das_count = setup.gse.DAQ6510.route.scan.COUNT.SCAN
                        das_interval = setup.gse.DAQ6510.route.scan.INTERVAL

                        das = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.das&#34;, &#34;daq6510&#34;, &#34;--count&#34;,
                                                   str(das_count), &#34;--interval&#34;, str(das_interval), &#34;--delay&#34;,
                                                   str(das_delay)])
                        das.execute(detach_from_parent=&#34;True&#34;)

                    # Check to see the CS actually started

                    try:
                        with find_class(proxy_type)(*device_args):
                            pass
                    except ConnectionError:
                        LOGGER.warning(f&#34;Could not start Control Server for {process_name}&#34;)

                except AttributeError:

                    LOGGER.debug(f&#34;Cannot start Control Server for {process_name}&#34;)

        LOGGER.debug(&#34;EGSE started&#34;)

    def start_cs(self, process_name, sim_mode):
        &#34;&#34;&#34;Start the device Control Server with the given process name.

        This method can only be used to start the Control Server of a device
        that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be started with
        this method.

        The Control Server can either be started in simulator mode (without
        H/W controller available) or in operational mode (with H/W controller
        available).

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            started.
            - sim_mode: Whether or not to start the Control Server in
                        simulator mode.
        &#34;&#34;&#34;

        LOGGER.debug(f&#34;Starting {process_name}&#34;)

        process_info = self.get_devices()[process_name]
        proxy_type = process_info[0]
        device_args = process_info[1]

        try:

            with find_class(proxy_type)(*device_args):

                # The CS is already running

                LOGGER.info(f&#34;{process_name} was already running&#34;)

        except ConnectionError:

            try:

                module_name = proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
                module = importlib.import_module(module_name)

                if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;ControlServer&#34;):
                    cs_type = module.DEVICE_SETTINGS.ControlServer
                else:
                    raise AttributeError(f&#34;DEVICE_SETTINGS (or ControlServer therein) not defined in {module_name}&#34;)

                # Simulator mode

                if sim_mode:

                    mode = &#34;simulator mode&#34;

                    if str.startswith(proxy_type, &#34;class//egse.aeu.aeu.CRIO&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-crio-cs&#34;, &#34;--sim&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.PSU&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-psu-cs&#34;, str(device_args[0]), &#34;--sim&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.AWG&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-awg-cs&#34;, str(device_args[0]), &#34;--sim&#34;])

                    else:

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;, &#34;--sim&#34;])

                # Operational mode

                else:

                    mode = &#34;operational mode&#34;

                    if str.startswith(proxy_type, &#34;class//egse.aeu.aeu.CRIO&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-crio-cs&#34;])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.PSU&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-psu-cs&#34;, str(device_args[0])])

                    elif str.startswith(proxy_type, &#34;class//egse.aeu.aeu.AWG&#34;):

                        cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start-awg-cs&#34;, str(device_args[0])])

                    else:
                        if len(device_args) == 0:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;])
                        else:
                            cs = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, cs_type, &#34;start&#34;, str(device_args[0])])
                    # os.system(sys.executable + &#34; -m &#34; + cs_type + &#34; start&#34;)

                LOGGER.info(f&#34;Starting Control Server for {process_name} in {mode}&#34;)
                cs.execute(detach_from_parent=True)

                if process_name == &#34;DAQ6510&#34;:

                    setup = load_setup()
                    das_delay = setup.gse.DAQ6510.route.delay
                    das_count = setup.gse.DAQ6510.route.scan.COUNT.SCAN
                    das_interval = setup.gse.DAQ6510.route.scan.INTERVAL

                    das = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.das&#34;, &#34;daq6510&#34;, &#34;--count&#34;, str(das_count),
                                               &#34;--interval&#34;, str(das_interval), &#34;--delay&#34;, str(das_delay)])
                    das.execute(detach_from_parent=&#34;True&#34;)

                # Check to see the CS actually started
                
                try:
                    with find_class(proxy_type)(*device_args):
                        pass
                except ConnectionError as exc:
                    LOGGER.warning(f&#34;Could not start Control Server for {process_name}&#34;, exc_info=True)

            except AttributeError as exc:

                LOGGER.error(f&#34;Cannot start Control Server for {process_name}&#34;, exc_info=True)

        # with find_class(proxy_type)(*device_args):
        #         pass

    def shut_down_egse(self):
        &#34;&#34;&#34;Shut down all device Control Servers in the current setup.

        This method can only be used to shut down the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be shut
        down with this method.
        &#34;&#34;&#34;

        LOGGER.debug(&#34;Shutting down EGSE&#34;)

        devices = self.get_devices()

        for key, process_info in reversed(devices.items()):

            LOGGER.debug(f&#34;Shutting down {key}&#34;)

            proxy_type = process_info[0]
            device_args = process_info[1]

            try:

                with find_class(proxy_type)(*device_args) as process_proxy:

                    with process_proxy.get_service_proxy() as service_proxy:

                        service_proxy.quit_server()

            except ConnectionError:

                pass

        LOGGER.debug(&#34;EGSE shut down&#34;)

    def shut_down_cs(self, process_name):
        &#34;&#34;&#34;Shut down the device Control Server with the given process name.

        This method can only be used to shut down the Control Server of a
        device that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be shut down with
        this method.

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            shut down.
        &#34;&#34;&#34;

        LOGGER.debug(f&#34;Shutting down {process_name}&#34;)

        try:

            process_info = self.get_devices()[process_name]
            proxy_type = process_info[0]
            device_args = process_info[1]

            with find_class(proxy_type)(*device_args) as process_proxy:

                with process_proxy.get_service_proxy() as service_proxy:

                    LOGGER.debug(&#34;Shutting down CS&#34;)

                    service_proxy.quit_server()

        except ConnectionError:

            # The CS is already down

            LOGGER.info(f&#34;{process_name} was already down&#34;)

    def start_fitsgen(self):
        &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

        # TODO Think about potential conditions for the FITS generator to be started:
        #   - FITS generator should not be running yet
        #   - FEE simulator must be running?
        #   - DPU CS must be running?

        # Check whether the DPU CS is running

        if not is_dpu_cs_active():

            LOGGER.critical(&#34;DPU Control Server must be running to be able to start the FITS generator.&#34;)
            return

        LOGGER.info(&#34;Starting the FITS generation&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen&#34;, &#34;start&#34;])
        fg.execute(detach_from_parent=True)

    def stop_fitsgen(self):
        &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

        LOGGER.info(&#34;Stopping the FITS generation&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen&#34;, &#34;stop&#34;])
        fg.execute(detach_from_parent=True)

    def start_fov_hk(self):
        &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Starting the generation of FOV HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fov.fov_hk&#34;, &#34;start&#34;])
        fg.execute(detach_from_parent=True)

    def stop_fov_hk(self):
        &#34;&#34;&#34; Stop the generation of FOV HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Stopping the generation of FOV HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fov.fov_hk&#34;, &#34;stop&#34;])
        fg.execute(detach_from_parent=True)

    def start_n_fee_hk(self):
        &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Starting the generation of N-FEE HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fee.n_fee_hk&#34;, &#34;start&#34;])
        fg.execute(detach_from_parent=True)

    def stop_n_fee_hk(self):
        &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

        LOGGER.info(&#34;Stopping the generation of N-FEE HK&#34;)

        fg = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.fee.n_fee_hk&#34;, &#34;stop&#34;])
        fg.execute(detach_from_parent=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.procman.ProcessManagerInterface" href="#egse.procman.ProcessManagerInterface">ProcessManagerInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.ProcessManagerController.get_core"><code class="name flex">
<span>def <span class="ident">get_core</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with the core EGSE processes.</p>
<p>The core EGSE processes are:</p>
<pre><code>- the Storage Manager,
- the Configuration Manager,
- the Process Manager,
- and the Synoptics Manager.
</code></pre>
<p>These processes should be running at all times, and can neither be
started nor shut down from within the Process Manager.</p>
<p>The keys in the dictionary are the names of the core processes.
The
values are the Proxy classes.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Dictionary with the core EGSE processes.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_core(self):
    &#34;&#34;&#34;Returns a dictionary with the core EGSE processes.

    The core EGSE processes are:

        - the Storage Manager,
        - the Configuration Manager,
        - the Process Manager,
        - and the Synoptics Manager.

    These processes should be running at all times, and can neither be
    started nor shut down from within the Process Manager.

    The keys in the dictionary are the names of the core processes.  The
    values are the Proxy classes.

    Returns:
        - Dictionary with the core EGSE processes.

    &#34;&#34;&#34;

    storage_proxy_class = &#34;class//egse.storage.StorageProxy&#34;
    confman_proxy_class = &#34;class//egse.confman.ConfigurationManagerProxy&#34;
    procman_proxy_class = &#34;class//egse.procman.ProcessManagerProxy&#34;
    syn_proxy_class = &#34;class//egse.synoptics.SynopticsManagerProxy&#34;

    return {
        &#34;Storage&#34;: (storage_proxy_class, ()),
        &#34;Configuration Manager&#34;: (confman_proxy_class, ()),
        &#34;Process Manager&#34;: (procman_proxy_class, ()),
        &#34;Synoptics Manager&#34;: (syn_proxy_class, ()),
    }</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerController.get_devices"><code class="name flex">
<span>def <span class="ident">get_devices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with the device processes.</p>
<p>The devices processes that are listed in this dictionary are the ones
that are included in the current setup.</p>
<p>The keys in the dictionary are taken from the "device_name" entries in
the setup file. The corresponding values in the dictionary are taken
from the "device" entries in the setup file (and should be Proxy classes).</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Dictionary with the devices that are included in the setup.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_devices(self):
    &#34;&#34;&#34;Returns a dictionary with the device processes.

    The devices processes that are listed in this dictionary are the ones
    that are included in the current setup.

    The keys in the dictionary are taken from the &#34;device_name&#34; entries in
    the setup file. The corresponding values in the dictionary are taken
    from the &#34;device&#34; entries in the setup file (and should be Proxy classes).

    Returns:
        - Dictionary with the devices that are included in the setup.
    &#34;&#34;&#34;

    try:

        setup = self.get_cm_proxy().get_setup()

        devices = {}
        devices = Setup.find_devices(setup, devices=devices)

        return devices

    except AttributeError:

        return {}</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerController.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    if self._configuration:
        self._configuration.disconnect_cs()</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerController.shut_down_cs"><code class="name flex">
<span>def <span class="ident">shut_down_cs</span></span>(<span>self, process_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Shut down the device Control Server with the given process name.</p>
<p>This method can only be used to shut down the Control Server of a
device that is included in the current setup.
Core processes (Storage,
Configuration Manager, and Process Manager) cannot be shut down with
this method.</p>
<p>The given process name is the one that is used as device name in the
setup file and can also be found in the dictionary returned by the
get_devices() method.</p>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Device name for which the Control Server should be
shut down.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shut_down_cs(self, process_name):
    &#34;&#34;&#34;Shut down the device Control Server with the given process name.

    This method can only be used to shut down the Control Server of a
    device that is included in the current setup.  Core processes (Storage,
    Configuration Manager, and Process Manager) cannot be shut down with
    this method.

    The given process name is the one that is used as device name in the
    setup file and can also be found in the dictionary returned by the
    get_devices() method.

    Args:
        - process_name: Device name for which the Control Server should be
                        shut down.
    &#34;&#34;&#34;

    LOGGER.debug(f&#34;Shutting down {process_name}&#34;)

    try:

        process_info = self.get_devices()[process_name]
        proxy_type = process_info[0]
        device_args = process_info[1]

        with find_class(proxy_type)(*device_args) as process_proxy:

            with process_proxy.get_service_proxy() as service_proxy:

                LOGGER.debug(&#34;Shutting down CS&#34;)

                service_proxy.quit_server()

    except ConnectionError:

        # The CS is already down

        LOGGER.info(f&#34;{process_name} was already down&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.procman.ProcessManagerInterface" href="#egse.procman.ProcessManagerInterface">ProcessManagerInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.procman.ProcessManagerInterface.get_cm_proxy" href="#egse.procman.ProcessManagerInterface.get_cm_proxy">get_cm_proxy</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.shut_down_egse" href="#egse.procman.ProcessManagerInterface.shut_down_egse">shut_down_egse</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_cs" href="#egse.procman.ProcessManagerInterface.start_cs">start_cs</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_egse" href="#egse.procman.ProcessManagerInterface.start_egse">start_egse</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_fitsgen" href="#egse.procman.ProcessManagerInterface.start_fitsgen">start_fitsgen</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_fov_hk" href="#egse.procman.ProcessManagerInterface.start_fov_hk">start_fov_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_n_fee_hk" href="#egse.procman.ProcessManagerInterface.start_n_fee_hk">start_n_fee_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_fitsgen" href="#egse.procman.ProcessManagerInterface.stop_fitsgen">stop_fitsgen</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_fov_hk" href="#egse.procman.ProcessManagerInterface.stop_fov_hk">stop_fov_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_n_fee_hk" href="#egse.procman.ProcessManagerInterface.stop_n_fee_hk">stop_n_fee_hk</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.ProcessManagerInterface"><code class="flex name class">
<span>class <span class="ident">ProcessManagerInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface for dynamic loading of the commands for Process Management.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerInterface:

    &#34;&#34;&#34;
    Interface for dynamic loading of the commands for Process Management.
    &#34;&#34;&#34;

    @dynamic_interface
    def get_cm_proxy(self):
        &#34;&#34;&#34;
        Returns the Proxy for Configuration Management.

        Returns:
            - Proxy for Configuration Management.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_cs(self, process_name, sim_mode):
        &#34;&#34;&#34;Start the device Control Server with the given process name.

        This method can only be used to start the Control Server of a device
        that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be started with
        this method.

        The Control Server can either be started in simulator mode (without
        H/W controller available) or in operational mode (with H/W controller
        available).

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            started.
            - sim_mode: Whether or not to start the Control Server in
                        simulator mode.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_egse(self):
        &#34;&#34;&#34;Start all device Control Servers in the current setup in operational mode.

        This method can only be used to start the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be
        started with this method.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def shut_down_egse(self, process_name):
        &#34;&#34;&#34;Shut down the device Control Server with the given process name.

        This method can only be used to shut down the Control Server of a
        device that is included in the current setup.  Core processes (Storage,
        Configuration Manager, and Process Manager) cannot be shut down with
        this method.

        The given process name is the one that is used as device name in the
        setup file and can also be found in the dictionary returned by the
        get_devices() method.

        Args:
            - process_name: Device name for which the Control Server should be
                            shut down.
        &#34;&#34;&#34;

    @dynamic_interface
    def shut_down_egse(self):
        &#34;&#34;&#34;Shut down all device Control Servers in the current setup.

        This method can only be used to shut down the Control Servers of the
        devices that are included in the current setup.  Core processes
        (Storage, Configuration Manager, and Process Manager) cannot be shut
        down with this method.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_fitsgen(self):
        &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def stop_fitsgen(self):
        &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_fov_hk(self):
        &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def stop_fov_hk(self):
        &#34;&#34;&#34; Stop the generation of FOV HK.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def start_n_fee_hk(self):
        &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def stop_n_fee_hk(self):
        &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.procman.ProcessManagerController" href="#egse.procman.ProcessManagerController">ProcessManagerController</a></li>
<li><a title="egse.procman.ProcessManagerProxy" href="#egse.procman.ProcessManagerProxy">ProcessManagerProxy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.ProcessManagerInterface.get_cm_proxy"><code class="name flex">
<span>def <span class="ident">get_cm_proxy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Proxy for Configuration Management.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Proxy for Configuration Management.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_cm_proxy(self):
    &#34;&#34;&#34;
    Returns the Proxy for Configuration Management.

    Returns:
        - Proxy for Configuration Management.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.shut_down_egse"><code class="name flex">
<span>def <span class="ident">shut_down_egse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shut down all device Control Servers in the current setup.</p>
<p>This method can only be used to shut down the Control Servers of the
devices that are included in the current setup.
Core processes
(Storage, Configuration Manager, and Process Manager) cannot be shut
down with this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def shut_down_egse(self):
    &#34;&#34;&#34;Shut down all device Control Servers in the current setup.

    This method can only be used to shut down the Control Servers of the
    devices that are included in the current setup.  Core processes
    (Storage, Configuration Manager, and Process Manager) cannot be shut
    down with this method.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.start_cs"><code class="name flex">
<span>def <span class="ident">start_cs</span></span>(<span>self, process_name, sim_mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the device Control Server with the given process name.</p>
<p>This method can only be used to start the Control Server of a device
that is included in the current setup.
Core processes (Storage,
Configuration Manager, and Process Manager) cannot be started with
this method.</p>
<p>The Control Server can either be started in simulator mode (without
H/W controller available) or in operational mode (with H/W controller
available).</p>
<p>The given process name is the one that is used as device name in the
setup file and can also be found in the dictionary returned by the
get_devices() method.</p>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Device name for which the Control Server should be
started.</li>
<li>sim_mode: Whether or not to start the Control Server in
simulator mode.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_cs(self, process_name, sim_mode):
    &#34;&#34;&#34;Start the device Control Server with the given process name.

    This method can only be used to start the Control Server of a device
    that is included in the current setup.  Core processes (Storage,
    Configuration Manager, and Process Manager) cannot be started with
    this method.

    The Control Server can either be started in simulator mode (without
    H/W controller available) or in operational mode (with H/W controller
    available).

    The given process name is the one that is used as device name in the
    setup file and can also be found in the dictionary returned by the
    get_devices() method.

    Args:
        - process_name: Device name for which the Control Server should be
                        started.
        - sim_mode: Whether or not to start the Control Server in
                    simulator mode.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.start_egse"><code class="name flex">
<span>def <span class="ident">start_egse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start all device Control Servers in the current setup in operational mode.</p>
<p>This method can only be used to start the Control Servers of the
devices that are included in the current setup.
Core processes
(Storage, Configuration Manager, and Process Manager) cannot be
started with this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_egse(self):
    &#34;&#34;&#34;Start all device Control Servers in the current setup in operational mode.

    This method can only be used to start the Control Servers of the
    devices that are included in the current setup.  Core processes
    (Storage, Configuration Manager, and Process Manager) cannot be
    started with this method.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.start_fitsgen"><code class="name flex">
<span>def <span class="ident">start_fitsgen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the FITS generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_fitsgen(self):
    &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.start_fov_hk"><code class="name flex">
<span>def <span class="ident">start_fov_hk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the generation of FOV HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_fov_hk(self):
    &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.start_n_fee_hk"><code class="name flex">
<span>def <span class="ident">start_n_fee_hk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the generation of N-FEE HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_n_fee_hk(self):
    &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.stop_fitsgen"><code class="name flex">
<span>def <span class="ident">stop_fitsgen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the FITS generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def stop_fitsgen(self):
    &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.stop_fov_hk"><code class="name flex">
<span>def <span class="ident">stop_fov_hk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the generation of FOV HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def stop_fov_hk(self):
    &#34;&#34;&#34; Stop the generation of FOV HK.&#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerInterface.stop_n_fee_hk"><code class="name flex">
<span>def <span class="ident">stop_n_fee_hk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the generation of N-FEE HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def stop_n_fee_hk(self):
    &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.ProcessManagerProtocol"><code class="flex name class">
<span>class <span class="ident">ProcessManagerProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Command Protocol for Process Management.</p>
<p>Initialisation of a new Protocol for Process Management.</p>
<p>The initialisation of this Protocol consists of the following steps:</p>
<pre><code>- create a Controller to which the given Control Server should send commands;
- load the commands;
- build a look-up table for the commands.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>control_server: Control Server via which commands should be sent
to the Controller.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerProtocol(CommandProtocol):

    &#34;&#34;&#34;
    Command Protocol for Process Management.
    &#34;&#34;&#34;

    def __init__(self, control_server: ControlServer):
        &#34;&#34;&#34;Initialisation of a new Protocol for Process Management.

        The initialisation of this Protocol consists of the following steps:

            - create a Controller to which the given Control Server should send commands;
            - load the commands;
            - build a look-up table for the commands.

        Args:
            - control_server: Control Server via which commands should be sent
                              to the Controller.
        &#34;&#34;&#34;

        super().__init__()

        # Control Server for Process Management

        self.control_server = control_server

        # Create a new Controller for Process Management

        self.controller = ProcessManagerController()

        # Load the commands (for commanding of the PM Controller) from the
        # YAML file into a dictionary, stored in the PM Protocol

        self.load_commands(
            COMMAND_SETTINGS.Commands, ProcessManagerCommand, ProcessManagerController
        )

        # Build a look-up table for the methods

        self.build_device_method_lookup_table(self.controller)

    def get_bind_address(self):
        &#34;&#34;&#34;Returns the address to bind a socket to.

        This bind address is a properly formatted URL, based on the
        communication protocol and the commanding port.

        Returns:
            - Properly formatted URL to bind a socket to.
        &#34;&#34;&#34;

        return bind_address(
            self.control_server.get_communication_protocol(),
            self.control_server.get_commanding_port(),
        )

    def get_status(self) -&gt; dict:
        &#34;&#34;&#34;Returns the status information for the Control Server.

        This status information is returned in the form of a dictionary that
        contains the following information about the Control Server for
        Process Management:

            - timestamp (str): string representation of the current datetime;
            - PID (int): process ID for the Control Server;
            - Up (float): uptime of the Control Server [s];
            - UUID (uuid1): Universally Unique Identifier for the Control
                            Server;
            - RSS (int): &#39;Resident Set Size&#39;, this is the non-swapped physical
                         memory a process has used [byte];
            - USS (int): &#39;Unique Set Size&#39;, this is the memory which is unique
                         to a process [byte];
            - CPU User (float): time spent in user mode [s];
            - CPU System (float): time spent in kernel mode [s];
            - CPU count: number of CPU cores in use by the process;
            - CPU% (float): process CPU utilization as a percentage [%].

        Returns:
            - Dictionary with status information for the Control Server for
              Process Management.
        &#34;&#34;&#34;

        return super().get_status()

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34;Returns the housekeeping data for the Control Server.

        This housekeeping data is returns in the form of a dictionary that
        contains the following information about the Control Server for
        Process Management:

            - timestamp (str): string representation of the current datetime.

        Returns:
            - Dictionary with housekeeping data for the Control Server for
              Process Management.
        &#34;&#34;&#34;

        return {&#34;timestamp&#34;: format_datetime()}

    def quit(self):
        self.controller.quit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.ProcessManagerProtocol.get_bind_address"><code class="name flex">
<span>def <span class="ident">get_bind_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the address to bind a socket to.</p>
<p>This bind address is a properly formatted URL, based on the
communication protocol and the commanding port.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Properly formatted URL to bind a socket to.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bind_address(self):
    &#34;&#34;&#34;Returns the address to bind a socket to.

    This bind address is a properly formatted URL, based on the
    communication protocol and the commanding port.

    Returns:
        - Properly formatted URL to bind a socket to.
    &#34;&#34;&#34;

    return bind_address(
        self.control_server.get_communication_protocol(),
        self.control_server.get_commanding_port(),
    )</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerProtocol.get_housekeeping"><code class="name flex">
<span>def <span class="ident">get_housekeeping</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the housekeeping data for the Control Server.</p>
<p>This housekeeping data is returns in the form of a dictionary that
contains the following information about the Control Server for
Process Management:</p>
<pre><code>- timestamp (str): string representation of the current datetime.
</code></pre>
<h2 id="returns">Returns</h2>
<ul>
<li>Dictionary with housekeeping data for the Control Server for
Process Management.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_housekeeping(self) -&gt; dict:
    &#34;&#34;&#34;Returns the housekeeping data for the Control Server.

    This housekeeping data is returns in the form of a dictionary that
    contains the following information about the Control Server for
    Process Management:

        - timestamp (str): string representation of the current datetime.

    Returns:
        - Dictionary with housekeeping data for the Control Server for
          Process Management.
    &#34;&#34;&#34;

    return {&#34;timestamp&#34;: format_datetime()}</code></pre>
</details>
</dd>
<dt id="egse.procman.ProcessManagerProtocol.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the status information for the Control Server.</p>
<p>This status information is returned in the form of a dictionary that
contains the following information about the Control Server for
Process Management:</p>
<pre><code>- timestamp (str): string representation of the current datetime;
- PID (int): process ID for the Control Server;
- Up (float): uptime of the Control Server [s];
- UUID (uuid1): Universally Unique Identifier for the Control
                Server;
- RSS (int): 'Resident Set Size', this is the non-swapped physical
             memory a process has used [byte];
- USS (int): 'Unique Set Size', this is the memory which is unique
             to a process [byte];
- CPU User (float): time spent in user mode [s];
- CPU System (float): time spent in kernel mode [s];
- CPU count: number of CPU cores in use by the process;
- CPU% (float): process CPU utilization as a percentage [%].
</code></pre>
<h2 id="returns">Returns</h2>
<ul>
<li>Dictionary with status information for the Control Server for
Process Management.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self) -&gt; dict:
    &#34;&#34;&#34;Returns the status information for the Control Server.

    This status information is returned in the form of a dictionary that
    contains the following information about the Control Server for
    Process Management:

        - timestamp (str): string representation of the current datetime;
        - PID (int): process ID for the Control Server;
        - Up (float): uptime of the Control Server [s];
        - UUID (uuid1): Universally Unique Identifier for the Control
                        Server;
        - RSS (int): &#39;Resident Set Size&#39;, this is the non-swapped physical
                     memory a process has used [byte];
        - USS (int): &#39;Unique Set Size&#39;, this is the memory which is unique
                     to a process [byte];
        - CPU User (float): time spent in user mode [s];
        - CPU System (float): time spent in kernel mode [s];
        - CPU count: number of CPU cores in use by the process;
        - CPU% (float): process CPU utilization as a percentage [%].

    Returns:
        - Dictionary with status information for the Control Server for
          Process Management.
    &#34;&#34;&#34;

    return super().get_status()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.protocol.CommandProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.ProcessManagerProxy"><code class="flex name class">
<span>class <span class="ident">ProcessManagerProxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6200)</span>
</code></dt>
<dd>
<div class="desc"><p>Proxy for Process Managements, used to connect to the Process Manager
Control Server and send commands remotely.</p>
<p>Initialisation of a new Proxy for Process Management.</p>
<p>If no connection details (transport protocol, hostname, and port) are
not provided, these are taken from the settings file.</p>
<h2 id="args">Args</h2>
<ul>
<li>protocol: Transport protocol [default is taken from settings
file].</li>
<li>hostname: Location of the control server (IP address) [default
is taken from settings file].</li>
<li>port: TCP port on which the Control Server is listening for
commands [default is taken from settings file].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerProxy(Proxy, ProcessManagerInterface):

    &#34;&#34;&#34;
    Proxy for Process Managements, used to connect to the Process Manager
    Control Server and send commands remotely.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;Initialisation of a new Proxy for Process Management.

        If no connection details (transport protocol, hostname, and port) are
        not provided, these are taken from the settings file.

        Args:
            - protocol: Transport protocol [default is taken from settings
                        file].
            - hostname: Location of the control server (IP address) [default
                        is taken from settings file].
            - port: TCP port on which the Control Server is listening for
                    commands [default is taken from settings file].
        &#34;&#34;&#34;

        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.procman.ProcessManagerInterface" href="#egse.procman.ProcessManagerInterface">ProcessManagerInterface</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.procman.ProcessManagerInterface" href="#egse.procman.ProcessManagerInterface">ProcessManagerInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.procman.ProcessManagerInterface.get_cm_proxy" href="#egse.procman.ProcessManagerInterface.get_cm_proxy">get_cm_proxy</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.shut_down_egse" href="#egse.procman.ProcessManagerInterface.shut_down_egse">shut_down_egse</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_cs" href="#egse.procman.ProcessManagerInterface.start_cs">start_cs</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_egse" href="#egse.procman.ProcessManagerInterface.start_egse">start_egse</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_fitsgen" href="#egse.procman.ProcessManagerInterface.start_fitsgen">start_fitsgen</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_fov_hk" href="#egse.procman.ProcessManagerInterface.start_fov_hk">start_fov_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_n_fee_hk" href="#egse.procman.ProcessManagerInterface.start_n_fee_hk">start_n_fee_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_fitsgen" href="#egse.procman.ProcessManagerInterface.stop_fitsgen">stop_fitsgen</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_fov_hk" href="#egse.procman.ProcessManagerInterface.stop_fov_hk">stop_fov_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_n_fee_hk" href="#egse.procman.ProcessManagerInterface.stop_n_fee_hk">stop_n_fee_hk</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="../index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="egse.procman.procman_cs" href="procman_cs.html">egse.procman.procman_cs</a></code></li>
<li><code><a title="egse.procman.procman_ui" href="procman_ui.html">egse.procman.procman_ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.procman.is_process_manager_cs_active" href="#egse.procman.is_process_manager_cs_active">is_process_manager_cs_active</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.procman.ProcessManagerCommand" href="#egse.procman.ProcessManagerCommand">ProcessManagerCommand</a></code></h4>
</li>
<li>
<h4><code><a title="egse.procman.ProcessManagerController" href="#egse.procman.ProcessManagerController">ProcessManagerController</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.ProcessManagerController.get_core" href="#egse.procman.ProcessManagerController.get_core">get_core</a></code></li>
<li><code><a title="egse.procman.ProcessManagerController.get_devices" href="#egse.procman.ProcessManagerController.get_devices">get_devices</a></code></li>
<li><code><a title="egse.procman.ProcessManagerController.quit" href="#egse.procman.ProcessManagerController.quit">quit</a></code></li>
<li><code><a title="egse.procman.ProcessManagerController.shut_down_cs" href="#egse.procman.ProcessManagerController.shut_down_cs">shut_down_cs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.ProcessManagerInterface" href="#egse.procman.ProcessManagerInterface">ProcessManagerInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.procman.ProcessManagerInterface.get_cm_proxy" href="#egse.procman.ProcessManagerInterface.get_cm_proxy">get_cm_proxy</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.shut_down_egse" href="#egse.procman.ProcessManagerInterface.shut_down_egse">shut_down_egse</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_cs" href="#egse.procman.ProcessManagerInterface.start_cs">start_cs</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_egse" href="#egse.procman.ProcessManagerInterface.start_egse">start_egse</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_fitsgen" href="#egse.procman.ProcessManagerInterface.start_fitsgen">start_fitsgen</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_fov_hk" href="#egse.procman.ProcessManagerInterface.start_fov_hk">start_fov_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.start_n_fee_hk" href="#egse.procman.ProcessManagerInterface.start_n_fee_hk">start_n_fee_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_fitsgen" href="#egse.procman.ProcessManagerInterface.stop_fitsgen">stop_fitsgen</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_fov_hk" href="#egse.procman.ProcessManagerInterface.stop_fov_hk">stop_fov_hk</a></code></li>
<li><code><a title="egse.procman.ProcessManagerInterface.stop_n_fee_hk" href="#egse.procman.ProcessManagerInterface.stop_n_fee_hk">stop_n_fee_hk</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.ProcessManagerProtocol" href="#egse.procman.ProcessManagerProtocol">ProcessManagerProtocol</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.ProcessManagerProtocol.get_bind_address" href="#egse.procman.ProcessManagerProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.procman.ProcessManagerProtocol.get_housekeeping" href="#egse.procman.ProcessManagerProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.procman.ProcessManagerProtocol.get_status" href="#egse.procman.ProcessManagerProtocol.get_status">get_status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.ProcessManagerProxy" href="#egse.procman.ProcessManagerProxy">ProcessManagerProxy</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.procman.procman_cs API documentation</title>
<meta name="description" content="The Process Manager Control Server is the service that handles all Common-EGSE
processes.
The list of processes to handle, is taken from the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.procman.procman_cs</code></h1>
</header>
<section id="section-intro">
<p>The Process Manager Control Server is the service that handles all Common-EGSE
processes.
The list of processes to handle, is taken from the Configuration
Manager (from the setup).</p>
<p>The Process Manager Control Server is implemented as a standard control server.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Process Manager Control Server is the service that handles all Common-EGSE
processes.  The list of processes to handle, is taken from the Configuration
Manager (from the setup).

The Process Manager Control Server is implemented as a standard control server.
&#34;&#34;&#34;
import logging
import multiprocessing
import sys

import click
import zmq
from prometheus_client import start_http_server

from egse.control import ControlServer
from egse.procman import ProcessManagerProtocol
from egse.procman import ProcessManagerProxy
from egse.procman import is_process_manager_cs_active
from egse.settings import Settings

CTRL_SETTINGS = Settings.load(&#34;Process Manager Control Server&#34;)

logger = logging.getLogger(__name__)


class ProcessManagerControlServer(ControlServer):
    &#34;&#34;&#34;
    The Process Manager Control Server handles all Common-EGSE processes.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialisation of a new Control Server for Process Management.

        The initialisation of this Control Server consists of the following
        steps:

            - Define the device protocol;
            - Bind the command socket to the device protocol (to listen for
              commands);
            - Add the device protocol to the poller, to be able to listen for
              commands on different sockets in one thread.
        &#34;&#34;&#34;

        super().__init__()

        # Protocol used for commanding

        self.device_protocol = ProcessManagerProtocol(self)

        # Bind to a socket to listen for commands

        bind_address = self.device_protocol.get_bind_address()

        self.logger = logger
        self.logger.debug(f&#34;Binding ZeroMQ socket to {bind_address}&#34;)

        self.device_protocol.bind(self.dev_ctrl_cmd_sock)

        # Listen on different sockets in the same threads -&gt; poller

        self.poller.register(self.dev_ctrl_cmd_sock, zmq.POLLIN)

    def get_communication_protocol(self):
        &#34;&#34;&#34;Returns the communication protocol, as defined in the settings.

        Returns:
            - Communication protocol, as defined in the settings.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.PROTOCOL

    def get_commanding_port(self):
        &#34;&#34;&#34;Returns the commanding port number.

        The commanding port is the port on which the Controller listens for
        commands, using the REQ-REP (ZeroMQ) socket pattern.  Its number is
        read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for commands.
        &#34;&#34;&#34;

        return CTRL_SETTINGS.COMMANDING_PORT

    def get_service_port(self):
        &#34;&#34;&#34;Returns the service port number.

        The service port is the port on which the Controller listens for
        configuration and administration, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for
              configuration and administration.
        &#34;&#34;&#34;

        return CTRL_SETTINGS.SERVICE_PORT

    def get_monitoring_port(self):
        &#34;&#34;&#34;Returns the monitoring port number.

        The monitoring port is the port on which the Controller sends periodic
        information on the device, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller sends periodic status
              information on the device.
        &#34;&#34;&#34;

        return CTRL_SETTINGS.MONITORING_PORT

    def get_storage_mnemonic(self):
        &#34;&#34;&#34;Returns the storage mnemonic for the Controller.

        The storage mnemonic is used in the filename of the housekeeping of
        the Controller (as using by the Storage).  If this is not defined in
        the settings file, &#34;PM&#34; will be used instead.

        Returns:
            - Storage mnemonic for the Controller.
        &#34;&#34;&#34;

        try:

            # As defined in the settings file

            return CTRL_SETTINGS.STORAGE_MNEMONIC

        except AttributeError:

            # Default

            return &#34;PM&#34;

    def before_serve(self):
        start_http_server(CTRL_SETTINGS.METRICS_PORT)


@click.group()
def cli():
    pass


@cli.command()
def start():
    &#34;&#34;&#34;Start the Process Manager.&#34;&#34;&#34;

    multiprocessing.current_process().name = &#34;procman_cs&#34;

    # We import this class such that the class name is
    # &#39;egse.procman.procman_cs.ProcessManagerControlServer&#39; and we
    # can compare self with isinstance inside the Control.
    # If this import would not be done, the class name for the
    # ProcessManagerControlServer would be &#39;__main__.ProcessManagerControlServer&#39;.

    from egse.procman.procman_cs import ProcessManagerControlServer

    try:
        control_server = ProcessManagerControlServer()
        control_server.serve()
    except KeyboardInterrupt:
        print(&#34;Shutdown requested...exiting&#34;)
    except SystemExit as exit_code:
        print(&#34;System Exit with code {}.&#34;.format(exit_code))
        sys.exit(exit_code)
    except Exception:
        import traceback

        traceback.print_exc(file=sys.stdout)

    return 0


@cli.command()
def stop():
    &#34;&#34;&#34;Send a &#39;quit_server&#39; command to the Process Manager.&#34;&#34;&#34;
    with ProcessManagerProxy() as pm:
        sp = pm.get_service_proxy()
        sp.quit_server()


@cli.command()
def status():
    &#34;&#34;&#34;Send a &#39;quit_server&#39; command to the Process Manager.&#34;&#34;&#34;

    import rich
    rich.print(&#34;Process Manager:&#34;)
    if is_process_manager_cs_active():
        rich.print(f&#34;  Status: [green]active&#34;)
        with ProcessManagerProxy() as pm:
            rich.print(f&#34;  Hostname: {pm.get_ip_address()}&#34;)
            rich.print(f&#34;  Monitoring port: {pm.get_monitoring_port()}&#34;)
            rich.print(f&#34;  Commanding port: {pm.get_commanding_port()}&#34;)
            rich.print(f&#34;  Service port: {pm.get_service_port()}&#34;)
    else:
        rich.print(f&#34;  Status: [red]not active&#34;)


if __name__ == &#34;__main__&#34;:
    sys.exit(cli())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer"><code class="flex name class">
<span>class <span class="ident">ProcessManagerControlServer</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Process Manager Control Server handles all Common-EGSE processes.</p>
<p>Initialisation of a new Control Server for Process Management.</p>
<p>The initialisation of this Control Server consists of the following
steps:</p>
<pre><code>- Define the device protocol;
- Bind the command socket to the device protocol (to listen for
  commands);
- Add the device protocol to the poller, to be able to listen for
  commands on different sockets in one thread.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerControlServer(ControlServer):
    &#34;&#34;&#34;
    The Process Manager Control Server handles all Common-EGSE processes.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialisation of a new Control Server for Process Management.

        The initialisation of this Control Server consists of the following
        steps:

            - Define the device protocol;
            - Bind the command socket to the device protocol (to listen for
              commands);
            - Add the device protocol to the poller, to be able to listen for
              commands on different sockets in one thread.
        &#34;&#34;&#34;

        super().__init__()

        # Protocol used for commanding

        self.device_protocol = ProcessManagerProtocol(self)

        # Bind to a socket to listen for commands

        bind_address = self.device_protocol.get_bind_address()

        self.logger = logger
        self.logger.debug(f&#34;Binding ZeroMQ socket to {bind_address}&#34;)

        self.device_protocol.bind(self.dev_ctrl_cmd_sock)

        # Listen on different sockets in the same threads -&gt; poller

        self.poller.register(self.dev_ctrl_cmd_sock, zmq.POLLIN)

    def get_communication_protocol(self):
        &#34;&#34;&#34;Returns the communication protocol, as defined in the settings.

        Returns:
            - Communication protocol, as defined in the settings.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.PROTOCOL

    def get_commanding_port(self):
        &#34;&#34;&#34;Returns the commanding port number.

        The commanding port is the port on which the Controller listens for
        commands, using the REQ-REP (ZeroMQ) socket pattern.  Its number is
        read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for commands.
        &#34;&#34;&#34;

        return CTRL_SETTINGS.COMMANDING_PORT

    def get_service_port(self):
        &#34;&#34;&#34;Returns the service port number.

        The service port is the port on which the Controller listens for
        configuration and administration, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for
              configuration and administration.
        &#34;&#34;&#34;

        return CTRL_SETTINGS.SERVICE_PORT

    def get_monitoring_port(self):
        &#34;&#34;&#34;Returns the monitoring port number.

        The monitoring port is the port on which the Controller sends periodic
        information on the device, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller sends periodic status
              information on the device.
        &#34;&#34;&#34;

        return CTRL_SETTINGS.MONITORING_PORT

    def get_storage_mnemonic(self):
        &#34;&#34;&#34;Returns the storage mnemonic for the Controller.

        The storage mnemonic is used in the filename of the housekeeping of
        the Controller (as using by the Storage).  If this is not defined in
        the settings file, &#34;PM&#34; will be used instead.

        Returns:
            - Storage mnemonic for the Controller.
        &#34;&#34;&#34;

        try:

            # As defined in the settings file

            return CTRL_SETTINGS.STORAGE_MNEMONIC

        except AttributeError:

            # Default

            return &#34;PM&#34;

    def before_serve(self):
        start_http_server(CTRL_SETTINGS.METRICS_PORT)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer.before_serve"><code class="name flex">
<span>def <span class="ident">before_serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_serve(self):
    start_http_server(CTRL_SETTINGS.METRICS_PORT)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer.get_commanding_port"><code class="name flex">
<span>def <span class="ident">get_commanding_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the commanding port number.</p>
<p>The commanding port is the port on which the Controller listens for
commands, using the REQ-REP (ZeroMQ) socket pattern.
Its number is
read from the settings file.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Number of the port on which the Controller listens for commands.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_commanding_port(self):
    &#34;&#34;&#34;Returns the commanding port number.

    The commanding port is the port on which the Controller listens for
    commands, using the REQ-REP (ZeroMQ) socket pattern.  Its number is
    read from the settings file.

    Returns:
        - Number of the port on which the Controller listens for commands.
    &#34;&#34;&#34;

    return CTRL_SETTINGS.COMMANDING_PORT</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer.get_communication_protocol"><code class="name flex">
<span>def <span class="ident">get_communication_protocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the communication protocol, as defined in the settings.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Communication protocol, as defined in the settings.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_communication_protocol(self):
    &#34;&#34;&#34;Returns the communication protocol, as defined in the settings.

    Returns:
        - Communication protocol, as defined in the settings.
    &#34;&#34;&#34;
    return CTRL_SETTINGS.PROTOCOL</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer.get_monitoring_port"><code class="name flex">
<span>def <span class="ident">get_monitoring_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the monitoring port number.</p>
<p>The monitoring port is the port on which the Controller sends periodic
information on the device, using the PUB-SUB (ZeroMQ) socket
pattern.
Its number is read from the settings file.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Number of the port on which the Controller sends periodic status
information on the device.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_monitoring_port(self):
    &#34;&#34;&#34;Returns the monitoring port number.

    The monitoring port is the port on which the Controller sends periodic
    information on the device, using the PUB-SUB (ZeroMQ) socket
    pattern.  Its number is read from the settings file.

    Returns:
        - Number of the port on which the Controller sends periodic status
          information on the device.
    &#34;&#34;&#34;

    return CTRL_SETTINGS.MONITORING_PORT</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer.get_service_port"><code class="name flex">
<span>def <span class="ident">get_service_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the service port number.</p>
<p>The service port is the port on which the Controller listens for
configuration and administration, using the PUB-SUB (ZeroMQ) socket
pattern.
Its number is read from the settings file.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Number of the port on which the Controller listens for
configuration and administration.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_service_port(self):
    &#34;&#34;&#34;Returns the service port number.

    The service port is the port on which the Controller listens for
    configuration and administration, using the PUB-SUB (ZeroMQ) socket
    pattern.  Its number is read from the settings file.

    Returns:
        - Number of the port on which the Controller listens for
          configuration and administration.
    &#34;&#34;&#34;

    return CTRL_SETTINGS.SERVICE_PORT</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_cs.ProcessManagerControlServer.get_storage_mnemonic"><code class="name flex">
<span>def <span class="ident">get_storage_mnemonic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the storage mnemonic for the Controller.</p>
<p>The storage mnemonic is used in the filename of the housekeeping of
the Controller (as using by the Storage).
If this is not defined in
the settings file, "PM" will be used instead.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Storage mnemonic for the Controller.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storage_mnemonic(self):
    &#34;&#34;&#34;Returns the storage mnemonic for the Controller.

    The storage mnemonic is used in the filename of the housekeeping of
    the Controller (as using by the Storage).  If this is not defined in
    the settings file, &#34;PM&#34; will be used instead.

    Returns:
        - Storage mnemonic for the Controller.
    &#34;&#34;&#34;

    try:

        # As defined in the settings file

        return CTRL_SETTINGS.STORAGE_MNEMONIC

    except AttributeError:

        # Default

        return &#34;PM&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.control.ControlServer.register_to_storage_manager" href="../control.html#egse.control.ControlServer.register_to_storage_manager">register_to_storage_manager</a></code></li>
<li><code><a title="egse.control.ControlServer.set_delay" href="../control.html#egse.control.ControlServer.set_delay">set_delay</a></code></li>
<li><code><a title="egse.control.ControlServer.set_hk_delay" href="../control.html#egse.control.ControlServer.set_hk_delay">set_hk_delay</a></code></li>
<li><code><a title="egse.control.ControlServer.store_housekeeping_information" href="../control.html#egse.control.ControlServer.store_housekeeping_information">store_housekeeping_information</a></code></li>
<li><code><a title="egse.control.ControlServer.unregister_from_storage_manager" href="../control.html#egse.control.ControlServer.unregister_from_storage_manager">unregister_from_storage_manager</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.procman" href="index.html">egse.procman</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.procman.procman_cs.ProcessManagerControlServer" href="#egse.procman.procman_cs.ProcessManagerControlServer">ProcessManagerControlServer</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_cs.ProcessManagerControlServer.before_serve" href="#egse.procman.procman_cs.ProcessManagerControlServer.before_serve">before_serve</a></code></li>
<li><code><a title="egse.procman.procman_cs.ProcessManagerControlServer.get_commanding_port" href="#egse.procman.procman_cs.ProcessManagerControlServer.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.procman.procman_cs.ProcessManagerControlServer.get_communication_protocol" href="#egse.procman.procman_cs.ProcessManagerControlServer.get_communication_protocol">get_communication_protocol</a></code></li>
<li><code><a title="egse.procman.procman_cs.ProcessManagerControlServer.get_monitoring_port" href="#egse.procman.procman_cs.ProcessManagerControlServer.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.procman.procman_cs.ProcessManagerControlServer.get_service_port" href="#egse.procman.procman_cs.ProcessManagerControlServer.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.procman.procman_cs.ProcessManagerControlServer.get_storage_mnemonic" href="#egse.procman.procman_cs.ProcessManagerControlServer.get_storage_mnemonic">get_storage_mnemonic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.procman.procman_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.procman.procman_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
import logging
import multiprocessing
import pickle
import threading
from enum import Enum

import sys
import time
import zmq
from PyQt5.QtCore import QObject
from PyQt5.QtCore import QThread
from PyQt5.QtCore import Qt
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtGui import QCloseEvent
from PyQt5.QtWidgets import QApplication, QScrollArea
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QGridLayout
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QVBoxLayout
from prometheus_client import start_http_server

from egse.config import set_logger_levels
from egse.confman import ConfigurationManagerProxy
from egse.confman import is_configuration_manager_active
from egse.control import is_control_server_active
from egse.gui import show_info_message
from egse.gui.buttons import ToggleButton, TouchButton
from egse.gui.led import Indic
from egse.gui.led import LED
from egse.process import ProcessStatus
from egse.process import SubProcess
from egse.procman import ProcessManagerProxy
from egse.resource import get_resource
from egse.settings import Settings
from egse.system import do_every
from egse.system import find_class
from egse.zmq_ser import connect_address
from egse.zmq_ser import set_address_port

logging.basicConfig(level=logging.INFO, format=Settings.LOG_FORMAT_FULL)

GUI_SETTINGS = Settings.load(&#34;PM GUI&#34;)
LOGGER = logging.getLogger(__name__)


class FILE_GENERATION_PROCESS_NAMES(str, Enum):

    FITSGEN = &#34;FITS generation&#34;
    FOV_HK = &#34;FOV HK&#34;
    N_FEE_HK = &#34;N-FEE HK&#34;


class ConfigurationMonitoringWorker(QObject):

    # The thread will send a signal with the monitoring information:
    #   - The obsid;
    #   - The setup that has been loaded by the configuration manager.

    setup_changed_signal = pyqtSignal(dict)
    obsid_changed_signal = pyqtSignal(object)   # This allows ObservationIdentifier or None to be returned

    def __init__(self):

        &#34;&#34;&#34; Initialisation of a monitoring thread.

        This monitoring thread will listen on the monitoring port of the
        Control Server.  At this point the socket (that will connect to the
        monitoring port) is not created yet.
        &#34;&#34;&#34;

        super(ConfigurationMonitoringWorker, self).__init__()

        self.setup = None   # Previous setup
        self.obsid = None   # Previous obsid
        self.active = False

        self.connect_socket()

    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.

        Args:
            - proxy_type: Proxy type (needed to read the connection details).
        &#34;&#34;&#34;

        # Start listening to the monitoring port

        self.socket = zmq.Context().socket(zmq.SUB)

        cm = ConfigurationManagerProxy()
        endpoint = cm.get_endpoint()
        monitoring_port = cm.get_monitoring_port()
        address = set_address_port(endpoint, monitoring_port)

        self.socket.connect(address)
        self.socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.
        &#34;&#34;&#34;

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port.

        If monitoring information is received before the timeout, it is
        checked whether the obsid and/or current setup have changed.  If so, a
        signal with the monitoring information is emitted.
        &#34;&#34;&#34;

        self.active = True

        while self.active:

            pickle_string = self.socket.recv()
            monitoring_info = pickle.loads(pickle_string)

            new_setup = monitoring_info[&#34;setup&#34;]  # New setup

            # The setup has changed

            if new_setup != self.setup:

                self.setup = new_setup

                # Emit the setup ID

                self.setup_changed_signal.emit(self.setup)

            new_obsid = monitoring_info[&#34;obsid&#34;]    # New obsid

            if new_obsid != self.obsid:

                self.obsid = new_obsid

                # Emit the obsid

                self.obsid_changed_signal.emit(self.obsid)

    def has_setup(self):
        &#34;&#34;&#34; Check whether a setup has been loaded.

        Returns: True if a setup has been loaded; False otherwise.
        &#34;&#34;&#34;

        return self.setup is not None


class MonitoringWorker(QObject):
    &#34;&#34;&#34; Worker for monitoring the status of an EGSE process.&#34;&#34;&#34;

    # The worker will send a signal with the following information:
    #   - process name
    #   - colour of the led (in the process widget)
    #   - in case of a running device process: whether or not it is running in simulator mode

    process_status_signal = pyqtSignal(dict)

    def __init__(self, process_name, process_info):
        &#34;&#34;&#34; Initialisation of a monitoring worker.

        This monitoring worker will listen on the monitoring port of the Control Server.

        Args:
            - process_name: Name of the process.
            - proxy_type: Proxy type (needed to read the connection details).
        &#34;&#34;&#34;

        super(MonitoringWorker, self).__init__()

        self.active = False
        self.start_stop_cs_button_clicked = False

        self.process_name = process_name
        self.proxy_type = process_info[0]
        self.device_args = process_info[1]

        self.monitoring_socket = None
        self.monitoring_timeout = 0.5  # [s]
        self.is_socket_connected = False

        self.commanding_address = None
        self.connect_socket()

        self.previous_state = -1

    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.&#34;&#34;&#34;

        try:

            module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
            module = importlib.import_module(module_name)

            # Ctrl settings:
            #   - transport protocol
            #   - hostname
            #   - commanding port (to check whether the CS is active)
            #   - monitoring port (to ask for process information)

            ctrl_settings = module.CTRL_SETTINGS

            transport = ctrl_settings.PROTOCOL
            hostname = ctrl_settings.HOSTNAME

            if module_name == &#34;egse.aeu.aeu&#34; or &#34;egse.tempcontrol.agilent.agilent3497&#34; in module_name:

                name = self.process_name.split(&#34; &#34;)[1].upper()

                commanding_port = ctrl_settings[name][&#34;COMMANDING_PORT&#34;]
                monitoring_port = ctrl_settings[name][&#34;MONITORING_PORT&#34;]

            elif module_name == &#34;egse.powermeter.ni.cdaq9184&#34;:
                commanding_port = ctrl_settings.CDAQ9184[&#34;COMMANDING_PORT&#34;]
                monitoring_port = ctrl_settings.CDAQ9184[&#34;MONITORING_PORT&#34;]

            else:
                commanding_port = ctrl_settings.COMMANDING_PORT
                monitoring_port = ctrl_settings.MONITORING_PORT

            # Create a socket and connect to the monitoring port

            monitoring_address = connect_address(transport, hostname, monitoring_port)
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

            # Address of the commanding port
            # This is needed when checking whether or not the CS is active

            self.commanding_address = connect_address(transport, hostname, commanding_port)

            self.is_socket_connected = True

        except AttributeError:

            self.is_socket_connected = False

    def stop(self):

        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;

        self.is_socket_connected = False
        self.monitoring_socket.close()

        # self.monitoring_socket.disconnect(self.monitoring_address)
        # self.monitoring_socket.close(linger=0)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.

        If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
        to notify the GUI.
        &#34;&#34;&#34;

        if not is_control_server_active(self.commanding_address, 0.5):

            # Emit a signal, indicating the CS is not running

            process_status = {&#34;Name&#34;: self.process_name, &#34;Color&#34;: Indic.RED}
            self.previous_state = Indic.RED

            self.process_status_signal.emit(process_status)

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port.

        If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
        Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
        process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
        0.5s).
        &#34;&#34;&#34;

        self.active = True

        while self.is_socket_connected and self.active:

            process_status = {&#34;Name&#34;: self.process_name}

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Update the timeout, to be more in line with the monitoring
                    # frequency of the CS (i.e. the delay).  Take 0.5s extra to be
                    # on the safe side.

                    self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                    # Running core CS

                    if self.process_name in [&#34;Logger&#34;, &#34;Storage&#34;, &#34;Configuration Manager&#34;, &#34;Process Manager&#34;,
                                             &#34;Synoptics Manager&#34;]:
                        process_status[&#34;Color&#34;] = Indic.GREEN

                    # Running device CS

                    else:
                        process_status[&#34;Color&#34;], process_status[&#34;Simulator&#34;] = self.get_device_process_status()

                    if self.previous_state != process_status[&#34;Color&#34;]:

                        self.process_status_signal.emit(process_status)
                        self.previous_state = process_status[&#34;Color&#34;]

            except zmq.ZMQError:
                pass

            # Timeout occurred

            else:

                # The CS is not active

                if not is_control_server_active(endpoint=self.commanding_address, timeout=10):

                    process_status[&#34;Color&#34;] = Indic.RED

                    if self.previous_state != process_status[&#34;Color&#34;]:

                        self.process_status_signal.emit(process_status)
                        self.previous_state = process_status[&#34;Color&#34;]

                    elif self.start_stop_cs_button_clicked:

                        self.process_status_signal.emit(process_status)
                        self.previous_state = process_status[&#34;Color&#34;]
                        self.start_stop_cs_button_clicked = False

                # The CS is active, but the timeout was too strict

                else:
                    self.monitoring_timeout += 0.5

    def get_device_process_status(self):
        &#34;&#34;&#34; Determine the status of the device Control Server.

        Returns:
            - color: Colour of the led light (to use in the process widget).
            - is_simulator: Whether or not the Control Server is running in simulator mode.
        &#34;&#34;&#34;

        color = Indic.BLACK
        is_simulator = False

        # Core process -&gt; green

        try:

            with find_class(self.proxy_type)(*self.device_args) as process_proxy:

                try:

                    # CS connected to Controller -&gt; green

                    if process_proxy.is_connected():
                        color = Indic.GREEN

                    # CS not connected to Controller -&gt; orange

                    else:
                        color = Indic.ORANGE

                except AttributeError:
                    color = Indic.GREEN

                is_simulator = process_proxy.is_simulator()

        except ConnectionError:
            pass

        return color, is_simulator


class ProcessMonitoringWorker(QObject):
    &#34;&#34;&#34; Worker for monitoring the status of a process.&#34;&#34;&#34;

    is_running_signal = pyqtSignal(bool)

    def __init__(self, module):
        &#34;&#34;&#34; Worker for monitoring the status of a process.

        Args:
            - module
        &#34;&#34;&#34;

        super(ProcessMonitoringWorker, self).__init__()

        self.active = False
        self.start_stop_cs_button_clicked = False

        self.was_running_before = None

        self.module = importlib.import_module(module)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.

        If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
        to notify the GUI.
        &#34;&#34;&#34;

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on asking for the status of the status of the process.

        Every 5s, ask for the status of the process.  If this changes w.r.t. of they way it was before, a signal is
        emitted with the current status.
        &#34;&#34;&#34;

        self.active = True
        last_time = time.time()

        while self.active:

            if time.time() - last_time &gt;= 5:

                is_running = self.module.send_request(&#34;status&#34;).get(&#34;status&#34;) == &#34;ACK&#34;

                if is_running != self.was_running_before:
                    self.was_running_before = is_running
                    self.is_running_signal.emit(is_running)

                elif self.start_stop_cs_button_clicked:

                    for index in range(15):

                        # Check (max 15x) to see whether pressing the button had an effect

                        is_running = self.module.send_request(&#34;status&#34;).get(&#34;status&#34;) == &#34;ACK&#34;
                        if self.was_running_before != is_running:
                            break
                        time.sleep(2)

                        self.was_running_before = is_running
                        self.start_stop_cs_button_clicked = False
                        self.is_running_signal.emit(is_running)

                last_time = time.time()

            else:
                time.sleep(0.1)


class ProcessWidget(QGroupBox):

    def __init__(self, process_name, process_info, parent, include_start_stop_button=True):
        &#34;&#34;&#34; Initialisation of a process widget.

        For a Control Server with the given process name and Proxy type, a process widget is created.  This widget will
        comprise the following components:

            - status LED;
            - process name;
            - button to start the GUI for the Control Server (if this has been
              configured in the YAML file with the &#34;UserInterface&#34; entry);
            - button to start / shut down the Control Server (for devices only).

        Args:
            - process_name: Name of the process (to display on the widget).
            - proxy_type: Type of Proxy (to check the status of the process).
        &#34;&#34;&#34;

        super().__init__()

        self.process_name = process_name
        self.proxy_type = process_info[0]
        self.device_args = process_info[1]
        self.is_simulator_mode = False

        self.parent = parent

        layout = QGridLayout()

        index = 0

        # Status LED

        self.status_led = LED(parent=self)
        layout.addWidget(self.status_led, 0, index)
        index += 1

        # Process name

        self.process_name_label = QLabel(process_name)
        layout.addWidget(self.process_name_label, 0, index)
        layout.setColumnStretch(index, 1)   # Push LED and name to the left and buttons to the right
        index += 1

        # Fire up (default) GUI

        self.show_gui_button = TouchButton(name=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                           status_tip=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                           selected=get_resource(&#34;:/icons/user-interface.svg&#34;)
                                           )
        self.show_gui_button.setFixedSize(30, 30)
        self.show_gui_button.clicked.connect(self.start_gui)

        module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
        module = importlib.import_module(module_name)

        if not process_name.startswith(&#34;AEU&#34;) or process_name == &#34;AEU cRIO&#34;:

            if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;UserInterface&#34;):
                layout.addWidget(self.show_gui_button, 0, index)
            elif hasattr(module, &#34;COMMAND_SETTINGS&#34;) and hasattr(module.COMMAND_SETTINGS, &#34;UserInterface&#34;):
                layout.addWidget(self.show_gui_button, 0, index)

        index += 1

        # Shut down / re-start

        if include_start_stop_button:

            self.start_stop_button = ToggleButton(name=f&#34;Start / shut down the {self.process_name} control server.&#34;,
                                                  status_tip=f&#34;Start / shut down the {self.process_name} control server.&#34;,
                                                  selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                                  not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                                  disabled=[get_resource(&#34;:/icons/busy.svg&#34;),
                                                            get_resource(&#34;:/icons/busy.svg&#34;)]
                                                  )
            self.start_stop_button.clicked.connect(self.start_stop_cs)

            layout.addWidget(self.start_stop_button, 0, index)
            index += 1

            self.sim_option_button = ToggleButton(name=f&#34;Operational vs. simulator mode&#34;,
                                                  status_tip=f&#34;Indicate whether you want to start the &#34;
                                                             f&#34;{self.process_name} Control Server in operational or in &#34;
                                                             f&#34;simulator mode.&#34;,
                                                  selected=get_resource(&#34;:/icons/sim-mode.svg&#34;),
                                                  not_selected=get_resource(&#34;:/icons/ops-mode.svg&#34;),
                                                  disabled=[get_resource(&#34;:/icons/sim-mode.svg&#34;),
                                                            get_resource(&#34;:/icons/ops-mode.svg&#34;)]
                                                  )
            self.sim_option_button.set_selected(False)  # Default: operational mode
            self.sim_option_button.clicked.connect(self.set_cs_start_mode)

            if self.process_name == &#34;DAQ&#34;:

                self.start_stop_button.setToolTip(f&#34;Start / shut down the {self.process_name} control server and its &#34;
                                                  f&#34;data acquisition.&#34;)
                self.sim_option_button.setEnabled(False)    # Only in operational mode
                self.sim_option_button.setStatusTip(f&#34;The {self.process_name} and its data acquisition can only be&#34;
                                                    f&#34;started in operational mode.&#34;)

            if self.process_name == &#34;DPU&#34;:

                self.sim_option_button.setEnabled(False)    # Only in operational mode

            layout.addWidget(self.sim_option_button, 0, index)
            index += 1

        self.setLayout(layout)

    def start_gui(self):
        &#34;&#34;&#34; Starting the default GUI for the process.&#34;&#34;&#34;

        LOGGER.debug(f&#34;Starting GUI for {self.process_name}&#34;)

        module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
        module = importlib.import_module(module_name)

        if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;UserInterface&#34;):
            gui_type = module.DEVICE_SETTINGS.UserInterface     # Device CS
        elif hasattr(module, &#34;COMMAND_SETTINGS&#34;) and hasattr(module.COMMAND_SETTINGS, &#34;UserInterface&#34;):
            gui_type = module.COMMAND_SETTINGS.UserInterface    # Core CS
        else:   # No GUI defined in the YAML file of the CS
            LOGGER.debug(f&#34;No GUI available for {self.process_name}&#34;)
            return

        gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, gui_type])
        gui_process.execute(detach_from_parent=True)

    def set_cs_start_mode(self):
        &#34;&#34;&#34; Change the start mode for the Control Server.

        Change the start mode for the Control Server from simulator mode to operational mode, or vice versa.
        &#34;&#34;&#34;
        self.is_simulator_mode = not self.is_simulator_mode

    def start_stop_cs(self):
        &#34;&#34;&#34; Start or shut down the Control Server.

        Depending on the current state of the Control Server, it will either be started or shut down.
        &#34;&#34;&#34;

        self.sim_option_button.setEnabled(False)
        self.start_stop_button.setDisabled(True)

        if self.start_stop_button.is_selected():

            LOGGER.info(f&#34;Shut down the {self.process_name} Control Server&#34;)
            thread = threading.Thread(target=self.stop_cs)

        else:

            LOGGER.info(f&#34;Start the {self.process_name} Control Server&#34;)
            thread = threading.Thread(target=self.start_cs)

        thread.daemon = True
        thread.start()

        # Let the main UI window know that the start/stop button has been clicked
        self.parent.on_start_stop_cs_button_clicked(self.process_name)

    def start_cs(self):

        try:

            with ProcessManagerProxy() as pm:

                try:
                    pm.start_cs(self.process_name, self.is_simulator_mode)
                    self.sim_option_button.setDisabled(True)

                except ConnectionError:
                    LOGGER.info(f&#34;Could not start Control Server for {self.process_name}&#34;)
                    self.sim_option_button.setEnabled(True)

        except ConnectionError:

            LOGGER.critical(f&#34;Lost connection to Process Manager&#34;)

            self.sim_option_button.setEnabled(True)
            self.start_stop_button.setEnabled(True)
            self.start_stop_button.set_selected(True)

    def stop_cs(self):

        try:
            with ProcessManagerProxy() as pm:
                LOGGER.info(f&#34;PM: shut down {self.process_name}&#34;)
                pm.shut_down_cs(self.process_name)
                self.sim_option_button.setDisabled(False)

        except ConnectionError:

            LOGGER.critical(f&#34;Lost connection to Process Manager&#34;)
            self.sim_option_button.setEnabled(True)

    def set_led_color(self, color: int):
        &#34;&#34;&#34; Set the colour of the LED, representing the status of the process.

        The meaning of the colours is the following:

                - green:
                    - core process with running Control Server;
                    - device process in simulator mode with running Control Server;
                    - device process in operational mode with running Control Server and connection to the Controller;
                - orange: device process in operational mode with Control Server running but without connection to the
                  Controller;
                - red: no Control Server running.

        Args:
            - color: Integer representing the colour to indicate the process status.  Should only be Indic.GREEN,
                     Indic.ORANGE, or Indic.RED.
        &#34;&#34;&#34;

        self.status_led.set_color(color)

        try:
            self.start_stop_button.setDisabled(False)
        except AttributeError:
            # Core processes don&#39;t have this button
            pass

        if color != Indic.RED:
            try:
                self.sim_option_button.setEnabled(False)
                self.start_stop_button.set_selected(False)
            except AttributeError:
                # Core processes don&#39;t have this button
                pass

        else:
            try:
                self.sim_option_button.setEnabled(True)
                self.start_stop_button.set_selected(True)
            except AttributeError:
                # Core processes don&#39;t have this button
                pass

    def is_simulator_mode(self):
        &#34;&#34;&#34; Check whether the simulator mode checkbox was checked.

        Returns: True of the simulator mode checkbox was checked; False otherwise.
        &#34;&#34;&#34;

        return self.sim_option_button.is_selected()


class NonCSProcessWidget(QGroupBox):

    def __init__(self, process_name, parent, include_gui_button=True, include_start_stop_button=True):
        &#34;&#34;&#34; Initialisation of a process widget.

        For a Control Server with the given process name and Proxy type, a process widget is created.  This widget will
        comprise the following components:

            - status LED;
            - process name;
            - button to start the GUI for the process;
            - button to start / shut down the process.

        Args:
            - process_name: Name of the process (to display on the widget).
        &#34;&#34;&#34;

        super().__init__()

        self.process_name = process_name
        self.parent = parent

        layout = QGridLayout()

        index = 0

        # Status LED

        self.status_led = LED(parent=self)
        layout.addWidget(self.status_led, 0, index)
        index += 1

        # Process name

        self.process_name_label = QLabel(process_name)
        layout.addWidget(self.process_name_label, 0, index)
        layout.setColumnStretch(index, 1)  # Push LED and name to the left and buttons to the right
        index += 1

        # Fire up (default) GUI

        if include_gui_button:

            self.show_gui_button = TouchButton(name=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                               status_tip=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                               selected=get_resource(&#34;:/icons/user-interface.svg&#34;)
                                               )
            self.show_gui_button.setFixedSize(30, 30)
            layout.addWidget(self.show_gui_button, 0, index)
            self.show_gui_button.clicked.connect(self.start_gui)

            index += 1

        # Shut down / re-start

        if include_start_stop_button:

            self.start_stop_button = ToggleButton(name=f&#34;Start / shut down the {self.process_name}.&#34;,
                                                  status_tip=f&#34;Start / shut down the {self.process_name}.&#34;,
                                                  selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                                  not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                                  disabled=[get_resource(&#34;:/icons/busy.svg&#34;),
                                                            get_resource(&#34;:/icons/busy.svg&#34;)]
                                                  )
            self.start_stop_button.clicked.connect(self.start_stop_service)
            layout.addWidget(self.start_stop_button, 0, index)
            index += 1

        self.setLayout(layout)

    def start_stop_service(self):

        self.start_stop_button.setDisabled(True)

        if self.start_stop_button.is_selected():

            print(f&#34;Stopping {self.process_name}&#34;)
            LOGGER.info(f&#34;Shut down the {self.process_name}&#34;)
            thread = threading.Thread(target=self.stop_service)

        else:

            print(f&#34;Starting {self.process_name}&#34;)
            LOGGER.info(f&#34;Start the {self.process_name}&#34;)
            thread = threading.Thread(target=self.start_service)

        thread.daemon = True
        thread.start()

        self.parent.on_start_stop_non_cs_process_button_clicked(self.process_name)

    # def start_gui(self):
    #     &#34;&#34;&#34; Starting the default GUI for the process.&#34;&#34;&#34;
    #
    #     LOGGER.debug(f&#34;Starting GUI for {self.process_name}&#34;)
    #     print(&#34;Starting GUI&#34;)

    def set_led_color(self, color: int):
        &#34;&#34;&#34; Set the colour of the LED, representing the status of the process.

        The meaning of the colours is the following:

            - green: process running;
            - red: process not running.

        Args:
            - color: Integer representing the colour to indicate the process status.  Should only be Indic.GREEN,
                     or Indic.RED.
        &#34;&#34;&#34;

        self.status_led.set_color(color)

        try:
            self.start_stop_button.setDisabled(False)
            self.start_stop_button.set_selected(color == Indic.RED)
        except AttributeError:
            # The logger doesn&#39;t have a start/stop button
            pass


class LogWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super().__init__(&#34;Logger&#34;, parent, include_gui_button=True, include_start_stop_button=False)

    def start_gui(self):

        gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;cutelog&#34;])
        gui_process.execute(detach_from_parent=True)


class FitsgenWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super(FitsgenWidget, self).__init__(FILE_GENERATION_PROCESS_NAMES.FITSGEN, parent, include_gui_button=True,
                                            include_start_stop_button=True)

    def start_gui(self):

        gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen_ui&#34;])
        gui_process.execute(detach_from_parent=True)

    def start_service(self):

        start_fitsgen()

    def stop_service(self):

        stop_fitsgen()


class FovHkWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super(FovHkWidget, self).__init__(FILE_GENERATION_PROCESS_NAMES.FOV_HK, parent, include_gui_button=False,
                                          include_start_stop_button=True)

    def start_service(self):

        start_fov_hk()

    def stop_service(self):

        stop_fov_hk()


class NFeeHkWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super(NFeeHkWidget, self).__init__(FILE_GENERATION_PROCESS_NAMES.N_FEE_HK, parent, include_gui_button=False,
                                           include_start_stop_button=True)

    def start_service(self):

        start_n_fee_hk()

    def stop_service(self):

        stop_n_fee_hk()


def start_fitsgen():
    &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_fitsgen()


def stop_fitsgen():
    &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.stop_fitsgen()


def start_fov_hk():
    &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_fov_hk()


def stop_fov_hk():
    &#34;&#34;&#34; Stop the generation of FOV HK&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.stop_fov_hk()


def start_n_fee_hk():
    &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_n_fee_hk()


def stop_n_fee_hk():
    &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.stop_n_fee_hk()


def start_egse():
    &#34;&#34;&#34; Start all device Control Servers in one go.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_egse()


def stop_egse():
    &#34;&#34;&#34; Stop all device Control Servers in one go.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.shut_down_egse()


class ProcessManagerUIView(QMainWindow):

    def __init__(self):
        &#34;&#34;&#34; Initialisation of the Process Manager GUI.

        The components are placed in the window and threads are created for all processes, to be able to check for
        updates in the process status (in the background) and display these in the GUI.
        &#34;&#34;&#34;

        super().__init__()

        self.setGeometry(300, 300, 150, 1000)
        self.setWindowTitle(&#34;Process Manager&#34;)

        self.processes = {}
        self.devices = {}

        try:

            with ProcessManagerProxy() as process_manager_proxy:

                self.core = process_manager_proxy.get_core()        # Core

        except ConnectionError:

            self.core = {}

        self.monitoring_threads = {}
        self.monitoring_workers = {}

        self.process_widgets = {}

        self.process_widgets_core = {}

        self.setup_monitoring_thread = QThread(self)
        self.setup_monitoring_worker = ConfigurationMonitoringWorker()
        self.setup_monitoring_worker.moveToThread(self.setup_monitoring_thread)

        # What to do when information has been received on the monitoring
        # port before timeout?

        self.setup_monitoring_worker.setup_changed_signal.connect(self.on_setup_changed_signal)
        self.setup_monitoring_worker.obsid_changed_signal.connect(self.on_obsid_changed_signal)
        self.setup_monitoring_thread.started.connect(self.setup_monitoring_worker.start_process)
        self.setup_monitoring_thread.start()

        # Build up the GUI

        self.init_ui()

        # Keep an eye on the logger

        self.logger_monitoring_thread = QThread(self)
        self.logger_monitoring_worker = ProcessMonitoringWorker(&#34;egse.logger.log_cs&#34;)
        self.logger_monitoring_worker.moveToThread(self.logger_monitoring_thread)
        self.logger_monitoring_worker.is_running_signal.connect(self.on_logger_is_running_signal)
        self.logger_monitoring_thread.started.connect(self.logger_monitoring_worker.start_process)
        self.logger_monitoring_thread.start()

        # Keep an eye on the FITS generation

        self.fitsgen_monitoring_thread = QThread(self)
        self.fitsgen_monitoring_worker = ProcessMonitoringWorker(&#34;egse.dpu.fitsgen&#34;)
        self.fitsgen_monitoring_worker.moveToThread(self.fitsgen_monitoring_thread)
        self.fitsgen_monitoring_worker.is_running_signal.connect(self.on_fitsgen_is_running_signal)
        self.fitsgen_monitoring_thread.started.connect(self.fitsgen_monitoring_worker.start_process)
        self.fitsgen_monitoring_thread.start()

        # Keep an eye on the generation of FOV HK

        self.fov_hk_monitoring_thread = QThread(self)
        self.fov_hk_monitoring_worker = ProcessMonitoringWorker(&#34;egse.fov.fov_hk&#34;)
        self.fov_hk_monitoring_worker.moveToThread(self.fov_hk_monitoring_thread)
        self.fov_hk_monitoring_worker.is_running_signal.connect(self.on_fov_hk_is_running_signal)
        self.fov_hk_monitoring_thread.started.connect(self.fov_hk_monitoring_worker.start_process)
        self.fov_hk_monitoring_thread.start()

        # Keep an eye on the generation of N-FEE HK

        self.n_fee_hk_monitoring_thread = QThread(self)
        self.n_fee_hk_monitoring_worker = ProcessMonitoringWorker(&#34;egse.fee.n_fee_hk&#34;)
        self.n_fee_hk_monitoring_worker.moveToThread(self.n_fee_hk_monitoring_thread)
        self.n_fee_hk_monitoring_worker.is_running_signal.connect(self.on_n_fee_hk_is_running_signal)
        self.n_fee_hk_monitoring_thread.started.connect(self.n_fee_hk_monitoring_worker.start_process)
        self.n_fee_hk_monitoring_thread.start()

        self.file_generation_monitoring_workers = {
            FILE_GENERATION_PROCESS_NAMES.FITSGEN: self.fitsgen_monitoring_worker,
            FILE_GENERATION_PROCESS_NAMES.FOV_HK: self.fov_hk_monitoring_worker,
            FILE_GENERATION_PROCESS_NAMES.N_FEE_HK: self.n_fee_hk_monitoring_worker
        }

    def init_ui(self):
        &#34;&#34;&#34; Put the components in the GUI window.

        The GUI comprises the following components:

            - the toolbar;
            - on the left-hand side: one process widget per process;
            - on the right-hand side: one tab per process.
        &#34;&#34;&#34;

        # Creating the content

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        self.create_toolbar()
        self.create_statusbar()

        layout = QHBoxLayout()
        vbox = QVBoxLayout()

        # Obsid

        self.obsid = QLabel(&#34;No observation is running&#34;)
        self.setStyleSheet(&#39;QMainWindow{border: 3px solid green;}&#39;)
        vbox.addWidget(self.obsid)
        vbox.addWidget(QLabel())

        # Left-hand side: one process widget per process

        widget_frame = QFrame()

        self.overview_widget_devices_layout = QVBoxLayout()
        self.overview_widget_devices_layout.addStretch()
        self.overview_widget_devices = QGroupBox(&#34;Devices&#34;, self)
        self.overview_widget_devices.setLayout(self.overview_widget_devices_layout)
        self.overview_widget_devices.setToolTip(
            &#34;EGSE device processes:\n&#34; +
            &#34;can be started in this GUI or on the command line.&#34;)

        self.create_overview_widget_core()
        vbox.addWidget(self.overview_widget_core)

        self.create_overview_widget_file_services()
        vbox.addWidget(self.overview_widget_file_services)

        vbox.addWidget(self.overview_widget_devices)

        widget_frame.setLayout(vbox)
        # layout.addWidget(widget_frame)

        scroll = QScrollArea()
        scroll.setWidget(widget_frame)
        scroll.setWidgetResizable(True)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        # scroll.setFixedHeight(400)
        scroll.setFixedWidth(550)
        layout.addWidget(scroll)

        app_frame.setLayout(layout)

        self.setCentralWidget(app_frame)

    def start_monitoring(self) -&gt; object:
        &#34;&#34;&#34; Start listening on the monitoring port.

        Create and start a thread that listens on the monitoring port in the background.  If information is received
        before timeout, the Control Server is running: the light in the process tab should be set to green or orange,
        and the process information should be updated in the process tab.
        &#34;&#34;&#34;

        for process_name, process_info in self.processes.items():

            self.monitoring_threads[process_name] = QThread()

            self.monitoring_workers[process_name] = MonitoringWorker(process_name, process_info)
            self.monitoring_workers[process_name].moveToThread(self.monitoring_threads[process_name])

            # What to do when information has been sent back from the process thread?

            self.monitoring_workers[process_name].process_status_signal.connect(self.on_process_status_signal)

            self.monitoring_threads[process_name].started.connect(
                self.monitoring_workers[process_name].start_process)

            self.monitoring_threads[process_name].start()

    def on_setup_changed_signal(self, setup):
        &#34;&#34;&#34; Re-build the GUI after a change in setup.

        Args:
            - setup: New setup.
        &#34;&#34;&#34;

        # self.all_aeu_cs_button.disable()
        # self.start_aeu_button.setDisabled(True)
        # self.stop_aeu_button.setDisabled(True)

        # Stop all workers and threads

        for process_name in self.processes.keys():

            self.monitoring_workers[process_name].process_status_signal.disconnect()

            self.monitoring_workers[process_name].stop()
            self.monitoring_threads[process_name].quit()
            self.monitoring_threads[process_name].wait()

        self.monitoring_workers.clear()
        self.monitoring_threads.clear()

        # Make process list

        self.processes.clear()
        self.core.clear()
        self.devices.clear()

        self.start_aeu_button.setVisible(False)
        self.stop_aeu_button.setVisible(False)

        # Remove the widgets from the layouts

        while self.overview_widget_devices_layout.count():

            widget = self.overview_widget_devices_layout.takeAt(0).widget()

            if widget is not None:
                widget.deleteLater()

        self.process_widgets.clear()

        # Re-build the process list

        try:

            with ProcessManagerProxy() as process_manager_proxy:

                self.core = process_manager_proxy.get_core()
                self.devices = process_manager_proxy.get_devices()

                self.processes.update(self.core)
                self.processes.update(self.devices)

        except ConnectionError:

            self.core = {}
            self.devices = {}

        # Make new process widgets

        for process_name in self.devices.keys():

            process_widget = ProcessWidget(process_name, self.devices[process_name], self)

            self.process_widgets[process_name] = process_widget

            self.overview_widget_devices_layout.addWidget(process_widget)

        self.process_widgets.update(self.process_widgets_core)

        # Make sure the boxes stay nicely together when vertically resizing

        self.overview_widget_devices_layout.addStretch()

        # Start monitoring the process status

        self.start_monitoring()

        if &#34;AEU cRIO&#34; in self.devices.keys():

            # self.all_aeu_cs_button.set_selected(False)
            # self.all_aeu_cs_button.enable()
            self.start_aeu_button.setEnabled(True)
            self.stop_aeu_button.setEnabled(True)

        else:

            # self.all_aeu_cs_button.set_selected(False)
            # self.all_aeu_cs_button.disable()
            self.start_aeu_button.setEnabled(False)
            self.stop_aeu_button.setEnabled(False)

    def on_obsid_changed_signal(self, obsid):
        &#34;&#34;&#34; Update the GUI for the new obsid.

        Args:
            - obsid: The new obsid.
        &#34;&#34;&#34;

        if obsid is None:

            self.obsid.setText(&#34;No observation is running&#34;)
            self.setStyleSheet(&#39;QMainWindow{border: 3px solid green;}&#39;)

        else:

            self.obsid.setText(f&#34;Observation {obsid} is running&#34;)
            self.setStyleSheet(&#39;QMainWindow{border: 3px solid red;}&#39;)

    def on_process_status_signal(self, process_info):
        &#34;&#34;&#34; Update the GUI for the process with the given name.

        This method is called to update the GUI for the process with the given name in case the Control Server is
        running:

            - the colour of the light in the process widget is set to green or orange;
            - the process information is updated in the tab.

        The meaning of the colours is the following:

            - green:
                - core process with running Control Server;
                - device process in simulator mode with running Control Server;
                - device process in operational mode with running Control Server and connection to the Controller;
            - orange: device process in operational mode with Control Server running but without connection to the
              Controller.


        Args:
            process_info: Information for one process, to be updated in the
                          Process Manager GUI.
        &#34;&#34;&#34;

        process_name = process_info[&#34;Name&#34;]
        color = process_info[&#34;Color&#34;]

        widget = self.process_widgets[process_name]

        # Update the process widget

        if &#34;Simulator&#34; in process_info:

            if process_name != &#34;DPU&#34;:

                try:
                    widget.sim_option_button.set_selected(process_info[&#34;Simulator&#34;])
                except TypeError:
                    # See #1419
                    widget.sim_option_button.set_selected(False)
                    LOGGER.debug(f&#34;Unchecking the simulator checkbox in PM UI for {process_name}&#34;)

                widget.sim_option_button.button_disabled = widget.sim_option_button.button_selected \
                    if widget.sim_option_button.is_selected() \
                    else widget.sim_option_button.button_disabled
                widget.sim_option_button.setDisabled(True)

        widget.set_led_color(color)

        if process_name == &#34;Configuration Manager&#34; and color == Indic.RED:

            self.obsid.setText(&#34;Obsid unknown&#34;)
            self.setStyleSheet(&#39;QMainWindow{border: 3px solid orange;}&#39;)

    def on_start_stop_cs_button_clicked(self, process_name):

        self.monitoring_workers[process_name].start_stop_cs_button_clicked = True

    def on_start_stop_non_cs_process_button_clicked(self, process_name):

        self.file_generation_monitoring_workers[process_name].start_stop_cs_button_clicked = True

    def on_logger_is_running_signal(self, logger_is_running: bool):

        if logger_is_running:
            self.logger_widget.set_led_color(Indic.GREEN)
        else:
            self.logger_widget.set_led_color(Indic.RED)

    def on_fitsgen_is_running_signal(self, fitsgen_is_running: bool):
        &#34;&#34;&#34; Update the icon of the toolbar button for FITS generation.

        Args:
            - fitsgen_is_running: Indicates whether or not the FITS generation is running.
        &#34;&#34;&#34;

        if fitsgen_is_running:
            self.fitsgen_widget.set_led_color(Indic.GREEN)
        else:
            self.fitsgen_widget.set_led_color(Indic.RED)

        self.fitsgen_widget.start_stop_button.set_selected(not fitsgen_is_running)

    def on_fov_hk_is_running_signal(self, fov_hk_is_running: bool):
        &#34;&#34;&#34; Update the icon of the toolbar button for the generation of FOV HK.

        Args:
            - fov_hk_is_running: Indicates whether or not the generation of FOV HK is running.
        &#34;&#34;&#34;

        if fov_hk_is_running:
            self.fov_hk_widget.set_led_color(Indic.GREEN)
        else:
            self.fov_hk_widget.set_led_color(Indic.RED)

        self.fov_hk_widget.start_stop_button.set_selected(not fov_hk_is_running)

    def on_n_fee_hk_is_running_signal(self, n_fee_hk_is_running: bool):
        &#34;&#34;&#34; Update the icon of the toolbar button for the generation of N-FEE HK.

        Args:
            - n_fee_hk_is_running: Indicates whether or not the generation of N-FEE HK is running.
        &#34;&#34;&#34;

        if n_fee_hk_is_running:
            self.n_fee_hk_widget.set_led_color(Indic.GREEN)
        else:
            self.n_fee_hk_widget.set_led_color(Indic.RED)

        self.n_fee_hk_widget.start_stop_button.set_selected(not n_fee_hk_is_running)

    def set_process_list(self):
        &#34;&#34;&#34; Make dictionary with all processes (core + devices).

        The Configuration Manager is asked which processes (core + devices) are included in the setup.
        &#34;&#34;&#34;

        self.processes = {}

        # Ask the CM which CS are included in the setup

        try:

            with ProcessManagerProxy() as process_manager_proxy:

                self.core = process_manager_proxy.get_core()        # Core
                self.devices = process_manager_proxy.get_devices()  # Devices

                self.processes.update(self.core)
                self.processes.update(self.devices)

                print(self.processes)

        except ConnectionError:

            self.devices = {}
            self.core = {}

    def create_toolbar(self):
        &#34;&#34;&#34; Create the toolbar.

        Buttons with the following functionality are foreseen:
            - Start/stop all EGSE device Control Servers in one go;
            - Start/stop all AEU Control Servers in one go:
            - Start/stop the FITS generation;
            - Start/stop the generation of FOV HK;
            - Start/stop the generation of N-FEE HK.
        &#34;&#34;&#34;

        self.start_egse_button = ToggleButton(name=&#34;Start all device control servers in one go.&#34;,
                                              status_tip=&#34;Start all device control servers in one go.&#34;,
                                              selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                              not_selected=get_resource(&#34;:/icons/play-green.svg&#34;)
                                              )
        self.start_egse_button.clicked.connect(self.start_egse)
        self.stop_egse_button = ToggleButton(name=&#34;Start all device control servers in one go.&#34;,
                                             status_tip=&#34;Stop all device control servers in one go.&#34;,
                                             selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                             not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;)
                                             )
        self.stop_egse_button.clicked.connect(self.stop_egse)

        self.start_aeu_button = ToggleButton(name=&#34;Start all AEU control servers in one go.&#34;,
                                             status_tip=&#34;Start all AEU control servers in one go.&#34;,
                                             selected=get_resource(&#34;:/icons/aeu-cs-start.svg&#34;),
                                             not_selected=get_resource(&#34;:/icons/aeu-cs-start.svg&#34;),
                                             disabled=[get_resource(&#34;:/icons/aeu-cs.svg&#34;),
                                                       get_resource(&#34;:/icons/aeu-cs.svg&#34;)]
                                             )
        self.start_aeu_button.clicked.connect(self.start_all_aeu_cs)

        self.stop_aeu_button = ToggleButton(name=&#34;Stop all AEU control servers in one go.&#34;,
                                            status_tip=&#34;Stop all AEU control servers in one go.&#34;,
                                            selected=get_resource(&#34;:/icons/aeu-cs-stop.svg&#34;),
                                            not_selected=get_resource(&#34;:/icons/aeu-cs-stop.svg&#34;),
                                            disabled=get_resource(&#34;:/icons/aeu-cs.svg&#34;)
                                            )
        self.stop_aeu_button.clicked.connect(self.stop_all_aeu_cs)

        # self.fitsgen_button = ToggleButton(name=&#34;FITS generator&#34;,
        #                                    selected=get_resource(&#34;:/icons/fitsgen-start.svg&#34;),
        #                                    not_selected=get_resource(&#34;:/icons/fitsgen-stop.svg&#34;),
        #                                    status_tip=&#34;Start/stop the FITS generation.&#34;)
        # self.fitsgen_button.clicked.connect(self.start_stop_fitsgen)
        #
        # self.fov_hk_button = ToggleButton(name=&#34;FOV HK&#34;,
        #                                   selected=get_resource(&#34;:/icons/fov-hk-start.svg&#34;),
        #                                   not_selected=get_resource(&#34;:/icons/fov-hk-stop.svg&#34;),
        #                                   status_tip=&#34;Start/stop the FOV HK generation.&#34;)
        # self.fov_hk_button.clicked.connect(self.start_stop_fov_hk)
        #
        # self.n_fee_hk_button = ToggleButton(name=&#34;N-FEE HK generator&#34;,
        #                                     selected=get_resource(&#34;:/icons/n-fee-hk-start.svg&#34;),
        #                                     not_selected=get_resource(&#34;:/icons/n-fee-hk-stop.svg&#34;),
        #                                     status_tip=&#34;Start/stop the N-FEE HK generation.&#34;)
        # self.n_fee_hk_button.clicked.connect(self.start_stop_n_fee_hk)

        self.toolbar = self.addToolBar(&#34;MainToolbar&#34;)
        self.toolbar.addWidget(self.start_egse_button)
        self.toolbar.addWidget(self.stop_egse_button)
        self.toolbar.addSeparator()
        # self.toolbar.addWidget(self.fitsgen_button)
        # self.toolbar.addWidget(self.fov_hk_button)
        # self.toolbar.addWidget(self.n_fee_hk_button)
        # self.toolbar.addSeparator()
        self.toolbar.addWidget(self.start_aeu_button)
        self.toolbar.addWidget(self.stop_aeu_button)

        return self.toolbar

    def create_statusbar(self):
        &#34;&#34;&#34; Create the status bar.&#34;&#34;&#34;

        self.statusBar().setStyleSheet(&#34;border: 0; background-color: #FFF8DC;&#34;)
        self.statusBar().setStyleSheet(&#34;QStatusBar::item {border: none;}&#34;)
        # self.statusBar().addPermanentWidget(VLine())


    def start_egse(self):
        &#34;&#34;&#34; Start all EGSE device Control Servers in one go.

        We only try to start the control servers that are currently down.  For those, the following steps are taken:
            - The start/stop button of each of these control servers should show the stop icon;
            - The simulator option button is disabled;
            - The control server is started, in the mode indicated by the simulator option button.

        For the control servers that could be started, the start/stop button keeps showing the stop icon and the
        simulator mode button stays disabled.  For control servers that could not be started, the start/stop button
        show the start icon again and the simulator mode button is enabled again.
        &#34;&#34;&#34;

        LOGGER.info(f&#34;Starting all device Control Servers&#34;)
        thread = threading.Thread(target=self._start_egse)

        thread.daemon = True
        thread.start()

    def _start_egse(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            process_widget: ProcessWidget = self.process_widgets[process_name]

            if process_widget.status_led.color == Indic.RED:

                process_widget.start_stop_button.setDisabled(True)
                process_widget.sim_option_button.setEnabled(False)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in self.devices.keys():

                if process_widget.status_led.color == Indic.RED:

                    self.monitoring_workers[process_name].start_stop_cs_button_clicked = True

                    sim_mode = self.process_widgets[process_name].is_simulator_mode
                    pm.start_cs(process_name, sim_mode)

    def stop_egse(self):
        &#34;&#34;&#34; Shut down all EGSE device Control Servers in one go.

        We only try to start the control servers that are currently running.  For those, the following steps are taken:
            - The start/stop button of each of these control servers should show the start icon;
            - The simulator option button is disabled;
            - The control server is stopped.

        For the control servers that could be stopped, the start/stop button keeps showing the start icon and the
        simulator mode button is enabled.  For control servers that could not be stopped, the start/stop button
        show the stop icon again and the simulator mode button is disabled again.
        &#34;&#34;&#34;

        LOGGER.info(f&#34;Shutting down all device Control Servers&#34;)
        thread = threading.Thread(target=self._stop_egse)

        thread.daemon = True
        thread.start()

    def _stop_egse(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            process_widget: ProcessWidget = self.process_widgets[process_name]

            if process_widget.status_led.color != Indic.RED:

                process_widget.start_stop_button.setDisabled(True)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in reversed(self.devices.keys()):

                if process_widget.status_led.color != Indic.RED:

                    self.monitoring_workers[process_name].start_stop_cs_button_clicked = True
                    pm.shut_down_cs(process_name)


    def start_all_aeu_cs(self):
        &#34;&#34;&#34; Start the AEU Control Servers in one go.&#34;&#34;&#34;

        thread = threading.Thread(target=self._start_all_aeu_cs)

        thread.daemon = True
        thread.start()

    def _start_all_aeu_cs(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            if str.startswith(process_name, &#34;AEU&#34;):

                process_widget: ProcessWidget = self.process_widgets[process_name]

                if process_widget.status_led.color == Indic.RED:

                    process_widget.start_stop_button.setDisabled(True)
                    process_widget.sim_option_button.setEnabled(False)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in self.devices.keys():

                if str.startswith(process_name, &#34;AEU&#34;):

                    process_widget: ProcessWidget = self.process_widgets[process_name]

                    if process_widget.status_led.color == Indic.RED:

                        self.monitoring_workers[process_name].start_stop_cs_button_clicked = True

                        sim_mode = self.process_widgets[process_name].is_simulator_mode
                        pm.start_cs(process_name, sim_mode)

    def stop_all_aeu_cs(self):
        &#34;&#34;&#34; Shut down the AEU Control Servers in one go.&#34;&#34;&#34;

        thread = threading.Thread(target=self._stop_all_aeu_cs)

        thread.daemon = True
        thread.start()

    def _stop_all_aeu_cs(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            if str.startswith(process_name, &#34;AEU&#34;):

                process_widget: ProcessWidget = self.process_widgets[process_name]

                if process_widget.status_led.color != Indic.RED:
                    process_widget.start_stop_button.setDisabled(True)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in reversed(self.devices.keys()):

                if str.startswith(process_name, &#34;AEU&#34;):

                    process_widget: ProcessWidget = self.process_widgets[process_name]

                    if process_widget.status_led.color != Indic.RED:

                        self.monitoring_workers[process_name].start_stop_cs_button_clicked = True
                        pm.shut_down_cs(process_name)

    # def start_stop_fitsgen(self):
    #     &#34;&#34;&#34; Start/stop the FITS generation.
    #
    #     Depending on the selection state of the FITS generation button, the FITS generation will be started or stopped
    #     (this is done in a separate thread).
    #     &#34;&#34;&#34;
    #
    #     if self.fitsgen_button.is_selected():
    #         thread = threading.Thread(target=stop_fitsgen)
    #     else:
    #         thread = threading.Thread(target=start_fitsgen)
    #
    #     thread.daemon = True
    #     thread.start()
    #
    # def start_stop_fov_hk(self):
    #     &#34;&#34;&#34; Start/stop the generation of FOV HK.
    #
    #     Depending on the selection state of the FOV HK generation button, the FOV HK generation will be started or
    #     stopped (this is done in a separate thread).
    #     &#34;&#34;&#34;
    #
    #     if self.fov_hk_button.is_selected():
    #         thread = threading.Thread(target=stop_fov_hk)
    #     else:
    #         thread = threading.Thread(target=start_fov_hk)
    #
    #     thread.daemon = True
    #     thread.start()
    #
    # def start_stop_n_fee_hk(self):
    #     &#34;&#34;&#34; Start/stop the generation of N-FEE HK.
    #
    #     Depending on the selection state of the N-FEE HK generation button, the N-FEE HK generation will be started or
    #     stopped (this is done in a separate thread).
    #     &#34;&#34;&#34;
    #
    #     if self.n_fee_hk_button.is_selected():
    #         thread = threading.Thread(target=stop_n_fee_hk)
    #     else:
    #         thread = threading.Thread(target=start_n_fee_hk)
    #
    #     thread.daemon = True
    #     thread.start()

    def create_overview_widget_core(self):
        &#34;&#34;&#34; Create a frame with one process widget per core process.&#34;&#34;&#34;

        # Core processes

        self.overview_widget_core_layout = QVBoxLayout()

        for process_name in self.core.keys():

            process_widget = ProcessWidget(
                process_name, self.core[process_name], self,
                include_start_stop_button=False)
            self.process_widgets[process_name] = process_widget
            self.process_widgets_core[process_name] = process_widget

            self.overview_widget_core_layout.addWidget(process_widget)

        self.logger_widget = LogWidget(self)
        self.overview_widget_core_layout.addWidget(self.logger_widget)

        self.overview_widget_core = QGroupBox(&#34;Services/Core&#34;, self)
        self.overview_widget_core.setLayout(self.overview_widget_core_layout)
        self.overview_widget_core.setToolTip(
            &#34;EGSE core processes: must be running at all times.&#34;)

    def create_overview_widget_file_services(self):

        # File generation processes

        self.overview_widget_file_services_layout = QVBoxLayout()

        self.fitsgen_widget = FitsgenWidget(self)
        self.overview_widget_file_services_layout.addWidget(self.fitsgen_widget)

        self.fov_hk_widget = FovHkWidget(self)
        self.overview_widget_file_services_layout.addWidget(self.fov_hk_widget)

        self.n_fee_hk_widget = NFeeHkWidget(self)
        self.overview_widget_file_services_layout.addWidget(self.n_fee_hk_widget)

        self.overview_widget_file_services = QGroupBox(&#34;File generation&#34;, self)
        self.overview_widget_file_services.setLayout(self.overview_widget_file_services_layout)
        # self.overview_widget_file_services.setToolTip(
        #     &#34;EGSE core processes: must be running at all times.&#34;)

    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

        Args:
            - close_event: Close event received when the GUI is closed.
        &#34;&#34;&#34;
        for monitoring_worker in self.monitoring_workers.values():

            monitoring_worker.active = False

        for monitoring_thread in self.monitoring_threads.values():

            monitoring_thread.quit()
            monitoring_thread.wait()

        self.setup_monitoring_worker.active = False
        self.setup_monitoring_thread.quit()
        self.setup_monitoring_thread.wait()

        self.logger_monitoring_worker.active = False
        self.logger_monitoring_thread.quit()
        self.logger_monitoring_thread.wait()

        self.fitsgen_monitoring_worker.active = False
        self.fitsgen_monitoring_thread.quit()
        self.fitsgen_monitoring_thread.wait()

        self.fov_hk_monitoring_worker.active = False
        self.fov_hk_monitoring_thread.quit()
        self.fov_hk_monitoring_thread.wait()

        self.n_fee_hk_monitoring_worker.active = False
        self.n_fee_hk_monitoring_thread.quit()
        self.n_fee_hk_monitoring_thread.wait()


class ProcessManagerUIModel:

    def __init__(self):
        &#34;&#34;&#34; Initialisation of the Process Manager UI model.&#34;&#34;&#34;

        try:

            self.process_manager = ProcessManagerProxy()

        except ConnectionError:

            self.process_manager = None

    def is_connected(self):
        &#34;&#34;&#34; Checks whether the Process Manager Control Server is active.

        Checks whether a connection to the Process Manager Control Server has been established.

        Returns:
            - True if a connection to the Process Manager Control Server has been established; False otherwise.
        &#34;&#34;&#34;

        return self.process_manager.ping() and self.process_manager.is_cs_connected()


class ProcessManagerUIController:

    def __init__(self, model: ProcessManagerUIModel, view: ProcessManagerUIView):
        &#34;&#34;&#34; Initialisation of the Controller for the Process Manager GUI.

        Args:
            - model: Process Manager UI model.
            - view: Process Manager UI view.
        &#34;&#34;&#34;

        self.model = model
        self.view = view


def main():
    &#34;&#34;&#34; Main method to launch the Process Manager GUI.&#34;&#34;&#34;

    multiprocessing.current_process().name = &#34;pm_ui&#34;

    process_status = ProcessStatus()

    timer_thread = threading.Thread(target=do_every, args=(10, process_status.update))
    timer_thread.daemon = True
    timer_thread.start()

    start_http_server(GUI_SETTINGS.METRICS_PORT)

    app = QApplication(sys.argv)

    # Check whether the Process Manager CS is running
    # (show a warning in a pop-up window if it&#39;s not)

    try:

        with ProcessManagerProxy():

            if not is_configuration_manager_active():

                description = &#34;Could not connect to Configuration Manager&#34;
                into_text = (
                    &#34;The GUI will start, but without listed processes. &#34;
                    &#34;Please, check if the Configuration Manager is running and start the server if needed.&#34;
                    # &#34;Otherwise, check if the correct HOSTNAME for the Configuration Manager is set in the &#34;
                    # &#34;Settings.yaml &#34;
                    # &#34;configuration file.&#34;
                    &#34;The Process Manager GUI will have to be re-started after that.&#34;
                )

                show_info_message(description, into_text)

    except ConnectionError:

        description = &#34;Could not connect to Process Manager Control Server&#34;

        into_text = (
            &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
            &#34;Please, check if the Control Server is running and start the server if needed. &#34;
            &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
            &#34;Settings.yaml &#34;
            &#34;configuration file.&#34;
        )

        show_info_message(description, into_text)

    # proxy = ProcessManagerProxy()

    # if not proxy.ping():
    #         description = &#34;Could not connect to Process Manager Control Server&#34;
    #         into_text = (
    #             &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
    #             &#34;Please check if the Control Server is running and start the server if needed. &#34;
    #             &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
    #             &#34;Settings.yaml &#34;
    #             &#34;configuration file.&#34;
    #         )

    #         show_info_message(description, into_text)

    # proxy.disconnect_cs()

    # Create the Process Manager GUI, following the MVC-model

    view = ProcessManagerUIView()
    model = ProcessManagerUIModel()
    ProcessManagerUIController(model, view)

    view.show()

    return app.exec_()


if __name__ == &#39;__main__&#39;:

    sys.exit(main())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.procman.procman_ui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main method to launch the Process Manager GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34; Main method to launch the Process Manager GUI.&#34;&#34;&#34;

    multiprocessing.current_process().name = &#34;pm_ui&#34;

    process_status = ProcessStatus()

    timer_thread = threading.Thread(target=do_every, args=(10, process_status.update))
    timer_thread.daemon = True
    timer_thread.start()

    start_http_server(GUI_SETTINGS.METRICS_PORT)

    app = QApplication(sys.argv)

    # Check whether the Process Manager CS is running
    # (show a warning in a pop-up window if it&#39;s not)

    try:

        with ProcessManagerProxy():

            if not is_configuration_manager_active():

                description = &#34;Could not connect to Configuration Manager&#34;
                into_text = (
                    &#34;The GUI will start, but without listed processes. &#34;
                    &#34;Please, check if the Configuration Manager is running and start the server if needed.&#34;
                    # &#34;Otherwise, check if the correct HOSTNAME for the Configuration Manager is set in the &#34;
                    # &#34;Settings.yaml &#34;
                    # &#34;configuration file.&#34;
                    &#34;The Process Manager GUI will have to be re-started after that.&#34;
                )

                show_info_message(description, into_text)

    except ConnectionError:

        description = &#34;Could not connect to Process Manager Control Server&#34;

        into_text = (
            &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
            &#34;Please, check if the Control Server is running and start the server if needed. &#34;
            &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
            &#34;Settings.yaml &#34;
            &#34;configuration file.&#34;
        )

        show_info_message(description, into_text)

    # proxy = ProcessManagerProxy()

    # if not proxy.ping():
    #         description = &#34;Could not connect to Process Manager Control Server&#34;
    #         into_text = (
    #             &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
    #             &#34;Please check if the Control Server is running and start the server if needed. &#34;
    #             &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
    #             &#34;Settings.yaml &#34;
    #             &#34;configuration file.&#34;
    #         )

    #         show_info_message(description, into_text)

    # proxy.disconnect_cs()

    # Create the Process Manager GUI, following the MVC-model

    view = ProcessManagerUIView()
    model = ProcessManagerUIModel()
    ProcessManagerUIController(model, view)

    view.show()

    return app.exec_()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.start_egse"><code class="name flex">
<span>def <span class="ident">start_egse</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start all device Control Servers in one go.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_egse():
    &#34;&#34;&#34; Start all device Control Servers in one go.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_egse()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.start_fitsgen"><code class="name flex">
<span>def <span class="ident">start_fitsgen</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the FITS generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_fitsgen():
    &#34;&#34;&#34; Start the FITS generation.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_fitsgen()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.start_fov_hk"><code class="name flex">
<span>def <span class="ident">start_fov_hk</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the generation of FOV HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_fov_hk():
    &#34;&#34;&#34; Start the generation of FOV HK.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_fov_hk()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.start_n_fee_hk"><code class="name flex">
<span>def <span class="ident">start_n_fee_hk</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the generation of N-FEE HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_n_fee_hk():
    &#34;&#34;&#34; Start the generation of N-FEE HK.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.start_n_fee_hk()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.stop_egse"><code class="name flex">
<span>def <span class="ident">stop_egse</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop all device Control Servers in one go.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_egse():
    &#34;&#34;&#34; Stop all device Control Servers in one go.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.shut_down_egse()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.stop_fitsgen"><code class="name flex">
<span>def <span class="ident">stop_fitsgen</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the FITS generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_fitsgen():
    &#34;&#34;&#34; Stop the FITS generation.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.stop_fitsgen()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.stop_fov_hk"><code class="name flex">
<span>def <span class="ident">stop_fov_hk</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the generation of FOV HK</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_fov_hk():
    &#34;&#34;&#34; Stop the generation of FOV HK&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.stop_fov_hk()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.stop_n_fee_hk"><code class="name flex">
<span>def <span class="ident">stop_n_fee_hk</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the generation of N-FEE HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_n_fee_hk():
    &#34;&#34;&#34; Stop the generation of N-FEE HK.&#34;&#34;&#34;

    with ProcessManagerProxy() as pm:
        pm.stop_n_fee_hk()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">ConfigurationMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p>
<p>Initialisation of a monitoring thread.</p>
<p>This monitoring thread will listen on the monitoring port of the
Control Server.
At this point the socket (that will connect to the
monitoring port) is not created yet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationMonitoringWorker(QObject):

    # The thread will send a signal with the monitoring information:
    #   - The obsid;
    #   - The setup that has been loaded by the configuration manager.

    setup_changed_signal = pyqtSignal(dict)
    obsid_changed_signal = pyqtSignal(object)   # This allows ObservationIdentifier or None to be returned

    def __init__(self):

        &#34;&#34;&#34; Initialisation of a monitoring thread.

        This monitoring thread will listen on the monitoring port of the
        Control Server.  At this point the socket (that will connect to the
        monitoring port) is not created yet.
        &#34;&#34;&#34;

        super(ConfigurationMonitoringWorker, self).__init__()

        self.setup = None   # Previous setup
        self.obsid = None   # Previous obsid
        self.active = False

        self.connect_socket()

    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.

        Args:
            - proxy_type: Proxy type (needed to read the connection details).
        &#34;&#34;&#34;

        # Start listening to the monitoring port

        self.socket = zmq.Context().socket(zmq.SUB)

        cm = ConfigurationManagerProxy()
        endpoint = cm.get_endpoint()
        monitoring_port = cm.get_monitoring_port()
        address = set_address_port(endpoint, monitoring_port)

        self.socket.connect(address)
        self.socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.
        &#34;&#34;&#34;

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port.

        If monitoring information is received before the timeout, it is
        checked whether the obsid and/or current setup have changed.  If so, a
        signal with the monitoring information is emitted.
        &#34;&#34;&#34;

        self.active = True

        while self.active:

            pickle_string = self.socket.recv()
            monitoring_info = pickle.loads(pickle_string)

            new_setup = monitoring_info[&#34;setup&#34;]  # New setup

            # The setup has changed

            if new_setup != self.setup:

                self.setup = new_setup

                # Emit the setup ID

                self.setup_changed_signal.emit(self.setup)

            new_obsid = monitoring_info[&#34;obsid&#34;]    # New obsid

            if new_obsid != self.obsid:

                self.obsid = new_obsid

                # Emit the obsid

                self.obsid_changed_signal.emit(self.obsid)

    def has_setup(self):
        &#34;&#34;&#34; Check whether a setup has been loaded.

        Returns: True if a setup has been loaded; False otherwise.
        &#34;&#34;&#34;

        return self.setup is not None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p>
<h2 id="args">Args</h2>
<ul>
<li>proxy_type: Proxy type (needed to read the connection details).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.

    Args:
        - proxy_type: Proxy type (needed to read the connection details).
    &#34;&#34;&#34;

    # Start listening to the monitoring port

    self.socket = zmq.Context().socket(zmq.SUB)

    cm = ConfigurationManagerProxy()
    endpoint = cm.get_endpoint()
    monitoring_port = cm.get_monitoring_port()
    address = set_address_port(endpoint, monitoring_port)

    self.socket.connect(address)
    self.socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker.has_setup"><code class="name flex">
<span>def <span class="ident">has_setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a setup has been loaded.</p>
<p>Returns: True if a setup has been loaded; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_setup(self):
    &#34;&#34;&#34; Check whether a setup has been loaded.

    Returns: True if a setup has been loaded; False otherwise.
    &#34;&#34;&#34;

    return self.setup is not None</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker.obsid_changed_signal"><code class="name flex">
<span>def <span class="ident">obsid_changed_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on listening on the monitoring port.</p>
<p>If monitoring information is received before the timeout, it is
checked whether the obsid and/or current setup have changed.
If so, a
signal with the monitoring information is emitted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34; Keep on listening on the monitoring port.

    If monitoring information is received before the timeout, it is
    checked whether the obsid and/or current setup have changed.  If so, a
    signal with the monitoring information is emitted.
    &#34;&#34;&#34;

    self.active = True

    while self.active:

        pickle_string = self.socket.recv()
        monitoring_info = pickle.loads(pickle_string)

        new_setup = monitoring_info[&#34;setup&#34;]  # New setup

        # The setup has changed

        if new_setup != self.setup:

            self.setup = new_setup

            # Emit the setup ID

            self.setup_changed_signal.emit(self.setup)

        new_obsid = monitoring_info[&#34;obsid&#34;]    # New obsid

        if new_obsid != self.obsid:

            self.obsid = new_obsid

            # Emit the obsid

            self.obsid_changed_signal.emit(self.obsid)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker.setup_changed_signal"><code class="name flex">
<span>def <span class="ident">setup_changed_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.procman.procman_ui.ConfigurationMonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34; Start listening on the monitoring port.
    &#34;&#34;&#34;

    self.run()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES"><code class="flex name class">
<span>class <span class="ident">FILE_GENERATION_PROCESS_NAMES</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FILE_GENERATION_PROCESS_NAMES(str, Enum):

    FITSGEN = &#34;FITS generation&#34;
    FOV_HK = &#34;FOV HK&#34;
    N_FEE_HK = &#34;N-FEE HK&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.FITSGEN"><code class="name">var <span class="ident">FITSGEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.FOV_HK"><code class="name">var <span class="ident">FOV_HK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.N_FEE_HK"><code class="name">var <span class="ident">N_FEE_HK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.FitsgenWidget"><code class="flex name class">
<span>class <span class="ident">FitsgenWidget</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a process widget.</p>
<p>For a Control Server with the given process name and Proxy type, a process widget is created.
This widget will
comprise the following components:</p>
<pre><code>- status LED;
- process name;
- button to start the GUI for the process;
- button to start / shut down the process.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process (to display on the widget).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FitsgenWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super(FitsgenWidget, self).__init__(FILE_GENERATION_PROCESS_NAMES.FITSGEN, parent, include_gui_button=True,
                                            include_start_stop_button=True)

    def start_gui(self):

        gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen_ui&#34;])
        gui_process.execute(detach_from_parent=True)

    def start_service(self):

        start_fitsgen()

    def stop_service(self):

        stop_fitsgen()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.FitsgenWidget.start_gui"><code class="name flex">
<span>def <span class="ident">start_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_gui(self):

    gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.dpu.fitsgen_ui&#34;])
    gui_process.execute(detach_from_parent=True)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.FitsgenWidget.start_service"><code class="name flex">
<span>def <span class="ident">start_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_service(self):

    start_fitsgen()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.FitsgenWidget.stop_service"><code class="name flex">
<span>def <span class="ident">stop_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_service(self):

    stop_fitsgen()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.procman.procman_ui.NonCSProcessWidget.set_led_color" href="#egse.procman.procman_ui.NonCSProcessWidget.set_led_color">set_led_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.procman_ui.FovHkWidget"><code class="flex name class">
<span>class <span class="ident">FovHkWidget</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a process widget.</p>
<p>For a Control Server with the given process name and Proxy type, a process widget is created.
This widget will
comprise the following components:</p>
<pre><code>- status LED;
- process name;
- button to start the GUI for the process;
- button to start / shut down the process.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process (to display on the widget).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FovHkWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super(FovHkWidget, self).__init__(FILE_GENERATION_PROCESS_NAMES.FOV_HK, parent, include_gui_button=False,
                                          include_start_stop_button=True)

    def start_service(self):

        start_fov_hk()

    def stop_service(self):

        stop_fov_hk()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.FovHkWidget.start_service"><code class="name flex">
<span>def <span class="ident">start_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_service(self):

    start_fov_hk()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.FovHkWidget.stop_service"><code class="name flex">
<span>def <span class="ident">stop_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_service(self):

    stop_fov_hk()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.procman.procman_ui.NonCSProcessWidget.set_led_color" href="#egse.procman.procman_ui.NonCSProcessWidget.set_led_color">set_led_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.procman_ui.LogWidget"><code class="flex name class">
<span>class <span class="ident">LogWidget</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a process widget.</p>
<p>For a Control Server with the given process name and Proxy type, a process widget is created.
This widget will
comprise the following components:</p>
<pre><code>- status LED;
- process name;
- button to start the GUI for the process;
- button to start / shut down the process.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process (to display on the widget).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super().__init__(&#34;Logger&#34;, parent, include_gui_button=True, include_start_stop_button=False)

    def start_gui(self):

        gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;cutelog&#34;])
        gui_process.execute(detach_from_parent=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.LogWidget.start_gui"><code class="name flex">
<span>def <span class="ident">start_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_gui(self):

    gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;cutelog&#34;])
    gui_process.execute(detach_from_parent=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.procman.procman_ui.NonCSProcessWidget.set_led_color" href="#egse.procman.procman_ui.NonCSProcessWidget.set_led_color">set_led_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.procman_ui.MonitoringWorker"><code class="flex name class">
<span>class <span class="ident">MonitoringWorker</span></span>
<span>(</span><span>process_name, process_info)</span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the status of an EGSE process.</p>
<p>Initialisation of a monitoring worker.</p>
<p>This monitoring worker will listen on the monitoring port of the Control Server.</p>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process.</li>
<li>proxy_type: Proxy type (needed to read the connection details).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MonitoringWorker(QObject):
    &#34;&#34;&#34; Worker for monitoring the status of an EGSE process.&#34;&#34;&#34;

    # The worker will send a signal with the following information:
    #   - process name
    #   - colour of the led (in the process widget)
    #   - in case of a running device process: whether or not it is running in simulator mode

    process_status_signal = pyqtSignal(dict)

    def __init__(self, process_name, process_info):
        &#34;&#34;&#34; Initialisation of a monitoring worker.

        This monitoring worker will listen on the monitoring port of the Control Server.

        Args:
            - process_name: Name of the process.
            - proxy_type: Proxy type (needed to read the connection details).
        &#34;&#34;&#34;

        super(MonitoringWorker, self).__init__()

        self.active = False
        self.start_stop_cs_button_clicked = False

        self.process_name = process_name
        self.proxy_type = process_info[0]
        self.device_args = process_info[1]

        self.monitoring_socket = None
        self.monitoring_timeout = 0.5  # [s]
        self.is_socket_connected = False

        self.commanding_address = None
        self.connect_socket()

        self.previous_state = -1

    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.&#34;&#34;&#34;

        try:

            module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
            module = importlib.import_module(module_name)

            # Ctrl settings:
            #   - transport protocol
            #   - hostname
            #   - commanding port (to check whether the CS is active)
            #   - monitoring port (to ask for process information)

            ctrl_settings = module.CTRL_SETTINGS

            transport = ctrl_settings.PROTOCOL
            hostname = ctrl_settings.HOSTNAME

            if module_name == &#34;egse.aeu.aeu&#34; or &#34;egse.tempcontrol.agilent.agilent3497&#34; in module_name:

                name = self.process_name.split(&#34; &#34;)[1].upper()

                commanding_port = ctrl_settings[name][&#34;COMMANDING_PORT&#34;]
                monitoring_port = ctrl_settings[name][&#34;MONITORING_PORT&#34;]

            elif module_name == &#34;egse.powermeter.ni.cdaq9184&#34;:
                commanding_port = ctrl_settings.CDAQ9184[&#34;COMMANDING_PORT&#34;]
                monitoring_port = ctrl_settings.CDAQ9184[&#34;MONITORING_PORT&#34;]

            else:
                commanding_port = ctrl_settings.COMMANDING_PORT
                monitoring_port = ctrl_settings.MONITORING_PORT

            # Create a socket and connect to the monitoring port

            monitoring_address = connect_address(transport, hostname, monitoring_port)
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

            # Address of the commanding port
            # This is needed when checking whether or not the CS is active

            self.commanding_address = connect_address(transport, hostname, commanding_port)

            self.is_socket_connected = True

        except AttributeError:

            self.is_socket_connected = False

    def stop(self):

        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;

        self.is_socket_connected = False
        self.monitoring_socket.close()

        # self.monitoring_socket.disconnect(self.monitoring_address)
        # self.monitoring_socket.close(linger=0)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.

        If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
        to notify the GUI.
        &#34;&#34;&#34;

        if not is_control_server_active(self.commanding_address, 0.5):

            # Emit a signal, indicating the CS is not running

            process_status = {&#34;Name&#34;: self.process_name, &#34;Color&#34;: Indic.RED}
            self.previous_state = Indic.RED

            self.process_status_signal.emit(process_status)

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port.

        If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
        Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
        process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
        0.5s).
        &#34;&#34;&#34;

        self.active = True

        while self.is_socket_connected and self.active:

            process_status = {&#34;Name&#34;: self.process_name}

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Update the timeout, to be more in line with the monitoring
                    # frequency of the CS (i.e. the delay).  Take 0.5s extra to be
                    # on the safe side.

                    self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                    # Running core CS

                    if self.process_name in [&#34;Logger&#34;, &#34;Storage&#34;, &#34;Configuration Manager&#34;, &#34;Process Manager&#34;,
                                             &#34;Synoptics Manager&#34;]:
                        process_status[&#34;Color&#34;] = Indic.GREEN

                    # Running device CS

                    else:
                        process_status[&#34;Color&#34;], process_status[&#34;Simulator&#34;] = self.get_device_process_status()

                    if self.previous_state != process_status[&#34;Color&#34;]:

                        self.process_status_signal.emit(process_status)
                        self.previous_state = process_status[&#34;Color&#34;]

            except zmq.ZMQError:
                pass

            # Timeout occurred

            else:

                # The CS is not active

                if not is_control_server_active(endpoint=self.commanding_address, timeout=10):

                    process_status[&#34;Color&#34;] = Indic.RED

                    if self.previous_state != process_status[&#34;Color&#34;]:

                        self.process_status_signal.emit(process_status)
                        self.previous_state = process_status[&#34;Color&#34;]

                    elif self.start_stop_cs_button_clicked:

                        self.process_status_signal.emit(process_status)
                        self.previous_state = process_status[&#34;Color&#34;]
                        self.start_stop_cs_button_clicked = False

                # The CS is active, but the timeout was too strict

                else:
                    self.monitoring_timeout += 0.5

    def get_device_process_status(self):
        &#34;&#34;&#34; Determine the status of the device Control Server.

        Returns:
            - color: Colour of the led light (to use in the process widget).
            - is_simulator: Whether or not the Control Server is running in simulator mode.
        &#34;&#34;&#34;

        color = Indic.BLACK
        is_simulator = False

        # Core process -&gt; green

        try:

            with find_class(self.proxy_type)(*self.device_args) as process_proxy:

                try:

                    # CS connected to Controller -&gt; green

                    if process_proxy.is_connected():
                        color = Indic.GREEN

                    # CS not connected to Controller -&gt; orange

                    else:
                        color = Indic.ORANGE

                except AttributeError:
                    color = Indic.GREEN

                is_simulator = process_proxy.is_simulator()

        except ConnectionError:
            pass

        return color, is_simulator</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.MonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.&#34;&#34;&#34;

    try:

        module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
        module = importlib.import_module(module_name)

        # Ctrl settings:
        #   - transport protocol
        #   - hostname
        #   - commanding port (to check whether the CS is active)
        #   - monitoring port (to ask for process information)

        ctrl_settings = module.CTRL_SETTINGS

        transport = ctrl_settings.PROTOCOL
        hostname = ctrl_settings.HOSTNAME

        if module_name == &#34;egse.aeu.aeu&#34; or &#34;egse.tempcontrol.agilent.agilent3497&#34; in module_name:

            name = self.process_name.split(&#34; &#34;)[1].upper()

            commanding_port = ctrl_settings[name][&#34;COMMANDING_PORT&#34;]
            monitoring_port = ctrl_settings[name][&#34;MONITORING_PORT&#34;]

        elif module_name == &#34;egse.powermeter.ni.cdaq9184&#34;:
            commanding_port = ctrl_settings.CDAQ9184[&#34;COMMANDING_PORT&#34;]
            monitoring_port = ctrl_settings.CDAQ9184[&#34;MONITORING_PORT&#34;]

        else:
            commanding_port = ctrl_settings.COMMANDING_PORT
            monitoring_port = ctrl_settings.MONITORING_PORT

        # Create a socket and connect to the monitoring port

        monitoring_address = connect_address(transport, hostname, monitoring_port)
        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        # Address of the commanding port
        # This is needed when checking whether or not the CS is active

        self.commanding_address = connect_address(transport, hostname, commanding_port)

        self.is_socket_connected = True

    except AttributeError:

        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.MonitoringWorker.get_device_process_status"><code class="name flex">
<span>def <span class="ident">get_device_process_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the status of the device Control Server.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>color: Colour of the led light (to use in the process widget).</li>
<li>is_simulator: Whether or not the Control Server is running in simulator mode.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_process_status(self):
    &#34;&#34;&#34; Determine the status of the device Control Server.

    Returns:
        - color: Colour of the led light (to use in the process widget).
        - is_simulator: Whether or not the Control Server is running in simulator mode.
    &#34;&#34;&#34;

    color = Indic.BLACK
    is_simulator = False

    # Core process -&gt; green

    try:

        with find_class(self.proxy_type)(*self.device_args) as process_proxy:

            try:

                # CS connected to Controller -&gt; green

                if process_proxy.is_connected():
                    color = Indic.GREEN

                # CS not connected to Controller -&gt; orange

                else:
                    color = Indic.ORANGE

            except AttributeError:
                color = Indic.GREEN

            is_simulator = process_proxy.is_simulator()

    except ConnectionError:
        pass

    return color, is_simulator</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.MonitoringWorker.process_status_signal"><code class="name flex">
<span>def <span class="ident">process_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.procman.procman_ui.MonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on listening on the monitoring port.</p>
<p>If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
Otherwise, it is checked whether or not the Control Server is active.
If not, a signal is emitted with the
process name.
Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
0.5s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34; Keep on listening on the monitoring port.

    If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
    Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
    process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
    0.5s).
    &#34;&#34;&#34;

    self.active = True

    while self.is_socket_connected and self.active:

        process_status = {&#34;Name&#34;: self.process_name}

        try:

            socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            # Monitoring information was received (before timeout)

            if self.monitoring_socket in socket_list:

                pickle_string = self.monitoring_socket.recv()
                monitoring_info = pickle.loads(pickle_string)

                # Update the timeout, to be more in line with the monitoring
                # frequency of the CS (i.e. the delay).  Take 0.5s extra to be
                # on the safe side.

                self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                # Running core CS

                if self.process_name in [&#34;Logger&#34;, &#34;Storage&#34;, &#34;Configuration Manager&#34;, &#34;Process Manager&#34;,
                                         &#34;Synoptics Manager&#34;]:
                    process_status[&#34;Color&#34;] = Indic.GREEN

                # Running device CS

                else:
                    process_status[&#34;Color&#34;], process_status[&#34;Simulator&#34;] = self.get_device_process_status()

                if self.previous_state != process_status[&#34;Color&#34;]:

                    self.process_status_signal.emit(process_status)
                    self.previous_state = process_status[&#34;Color&#34;]

        except zmq.ZMQError:
            pass

        # Timeout occurred

        else:

            # The CS is not active

            if not is_control_server_active(endpoint=self.commanding_address, timeout=10):

                process_status[&#34;Color&#34;] = Indic.RED

                if self.previous_state != process_status[&#34;Color&#34;]:

                    self.process_status_signal.emit(process_status)
                    self.previous_state = process_status[&#34;Color&#34;]

                elif self.start_stop_cs_button_clicked:

                    self.process_status_signal.emit(process_status)
                    self.previous_state = process_status[&#34;Color&#34;]
                    self.start_stop_cs_button_clicked = False

            # The CS is active, but the timeout was too strict

            else:
                self.monitoring_timeout += 0.5</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.MonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on the monitoring port.</p>
<p>If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
to notify the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34; Start listening on the monitoring port.

    If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
    to notify the GUI.
    &#34;&#34;&#34;

    if not is_control_server_active(self.commanding_address, 0.5):

        # Emit a signal, indicating the CS is not running

        process_status = {&#34;Name&#34;: self.process_name, &#34;Color&#34;: Indic.RED}
        self.previous_state = Indic.RED

        self.process_status_signal.emit(process_status)

    self.run()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.MonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the monitoring worker.</p>
<p>The monitoring socket is disconnected from the monitoring port and is then closed immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):

    &#34;&#34;&#34; Stop the monitoring worker.

    The monitoring socket is disconnected from the monitoring port and is then closed immediately.
    &#34;&#34;&#34;

    self.is_socket_connected = False
    self.monitoring_socket.close()

    # self.monitoring_socket.disconnect(self.monitoring_address)
    # self.monitoring_socket.close(linger=0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.NFeeHkWidget"><code class="flex name class">
<span>class <span class="ident">NFeeHkWidget</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a process widget.</p>
<p>For a Control Server with the given process name and Proxy type, a process widget is created.
This widget will
comprise the following components:</p>
<pre><code>- status LED;
- process name;
- button to start the GUI for the process;
- button to start / shut down the process.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process (to display on the widget).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NFeeHkWidget(NonCSProcessWidget):

    def __init__(self, parent):

        super(NFeeHkWidget, self).__init__(FILE_GENERATION_PROCESS_NAMES.N_FEE_HK, parent, include_gui_button=False,
                                           include_start_stop_button=True)

    def start_service(self):

        start_n_fee_hk()

    def stop_service(self):

        stop_n_fee_hk()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.NFeeHkWidget.start_service"><code class="name flex">
<span>def <span class="ident">start_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_service(self):

    start_n_fee_hk()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.NFeeHkWidget.stop_service"><code class="name flex">
<span>def <span class="ident">stop_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_service(self):

    stop_n_fee_hk()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.procman.procman_ui.NonCSProcessWidget.set_led_color" href="#egse.procman.procman_ui.NonCSProcessWidget.set_led_color">set_led_color</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.procman.procman_ui.NonCSProcessWidget"><code class="flex name class">
<span>class <span class="ident">NonCSProcessWidget</span></span>
<span>(</span><span>process_name, parent, include_gui_button=True, include_start_stop_button=True)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a process widget.</p>
<p>For a Control Server with the given process name and Proxy type, a process widget is created.
This widget will
comprise the following components:</p>
<pre><code>- status LED;
- process name;
- button to start the GUI for the process;
- button to start / shut down the process.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process (to display on the widget).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonCSProcessWidget(QGroupBox):

    def __init__(self, process_name, parent, include_gui_button=True, include_start_stop_button=True):
        &#34;&#34;&#34; Initialisation of a process widget.

        For a Control Server with the given process name and Proxy type, a process widget is created.  This widget will
        comprise the following components:

            - status LED;
            - process name;
            - button to start the GUI for the process;
            - button to start / shut down the process.

        Args:
            - process_name: Name of the process (to display on the widget).
        &#34;&#34;&#34;

        super().__init__()

        self.process_name = process_name
        self.parent = parent

        layout = QGridLayout()

        index = 0

        # Status LED

        self.status_led = LED(parent=self)
        layout.addWidget(self.status_led, 0, index)
        index += 1

        # Process name

        self.process_name_label = QLabel(process_name)
        layout.addWidget(self.process_name_label, 0, index)
        layout.setColumnStretch(index, 1)  # Push LED and name to the left and buttons to the right
        index += 1

        # Fire up (default) GUI

        if include_gui_button:

            self.show_gui_button = TouchButton(name=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                               status_tip=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                               selected=get_resource(&#34;:/icons/user-interface.svg&#34;)
                                               )
            self.show_gui_button.setFixedSize(30, 30)
            layout.addWidget(self.show_gui_button, 0, index)
            self.show_gui_button.clicked.connect(self.start_gui)

            index += 1

        # Shut down / re-start

        if include_start_stop_button:

            self.start_stop_button = ToggleButton(name=f&#34;Start / shut down the {self.process_name}.&#34;,
                                                  status_tip=f&#34;Start / shut down the {self.process_name}.&#34;,
                                                  selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                                  not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                                  disabled=[get_resource(&#34;:/icons/busy.svg&#34;),
                                                            get_resource(&#34;:/icons/busy.svg&#34;)]
                                                  )
            self.start_stop_button.clicked.connect(self.start_stop_service)
            layout.addWidget(self.start_stop_button, 0, index)
            index += 1

        self.setLayout(layout)

    def start_stop_service(self):

        self.start_stop_button.setDisabled(True)

        if self.start_stop_button.is_selected():

            print(f&#34;Stopping {self.process_name}&#34;)
            LOGGER.info(f&#34;Shut down the {self.process_name}&#34;)
            thread = threading.Thread(target=self.stop_service)

        else:

            print(f&#34;Starting {self.process_name}&#34;)
            LOGGER.info(f&#34;Start the {self.process_name}&#34;)
            thread = threading.Thread(target=self.start_service)

        thread.daemon = True
        thread.start()

        self.parent.on_start_stop_non_cs_process_button_clicked(self.process_name)

    # def start_gui(self):
    #     &#34;&#34;&#34; Starting the default GUI for the process.&#34;&#34;&#34;
    #
    #     LOGGER.debug(f&#34;Starting GUI for {self.process_name}&#34;)
    #     print(&#34;Starting GUI&#34;)

    def set_led_color(self, color: int):
        &#34;&#34;&#34; Set the colour of the LED, representing the status of the process.

        The meaning of the colours is the following:

            - green: process running;
            - red: process not running.

        Args:
            - color: Integer representing the colour to indicate the process status.  Should only be Indic.GREEN,
                     or Indic.RED.
        &#34;&#34;&#34;

        self.status_led.set_color(color)

        try:
            self.start_stop_button.setDisabled(False)
            self.start_stop_button.set_selected(color == Indic.RED)
        except AttributeError:
            # The logger doesn&#39;t have a start/stop button
            pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.procman.procman_ui.FitsgenWidget" href="#egse.procman.procman_ui.FitsgenWidget">FitsgenWidget</a></li>
<li><a title="egse.procman.procman_ui.FovHkWidget" href="#egse.procman.procman_ui.FovHkWidget">FovHkWidget</a></li>
<li><a title="egse.procman.procman_ui.LogWidget" href="#egse.procman.procman_ui.LogWidget">LogWidget</a></li>
<li><a title="egse.procman.procman_ui.NFeeHkWidget" href="#egse.procman.procman_ui.NFeeHkWidget">NFeeHkWidget</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.NonCSProcessWidget.set_led_color"><code class="name flex">
<span>def <span class="ident">set_led_color</span></span>(<span>self, color: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the colour of the LED, representing the status of the process.</p>
<p>The meaning of the colours is the following:</p>
<pre><code>- green: process running;
- red: process not running.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>color: Integer representing the colour to indicate the process status.
Should only be Indic.GREEN,
or Indic.RED.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_led_color(self, color: int):
    &#34;&#34;&#34; Set the colour of the LED, representing the status of the process.

    The meaning of the colours is the following:

        - green: process running;
        - red: process not running.

    Args:
        - color: Integer representing the colour to indicate the process status.  Should only be Indic.GREEN,
                 or Indic.RED.
    &#34;&#34;&#34;

    self.status_led.set_color(color)

    try:
        self.start_stop_button.setDisabled(False)
        self.start_stop_button.set_selected(color == Indic.RED)
    except AttributeError:
        # The logger doesn&#39;t have a start/stop button
        pass</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.NonCSProcessWidget.start_stop_service"><code class="name flex">
<span>def <span class="ident">start_stop_service</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_stop_service(self):

    self.start_stop_button.setDisabled(True)

    if self.start_stop_button.is_selected():

        print(f&#34;Stopping {self.process_name}&#34;)
        LOGGER.info(f&#34;Shut down the {self.process_name}&#34;)
        thread = threading.Thread(target=self.stop_service)

    else:

        print(f&#34;Starting {self.process_name}&#34;)
        LOGGER.info(f&#34;Start the {self.process_name}&#34;)
        thread = threading.Thread(target=self.start_service)

    thread.daemon = True
    thread.start()

    self.parent.on_start_stop_non_cs_process_button_clicked(self.process_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIController"><code class="flex name class">
<span>class <span class="ident">ProcessManagerUIController</span></span>
<span>(</span><span>model: <a title="egse.procman.procman_ui.ProcessManagerUIModel" href="#egse.procman.procman_ui.ProcessManagerUIModel">ProcessManagerUIModel</a>, view: <a title="egse.procman.procman_ui.ProcessManagerUIView" href="#egse.procman.procman_ui.ProcessManagerUIView">ProcessManagerUIView</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialisation of the Controller for the Process Manager GUI.</p>
<h2 id="args">Args</h2>
<ul>
<li>model: Process Manager UI model.</li>
<li>view: Process Manager UI view.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerUIController:

    def __init__(self, model: ProcessManagerUIModel, view: ProcessManagerUIView):
        &#34;&#34;&#34; Initialisation of the Controller for the Process Manager GUI.

        Args:
            - model: Process Manager UI model.
            - view: Process Manager UI view.
        &#34;&#34;&#34;

        self.model = model
        self.view = view</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIModel"><code class="flex name class">
<span>class <span class="ident">ProcessManagerUIModel</span></span>
</code></dt>
<dd>
<div class="desc"><p>Initialisation of the Process Manager UI model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerUIModel:

    def __init__(self):
        &#34;&#34;&#34; Initialisation of the Process Manager UI model.&#34;&#34;&#34;

        try:

            self.process_manager = ProcessManagerProxy()

        except ConnectionError:

            self.process_manager = None

    def is_connected(self):
        &#34;&#34;&#34; Checks whether the Process Manager Control Server is active.

        Checks whether a connection to the Process Manager Control Server has been established.

        Returns:
            - True if a connection to the Process Manager Control Server has been established; False otherwise.
        &#34;&#34;&#34;

        return self.process_manager.ping() and self.process_manager.is_cs_connected()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.ProcessManagerUIModel.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the Process Manager Control Server is active.</p>
<p>Checks whether a connection to the Process Manager Control Server has been established.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>True if a connection to the Process Manager Control Server has been established; False otherwise.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34; Checks whether the Process Manager Control Server is active.

    Checks whether a connection to the Process Manager Control Server has been established.

    Returns:
        - True if a connection to the Process Manager Control Server has been established; False otherwise.
    &#34;&#34;&#34;

    return self.process_manager.ping() and self.process_manager.is_cs_connected()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView"><code class="flex name class">
<span>class <span class="ident">ProcessManagerUIView</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p>
<p>Initialisation of the Process Manager GUI.</p>
<p>The components are placed in the window and threads are created for all processes, to be able to check for
updates in the process status (in the background) and display these in the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessManagerUIView(QMainWindow):

    def __init__(self):
        &#34;&#34;&#34; Initialisation of the Process Manager GUI.

        The components are placed in the window and threads are created for all processes, to be able to check for
        updates in the process status (in the background) and display these in the GUI.
        &#34;&#34;&#34;

        super().__init__()

        self.setGeometry(300, 300, 150, 1000)
        self.setWindowTitle(&#34;Process Manager&#34;)

        self.processes = {}
        self.devices = {}

        try:

            with ProcessManagerProxy() as process_manager_proxy:

                self.core = process_manager_proxy.get_core()        # Core

        except ConnectionError:

            self.core = {}

        self.monitoring_threads = {}
        self.monitoring_workers = {}

        self.process_widgets = {}

        self.process_widgets_core = {}

        self.setup_monitoring_thread = QThread(self)
        self.setup_monitoring_worker = ConfigurationMonitoringWorker()
        self.setup_monitoring_worker.moveToThread(self.setup_monitoring_thread)

        # What to do when information has been received on the monitoring
        # port before timeout?

        self.setup_monitoring_worker.setup_changed_signal.connect(self.on_setup_changed_signal)
        self.setup_monitoring_worker.obsid_changed_signal.connect(self.on_obsid_changed_signal)
        self.setup_monitoring_thread.started.connect(self.setup_monitoring_worker.start_process)
        self.setup_monitoring_thread.start()

        # Build up the GUI

        self.init_ui()

        # Keep an eye on the logger

        self.logger_monitoring_thread = QThread(self)
        self.logger_monitoring_worker = ProcessMonitoringWorker(&#34;egse.logger.log_cs&#34;)
        self.logger_monitoring_worker.moveToThread(self.logger_monitoring_thread)
        self.logger_monitoring_worker.is_running_signal.connect(self.on_logger_is_running_signal)
        self.logger_monitoring_thread.started.connect(self.logger_monitoring_worker.start_process)
        self.logger_monitoring_thread.start()

        # Keep an eye on the FITS generation

        self.fitsgen_monitoring_thread = QThread(self)
        self.fitsgen_monitoring_worker = ProcessMonitoringWorker(&#34;egse.dpu.fitsgen&#34;)
        self.fitsgen_monitoring_worker.moveToThread(self.fitsgen_monitoring_thread)
        self.fitsgen_monitoring_worker.is_running_signal.connect(self.on_fitsgen_is_running_signal)
        self.fitsgen_monitoring_thread.started.connect(self.fitsgen_monitoring_worker.start_process)
        self.fitsgen_monitoring_thread.start()

        # Keep an eye on the generation of FOV HK

        self.fov_hk_monitoring_thread = QThread(self)
        self.fov_hk_monitoring_worker = ProcessMonitoringWorker(&#34;egse.fov.fov_hk&#34;)
        self.fov_hk_monitoring_worker.moveToThread(self.fov_hk_monitoring_thread)
        self.fov_hk_monitoring_worker.is_running_signal.connect(self.on_fov_hk_is_running_signal)
        self.fov_hk_monitoring_thread.started.connect(self.fov_hk_monitoring_worker.start_process)
        self.fov_hk_monitoring_thread.start()

        # Keep an eye on the generation of N-FEE HK

        self.n_fee_hk_monitoring_thread = QThread(self)
        self.n_fee_hk_monitoring_worker = ProcessMonitoringWorker(&#34;egse.fee.n_fee_hk&#34;)
        self.n_fee_hk_monitoring_worker.moveToThread(self.n_fee_hk_monitoring_thread)
        self.n_fee_hk_monitoring_worker.is_running_signal.connect(self.on_n_fee_hk_is_running_signal)
        self.n_fee_hk_monitoring_thread.started.connect(self.n_fee_hk_monitoring_worker.start_process)
        self.n_fee_hk_monitoring_thread.start()

        self.file_generation_monitoring_workers = {
            FILE_GENERATION_PROCESS_NAMES.FITSGEN: self.fitsgen_monitoring_worker,
            FILE_GENERATION_PROCESS_NAMES.FOV_HK: self.fov_hk_monitoring_worker,
            FILE_GENERATION_PROCESS_NAMES.N_FEE_HK: self.n_fee_hk_monitoring_worker
        }

    def init_ui(self):
        &#34;&#34;&#34; Put the components in the GUI window.

        The GUI comprises the following components:

            - the toolbar;
            - on the left-hand side: one process widget per process;
            - on the right-hand side: one tab per process.
        &#34;&#34;&#34;

        # Creating the content

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        self.create_toolbar()
        self.create_statusbar()

        layout = QHBoxLayout()
        vbox = QVBoxLayout()

        # Obsid

        self.obsid = QLabel(&#34;No observation is running&#34;)
        self.setStyleSheet(&#39;QMainWindow{border: 3px solid green;}&#39;)
        vbox.addWidget(self.obsid)
        vbox.addWidget(QLabel())

        # Left-hand side: one process widget per process

        widget_frame = QFrame()

        self.overview_widget_devices_layout = QVBoxLayout()
        self.overview_widget_devices_layout.addStretch()
        self.overview_widget_devices = QGroupBox(&#34;Devices&#34;, self)
        self.overview_widget_devices.setLayout(self.overview_widget_devices_layout)
        self.overview_widget_devices.setToolTip(
            &#34;EGSE device processes:\n&#34; +
            &#34;can be started in this GUI or on the command line.&#34;)

        self.create_overview_widget_core()
        vbox.addWidget(self.overview_widget_core)

        self.create_overview_widget_file_services()
        vbox.addWidget(self.overview_widget_file_services)

        vbox.addWidget(self.overview_widget_devices)

        widget_frame.setLayout(vbox)
        # layout.addWidget(widget_frame)

        scroll = QScrollArea()
        scroll.setWidget(widget_frame)
        scroll.setWidgetResizable(True)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        # scroll.setFixedHeight(400)
        scroll.setFixedWidth(550)
        layout.addWidget(scroll)

        app_frame.setLayout(layout)

        self.setCentralWidget(app_frame)

    def start_monitoring(self) -&gt; object:
        &#34;&#34;&#34; Start listening on the monitoring port.

        Create and start a thread that listens on the monitoring port in the background.  If information is received
        before timeout, the Control Server is running: the light in the process tab should be set to green or orange,
        and the process information should be updated in the process tab.
        &#34;&#34;&#34;

        for process_name, process_info in self.processes.items():

            self.monitoring_threads[process_name] = QThread()

            self.monitoring_workers[process_name] = MonitoringWorker(process_name, process_info)
            self.monitoring_workers[process_name].moveToThread(self.monitoring_threads[process_name])

            # What to do when information has been sent back from the process thread?

            self.monitoring_workers[process_name].process_status_signal.connect(self.on_process_status_signal)

            self.monitoring_threads[process_name].started.connect(
                self.monitoring_workers[process_name].start_process)

            self.monitoring_threads[process_name].start()

    def on_setup_changed_signal(self, setup):
        &#34;&#34;&#34; Re-build the GUI after a change in setup.

        Args:
            - setup: New setup.
        &#34;&#34;&#34;

        # self.all_aeu_cs_button.disable()
        # self.start_aeu_button.setDisabled(True)
        # self.stop_aeu_button.setDisabled(True)

        # Stop all workers and threads

        for process_name in self.processes.keys():

            self.monitoring_workers[process_name].process_status_signal.disconnect()

            self.monitoring_workers[process_name].stop()
            self.monitoring_threads[process_name].quit()
            self.monitoring_threads[process_name].wait()

        self.monitoring_workers.clear()
        self.monitoring_threads.clear()

        # Make process list

        self.processes.clear()
        self.core.clear()
        self.devices.clear()

        self.start_aeu_button.setVisible(False)
        self.stop_aeu_button.setVisible(False)

        # Remove the widgets from the layouts

        while self.overview_widget_devices_layout.count():

            widget = self.overview_widget_devices_layout.takeAt(0).widget()

            if widget is not None:
                widget.deleteLater()

        self.process_widgets.clear()

        # Re-build the process list

        try:

            with ProcessManagerProxy() as process_manager_proxy:

                self.core = process_manager_proxy.get_core()
                self.devices = process_manager_proxy.get_devices()

                self.processes.update(self.core)
                self.processes.update(self.devices)

        except ConnectionError:

            self.core = {}
            self.devices = {}

        # Make new process widgets

        for process_name in self.devices.keys():

            process_widget = ProcessWidget(process_name, self.devices[process_name], self)

            self.process_widgets[process_name] = process_widget

            self.overview_widget_devices_layout.addWidget(process_widget)

        self.process_widgets.update(self.process_widgets_core)

        # Make sure the boxes stay nicely together when vertically resizing

        self.overview_widget_devices_layout.addStretch()

        # Start monitoring the process status

        self.start_monitoring()

        if &#34;AEU cRIO&#34; in self.devices.keys():

            # self.all_aeu_cs_button.set_selected(False)
            # self.all_aeu_cs_button.enable()
            self.start_aeu_button.setEnabled(True)
            self.stop_aeu_button.setEnabled(True)

        else:

            # self.all_aeu_cs_button.set_selected(False)
            # self.all_aeu_cs_button.disable()
            self.start_aeu_button.setEnabled(False)
            self.stop_aeu_button.setEnabled(False)

    def on_obsid_changed_signal(self, obsid):
        &#34;&#34;&#34; Update the GUI for the new obsid.

        Args:
            - obsid: The new obsid.
        &#34;&#34;&#34;

        if obsid is None:

            self.obsid.setText(&#34;No observation is running&#34;)
            self.setStyleSheet(&#39;QMainWindow{border: 3px solid green;}&#39;)

        else:

            self.obsid.setText(f&#34;Observation {obsid} is running&#34;)
            self.setStyleSheet(&#39;QMainWindow{border: 3px solid red;}&#39;)

    def on_process_status_signal(self, process_info):
        &#34;&#34;&#34; Update the GUI for the process with the given name.

        This method is called to update the GUI for the process with the given name in case the Control Server is
        running:

            - the colour of the light in the process widget is set to green or orange;
            - the process information is updated in the tab.

        The meaning of the colours is the following:

            - green:
                - core process with running Control Server;
                - device process in simulator mode with running Control Server;
                - device process in operational mode with running Control Server and connection to the Controller;
            - orange: device process in operational mode with Control Server running but without connection to the
              Controller.


        Args:
            process_info: Information for one process, to be updated in the
                          Process Manager GUI.
        &#34;&#34;&#34;

        process_name = process_info[&#34;Name&#34;]
        color = process_info[&#34;Color&#34;]

        widget = self.process_widgets[process_name]

        # Update the process widget

        if &#34;Simulator&#34; in process_info:

            if process_name != &#34;DPU&#34;:

                try:
                    widget.sim_option_button.set_selected(process_info[&#34;Simulator&#34;])
                except TypeError:
                    # See #1419
                    widget.sim_option_button.set_selected(False)
                    LOGGER.debug(f&#34;Unchecking the simulator checkbox in PM UI for {process_name}&#34;)

                widget.sim_option_button.button_disabled = widget.sim_option_button.button_selected \
                    if widget.sim_option_button.is_selected() \
                    else widget.sim_option_button.button_disabled
                widget.sim_option_button.setDisabled(True)

        widget.set_led_color(color)

        if process_name == &#34;Configuration Manager&#34; and color == Indic.RED:

            self.obsid.setText(&#34;Obsid unknown&#34;)
            self.setStyleSheet(&#39;QMainWindow{border: 3px solid orange;}&#39;)

    def on_start_stop_cs_button_clicked(self, process_name):

        self.monitoring_workers[process_name].start_stop_cs_button_clicked = True

    def on_start_stop_non_cs_process_button_clicked(self, process_name):

        self.file_generation_monitoring_workers[process_name].start_stop_cs_button_clicked = True

    def on_logger_is_running_signal(self, logger_is_running: bool):

        if logger_is_running:
            self.logger_widget.set_led_color(Indic.GREEN)
        else:
            self.logger_widget.set_led_color(Indic.RED)

    def on_fitsgen_is_running_signal(self, fitsgen_is_running: bool):
        &#34;&#34;&#34; Update the icon of the toolbar button for FITS generation.

        Args:
            - fitsgen_is_running: Indicates whether or not the FITS generation is running.
        &#34;&#34;&#34;

        if fitsgen_is_running:
            self.fitsgen_widget.set_led_color(Indic.GREEN)
        else:
            self.fitsgen_widget.set_led_color(Indic.RED)

        self.fitsgen_widget.start_stop_button.set_selected(not fitsgen_is_running)

    def on_fov_hk_is_running_signal(self, fov_hk_is_running: bool):
        &#34;&#34;&#34; Update the icon of the toolbar button for the generation of FOV HK.

        Args:
            - fov_hk_is_running: Indicates whether or not the generation of FOV HK is running.
        &#34;&#34;&#34;

        if fov_hk_is_running:
            self.fov_hk_widget.set_led_color(Indic.GREEN)
        else:
            self.fov_hk_widget.set_led_color(Indic.RED)

        self.fov_hk_widget.start_stop_button.set_selected(not fov_hk_is_running)

    def on_n_fee_hk_is_running_signal(self, n_fee_hk_is_running: bool):
        &#34;&#34;&#34; Update the icon of the toolbar button for the generation of N-FEE HK.

        Args:
            - n_fee_hk_is_running: Indicates whether or not the generation of N-FEE HK is running.
        &#34;&#34;&#34;

        if n_fee_hk_is_running:
            self.n_fee_hk_widget.set_led_color(Indic.GREEN)
        else:
            self.n_fee_hk_widget.set_led_color(Indic.RED)

        self.n_fee_hk_widget.start_stop_button.set_selected(not n_fee_hk_is_running)

    def set_process_list(self):
        &#34;&#34;&#34; Make dictionary with all processes (core + devices).

        The Configuration Manager is asked which processes (core + devices) are included in the setup.
        &#34;&#34;&#34;

        self.processes = {}

        # Ask the CM which CS are included in the setup

        try:

            with ProcessManagerProxy() as process_manager_proxy:

                self.core = process_manager_proxy.get_core()        # Core
                self.devices = process_manager_proxy.get_devices()  # Devices

                self.processes.update(self.core)
                self.processes.update(self.devices)

                print(self.processes)

        except ConnectionError:

            self.devices = {}
            self.core = {}

    def create_toolbar(self):
        &#34;&#34;&#34; Create the toolbar.

        Buttons with the following functionality are foreseen:
            - Start/stop all EGSE device Control Servers in one go;
            - Start/stop all AEU Control Servers in one go:
            - Start/stop the FITS generation;
            - Start/stop the generation of FOV HK;
            - Start/stop the generation of N-FEE HK.
        &#34;&#34;&#34;

        self.start_egse_button = ToggleButton(name=&#34;Start all device control servers in one go.&#34;,
                                              status_tip=&#34;Start all device control servers in one go.&#34;,
                                              selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                              not_selected=get_resource(&#34;:/icons/play-green.svg&#34;)
                                              )
        self.start_egse_button.clicked.connect(self.start_egse)
        self.stop_egse_button = ToggleButton(name=&#34;Start all device control servers in one go.&#34;,
                                             status_tip=&#34;Stop all device control servers in one go.&#34;,
                                             selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                             not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;)
                                             )
        self.stop_egse_button.clicked.connect(self.stop_egse)

        self.start_aeu_button = ToggleButton(name=&#34;Start all AEU control servers in one go.&#34;,
                                             status_tip=&#34;Start all AEU control servers in one go.&#34;,
                                             selected=get_resource(&#34;:/icons/aeu-cs-start.svg&#34;),
                                             not_selected=get_resource(&#34;:/icons/aeu-cs-start.svg&#34;),
                                             disabled=[get_resource(&#34;:/icons/aeu-cs.svg&#34;),
                                                       get_resource(&#34;:/icons/aeu-cs.svg&#34;)]
                                             )
        self.start_aeu_button.clicked.connect(self.start_all_aeu_cs)

        self.stop_aeu_button = ToggleButton(name=&#34;Stop all AEU control servers in one go.&#34;,
                                            status_tip=&#34;Stop all AEU control servers in one go.&#34;,
                                            selected=get_resource(&#34;:/icons/aeu-cs-stop.svg&#34;),
                                            not_selected=get_resource(&#34;:/icons/aeu-cs-stop.svg&#34;),
                                            disabled=get_resource(&#34;:/icons/aeu-cs.svg&#34;)
                                            )
        self.stop_aeu_button.clicked.connect(self.stop_all_aeu_cs)

        # self.fitsgen_button = ToggleButton(name=&#34;FITS generator&#34;,
        #                                    selected=get_resource(&#34;:/icons/fitsgen-start.svg&#34;),
        #                                    not_selected=get_resource(&#34;:/icons/fitsgen-stop.svg&#34;),
        #                                    status_tip=&#34;Start/stop the FITS generation.&#34;)
        # self.fitsgen_button.clicked.connect(self.start_stop_fitsgen)
        #
        # self.fov_hk_button = ToggleButton(name=&#34;FOV HK&#34;,
        #                                   selected=get_resource(&#34;:/icons/fov-hk-start.svg&#34;),
        #                                   not_selected=get_resource(&#34;:/icons/fov-hk-stop.svg&#34;),
        #                                   status_tip=&#34;Start/stop the FOV HK generation.&#34;)
        # self.fov_hk_button.clicked.connect(self.start_stop_fov_hk)
        #
        # self.n_fee_hk_button = ToggleButton(name=&#34;N-FEE HK generator&#34;,
        #                                     selected=get_resource(&#34;:/icons/n-fee-hk-start.svg&#34;),
        #                                     not_selected=get_resource(&#34;:/icons/n-fee-hk-stop.svg&#34;),
        #                                     status_tip=&#34;Start/stop the N-FEE HK generation.&#34;)
        # self.n_fee_hk_button.clicked.connect(self.start_stop_n_fee_hk)

        self.toolbar = self.addToolBar(&#34;MainToolbar&#34;)
        self.toolbar.addWidget(self.start_egse_button)
        self.toolbar.addWidget(self.stop_egse_button)
        self.toolbar.addSeparator()
        # self.toolbar.addWidget(self.fitsgen_button)
        # self.toolbar.addWidget(self.fov_hk_button)
        # self.toolbar.addWidget(self.n_fee_hk_button)
        # self.toolbar.addSeparator()
        self.toolbar.addWidget(self.start_aeu_button)
        self.toolbar.addWidget(self.stop_aeu_button)

        return self.toolbar

    def create_statusbar(self):
        &#34;&#34;&#34; Create the status bar.&#34;&#34;&#34;

        self.statusBar().setStyleSheet(&#34;border: 0; background-color: #FFF8DC;&#34;)
        self.statusBar().setStyleSheet(&#34;QStatusBar::item {border: none;}&#34;)
        # self.statusBar().addPermanentWidget(VLine())


    def start_egse(self):
        &#34;&#34;&#34; Start all EGSE device Control Servers in one go.

        We only try to start the control servers that are currently down.  For those, the following steps are taken:
            - The start/stop button of each of these control servers should show the stop icon;
            - The simulator option button is disabled;
            - The control server is started, in the mode indicated by the simulator option button.

        For the control servers that could be started, the start/stop button keeps showing the stop icon and the
        simulator mode button stays disabled.  For control servers that could not be started, the start/stop button
        show the start icon again and the simulator mode button is enabled again.
        &#34;&#34;&#34;

        LOGGER.info(f&#34;Starting all device Control Servers&#34;)
        thread = threading.Thread(target=self._start_egse)

        thread.daemon = True
        thread.start()

    def _start_egse(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            process_widget: ProcessWidget = self.process_widgets[process_name]

            if process_widget.status_led.color == Indic.RED:

                process_widget.start_stop_button.setDisabled(True)
                process_widget.sim_option_button.setEnabled(False)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in self.devices.keys():

                if process_widget.status_led.color == Indic.RED:

                    self.monitoring_workers[process_name].start_stop_cs_button_clicked = True

                    sim_mode = self.process_widgets[process_name].is_simulator_mode
                    pm.start_cs(process_name, sim_mode)

    def stop_egse(self):
        &#34;&#34;&#34; Shut down all EGSE device Control Servers in one go.

        We only try to start the control servers that are currently running.  For those, the following steps are taken:
            - The start/stop button of each of these control servers should show the start icon;
            - The simulator option button is disabled;
            - The control server is stopped.

        For the control servers that could be stopped, the start/stop button keeps showing the start icon and the
        simulator mode button is enabled.  For control servers that could not be stopped, the start/stop button
        show the stop icon again and the simulator mode button is disabled again.
        &#34;&#34;&#34;

        LOGGER.info(f&#34;Shutting down all device Control Servers&#34;)
        thread = threading.Thread(target=self._stop_egse)

        thread.daemon = True
        thread.start()

    def _stop_egse(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            process_widget: ProcessWidget = self.process_widgets[process_name]

            if process_widget.status_led.color != Indic.RED:

                process_widget.start_stop_button.setDisabled(True)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in reversed(self.devices.keys()):

                if process_widget.status_led.color != Indic.RED:

                    self.monitoring_workers[process_name].start_stop_cs_button_clicked = True
                    pm.shut_down_cs(process_name)


    def start_all_aeu_cs(self):
        &#34;&#34;&#34; Start the AEU Control Servers in one go.&#34;&#34;&#34;

        thread = threading.Thread(target=self._start_all_aeu_cs)

        thread.daemon = True
        thread.start()

    def _start_all_aeu_cs(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            if str.startswith(process_name, &#34;AEU&#34;):

                process_widget: ProcessWidget = self.process_widgets[process_name]

                if process_widget.status_led.color == Indic.RED:

                    process_widget.start_stop_button.setDisabled(True)
                    process_widget.sim_option_button.setEnabled(False)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in self.devices.keys():

                if str.startswith(process_name, &#34;AEU&#34;):

                    process_widget: ProcessWidget = self.process_widgets[process_name]

                    if process_widget.status_led.color == Indic.RED:

                        self.monitoring_workers[process_name].start_stop_cs_button_clicked = True

                        sim_mode = self.process_widgets[process_name].is_simulator_mode
                        pm.start_cs(process_name, sim_mode)

    def stop_all_aeu_cs(self):
        &#34;&#34;&#34; Shut down the AEU Control Servers in one go.&#34;&#34;&#34;

        thread = threading.Thread(target=self._stop_all_aeu_cs)

        thread.daemon = True
        thread.start()

    def _stop_all_aeu_cs(self):

        # First make sure that the start/stop buttons in the process widgets show the hourglass icon (denoting is going
        # on with that CD) and that the simulator option button is disabled (so you cannot switch between simulator and
        # operational mode while starting the CS)

        for process_name in self.devices.keys():

            if str.startswith(process_name, &#34;AEU&#34;):

                process_widget: ProcessWidget = self.process_widgets[process_name]

                if process_widget.status_led.color != Indic.RED:
                    process_widget.start_stop_button.setDisabled(True)

        # In order not to overload the Process Manager, we loop through the list of devices again and start the CS
        # one-by-one

        with ProcessManagerProxy() as pm:

            for process_name in reversed(self.devices.keys()):

                if str.startswith(process_name, &#34;AEU&#34;):

                    process_widget: ProcessWidget = self.process_widgets[process_name]

                    if process_widget.status_led.color != Indic.RED:

                        self.monitoring_workers[process_name].start_stop_cs_button_clicked = True
                        pm.shut_down_cs(process_name)

    # def start_stop_fitsgen(self):
    #     &#34;&#34;&#34; Start/stop the FITS generation.
    #
    #     Depending on the selection state of the FITS generation button, the FITS generation will be started or stopped
    #     (this is done in a separate thread).
    #     &#34;&#34;&#34;
    #
    #     if self.fitsgen_button.is_selected():
    #         thread = threading.Thread(target=stop_fitsgen)
    #     else:
    #         thread = threading.Thread(target=start_fitsgen)
    #
    #     thread.daemon = True
    #     thread.start()
    #
    # def start_stop_fov_hk(self):
    #     &#34;&#34;&#34; Start/stop the generation of FOV HK.
    #
    #     Depending on the selection state of the FOV HK generation button, the FOV HK generation will be started or
    #     stopped (this is done in a separate thread).
    #     &#34;&#34;&#34;
    #
    #     if self.fov_hk_button.is_selected():
    #         thread = threading.Thread(target=stop_fov_hk)
    #     else:
    #         thread = threading.Thread(target=start_fov_hk)
    #
    #     thread.daemon = True
    #     thread.start()
    #
    # def start_stop_n_fee_hk(self):
    #     &#34;&#34;&#34; Start/stop the generation of N-FEE HK.
    #
    #     Depending on the selection state of the N-FEE HK generation button, the N-FEE HK generation will be started or
    #     stopped (this is done in a separate thread).
    #     &#34;&#34;&#34;
    #
    #     if self.n_fee_hk_button.is_selected():
    #         thread = threading.Thread(target=stop_n_fee_hk)
    #     else:
    #         thread = threading.Thread(target=start_n_fee_hk)
    #
    #     thread.daemon = True
    #     thread.start()

    def create_overview_widget_core(self):
        &#34;&#34;&#34; Create a frame with one process widget per core process.&#34;&#34;&#34;

        # Core processes

        self.overview_widget_core_layout = QVBoxLayout()

        for process_name in self.core.keys():

            process_widget = ProcessWidget(
                process_name, self.core[process_name], self,
                include_start_stop_button=False)
            self.process_widgets[process_name] = process_widget
            self.process_widgets_core[process_name] = process_widget

            self.overview_widget_core_layout.addWidget(process_widget)

        self.logger_widget = LogWidget(self)
        self.overview_widget_core_layout.addWidget(self.logger_widget)

        self.overview_widget_core = QGroupBox(&#34;Services/Core&#34;, self)
        self.overview_widget_core.setLayout(self.overview_widget_core_layout)
        self.overview_widget_core.setToolTip(
            &#34;EGSE core processes: must be running at all times.&#34;)

    def create_overview_widget_file_services(self):

        # File generation processes

        self.overview_widget_file_services_layout = QVBoxLayout()

        self.fitsgen_widget = FitsgenWidget(self)
        self.overview_widget_file_services_layout.addWidget(self.fitsgen_widget)

        self.fov_hk_widget = FovHkWidget(self)
        self.overview_widget_file_services_layout.addWidget(self.fov_hk_widget)

        self.n_fee_hk_widget = NFeeHkWidget(self)
        self.overview_widget_file_services_layout.addWidget(self.n_fee_hk_widget)

        self.overview_widget_file_services = QGroupBox(&#34;File generation&#34;, self)
        self.overview_widget_file_services.setLayout(self.overview_widget_file_services_layout)
        # self.overview_widget_file_services.setToolTip(
        #     &#34;EGSE core processes: must be running at all times.&#34;)

    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

        Args:
            - close_event: Close event received when the GUI is closed.
        &#34;&#34;&#34;
        for monitoring_worker in self.monitoring_workers.values():

            monitoring_worker.active = False

        for monitoring_thread in self.monitoring_threads.values():

            monitoring_thread.quit()
            monitoring_thread.wait()

        self.setup_monitoring_worker.active = False
        self.setup_monitoring_thread.quit()
        self.setup_monitoring_thread.wait()

        self.logger_monitoring_worker.active = False
        self.logger_monitoring_thread.quit()
        self.logger_monitoring_thread.wait()

        self.fitsgen_monitoring_worker.active = False
        self.fitsgen_monitoring_thread.quit()
        self.fitsgen_monitoring_thread.wait()

        self.fov_hk_monitoring_worker.active = False
        self.fov_hk_monitoring_thread.quit()
        self.fov_hk_monitoring_thread.wait()

        self.n_fee_hk_monitoring_worker.active = False
        self.n_fee_hk_monitoring_thread.quit()
        self.n_fee_hk_monitoring_thread.wait()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, close_event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure that all threads are stopped when the GUI is closed.</p>
<h2 id="args">Args</h2>
<ul>
<li>close_event: Close event received when the GUI is closed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, close_event: QCloseEvent) -&gt; None:
    &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

    Args:
        - close_event: Close event received when the GUI is closed.
    &#34;&#34;&#34;
    for monitoring_worker in self.monitoring_workers.values():

        monitoring_worker.active = False

    for monitoring_thread in self.monitoring_threads.values():

        monitoring_thread.quit()
        monitoring_thread.wait()

    self.setup_monitoring_worker.active = False
    self.setup_monitoring_thread.quit()
    self.setup_monitoring_thread.wait()

    self.logger_monitoring_worker.active = False
    self.logger_monitoring_thread.quit()
    self.logger_monitoring_thread.wait()

    self.fitsgen_monitoring_worker.active = False
    self.fitsgen_monitoring_thread.quit()
    self.fitsgen_monitoring_thread.wait()

    self.fov_hk_monitoring_worker.active = False
    self.fov_hk_monitoring_thread.quit()
    self.fov_hk_monitoring_thread.wait()

    self.n_fee_hk_monitoring_worker.active = False
    self.n_fee_hk_monitoring_thread.quit()
    self.n_fee_hk_monitoring_thread.wait()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.create_overview_widget_core"><code class="name flex">
<span>def <span class="ident">create_overview_widget_core</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a frame with one process widget per core process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_overview_widget_core(self):
    &#34;&#34;&#34; Create a frame with one process widget per core process.&#34;&#34;&#34;

    # Core processes

    self.overview_widget_core_layout = QVBoxLayout()

    for process_name in self.core.keys():

        process_widget = ProcessWidget(
            process_name, self.core[process_name], self,
            include_start_stop_button=False)
        self.process_widgets[process_name] = process_widget
        self.process_widgets_core[process_name] = process_widget

        self.overview_widget_core_layout.addWidget(process_widget)

    self.logger_widget = LogWidget(self)
    self.overview_widget_core_layout.addWidget(self.logger_widget)

    self.overview_widget_core = QGroupBox(&#34;Services/Core&#34;, self)
    self.overview_widget_core.setLayout(self.overview_widget_core_layout)
    self.overview_widget_core.setToolTip(
        &#34;EGSE core processes: must be running at all times.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.create_overview_widget_file_services"><code class="name flex">
<span>def <span class="ident">create_overview_widget_file_services</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_overview_widget_file_services(self):

    # File generation processes

    self.overview_widget_file_services_layout = QVBoxLayout()

    self.fitsgen_widget = FitsgenWidget(self)
    self.overview_widget_file_services_layout.addWidget(self.fitsgen_widget)

    self.fov_hk_widget = FovHkWidget(self)
    self.overview_widget_file_services_layout.addWidget(self.fov_hk_widget)

    self.n_fee_hk_widget = NFeeHkWidget(self)
    self.overview_widget_file_services_layout.addWidget(self.n_fee_hk_widget)

    self.overview_widget_file_services = QGroupBox(&#34;File generation&#34;, self)
    self.overview_widget_file_services.setLayout(self.overview_widget_file_services_layout)
    # self.overview_widget_file_services.setToolTip(
    #     &#34;EGSE core processes: must be running at all times.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.create_statusbar"><code class="name flex">
<span>def <span class="ident">create_statusbar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the status bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_statusbar(self):
    &#34;&#34;&#34; Create the status bar.&#34;&#34;&#34;

    self.statusBar().setStyleSheet(&#34;border: 0; background-color: #FFF8DC;&#34;)
    self.statusBar().setStyleSheet(&#34;QStatusBar::item {border: none;}&#34;)
    # self.statusBar().addPermanentWidget(VLine())</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.create_toolbar"><code class="name flex">
<span>def <span class="ident">create_toolbar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the toolbar.</p>
<p>Buttons with the following functionality are foreseen:
- Start/stop all EGSE device Control Servers in one go;
- Start/stop all AEU Control Servers in one go:
- Start/stop the FITS generation;
- Start/stop the generation of FOV HK;
- Start/stop the generation of N-FEE HK.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_toolbar(self):
    &#34;&#34;&#34; Create the toolbar.

    Buttons with the following functionality are foreseen:
        - Start/stop all EGSE device Control Servers in one go;
        - Start/stop all AEU Control Servers in one go:
        - Start/stop the FITS generation;
        - Start/stop the generation of FOV HK;
        - Start/stop the generation of N-FEE HK.
    &#34;&#34;&#34;

    self.start_egse_button = ToggleButton(name=&#34;Start all device control servers in one go.&#34;,
                                          status_tip=&#34;Start all device control servers in one go.&#34;,
                                          selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                          not_selected=get_resource(&#34;:/icons/play-green.svg&#34;)
                                          )
    self.start_egse_button.clicked.connect(self.start_egse)
    self.stop_egse_button = ToggleButton(name=&#34;Start all device control servers in one go.&#34;,
                                         status_tip=&#34;Stop all device control servers in one go.&#34;,
                                         selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                         not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;)
                                         )
    self.stop_egse_button.clicked.connect(self.stop_egse)

    self.start_aeu_button = ToggleButton(name=&#34;Start all AEU control servers in one go.&#34;,
                                         status_tip=&#34;Start all AEU control servers in one go.&#34;,
                                         selected=get_resource(&#34;:/icons/aeu-cs-start.svg&#34;),
                                         not_selected=get_resource(&#34;:/icons/aeu-cs-start.svg&#34;),
                                         disabled=[get_resource(&#34;:/icons/aeu-cs.svg&#34;),
                                                   get_resource(&#34;:/icons/aeu-cs.svg&#34;)]
                                         )
    self.start_aeu_button.clicked.connect(self.start_all_aeu_cs)

    self.stop_aeu_button = ToggleButton(name=&#34;Stop all AEU control servers in one go.&#34;,
                                        status_tip=&#34;Stop all AEU control servers in one go.&#34;,
                                        selected=get_resource(&#34;:/icons/aeu-cs-stop.svg&#34;),
                                        not_selected=get_resource(&#34;:/icons/aeu-cs-stop.svg&#34;),
                                        disabled=get_resource(&#34;:/icons/aeu-cs.svg&#34;)
                                        )
    self.stop_aeu_button.clicked.connect(self.stop_all_aeu_cs)

    # self.fitsgen_button = ToggleButton(name=&#34;FITS generator&#34;,
    #                                    selected=get_resource(&#34;:/icons/fitsgen-start.svg&#34;),
    #                                    not_selected=get_resource(&#34;:/icons/fitsgen-stop.svg&#34;),
    #                                    status_tip=&#34;Start/stop the FITS generation.&#34;)
    # self.fitsgen_button.clicked.connect(self.start_stop_fitsgen)
    #
    # self.fov_hk_button = ToggleButton(name=&#34;FOV HK&#34;,
    #                                   selected=get_resource(&#34;:/icons/fov-hk-start.svg&#34;),
    #                                   not_selected=get_resource(&#34;:/icons/fov-hk-stop.svg&#34;),
    #                                   status_tip=&#34;Start/stop the FOV HK generation.&#34;)
    # self.fov_hk_button.clicked.connect(self.start_stop_fov_hk)
    #
    # self.n_fee_hk_button = ToggleButton(name=&#34;N-FEE HK generator&#34;,
    #                                     selected=get_resource(&#34;:/icons/n-fee-hk-start.svg&#34;),
    #                                     not_selected=get_resource(&#34;:/icons/n-fee-hk-stop.svg&#34;),
    #                                     status_tip=&#34;Start/stop the N-FEE HK generation.&#34;)
    # self.n_fee_hk_button.clicked.connect(self.start_stop_n_fee_hk)

    self.toolbar = self.addToolBar(&#34;MainToolbar&#34;)
    self.toolbar.addWidget(self.start_egse_button)
    self.toolbar.addWidget(self.stop_egse_button)
    self.toolbar.addSeparator()
    # self.toolbar.addWidget(self.fitsgen_button)
    # self.toolbar.addWidget(self.fov_hk_button)
    # self.toolbar.addWidget(self.n_fee_hk_button)
    # self.toolbar.addSeparator()
    self.toolbar.addWidget(self.start_aeu_button)
    self.toolbar.addWidget(self.stop_aeu_button)

    return self.toolbar</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.init_ui"><code class="name flex">
<span>def <span class="ident">init_ui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Put the components in the GUI window.</p>
<p>The GUI comprises the following components:</p>
<pre><code>- the toolbar;
- on the left-hand side: one process widget per process;
- on the right-hand side: one tab per process.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_ui(self):
    &#34;&#34;&#34; Put the components in the GUI window.

    The GUI comprises the following components:

        - the toolbar;
        - on the left-hand side: one process widget per process;
        - on the right-hand side: one tab per process.
    &#34;&#34;&#34;

    # Creating the content

    app_frame = QFrame()
    app_frame.setObjectName(&#34;AppFrame&#34;)

    self.create_toolbar()
    self.create_statusbar()

    layout = QHBoxLayout()
    vbox = QVBoxLayout()

    # Obsid

    self.obsid = QLabel(&#34;No observation is running&#34;)
    self.setStyleSheet(&#39;QMainWindow{border: 3px solid green;}&#39;)
    vbox.addWidget(self.obsid)
    vbox.addWidget(QLabel())

    # Left-hand side: one process widget per process

    widget_frame = QFrame()

    self.overview_widget_devices_layout = QVBoxLayout()
    self.overview_widget_devices_layout.addStretch()
    self.overview_widget_devices = QGroupBox(&#34;Devices&#34;, self)
    self.overview_widget_devices.setLayout(self.overview_widget_devices_layout)
    self.overview_widget_devices.setToolTip(
        &#34;EGSE device processes:\n&#34; +
        &#34;can be started in this GUI or on the command line.&#34;)

    self.create_overview_widget_core()
    vbox.addWidget(self.overview_widget_core)

    self.create_overview_widget_file_services()
    vbox.addWidget(self.overview_widget_file_services)

    vbox.addWidget(self.overview_widget_devices)

    widget_frame.setLayout(vbox)
    # layout.addWidget(widget_frame)

    scroll = QScrollArea()
    scroll.setWidget(widget_frame)
    scroll.setWidgetResizable(True)
    scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    # scroll.setFixedHeight(400)
    scroll.setFixedWidth(550)
    layout.addWidget(scroll)

    app_frame.setLayout(layout)

    self.setCentralWidget(app_frame)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_fitsgen_is_running_signal"><code class="name flex">
<span>def <span class="ident">on_fitsgen_is_running_signal</span></span>(<span>self, fitsgen_is_running: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the icon of the toolbar button for FITS generation.</p>
<h2 id="args">Args</h2>
<ul>
<li>fitsgen_is_running: Indicates whether or not the FITS generation is running.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_fitsgen_is_running_signal(self, fitsgen_is_running: bool):
    &#34;&#34;&#34; Update the icon of the toolbar button for FITS generation.

    Args:
        - fitsgen_is_running: Indicates whether or not the FITS generation is running.
    &#34;&#34;&#34;

    if fitsgen_is_running:
        self.fitsgen_widget.set_led_color(Indic.GREEN)
    else:
        self.fitsgen_widget.set_led_color(Indic.RED)

    self.fitsgen_widget.start_stop_button.set_selected(not fitsgen_is_running)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_fov_hk_is_running_signal"><code class="name flex">
<span>def <span class="ident">on_fov_hk_is_running_signal</span></span>(<span>self, fov_hk_is_running: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the icon of the toolbar button for the generation of FOV HK.</p>
<h2 id="args">Args</h2>
<ul>
<li>fov_hk_is_running: Indicates whether or not the generation of FOV HK is running.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_fov_hk_is_running_signal(self, fov_hk_is_running: bool):
    &#34;&#34;&#34; Update the icon of the toolbar button for the generation of FOV HK.

    Args:
        - fov_hk_is_running: Indicates whether or not the generation of FOV HK is running.
    &#34;&#34;&#34;

    if fov_hk_is_running:
        self.fov_hk_widget.set_led_color(Indic.GREEN)
    else:
        self.fov_hk_widget.set_led_color(Indic.RED)

    self.fov_hk_widget.start_stop_button.set_selected(not fov_hk_is_running)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_logger_is_running_signal"><code class="name flex">
<span>def <span class="ident">on_logger_is_running_signal</span></span>(<span>self, logger_is_running: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_logger_is_running_signal(self, logger_is_running: bool):

    if logger_is_running:
        self.logger_widget.set_led_color(Indic.GREEN)
    else:
        self.logger_widget.set_led_color(Indic.RED)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_n_fee_hk_is_running_signal"><code class="name flex">
<span>def <span class="ident">on_n_fee_hk_is_running_signal</span></span>(<span>self, n_fee_hk_is_running: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the icon of the toolbar button for the generation of N-FEE HK.</p>
<h2 id="args">Args</h2>
<ul>
<li>n_fee_hk_is_running: Indicates whether or not the generation of N-FEE HK is running.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_n_fee_hk_is_running_signal(self, n_fee_hk_is_running: bool):
    &#34;&#34;&#34; Update the icon of the toolbar button for the generation of N-FEE HK.

    Args:
        - n_fee_hk_is_running: Indicates whether or not the generation of N-FEE HK is running.
    &#34;&#34;&#34;

    if n_fee_hk_is_running:
        self.n_fee_hk_widget.set_led_color(Indic.GREEN)
    else:
        self.n_fee_hk_widget.set_led_color(Indic.RED)

    self.n_fee_hk_widget.start_stop_button.set_selected(not n_fee_hk_is_running)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_obsid_changed_signal"><code class="name flex">
<span>def <span class="ident">on_obsid_changed_signal</span></span>(<span>self, obsid)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the GUI for the new obsid.</p>
<h2 id="args">Args</h2>
<ul>
<li>obsid: The new obsid.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_obsid_changed_signal(self, obsid):
    &#34;&#34;&#34; Update the GUI for the new obsid.

    Args:
        - obsid: The new obsid.
    &#34;&#34;&#34;

    if obsid is None:

        self.obsid.setText(&#34;No observation is running&#34;)
        self.setStyleSheet(&#39;QMainWindow{border: 3px solid green;}&#39;)

    else:

        self.obsid.setText(f&#34;Observation {obsid} is running&#34;)
        self.setStyleSheet(&#39;QMainWindow{border: 3px solid red;}&#39;)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_process_status_signal"><code class="name flex">
<span>def <span class="ident">on_process_status_signal</span></span>(<span>self, process_info)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the GUI for the process with the given name.</p>
<p>This method is called to update the GUI for the process with the given name in case the Control Server is
running:</p>
<pre><code>- the colour of the light in the process widget is set to green or orange;
- the process information is updated in the tab.
</code></pre>
<p>The meaning of the colours is the following:</p>
<pre><code>- green:
    - core process with running Control Server;
    - device process in simulator mode with running Control Server;
    - device process in operational mode with running Control Server and connection to the Controller;
- orange: device process in operational mode with Control Server running but without connection to the
  Controller.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>process_info</code></strong></dt>
<dd>Information for one process, to be updated in the
Process Manager GUI.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_process_status_signal(self, process_info):
    &#34;&#34;&#34; Update the GUI for the process with the given name.

    This method is called to update the GUI for the process with the given name in case the Control Server is
    running:

        - the colour of the light in the process widget is set to green or orange;
        - the process information is updated in the tab.

    The meaning of the colours is the following:

        - green:
            - core process with running Control Server;
            - device process in simulator mode with running Control Server;
            - device process in operational mode with running Control Server and connection to the Controller;
        - orange: device process in operational mode with Control Server running but without connection to the
          Controller.


    Args:
        process_info: Information for one process, to be updated in the
                      Process Manager GUI.
    &#34;&#34;&#34;

    process_name = process_info[&#34;Name&#34;]
    color = process_info[&#34;Color&#34;]

    widget = self.process_widgets[process_name]

    # Update the process widget

    if &#34;Simulator&#34; in process_info:

        if process_name != &#34;DPU&#34;:

            try:
                widget.sim_option_button.set_selected(process_info[&#34;Simulator&#34;])
            except TypeError:
                # See #1419
                widget.sim_option_button.set_selected(False)
                LOGGER.debug(f&#34;Unchecking the simulator checkbox in PM UI for {process_name}&#34;)

            widget.sim_option_button.button_disabled = widget.sim_option_button.button_selected \
                if widget.sim_option_button.is_selected() \
                else widget.sim_option_button.button_disabled
            widget.sim_option_button.setDisabled(True)

    widget.set_led_color(color)

    if process_name == &#34;Configuration Manager&#34; and color == Indic.RED:

        self.obsid.setText(&#34;Obsid unknown&#34;)
        self.setStyleSheet(&#39;QMainWindow{border: 3px solid orange;}&#39;)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_setup_changed_signal"><code class="name flex">
<span>def <span class="ident">on_setup_changed_signal</span></span>(<span>self, setup)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-build the GUI after a change in setup.</p>
<h2 id="args">Args</h2>
<ul>
<li>setup: New setup.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_setup_changed_signal(self, setup):
    &#34;&#34;&#34; Re-build the GUI after a change in setup.

    Args:
        - setup: New setup.
    &#34;&#34;&#34;

    # self.all_aeu_cs_button.disable()
    # self.start_aeu_button.setDisabled(True)
    # self.stop_aeu_button.setDisabled(True)

    # Stop all workers and threads

    for process_name in self.processes.keys():

        self.monitoring_workers[process_name].process_status_signal.disconnect()

        self.monitoring_workers[process_name].stop()
        self.monitoring_threads[process_name].quit()
        self.monitoring_threads[process_name].wait()

    self.monitoring_workers.clear()
    self.monitoring_threads.clear()

    # Make process list

    self.processes.clear()
    self.core.clear()
    self.devices.clear()

    self.start_aeu_button.setVisible(False)
    self.stop_aeu_button.setVisible(False)

    # Remove the widgets from the layouts

    while self.overview_widget_devices_layout.count():

        widget = self.overview_widget_devices_layout.takeAt(0).widget()

        if widget is not None:
            widget.deleteLater()

    self.process_widgets.clear()

    # Re-build the process list

    try:

        with ProcessManagerProxy() as process_manager_proxy:

            self.core = process_manager_proxy.get_core()
            self.devices = process_manager_proxy.get_devices()

            self.processes.update(self.core)
            self.processes.update(self.devices)

    except ConnectionError:

        self.core = {}
        self.devices = {}

    # Make new process widgets

    for process_name in self.devices.keys():

        process_widget = ProcessWidget(process_name, self.devices[process_name], self)

        self.process_widgets[process_name] = process_widget

        self.overview_widget_devices_layout.addWidget(process_widget)

    self.process_widgets.update(self.process_widgets_core)

    # Make sure the boxes stay nicely together when vertically resizing

    self.overview_widget_devices_layout.addStretch()

    # Start monitoring the process status

    self.start_monitoring()

    if &#34;AEU cRIO&#34; in self.devices.keys():

        # self.all_aeu_cs_button.set_selected(False)
        # self.all_aeu_cs_button.enable()
        self.start_aeu_button.setEnabled(True)
        self.stop_aeu_button.setEnabled(True)

    else:

        # self.all_aeu_cs_button.set_selected(False)
        # self.all_aeu_cs_button.disable()
        self.start_aeu_button.setEnabled(False)
        self.stop_aeu_button.setEnabled(False)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_start_stop_cs_button_clicked"><code class="name flex">
<span>def <span class="ident">on_start_stop_cs_button_clicked</span></span>(<span>self, process_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_start_stop_cs_button_clicked(self, process_name):

    self.monitoring_workers[process_name].start_stop_cs_button_clicked = True</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.on_start_stop_non_cs_process_button_clicked"><code class="name flex">
<span>def <span class="ident">on_start_stop_non_cs_process_button_clicked</span></span>(<span>self, process_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_start_stop_non_cs_process_button_clicked(self, process_name):

    self.file_generation_monitoring_workers[process_name].start_stop_cs_button_clicked = True</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.set_process_list"><code class="name flex">
<span>def <span class="ident">set_process_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make dictionary with all processes (core + devices).</p>
<p>The Configuration Manager is asked which processes (core + devices) are included in the setup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_process_list(self):
    &#34;&#34;&#34; Make dictionary with all processes (core + devices).

    The Configuration Manager is asked which processes (core + devices) are included in the setup.
    &#34;&#34;&#34;

    self.processes = {}

    # Ask the CM which CS are included in the setup

    try:

        with ProcessManagerProxy() as process_manager_proxy:

            self.core = process_manager_proxy.get_core()        # Core
            self.devices = process_manager_proxy.get_devices()  # Devices

            self.processes.update(self.core)
            self.processes.update(self.devices)

            print(self.processes)

    except ConnectionError:

        self.devices = {}
        self.core = {}</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.start_all_aeu_cs"><code class="name flex">
<span>def <span class="ident">start_all_aeu_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the AEU Control Servers in one go.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_all_aeu_cs(self):
    &#34;&#34;&#34; Start the AEU Control Servers in one go.&#34;&#34;&#34;

    thread = threading.Thread(target=self._start_all_aeu_cs)

    thread.daemon = True
    thread.start()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.start_egse"><code class="name flex">
<span>def <span class="ident">start_egse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start all EGSE device Control Servers in one go.</p>
<p>We only try to start the control servers that are currently down.
For those, the following steps are taken:
- The start/stop button of each of these control servers should show the stop icon;
- The simulator option button is disabled;
- The control server is started, in the mode indicated by the simulator option button.</p>
<p>For the control servers that could be started, the start/stop button keeps showing the stop icon and the
simulator mode button stays disabled.
For control servers that could not be started, the start/stop button
show the start icon again and the simulator mode button is enabled again.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_egse(self):
    &#34;&#34;&#34; Start all EGSE device Control Servers in one go.

    We only try to start the control servers that are currently down.  For those, the following steps are taken:
        - The start/stop button of each of these control servers should show the stop icon;
        - The simulator option button is disabled;
        - The control server is started, in the mode indicated by the simulator option button.

    For the control servers that could be started, the start/stop button keeps showing the stop icon and the
    simulator mode button stays disabled.  For control servers that could not be started, the start/stop button
    show the start icon again and the simulator mode button is enabled again.
    &#34;&#34;&#34;

    LOGGER.info(f&#34;Starting all device Control Servers&#34;)
    thread = threading.Thread(target=self._start_egse)

    thread.daemon = True
    thread.start()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.start_monitoring"><code class="name flex">
<span>def <span class="ident">start_monitoring</span></span>(<span>self) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on the monitoring port.</p>
<p>Create and start a thread that listens on the monitoring port in the background.
If information is received
before timeout, the Control Server is running: the light in the process tab should be set to green or orange,
and the process information should be updated in the process tab.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_monitoring(self) -&gt; object:
    &#34;&#34;&#34; Start listening on the monitoring port.

    Create and start a thread that listens on the monitoring port in the background.  If information is received
    before timeout, the Control Server is running: the light in the process tab should be set to green or orange,
    and the process information should be updated in the process tab.
    &#34;&#34;&#34;

    for process_name, process_info in self.processes.items():

        self.monitoring_threads[process_name] = QThread()

        self.monitoring_workers[process_name] = MonitoringWorker(process_name, process_info)
        self.monitoring_workers[process_name].moveToThread(self.monitoring_threads[process_name])

        # What to do when information has been sent back from the process thread?

        self.monitoring_workers[process_name].process_status_signal.connect(self.on_process_status_signal)

        self.monitoring_threads[process_name].started.connect(
            self.monitoring_workers[process_name].start_process)

        self.monitoring_threads[process_name].start()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.stop_all_aeu_cs"><code class="name flex">
<span>def <span class="ident">stop_all_aeu_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shut down the AEU Control Servers in one go.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_all_aeu_cs(self):
    &#34;&#34;&#34; Shut down the AEU Control Servers in one go.&#34;&#34;&#34;

    thread = threading.Thread(target=self._stop_all_aeu_cs)

    thread.daemon = True
    thread.start()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessManagerUIView.stop_egse"><code class="name flex">
<span>def <span class="ident">stop_egse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shut down all EGSE device Control Servers in one go.</p>
<p>We only try to start the control servers that are currently running.
For those, the following steps are taken:
- The start/stop button of each of these control servers should show the start icon;
- The simulator option button is disabled;
- The control server is stopped.</p>
<p>For the control servers that could be stopped, the start/stop button keeps showing the start icon and the
simulator mode button is enabled.
For control servers that could not be stopped, the start/stop button
show the stop icon again and the simulator mode button is disabled again.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_egse(self):
    &#34;&#34;&#34; Shut down all EGSE device Control Servers in one go.

    We only try to start the control servers that are currently running.  For those, the following steps are taken:
        - The start/stop button of each of these control servers should show the start icon;
        - The simulator option button is disabled;
        - The control server is stopped.

    For the control servers that could be stopped, the start/stop button keeps showing the start icon and the
    simulator mode button is enabled.  For control servers that could not be stopped, the start/stop button
    show the stop icon again and the simulator mode button is disabled again.
    &#34;&#34;&#34;

    LOGGER.info(f&#34;Shutting down all device Control Servers&#34;)
    thread = threading.Thread(target=self._stop_egse)

    thread.daemon = True
    thread.start()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.ProcessMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">ProcessMonitoringWorker</span></span>
<span>(</span><span>module)</span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the status of a process.</p>
<p>Worker for monitoring the status of a process.</p>
<h2 id="args">Args</h2>
<ul>
<li>module</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessMonitoringWorker(QObject):
    &#34;&#34;&#34; Worker for monitoring the status of a process.&#34;&#34;&#34;

    is_running_signal = pyqtSignal(bool)

    def __init__(self, module):
        &#34;&#34;&#34; Worker for monitoring the status of a process.

        Args:
            - module
        &#34;&#34;&#34;

        super(ProcessMonitoringWorker, self).__init__()

        self.active = False
        self.start_stop_cs_button_clicked = False

        self.was_running_before = None

        self.module = importlib.import_module(module)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.

        If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
        to notify the GUI.
        &#34;&#34;&#34;

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on asking for the status of the status of the process.

        Every 5s, ask for the status of the process.  If this changes w.r.t. of they way it was before, a signal is
        emitted with the current status.
        &#34;&#34;&#34;

        self.active = True
        last_time = time.time()

        while self.active:

            if time.time() - last_time &gt;= 5:

                is_running = self.module.send_request(&#34;status&#34;).get(&#34;status&#34;) == &#34;ACK&#34;

                if is_running != self.was_running_before:
                    self.was_running_before = is_running
                    self.is_running_signal.emit(is_running)

                elif self.start_stop_cs_button_clicked:

                    for index in range(15):

                        # Check (max 15x) to see whether pressing the button had an effect

                        is_running = self.module.send_request(&#34;status&#34;).get(&#34;status&#34;) == &#34;ACK&#34;
                        if self.was_running_before != is_running:
                            break
                        time.sleep(2)

                        self.was_running_before = is_running
                        self.start_stop_cs_button_clicked = False
                        self.is_running_signal.emit(is_running)

                last_time = time.time()

            else:
                time.sleep(0.1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.ProcessMonitoringWorker.is_running_signal"><code class="name flex">
<span>def <span class="ident">is_running_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.procman.procman_ui.ProcessMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on asking for the status of the status of the process.</p>
<p>Every 5s, ask for the status of the process.
If this changes w.r.t. of they way it was before, a signal is
emitted with the current status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34; Keep on asking for the status of the status of the process.

    Every 5s, ask for the status of the process.  If this changes w.r.t. of they way it was before, a signal is
    emitted with the current status.
    &#34;&#34;&#34;

    self.active = True
    last_time = time.time()

    while self.active:

        if time.time() - last_time &gt;= 5:

            is_running = self.module.send_request(&#34;status&#34;).get(&#34;status&#34;) == &#34;ACK&#34;

            if is_running != self.was_running_before:
                self.was_running_before = is_running
                self.is_running_signal.emit(is_running)

            elif self.start_stop_cs_button_clicked:

                for index in range(15):

                    # Check (max 15x) to see whether pressing the button had an effect

                    is_running = self.module.send_request(&#34;status&#34;).get(&#34;status&#34;) == &#34;ACK&#34;
                    if self.was_running_before != is_running:
                        break
                    time.sleep(2)

                    self.was_running_before = is_running
                    self.start_stop_cs_button_clicked = False
                    self.is_running_signal.emit(is_running)

            last_time = time.time()

        else:
            time.sleep(0.1)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessMonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on the monitoring port.</p>
<p>If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
to notify the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34; Start listening on the monitoring port.

    If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
    to notify the GUI.
    &#34;&#34;&#34;

    self.run()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget"><code class="flex name class">
<span>class <span class="ident">ProcessWidget</span></span>
<span>(</span><span>process_name, process_info, parent, include_start_stop_button=True)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a process widget.</p>
<p>For a Control Server with the given process name and Proxy type, a process widget is created.
This widget will
comprise the following components:</p>
<pre><code>- status LED;
- process name;
- button to start the GUI for the Control Server (if this has been
  configured in the YAML file with the "UserInterface" entry);
- button to start / shut down the Control Server (for devices only).
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>process_name: Name of the process (to display on the widget).</li>
<li>proxy_type: Type of Proxy (to check the status of the process).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessWidget(QGroupBox):

    def __init__(self, process_name, process_info, parent, include_start_stop_button=True):
        &#34;&#34;&#34; Initialisation of a process widget.

        For a Control Server with the given process name and Proxy type, a process widget is created.  This widget will
        comprise the following components:

            - status LED;
            - process name;
            - button to start the GUI for the Control Server (if this has been
              configured in the YAML file with the &#34;UserInterface&#34; entry);
            - button to start / shut down the Control Server (for devices only).

        Args:
            - process_name: Name of the process (to display on the widget).
            - proxy_type: Type of Proxy (to check the status of the process).
        &#34;&#34;&#34;

        super().__init__()

        self.process_name = process_name
        self.proxy_type = process_info[0]
        self.device_args = process_info[1]
        self.is_simulator_mode = False

        self.parent = parent

        layout = QGridLayout()

        index = 0

        # Status LED

        self.status_led = LED(parent=self)
        layout.addWidget(self.status_led, 0, index)
        index += 1

        # Process name

        self.process_name_label = QLabel(process_name)
        layout.addWidget(self.process_name_label, 0, index)
        layout.setColumnStretch(index, 1)   # Push LED and name to the left and buttons to the right
        index += 1

        # Fire up (default) GUI

        self.show_gui_button = TouchButton(name=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                           status_tip=f&#34;Open the GUI for the {self.process_name}.&#34;,
                                           selected=get_resource(&#34;:/icons/user-interface.svg&#34;)
                                           )
        self.show_gui_button.setFixedSize(30, 30)
        self.show_gui_button.clicked.connect(self.start_gui)

        module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
        module = importlib.import_module(module_name)

        if not process_name.startswith(&#34;AEU&#34;) or process_name == &#34;AEU cRIO&#34;:

            if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;UserInterface&#34;):
                layout.addWidget(self.show_gui_button, 0, index)
            elif hasattr(module, &#34;COMMAND_SETTINGS&#34;) and hasattr(module.COMMAND_SETTINGS, &#34;UserInterface&#34;):
                layout.addWidget(self.show_gui_button, 0, index)

        index += 1

        # Shut down / re-start

        if include_start_stop_button:

            self.start_stop_button = ToggleButton(name=f&#34;Start / shut down the {self.process_name} control server.&#34;,
                                                  status_tip=f&#34;Start / shut down the {self.process_name} control server.&#34;,
                                                  selected=get_resource(&#34;:/icons/play-green.svg&#34;),
                                                  not_selected=get_resource(&#34;:/icons/stop-red.svg&#34;),
                                                  disabled=[get_resource(&#34;:/icons/busy.svg&#34;),
                                                            get_resource(&#34;:/icons/busy.svg&#34;)]
                                                  )
            self.start_stop_button.clicked.connect(self.start_stop_cs)

            layout.addWidget(self.start_stop_button, 0, index)
            index += 1

            self.sim_option_button = ToggleButton(name=f&#34;Operational vs. simulator mode&#34;,
                                                  status_tip=f&#34;Indicate whether you want to start the &#34;
                                                             f&#34;{self.process_name} Control Server in operational or in &#34;
                                                             f&#34;simulator mode.&#34;,
                                                  selected=get_resource(&#34;:/icons/sim-mode.svg&#34;),
                                                  not_selected=get_resource(&#34;:/icons/ops-mode.svg&#34;),
                                                  disabled=[get_resource(&#34;:/icons/sim-mode.svg&#34;),
                                                            get_resource(&#34;:/icons/ops-mode.svg&#34;)]
                                                  )
            self.sim_option_button.set_selected(False)  # Default: operational mode
            self.sim_option_button.clicked.connect(self.set_cs_start_mode)

            if self.process_name == &#34;DAQ&#34;:

                self.start_stop_button.setToolTip(f&#34;Start / shut down the {self.process_name} control server and its &#34;
                                                  f&#34;data acquisition.&#34;)
                self.sim_option_button.setEnabled(False)    # Only in operational mode
                self.sim_option_button.setStatusTip(f&#34;The {self.process_name} and its data acquisition can only be&#34;
                                                    f&#34;started in operational mode.&#34;)

            if self.process_name == &#34;DPU&#34;:

                self.sim_option_button.setEnabled(False)    # Only in operational mode

            layout.addWidget(self.sim_option_button, 0, index)
            index += 1

        self.setLayout(layout)

    def start_gui(self):
        &#34;&#34;&#34; Starting the default GUI for the process.&#34;&#34;&#34;

        LOGGER.debug(f&#34;Starting GUI for {self.process_name}&#34;)

        module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
        module = importlib.import_module(module_name)

        if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;UserInterface&#34;):
            gui_type = module.DEVICE_SETTINGS.UserInterface     # Device CS
        elif hasattr(module, &#34;COMMAND_SETTINGS&#34;) and hasattr(module.COMMAND_SETTINGS, &#34;UserInterface&#34;):
            gui_type = module.COMMAND_SETTINGS.UserInterface    # Core CS
        else:   # No GUI defined in the YAML file of the CS
            LOGGER.debug(f&#34;No GUI available for {self.process_name}&#34;)
            return

        gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, gui_type])
        gui_process.execute(detach_from_parent=True)

    def set_cs_start_mode(self):
        &#34;&#34;&#34; Change the start mode for the Control Server.

        Change the start mode for the Control Server from simulator mode to operational mode, or vice versa.
        &#34;&#34;&#34;
        self.is_simulator_mode = not self.is_simulator_mode

    def start_stop_cs(self):
        &#34;&#34;&#34; Start or shut down the Control Server.

        Depending on the current state of the Control Server, it will either be started or shut down.
        &#34;&#34;&#34;

        self.sim_option_button.setEnabled(False)
        self.start_stop_button.setDisabled(True)

        if self.start_stop_button.is_selected():

            LOGGER.info(f&#34;Shut down the {self.process_name} Control Server&#34;)
            thread = threading.Thread(target=self.stop_cs)

        else:

            LOGGER.info(f&#34;Start the {self.process_name} Control Server&#34;)
            thread = threading.Thread(target=self.start_cs)

        thread.daemon = True
        thread.start()

        # Let the main UI window know that the start/stop button has been clicked
        self.parent.on_start_stop_cs_button_clicked(self.process_name)

    def start_cs(self):

        try:

            with ProcessManagerProxy() as pm:

                try:
                    pm.start_cs(self.process_name, self.is_simulator_mode)
                    self.sim_option_button.setDisabled(True)

                except ConnectionError:
                    LOGGER.info(f&#34;Could not start Control Server for {self.process_name}&#34;)
                    self.sim_option_button.setEnabled(True)

        except ConnectionError:

            LOGGER.critical(f&#34;Lost connection to Process Manager&#34;)

            self.sim_option_button.setEnabled(True)
            self.start_stop_button.setEnabled(True)
            self.start_stop_button.set_selected(True)

    def stop_cs(self):

        try:
            with ProcessManagerProxy() as pm:
                LOGGER.info(f&#34;PM: shut down {self.process_name}&#34;)
                pm.shut_down_cs(self.process_name)
                self.sim_option_button.setDisabled(False)

        except ConnectionError:

            LOGGER.critical(f&#34;Lost connection to Process Manager&#34;)
            self.sim_option_button.setEnabled(True)

    def set_led_color(self, color: int):
        &#34;&#34;&#34; Set the colour of the LED, representing the status of the process.

        The meaning of the colours is the following:

                - green:
                    - core process with running Control Server;
                    - device process in simulator mode with running Control Server;
                    - device process in operational mode with running Control Server and connection to the Controller;
                - orange: device process in operational mode with Control Server running but without connection to the
                  Controller;
                - red: no Control Server running.

        Args:
            - color: Integer representing the colour to indicate the process status.  Should only be Indic.GREEN,
                     Indic.ORANGE, or Indic.RED.
        &#34;&#34;&#34;

        self.status_led.set_color(color)

        try:
            self.start_stop_button.setDisabled(False)
        except AttributeError:
            # Core processes don&#39;t have this button
            pass

        if color != Indic.RED:
            try:
                self.sim_option_button.setEnabled(False)
                self.start_stop_button.set_selected(False)
            except AttributeError:
                # Core processes don&#39;t have this button
                pass

        else:
            try:
                self.sim_option_button.setEnabled(True)
                self.start_stop_button.set_selected(True)
            except AttributeError:
                # Core processes don&#39;t have this button
                pass

    def is_simulator_mode(self):
        &#34;&#34;&#34; Check whether the simulator mode checkbox was checked.

        Returns: True of the simulator mode checkbox was checked; False otherwise.
        &#34;&#34;&#34;

        return self.sim_option_button.is_selected()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.procman.procman_ui.ProcessWidget.is_simulator_mode"><code class="name flex">
<span>def <span class="ident">is_simulator_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the simulator mode checkbox was checked.</p>
<p>Returns: True of the simulator mode checkbox was checked; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulator_mode(self):
    &#34;&#34;&#34; Check whether the simulator mode checkbox was checked.

    Returns: True of the simulator mode checkbox was checked; False otherwise.
    &#34;&#34;&#34;

    return self.sim_option_button.is_selected()</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget.set_cs_start_mode"><code class="name flex">
<span>def <span class="ident">set_cs_start_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the start mode for the Control Server.</p>
<p>Change the start mode for the Control Server from simulator mode to operational mode, or vice versa.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cs_start_mode(self):
    &#34;&#34;&#34; Change the start mode for the Control Server.

    Change the start mode for the Control Server from simulator mode to operational mode, or vice versa.
    &#34;&#34;&#34;
    self.is_simulator_mode = not self.is_simulator_mode</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget.set_led_color"><code class="name flex">
<span>def <span class="ident">set_led_color</span></span>(<span>self, color: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the colour of the LED, representing the status of the process.</p>
<p>The meaning of the colours is the following:</p>
<pre><code>    - green:
        - core process with running Control Server;
        - device process in simulator mode with running Control Server;
        - device process in operational mode with running Control Server and connection to the Controller;
    - orange: device process in operational mode with Control Server running but without connection to the
      Controller;
    - red: no Control Server running.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>color: Integer representing the colour to indicate the process status.
Should only be Indic.GREEN,
Indic.ORANGE, or Indic.RED.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_led_color(self, color: int):
    &#34;&#34;&#34; Set the colour of the LED, representing the status of the process.

    The meaning of the colours is the following:

            - green:
                - core process with running Control Server;
                - device process in simulator mode with running Control Server;
                - device process in operational mode with running Control Server and connection to the Controller;
            - orange: device process in operational mode with Control Server running but without connection to the
              Controller;
            - red: no Control Server running.

    Args:
        - color: Integer representing the colour to indicate the process status.  Should only be Indic.GREEN,
                 Indic.ORANGE, or Indic.RED.
    &#34;&#34;&#34;

    self.status_led.set_color(color)

    try:
        self.start_stop_button.setDisabled(False)
    except AttributeError:
        # Core processes don&#39;t have this button
        pass

    if color != Indic.RED:
        try:
            self.sim_option_button.setEnabled(False)
            self.start_stop_button.set_selected(False)
        except AttributeError:
            # Core processes don&#39;t have this button
            pass

    else:
        try:
            self.sim_option_button.setEnabled(True)
            self.start_stop_button.set_selected(True)
        except AttributeError:
            # Core processes don&#39;t have this button
            pass</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget.start_cs"><code class="name flex">
<span>def <span class="ident">start_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_cs(self):

    try:

        with ProcessManagerProxy() as pm:

            try:
                pm.start_cs(self.process_name, self.is_simulator_mode)
                self.sim_option_button.setDisabled(True)

            except ConnectionError:
                LOGGER.info(f&#34;Could not start Control Server for {self.process_name}&#34;)
                self.sim_option_button.setEnabled(True)

    except ConnectionError:

        LOGGER.critical(f&#34;Lost connection to Process Manager&#34;)

        self.sim_option_button.setEnabled(True)
        self.start_stop_button.setEnabled(True)
        self.start_stop_button.set_selected(True)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget.start_gui"><code class="name flex">
<span>def <span class="ident">start_gui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starting the default GUI for the process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_gui(self):
    &#34;&#34;&#34; Starting the default GUI for the process.&#34;&#34;&#34;

    LOGGER.debug(f&#34;Starting GUI for {self.process_name}&#34;)

    module_name = self.proxy_type[7:].rsplit(&#34;.&#34;, 1)[0]
    module = importlib.import_module(module_name)

    if hasattr(module, &#34;DEVICE_SETTINGS&#34;) and hasattr(module.DEVICE_SETTINGS, &#34;UserInterface&#34;):
        gui_type = module.DEVICE_SETTINGS.UserInterface     # Device CS
    elif hasattr(module, &#34;COMMAND_SETTINGS&#34;) and hasattr(module.COMMAND_SETTINGS, &#34;UserInterface&#34;):
        gui_type = module.COMMAND_SETTINGS.UserInterface    # Core CS
    else:   # No GUI defined in the YAML file of the CS
        LOGGER.debug(f&#34;No GUI available for {self.process_name}&#34;)
        return

    gui_process = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, gui_type])
    gui_process.execute(detach_from_parent=True)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget.start_stop_cs"><code class="name flex">
<span>def <span class="ident">start_stop_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start or shut down the Control Server.</p>
<p>Depending on the current state of the Control Server, it will either be started or shut down.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_stop_cs(self):
    &#34;&#34;&#34; Start or shut down the Control Server.

    Depending on the current state of the Control Server, it will either be started or shut down.
    &#34;&#34;&#34;

    self.sim_option_button.setEnabled(False)
    self.start_stop_button.setDisabled(True)

    if self.start_stop_button.is_selected():

        LOGGER.info(f&#34;Shut down the {self.process_name} Control Server&#34;)
        thread = threading.Thread(target=self.stop_cs)

    else:

        LOGGER.info(f&#34;Start the {self.process_name} Control Server&#34;)
        thread = threading.Thread(target=self.start_cs)

    thread.daemon = True
    thread.start()

    # Let the main UI window know that the start/stop button has been clicked
    self.parent.on_start_stop_cs_button_clicked(self.process_name)</code></pre>
</details>
</dd>
<dt id="egse.procman.procman_ui.ProcessWidget.stop_cs"><code class="name flex">
<span>def <span class="ident">stop_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_cs(self):

    try:
        with ProcessManagerProxy() as pm:
            LOGGER.info(f&#34;PM: shut down {self.process_name}&#34;)
            pm.shut_down_cs(self.process_name)
            self.sim_option_button.setDisabled(False)

    except ConnectionError:

        LOGGER.critical(f&#34;Lost connection to Process Manager&#34;)
        self.sim_option_button.setEnabled(True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.procman" href="index.html">egse.procman</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="egse.procman.procman_ui.main" href="#egse.procman.procman_ui.main">main</a></code></li>
<li><code><a title="egse.procman.procman_ui.start_egse" href="#egse.procman.procman_ui.start_egse">start_egse</a></code></li>
<li><code><a title="egse.procman.procman_ui.start_fitsgen" href="#egse.procman.procman_ui.start_fitsgen">start_fitsgen</a></code></li>
<li><code><a title="egse.procman.procman_ui.start_fov_hk" href="#egse.procman.procman_ui.start_fov_hk">start_fov_hk</a></code></li>
<li><code><a title="egse.procman.procman_ui.start_n_fee_hk" href="#egse.procman.procman_ui.start_n_fee_hk">start_n_fee_hk</a></code></li>
<li><code><a title="egse.procman.procman_ui.stop_egse" href="#egse.procman.procman_ui.stop_egse">stop_egse</a></code></li>
<li><code><a title="egse.procman.procman_ui.stop_fitsgen" href="#egse.procman.procman_ui.stop_fitsgen">stop_fitsgen</a></code></li>
<li><code><a title="egse.procman.procman_ui.stop_fov_hk" href="#egse.procman.procman_ui.stop_fov_hk">stop_fov_hk</a></code></li>
<li><code><a title="egse.procman.procman_ui.stop_n_fee_hk" href="#egse.procman.procman_ui.stop_n_fee_hk">stop_n_fee_hk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker">ConfigurationMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker.connect_socket" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker.has_setup" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker.has_setup">has_setup</a></code></li>
<li><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker.obsid_changed_signal" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker.obsid_changed_signal">obsid_changed_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker.run" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker.setup_changed_signal" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker.setup_changed_signal">setup_changed_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ConfigurationMonitoringWorker.start_process" href="#egse.procman.procman_ui.ConfigurationMonitoringWorker.start_process">start_process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES" href="#egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES">FILE_GENERATION_PROCESS_NAMES</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.FITSGEN" href="#egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.FITSGEN">FITSGEN</a></code></li>
<li><code><a title="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.FOV_HK" href="#egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.FOV_HK">FOV_HK</a></code></li>
<li><code><a title="egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.N_FEE_HK" href="#egse.procman.procman_ui.FILE_GENERATION_PROCESS_NAMES.N_FEE_HK">N_FEE_HK</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.FitsgenWidget" href="#egse.procman.procman_ui.FitsgenWidget">FitsgenWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.FitsgenWidget.start_gui" href="#egse.procman.procman_ui.FitsgenWidget.start_gui">start_gui</a></code></li>
<li><code><a title="egse.procman.procman_ui.FitsgenWidget.start_service" href="#egse.procman.procman_ui.FitsgenWidget.start_service">start_service</a></code></li>
<li><code><a title="egse.procman.procman_ui.FitsgenWidget.stop_service" href="#egse.procman.procman_ui.FitsgenWidget.stop_service">stop_service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.FovHkWidget" href="#egse.procman.procman_ui.FovHkWidget">FovHkWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.FovHkWidget.start_service" href="#egse.procman.procman_ui.FovHkWidget.start_service">start_service</a></code></li>
<li><code><a title="egse.procman.procman_ui.FovHkWidget.stop_service" href="#egse.procman.procman_ui.FovHkWidget.stop_service">stop_service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.LogWidget" href="#egse.procman.procman_ui.LogWidget">LogWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.LogWidget.start_gui" href="#egse.procman.procman_ui.LogWidget.start_gui">start_gui</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.MonitoringWorker" href="#egse.procman.procman_ui.MonitoringWorker">MonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.MonitoringWorker.connect_socket" href="#egse.procman.procman_ui.MonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.procman.procman_ui.MonitoringWorker.get_device_process_status" href="#egse.procman.procman_ui.MonitoringWorker.get_device_process_status">get_device_process_status</a></code></li>
<li><code><a title="egse.procman.procman_ui.MonitoringWorker.process_status_signal" href="#egse.procman.procman_ui.MonitoringWorker.process_status_signal">process_status_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.MonitoringWorker.run" href="#egse.procman.procman_ui.MonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.procman.procman_ui.MonitoringWorker.start_process" href="#egse.procman.procman_ui.MonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.procman.procman_ui.MonitoringWorker.stop" href="#egse.procman.procman_ui.MonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.NFeeHkWidget" href="#egse.procman.procman_ui.NFeeHkWidget">NFeeHkWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.NFeeHkWidget.start_service" href="#egse.procman.procman_ui.NFeeHkWidget.start_service">start_service</a></code></li>
<li><code><a title="egse.procman.procman_ui.NFeeHkWidget.stop_service" href="#egse.procman.procman_ui.NFeeHkWidget.stop_service">stop_service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.NonCSProcessWidget" href="#egse.procman.procman_ui.NonCSProcessWidget">NonCSProcessWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.NonCSProcessWidget.set_led_color" href="#egse.procman.procman_ui.NonCSProcessWidget.set_led_color">set_led_color</a></code></li>
<li><code><a title="egse.procman.procman_ui.NonCSProcessWidget.start_stop_service" href="#egse.procman.procman_ui.NonCSProcessWidget.start_stop_service">start_stop_service</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.ProcessManagerUIController" href="#egse.procman.procman_ui.ProcessManagerUIController">ProcessManagerUIController</a></code></h4>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.ProcessManagerUIModel" href="#egse.procman.procman_ui.ProcessManagerUIModel">ProcessManagerUIModel</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIModel.is_connected" href="#egse.procman.procman_ui.ProcessManagerUIModel.is_connected">is_connected</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.ProcessManagerUIView" href="#egse.procman.procman_ui.ProcessManagerUIView">ProcessManagerUIView</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.closeEvent" href="#egse.procman.procman_ui.ProcessManagerUIView.closeEvent">closeEvent</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.create_overview_widget_core" href="#egse.procman.procman_ui.ProcessManagerUIView.create_overview_widget_core">create_overview_widget_core</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.create_overview_widget_file_services" href="#egse.procman.procman_ui.ProcessManagerUIView.create_overview_widget_file_services">create_overview_widget_file_services</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.create_statusbar" href="#egse.procman.procman_ui.ProcessManagerUIView.create_statusbar">create_statusbar</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.create_toolbar" href="#egse.procman.procman_ui.ProcessManagerUIView.create_toolbar">create_toolbar</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.init_ui" href="#egse.procman.procman_ui.ProcessManagerUIView.init_ui">init_ui</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_fitsgen_is_running_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_fitsgen_is_running_signal">on_fitsgen_is_running_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_fov_hk_is_running_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_fov_hk_is_running_signal">on_fov_hk_is_running_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_logger_is_running_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_logger_is_running_signal">on_logger_is_running_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_n_fee_hk_is_running_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_n_fee_hk_is_running_signal">on_n_fee_hk_is_running_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_obsid_changed_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_obsid_changed_signal">on_obsid_changed_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_process_status_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_process_status_signal">on_process_status_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_setup_changed_signal" href="#egse.procman.procman_ui.ProcessManagerUIView.on_setup_changed_signal">on_setup_changed_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_start_stop_cs_button_clicked" href="#egse.procman.procman_ui.ProcessManagerUIView.on_start_stop_cs_button_clicked">on_start_stop_cs_button_clicked</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.on_start_stop_non_cs_process_button_clicked" href="#egse.procman.procman_ui.ProcessManagerUIView.on_start_stop_non_cs_process_button_clicked">on_start_stop_non_cs_process_button_clicked</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.set_process_list" href="#egse.procman.procman_ui.ProcessManagerUIView.set_process_list">set_process_list</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.start_all_aeu_cs" href="#egse.procman.procman_ui.ProcessManagerUIView.start_all_aeu_cs">start_all_aeu_cs</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.start_egse" href="#egse.procman.procman_ui.ProcessManagerUIView.start_egse">start_egse</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.start_monitoring" href="#egse.procman.procman_ui.ProcessManagerUIView.start_monitoring">start_monitoring</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.stop_all_aeu_cs" href="#egse.procman.procman_ui.ProcessManagerUIView.stop_all_aeu_cs">stop_all_aeu_cs</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessManagerUIView.stop_egse" href="#egse.procman.procman_ui.ProcessManagerUIView.stop_egse">stop_egse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.ProcessMonitoringWorker" href="#egse.procman.procman_ui.ProcessMonitoringWorker">ProcessMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.procman.procman_ui.ProcessMonitoringWorker.is_running_signal" href="#egse.procman.procman_ui.ProcessMonitoringWorker.is_running_signal">is_running_signal</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessMonitoringWorker.run" href="#egse.procman.procman_ui.ProcessMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessMonitoringWorker.start_process" href="#egse.procman.procman_ui.ProcessMonitoringWorker.start_process">start_process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.procman.procman_ui.ProcessWidget" href="#egse.procman.procman_ui.ProcessWidget">ProcessWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.procman.procman_ui.ProcessWidget.is_simulator_mode" href="#egse.procman.procman_ui.ProcessWidget.is_simulator_mode">is_simulator_mode</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessWidget.set_cs_start_mode" href="#egse.procman.procman_ui.ProcessWidget.set_cs_start_mode">set_cs_start_mode</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessWidget.set_led_color" href="#egse.procman.procman_ui.ProcessWidget.set_led_color">set_led_color</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessWidget.start_cs" href="#egse.procman.procman_ui.ProcessWidget.start_cs">start_cs</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessWidget.start_gui" href="#egse.procman.procman_ui.ProcessWidget.start_gui">start_gui</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessWidget.start_stop_cs" href="#egse.procman.procman_ui.ProcessWidget.start_stop_cs">start_stop_cs</a></code></li>
<li><code><a title="egse.procman.procman_ui.ProcessWidget.stop_cs" href="#egse.procman.procman_ui.ProcessWidget.stop_cs">stop_cs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.gui.focalplane API documentation</title>
<meta name="description" content="This modules yields to widgets in which the focal plane is visualised.
The combobox
below the plot can be used to choose the coordinate system used â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.gui.focalplane</code></h1>
</header>
<section id="section-intro">
<p>This modules yields to widgets in which the focal plane is visualised.
The combobox
below the plot can be used to choose the coordinate system used in the plot: focal-plane
coordinates, pixel coordinates, and field angles.
A blue cirle denotes the edge of the
FOV.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This modules yields to widgets in which the focal plane is visualised.  The combobox
below the plot can be used to choose the coordinate system used in the plot: focal-plane
coordinates, pixel coordinates, and field angles.  A blue cirle denotes the edge of the
FOV.
&#34;&#34;&#34;
import logging
from math import atan
from math import degrees
from math import radians

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QComboBox
from PyQt5.QtWidgets import QGridLayout
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QSizePolicy
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from egse.coordinates import ccd_to_focal_plane_coordinates
from egse.coordinates import focal_plane_coordinates_to_angles
from egse.gui.formatter import degree_formatter
from egse.settings import Settings
from egse.state import GlobalState

FONT = QFont(&#34;Helvetica&#34;, 18)

FOV_SETTINGS = Settings.load(&#34;Field-Of-View&#34;)
MODULE_LOGGER = logging.getLogger(__name__)

COORDINATE_SYSTEMS = {
    &#34;Focal plane&#34;: &#34;Focal-plane coordinates [mm]&#34;,
    &#34;Pixels&#34;: &#34;Pixel coordinates&#34;,
    &#34;Angles&#34;: &#34;Angles&#34;
}

PIXEL_SIZE = CCD_SETTINGS = Settings.load(&#34;CCD&#34;).PIXEL_SIZE / 1000     # Pixel size [mm]
ZEROPOINT = Settings.load(&#34;CCD&#34;).ZEROPOINT          # CCD zeropoint (x, y) [mm]
NUM_ROWS = Settings.load(&#34;CCD&#34;).NUM_ROWS
NUM_COLUMNS = Settings.load(&#34;CCD&#34;).NUM_COLUMNS


class FocalPlane(FigureCanvas):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].
    &#34;&#34;&#34;

    def __init__(self, parent=None, dpi=100):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;
        self.fee_side = GlobalState.setup.camera.fee.ccd_sides.enum
        self.ccd_id = GlobalState.setup.camera.fee.ccd_numbering.CCD_ID

        self.figure = Figure()
        self.ax = self.figure.add_subplot(111)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.

        The draw() method should be called in the sub-classes.
        &#34;&#34;&#34;

        self.coordinate_system = COORDINATE_SYSTEMS[&#34;Focal plane&#34;]

        self.figure.delaxes(self.ax)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_aspect(1)

        # Circle indicating the size of the FOV [mm]

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_MM, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
        self.ax.add_artist(self.circle)

        # Range

        limit = 85
        self.ax.set_xlim([-limit, limit])
        self.ax.set_ylim([-limit, limit])

        self.ax.set_xlabel(&#34;$x_{FP} [mm]$&#34;, fontsize=10)
        self.ax.xaxis.set_label_coords(1.085, 0.45)
        self.ax.set_ylabel(&#34;$y_{FP} [mm]$&#34;, fontsize=10, rotation=0)
        self.ax.yaxis.set_label_coords(0.47, 1.05)

        # Make sure the axes cross at the origin

        self.ax.axvline(x=0, color=&#34;k&#34;, linewidth=1)
        self.ax.axhline(y=0, color=&#34;k&#34;, linewidth=1)

        self.ax.spines[&#39;left&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
        self.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)

        xmin, xmax = self.ax.get_xlim()
        ymin, ymax = self.ax.get_ylim()

        self.ax.arrow(xmin, 0, xmax-xmin+7, 0., fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3, head_length=5, overhang=0.3,
                      length_includes_head=True, clip_on=False)

        self.ax.arrow(0, ymin, 0., ymax-ymin+7, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3, head_length=5, overhang=0.3,
                      length_includes_head=True, clip_on=False)

        # Readout registers

        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1]], [-ZEROPOINT[1], -
                                                     ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)   # Upper left CCD
        self.ax.plot([ZEROPOINT[1], ZEROPOINT[1]], [-ZEROPOINT[0],
                                                    ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)    # Lower left CCD
        self.ax.plot([ZEROPOINT[0], -ZEROPOINT[1]], [ZEROPOINT[1],
                                                     ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)   # Lower right CCD
        self.ax.plot([-ZEROPOINT[1], -ZEROPOINT[1]], [ZEROPOINT[0], -
                                                      ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)  # Upper right CCD

        # CCD middle

        self.ax.plot([ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE, ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE],
                     [-ZEROPOINT[0], ZEROPOINT[1]], color=&#34;k&#34;, linewidth=1,
                     linestyle=&#34;dotted&#34;)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0]],
                     [ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE, ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE, -ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE],
                     [-ZEROPOINT[1], ZEROPOINT[0]], color=&#34;k&#34;, linewidth=1,
                     linestyle=&#34;dotted&#34;)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1]],
                     [-ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE, -ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper right CCD

        # CCD codes

        self.ax.text(-80, 70, self.ccd_id[2])     # Upper left CCD
        self.ax.text(-80, -75, self.ccd_id[3])    # Lower left CCD
        self.ax.text(60, -75, self.ccd_id[0])     # Lower right CCD
        self.ax.text(60, 70, self.ccd_id[1])      # Upper right CCD

        self.ax.text(-30, 10, self.fee_side.LEFT_SIDE.name, rotation=180)       # Upper leftCCD, left side
        self.ax.text(-75, 10, self.fee_side.RIGHT_SIDE.name, rotation=180)      # Upper left CCD, right side
        self.ax.text(-20, -15, self.fee_side.LEFT_SIDE.name, rotation=-90)      # Lower left CCD, left side
        self.ax.text(-20, -75, self.fee_side.RIGHT_SIDE.name, rotation=-90)     # Lower left CCD, right side
        self.ax.text(10, -15, self.fee_side.LEFT_SIDE.name)                     # Lower right CCD, left side
        self.ax.text(50, -15, self.fee_side.RIGHT_SIDE.name)                    # Lower right CCD, right side
        self.ax.text(10, 10, self.fee_side.LEFT_SIDE.name, rotation=90)         # Upper right CCD, left side
        self.ax.text(10, 50, self.fee_side.RIGHT_SIDE.name, rotation=90)        # Upper right CCD, right side

        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0], -ZEROPOINT[0]],
                     [ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1], ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0], -ZEROPOINT[0]],
                     [-ZEROPOINT[0], - ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1]],
                     [-ZEROPOINT[0], - ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1]],
                     [ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1], ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Upper right CCD

        # Grid lines

        self.ax.grid(color=&#34;lightgray&#34;, linewidth=0.5)

        ticks = np.arange(-80, 90, 20)
        ticks = np.delete(ticks, 4)
        self.ax.set_xticks(ticks)
        self.ax.set_yticks(ticks)

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.

        The draw() method should be called in the sub-classes.
        &#34;&#34;&#34;

        self.coordinate_system = COORDINATE_SYSTEMS[&#34;Pixels&#34;]

        self.figure.delaxes(self.ax)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_aspect(1)

        # Circle indicating the size of the FOV [mm]

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_PIXELS, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
        self.ax.add_artist(self.circle)

        # Range
        # If we do it like this, the circle will have the same size on screen when
        # switching between coordinate systems

        limit = 85 / PIXEL_SIZE
        self.ax.set_xlim([-limit, limit])
        self.ax.set_ylim([-limit, limit])

        self.ax.set_xlabel(&#34;$x_{CCD} [pixels]$&#34;, fontsize=10)
        self.ax.xaxis.set_label_coords(1.085, 0.45)
        self.ax.set_ylabel(&#34;$y_{CCD} [pixels]$&#34;, fontsize=10, rotation=0)
        self.ax.yaxis.set_label_coords(0.47, 1.05)

        # Make sure the axes cross at the origin

        self.ax.axvline(x=0, color=&#34;k&#34;, linewidth=1)
        self.ax.axhline(y=0, color=&#34;k&#34;, linewidth=1)

        self.ax.spines[&#39;left&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
        self.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)

        xmin, xmax = self.ax.get_xlim()
        ymin, ymax = self.ax.get_ylim()

        self.ax.arrow(xmin, 0, xmax-xmin+7/PIXEL_SIZE, 0., fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3/PIXEL_SIZE, head_length=5/PIXEL_SIZE,
                      length_includes_head=True, clip_on=False)

        self.ax.arrow(0, ymin, 0., ymax-ymin+7/PIXEL_SIZE, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3/PIXEL_SIZE, head_length=5/PIXEL_SIZE, overhang=0.3,
                      length_includes_head=True, clip_on=False)

        # Readout registers

        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)  # Upper left CCD
        self.ax.plot([ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)    # Lower left CCD
        self.ax.plot([ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)    # Lower right CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)  # Upper right CCD

        # CCD middle

        self.ax.plot([ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2, ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2],
                     [-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2, ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2, -ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2],
                     [-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2, -ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper right CCD

        # CCD codes

        self.ax.text(-80 / PIXEL_SIZE, 70 / PIXEL_SIZE, self.ccd_id[2])     # Upper left CCD
        self.ax.text(-80 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.ccd_id[3])    # Lower left CCD
        self.ax.text(60 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.ccd_id[0])     # Lower right CCD
        self.ax.text(60 / PIXEL_SIZE, 70 / PIXEL_SIZE, self.ccd_id[1])      # Upper right CCD

        self.ax.text(-30 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=180)     # Upper left CCD, left side
        self.ax.text(-75 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=180)    # Upper left CCD, right side
        self.ax.text(-20 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=-90)    # Lower left CCD, left side
        self.ax.text(-20 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=-90)   # Lower left CCD, right side
        self.ax.text(10 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name)   # Lower right CCD, left side
        self.ax.text(50 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name)  # Lower right CCD, right side
        self.ax.text(10 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=90)   # Upper right CCD, left side
        self.ax.text(10 / PIXEL_SIZE, 50 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=90)  # Upper right CCD, right side

        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Upper right CCD

        # Grid lines

        ticks = np.arange(-4000, 5000, 1000)
        ticks = np.delete(ticks, 4)
        self.ax.set_xticks(ticks)
        self.ax.set_yticks(ticks)
        self.ax.grid(color=&#34;lightgray&#34;, linewidth=0.5)

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.

        The draw() method should be called in the sub-classes.
        &#34;&#34;&#34;

        self.coordinate_system = COORDINATE_SYSTEMS[&#34;Angles&#34;]

        self.figure.delaxes(self.ax)
        self.ax = self.figure.add_subplot(111, projection=&#34;polar&#34;)
        self.ax.set_aspect(1)

        # Circle indicating the size of the FOV [mm]

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_DEGREES, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1,
            transform=self.ax.transData._b)
        self.ax.add_artist(self.circle)

        # Range
        # If we do it like this, the circle will have the same size on screen when
        # switching between coordinate systems

        limit = degrees(atan(85 / FOV_SETTINGS.FOCAL_LENGTH))

        self.ax.set_rlim([0, limit])

        # CCD codes

        theta, phi = focal_plane_coordinates_to_angles(-30, 10)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=180)      # Upper left CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(-75, 10)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=180)     # Upper left CCD, right side
        theta, phi = focal_plane_coordinates_to_angles(-20, -15)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=-90)      # Lower left CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(-20, -75)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=-90)     # Lower left CCD, right side
        theta, phi = focal_plane_coordinates_to_angles(10, -15)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name)                    # Lower right CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(50, -15)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name)                   # Lower right CCD, right side
        theta, phi = focal_plane_coordinates_to_angles(10, 10)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=90)       # Upper right CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(10, 50)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=90)      # Upper right CCD, right side

        self.ax.text(radians(135), 22, self.ccd_id[2], ha=&#34;center&#34;)              # Upper left CCD
        self.ax.text(radians(-135), 22, self.ccd_id[3], ha=&#34;center&#34;, va=&#34;top&#34;)   # Lower left CCD
        self.ax.text(radians(-45), 22, self.ccd_id[0], ha=&#34;center&#34;, va=&#34;top&#34;)    # Lower right CCD
        self.ax.text(radians(45), 22, self.ccd_id[1], ha=&#34;center&#34;)               # Upper right CCD

        (theta1_ccd1, phi1_ccd1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], -ZEROPOINT[1])
        (theta2_ccd1, phi2_ccd1) = focal_plane_coordinates_to_angles(ZEROPOINT[1], -ZEROPOINT[1])
        (theta3_ccd1, phi3_ccd1) = focal_plane_coordinates_to_angles(ZEROPOINT[1], ZEROPOINT[0])
        (theta4_ccd1, phi4_ccd1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], ZEROPOINT[0])

        phi1_ccd1 = radians(phi1_ccd1)
        phi2_ccd1 = radians(phi2_ccd1)
        phi3_ccd1 = radians(phi3_ccd1)
        phi4_ccd1 = radians(phi4_ccd1)

        self.ax.plot([phi1_ccd1, phi2_ccd1], [theta1_ccd1, theta2_ccd1], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd1, phi2_ccd1, phi3_ccd1, phi4_ccd1, phi1_ccd1],
                     [theta1_ccd1, theta2_ccd1, theta3_ccd1, theta4_ccd1, theta1_ccd1], color=&#34;k&#34;, linewidth=1)

        (theta1_ccd2, phi1_ccd2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], -ZEROPOINT[0])
        (theta2_ccd2, phi2_ccd2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], ZEROPOINT[1])
        (theta3_ccd2, phi3_ccd2) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], ZEROPOINT[1])
        (theta4_ccd2, phi4_ccd2) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], -ZEROPOINT[0])

        phi1_ccd2 = radians(phi1_ccd2)
        phi2_ccd2 = radians(phi2_ccd2)
        phi3_ccd2 = radians(phi3_ccd2)
        phi4_ccd2 = radians(phi4_ccd2)

        self.ax.plot([phi1_ccd2, phi2_ccd2], [theta1_ccd2, theta2_ccd2], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd2, phi2_ccd2, phi3_ccd2, phi4_ccd2, phi1_ccd2],
                     [theta1_ccd2, theta2_ccd2, theta3_ccd2, theta4_ccd2, theta1_ccd2], color=&#34;k&#34;, linewidth=1)

        (theta1_ccd3, phi1_ccd3) = focal_plane_coordinates_to_angles(ZEROPOINT[0], ZEROPOINT[1])
        (theta2_ccd3, phi2_ccd3) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], ZEROPOINT[1])
        (theta3_ccd3, phi3_ccd3) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -ZEROPOINT[0])
        (theta4_ccd3, phi4_ccd3) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -ZEROPOINT[0])

        phi1_ccd3 = radians(phi1_ccd3)
        phi2_ccd3 = radians(phi2_ccd3)
        phi3_ccd3 = radians(phi3_ccd3)
        phi4_ccd3 = radians(phi4_ccd3)

        self.ax.plot([phi1_ccd3, phi2_ccd3], [theta1_ccd3, theta2_ccd3], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd3, phi2_ccd3, phi3_ccd3, phi4_ccd3, phi1_ccd3],
                     [theta1_ccd3, theta2_ccd3, theta3_ccd3, theta4_ccd3, theta1_ccd3], color=&#34;k&#34;, linewidth=1)

        (theta1_ccd4, phi1_ccd4) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], ZEROPOINT[0])
        (theta2_ccd4, phi2_ccd4) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -ZEROPOINT[1])
        (theta3_ccd4, phi3_ccd4) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -ZEROPOINT[1])
        (theta4_ccd4, phi4_ccd4) = focal_plane_coordinates_to_angles(ZEROPOINT[0], ZEROPOINT[0])

        phi1_ccd4 = radians(phi1_ccd4)
        phi2_ccd4 = radians(phi2_ccd4)
        phi3_ccd4 = radians(phi3_ccd4)
        phi4_ccd4 = radians(phi4_ccd4)

        self.ax.plot([phi1_ccd4, phi2_ccd4], [theta1_ccd4, theta2_ccd4], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd4, phi2_ccd4, phi3_ccd4, phi4_ccd4, phi1_ccd4],
                     [theta1_ccd4, theta2_ccd4, theta3_ccd4, theta4_ccd4, theta1_ccd4], color=&#34;k&#34;, linewidth=1)

        # CCD middle

        (theta1, phi1) = focal_plane_coordinates_to_angles((ZEROPOINT[1] - ZEROPOINT[0]) / 2, -ZEROPOINT[1])
        (theta2, phi2) = focal_plane_coordinates_to_angles((ZEROPOINT[1] - ZEROPOINT[0]) / 2, ZEROPOINT[0])
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Upper left CCD

        (theta1, phi1) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -(ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        (theta2, phi2) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -(ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Lower left CCD

        (theta1, phi1) = focal_plane_coordinates_to_angles(-(ZEROPOINT[1] - ZEROPOINT[0]) / 2, ZEROPOINT[1])
        (theta2, phi2) = focal_plane_coordinates_to_angles(-(ZEROPOINT[1] - ZEROPOINT[0]) / 2, -ZEROPOINT[0])
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Lower right CCD

        (theta1, phi1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], (ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        (theta2, phi2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], (ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Uoper right CCD

        # Grid lines

        tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.]
        for t in np.deg2rad(np.arange(0, 360, 15)):
            self.ax.plot([t, t], tick, lw=0.72, color=&#34;lightgray&#34;)

        tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.]
        for t in np.deg2rad(np.arange(0, 360, 45)):
            self.ax.plot([t, t], tick, lw=0.72, color=&#34;k&#34;)

        ticks = np.arange(2, 20, 2)
        self.ax.set_rticks(ticks)

        self.ax.yaxis.set_major_formatter(
            ticker.FuncFormatter(degree_formatter))


class FocalPlaneWithSubField(FocalPlane):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the position of the sub-field on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;

        super(FocalPlaneWithSubField, self).__init__()

        self.subfield_is_drawn = False
        self.ccd_code = None
        self.zeropoint_row = None
        self.zeropoint_column = None
        self.num_rows = None
        self.num_columns = None

        self.change_to_pixel_coordinates()

    def set_subfield(self, ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None):

        &#34;&#34;&#34;
        First-time drawing of the sub-field (in pixel coordinates).  All information is stored in
        variables and the sub-field is shown as a red rectangle on the focal plane.

        :param ccd_code: Code of the CCD on which the sub-field is located.

        :param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
                              of the given CCD [pixels].

        :param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
                                 of the given CCD [pixels].

        :param num_rows: Number of rows in the sub-field [pixels].

        :param num_columns: Number of columns in the sub-field [pixels].
        &#34;&#34;&#34;

        self.ccd_code = ccd_code
        self.zeropoint_row = zeropoint_row
        self.zeropoint_column = zeropoint_column
        self.num_rows = num_rows
        self.num_columns = num_columns

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:
            self.change_to_focal_plane_coordinates
        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:
            self.change_to_pixel_coordinates()
        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:
            self.change_to_angle_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the sub-field (if any).
        &#34;&#34;&#34;

        super().change_to_pixel_coordinates()
        self.subfield_is_drawn = False

        self.update_subfield()

        self.draw()

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the sub-field (if any).
        &#34;&#34;&#34;

        super().change_to_focal_plane_coordinates()
        self.subfield_is_drawn = False

        self.update_subfield()

        self.draw()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the sub-field (if any).
        &#34;&#34;&#34;

        super().change_to_angle_coordinates()
        self.subfield_is_drawn = False

        self.update_subfield()

        self.draw()

    def update_subfield(self):

        # Remove the sub-field (if needed)

        if self.subfield_is_drawn:

            del self.ax.lines[-1]
            self.subfield_is_drawn = False

        if self.ccd_code is None:
            self.draw()
            return

        # Draw the sub-field

        (x_fp_1, y_fp_1) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row, self.zeropoint_column, self.ccd_code)
        (x_fp_2, y_fp_2) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row + self.num_rows, self.zeropoint_column, self.ccd_code)
        (x_fp_3, y_fp_3) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row + self.num_rows, self.zeropoint_column + self.num_columns, self.ccd_code)
        (x_fp_4, y_fp_4) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row, self.zeropoint_column + self.num_columns, self.ccd_code)

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.ax.plot([x_fp_1, x_fp_2], [y_fp_1, y_fp_2], &#34;r-&#34;)
            self.ax.plot([x_fp_2, x_fp_3], [y_fp_2, y_fp_3], &#34;r-&#34;)
            self.ax.plot([x_fp_3, x_fp_4], [y_fp_3, y_fp_4], &#34;r-&#34;)
            self.ax.plot([x_fp_4, x_fp_1], [y_fp_4, y_fp_1], &#34;r-&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.ax.plot([x_fp_1 / PIXEL_SIZE, x_fp_2 / PIXEL_SIZE], [y_fp_1 / PIXEL_SIZE, y_fp_2 / PIXEL_SIZE], &#34;r-&#34;)
            self.ax.plot([x_fp_2 / PIXEL_SIZE, x_fp_3 / PIXEL_SIZE], [y_fp_2 / PIXEL_SIZE, y_fp_3 / PIXEL_SIZE], &#34;r-&#34;)
            self.ax.plot([x_fp_3 / PIXEL_SIZE, x_fp_4 / PIXEL_SIZE], [y_fp_3 / PIXEL_SIZE, y_fp_4 / PIXEL_SIZE], &#34;r-&#34;)
            self.ax.plot([x_fp_4 / PIXEL_SIZE, x_fp_1 / PIXEL_SIZE], [y_fp_4 / PIXEL_SIZE, y_fp_1 / PIXEL_SIZE], &#34;r-&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            (theta1, phi1) = focal_plane_coordinates_to_angles(x_fp_1, y_fp_1)
            (theta2, phi2) = focal_plane_coordinates_to_angles(x_fp_2, y_fp_2)
            (theta3, phi3) = focal_plane_coordinates_to_angles(x_fp_3, y_fp_3)
            (theta4, phi4) = focal_plane_coordinates_to_angles(x_fp_4, y_fp_4)

            phi1 = radians(phi1)
            phi2 = radians(phi2)
            phi3 = radians(phi3)
            phi4 = radians(phi4)

            self.ax.plot([phi1, phi2], [theta1, theta2], &#34;r-&#34;)
            self.ax.plot([phi2, phi3], [theta2, theta3], &#34;r-&#34;)
            self.ax.plot([phi3, phi4], [theta3, theta4], &#34;r-&#34;)
            self.ax.plot([phi4, phi1], [theta4, theta1], &#34;r-&#34;)

        self.subfield_is_drawn = True

        self.draw()


class FocalPlaneWithSourcePosition(FocalPlane):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the source position on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;

        super(FocalPlaneWithSourcePosition, self).__init__()

        self.source_position_is_drawn = False
        self.x_fp = None
        self.y_fp = None

        self.change_to_pixel_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the source position (if any).
        &#34;&#34;&#34;

        super().change_to_pixel_coordinates()
        self.source_position_is_drawn = False

        self.update_source_position(self.x_fp, self.y_fp)

        self.draw()

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the source position (if any).
        &#34;&#34;&#34;

        super().change_to_focal_plane_coordinates()
        self.source_position_is_drawn = False

        self.update_source_position(self.x_fp, self.y_fp)

        self.draw()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the source position (if any).
        &#34;&#34;&#34;

        super().change_to_angle_coordinates()
        self.source_position_is_drawn = False

        self.update_source_position(self.x_fp, self.y_fp)

        self.draw()

    def update_source_position(self, x_fp, y_fp):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates. In case
        a source position had been marked before, that red dot must be removed first.

        :param x_fp: Focal-plane x-coordinate of the new source position [mm].

        :param y_fp: Focal-plane y-coordinate of the new source position [mm].
        &#34;&#34;&#34;

        # Remove the previously visited location (if needed)

        if self.source_position_is_drawn:

            del self.ax.lines[-1]
            self.source_position_is_drawn = False

        if (x_fp is None) or (y_fp is None):
            return

        # Outside the FOV

        if abs(x_fp) &gt; FOV_SETTINGS.RADIUS_MM and abs(y_fp) &gt; FOV_SETTINGS.RADIUS_MM:

            self.ax.plot([0], [0], color=&#34;white&#34;)

        # Put a red dot at the new source position

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.ax.plot([x_fp], [y_fp], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.ax.plot([x_fp / PIXEL_SIZE], [y_fp / PIXEL_SIZE], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            (theta, phi) = focal_plane_coordinates_to_angles(x_fp, y_fp)

            self.ax.plot([radians(phi)], [theta], &#34;ro&#34;)

        self.source_position_is_drawn = True
        self.x_fp = x_fp
        self.y_fp = y_fp

        self.draw()


class FocalPlaneWithVisitedPositions(FocalPlane):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the visited positions of the sub-field on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;

        super(FocalPlaneWithVisitedPositions, self).__init__()

        self.visited_x_fp = np.array([])
        self.visited_y_fp = np.array([])

        self.change_to_pixel_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the visited positions (if any).
        &#34;&#34;&#34;

        super().change_to_pixel_coordinates()

        # Re-draw the visited positions in the new coordinate system

        self.redraw_visited_positions()

        self.draw()

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the visited postiions (if any).
        &#34;&#34;&#34;

        super().change_to_focal_plane_coordinates()

        # Re-draw the visited positions in the new coordinate system

        self.redraw_visited_positions()

        self.draw()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the visited positions (if any).
        &#34;&#34;&#34;

        super().change_to_angle_coordinates()

        # Re-draw the visited positions in the new coordinate system

        self.redraw_visited_positions()

        self.draw()

    def visit_position(self, x_fp, y_fp, redraw=False):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates. If you are not
        in re-drawing mode, keep track of this new position in the list of visited positions.

        :param x: Focal-plane x-coordinate of the new visited position [mm].

        :param y: Focal-plane y-coordinate of the new visited position [mm].

        :param redraw: If False, the given position should not be added to the list of visited
                       positions (as it is already in there); otherwise, the list of visited
                       positions must be expanded with the given position.
        &#34;&#34;&#34;

        if len(self.visited_x_fp) &gt; 0:

            self.ax.lines[-1].set_color(&#34;blue&#34;)

        # Outside the FOV

        if abs(x_fp) &gt; FOV_SETTINGS.RADIUS_MM and abs(y_fp) &gt; FOV_SETTINGS.RADIUS_MM:

            self.ax.plot([0], [0], color=&#34;white&#34;)

        # Put a red dot at the new source position

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.ax.plot([x_fp], [y_fp], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.ax.plot([x_fp / PIXEL_SIZE], [y_fp / PIXEL_SIZE], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            (theta, phi) = focal_plane_coordinates_to_angles(x_fp, y_fp)

            self.ax.plot([radians(phi)], [theta], &#34;ro&#34;)

        if not redraw:

            self.visited_x_fp = np.append(self.visited_x_fp, x_fp)
            self.visited_y_fp = np.append(self.visited_y_fp, y_fp)

        self.draw()

    def redraw_visited_positions(self):

        &#34;&#34;&#34;
        Re-draw the visited positions in the current coordinate system.
        &#34;&#34;&#34;

        for (x_fp, y_fp) in zip(self.visited_x_fp, self.visited_y_fp):
            self.visit_position(x_fp, y_fp, redraw=True)

    def clear_visited_positions(self):
        &#34;&#34;&#34; Clear all visited positions.&#34;&#34;&#34;

        num_points = len(self.visited_x_fp)
        while num_points &gt; 0:
            del self.ax.lines[-1]
            num_points -= 1

        self.visited_x_fp = np.array([])
        self.visited_y_fp = np.array([])

        self.draw()
############################################
# Focal plane + combobox (coordinate system)
############################################


class FocalPlaneWidget(QGroupBox):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.
        &#34;&#34;&#34;

        super(FocalPlaneWidget, self).__init__(&#34;Focal Plane&#34;)

        self.setFont(FONT)

        layout = QGridLayout()

        # Focal plane

        self.focal_plane = self.get_focal_plane()

        # Combobox (coordinate system)

        coordinate_system_combobox = QComboBox(self)
        coordinate_system_combobox.setFont(FONT)
        coordinate_system_combobox.addItem(COORDINATE_SYSTEMS[&#34;Pixels&#34;])
        coordinate_system_combobox.addItem(COORDINATE_SYSTEMS[&#34;Angles&#34;])
        coordinate_system_combobox.addItem(COORDINATE_SYSTEMS[&#34;Focal plane&#34;])
        coordinate_system_combobox.currentTextChanged.connect(self.update_coordinate_system)

        coordinate_label = QLabel(&#34;Coordinate system&#34;)
        coordinate_label.setFont(FONT)
        coordinate_label.setStatusTip(&#34;Coordinate system to use in the plot&#34;)

        # Putting everything together

        layout.addWidget(self.focal_plane)
        layout.addWidget(coordinate_label)
        layout.addWidget(coordinate_system_combobox)

        self.setLayout(layout)

    def update_coordinate_system(self, value):

        &#34;&#34;&#34;
        Switch to the given coordinate system to use in the plot.  Currently implemented are
        focal-plane coordinates, pixel coordinates, and field angles.  This means that the plot
        needs to be cleared and re-built in the specified coordinate system.

        :param value: Name of the coordinate system to switch to.
        &#34;&#34;&#34;

        # Focal-plane coordinates

        if value == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.focal_plane.change_to_focal_plane_coordinates()

        # Field angles

        elif value == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            self.focal_plane.change_to_angle_coordinates()

        # Pixel coordinates

        elif value == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.focal_plane.change_to_pixel_coordinates()

    def get_focal_plane(self):

        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return None

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.
        &#34;&#34;&#34;

        self.focal_plane.change_to_focal_plane_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.
        &#34;&#34;&#34;

        self.focal_plane.change_to_pixel_coordinates()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.
        &#34;&#34;&#34;

        self.focal_plane.change_to_angle_coordinates()

    def get_widget(self):

        &#34;&#34;&#34;
        Returns the widget itself.

        :return: Widget itself.
        &#34;&#34;&#34;

        return self


class FocalPlaneWidgetWithSubField(FocalPlaneWidget):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the position of the sub-field on the focal plane.
    &#34;&#34;&#34;

    def __init__(self, ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        In the plot window, the position of tbe sub-field will be plotted.

        :param ccd_code: Code of the CCD on which the sub-field is located.

        :param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
                              of the given CCD [pixels].

        :param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
                                 of the given CCD [pixels].

        :param num_rows: Number of rows in the sub-field [pixels].

        :param num_columns: Number of columns in the sub-field [pixels].
        &#34;&#34;&#34;

        super(FocalPlaneWidgetWithSubField, self).__init__()

        self.setStatusTip(
            &#34;Position of the sub-field on the focal plane, based on the FITS header&#34;)

        self.focal_plane.set_subfield(ccd_code=ccd_code, zeropoint_row=zeropoint_row,
                                      zeropoint_column=zeropoint_column, num_rows=num_rows, num_columns=num_columns)


    def get_focal_plane(self):

        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return FocalPlaneWithSubField()


class FocalPlaneWidgetWithSourcePosition(FocalPlaneWidget):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the source position on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        In the plot window, the position of tbe sub-field will be plotted.
        &#34;&#34;&#34;

        super(FocalPlaneWidgetWithSourcePosition, self).__init__()

        self.setStatusTip(
            &#34;Position of the source on the focal plane, based on the position of the mechanisms&#34;)

    def update_source_position(self, x_fp, y_fp):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates. In case
        a source position had been marked before, that red dot must be removed first.

        :param x_fp: Focal-plane x-coordinate of the new source position [mm].

        :param y_fp: Focal-plane y-coordinate of the new source position [mm].
        &#34;&#34;&#34;

        self.focal_plane.update_source_position(x_fp, y_fp)

    def get_focal_plane(self):
        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return FocalPlaneWithSourcePosition()


class FocalPlaneWidgetWithVisitedPositions(FocalPlaneWidget):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the visited positions on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        In the plot window, the visited positions will be plotted.
        &#34;&#34;&#34;

        super(FocalPlaneWidgetWithVisitedPositions, self).__init__()

        self.setToolTip(&#34;Visited positions&#34;)

    def visit_position(self, x_fp, y_fp):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates.

        :param x: Focal-plane x-coordinate of the new visited position [mm].

        :param y: Focal-plane y-coordinate of the new visited position [mm].
        &#34;&#34;&#34;

        self.focal_plane.visit_position(x_fp, y_fp)

    def get_focal_plane(self):

        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return FocalPlaneWithVisitedPositions()

    def clear_visited_positions(self):
        &#34;&#34;&#34; Clear all visited positions.&#34;&#34;&#34;

        self.focal_plane.clear_visited_positions()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.gui.focalplane.FocalPlane"><code class="flex name class">
<span>class <span class="ident">FocalPlane</span></span>
<span>(</span><span>parent=None, dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlane(FigureCanvas):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].
    &#34;&#34;&#34;

    def __init__(self, parent=None, dpi=100):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;
        self.fee_side = GlobalState.setup.camera.fee.ccd_sides.enum
        self.ccd_id = GlobalState.setup.camera.fee.ccd_numbering.CCD_ID

        self.figure = Figure()
        self.ax = self.figure.add_subplot(111)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.

        The draw() method should be called in the sub-classes.
        &#34;&#34;&#34;

        self.coordinate_system = COORDINATE_SYSTEMS[&#34;Focal plane&#34;]

        self.figure.delaxes(self.ax)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_aspect(1)

        # Circle indicating the size of the FOV [mm]

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_MM, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
        self.ax.add_artist(self.circle)

        # Range

        limit = 85
        self.ax.set_xlim([-limit, limit])
        self.ax.set_ylim([-limit, limit])

        self.ax.set_xlabel(&#34;$x_{FP} [mm]$&#34;, fontsize=10)
        self.ax.xaxis.set_label_coords(1.085, 0.45)
        self.ax.set_ylabel(&#34;$y_{FP} [mm]$&#34;, fontsize=10, rotation=0)
        self.ax.yaxis.set_label_coords(0.47, 1.05)

        # Make sure the axes cross at the origin

        self.ax.axvline(x=0, color=&#34;k&#34;, linewidth=1)
        self.ax.axhline(y=0, color=&#34;k&#34;, linewidth=1)

        self.ax.spines[&#39;left&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
        self.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)

        xmin, xmax = self.ax.get_xlim()
        ymin, ymax = self.ax.get_ylim()

        self.ax.arrow(xmin, 0, xmax-xmin+7, 0., fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3, head_length=5, overhang=0.3,
                      length_includes_head=True, clip_on=False)

        self.ax.arrow(0, ymin, 0., ymax-ymin+7, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3, head_length=5, overhang=0.3,
                      length_includes_head=True, clip_on=False)

        # Readout registers

        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1]], [-ZEROPOINT[1], -
                                                     ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)   # Upper left CCD
        self.ax.plot([ZEROPOINT[1], ZEROPOINT[1]], [-ZEROPOINT[0],
                                                    ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)    # Lower left CCD
        self.ax.plot([ZEROPOINT[0], -ZEROPOINT[1]], [ZEROPOINT[1],
                                                     ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)   # Lower right CCD
        self.ax.plot([-ZEROPOINT[1], -ZEROPOINT[1]], [ZEROPOINT[0], -
                                                      ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)  # Upper right CCD

        # CCD middle

        self.ax.plot([ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE, ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE],
                     [-ZEROPOINT[0], ZEROPOINT[1]], color=&#34;k&#34;, linewidth=1,
                     linestyle=&#34;dotted&#34;)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0]],
                     [ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE, ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE, -ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE],
                     [-ZEROPOINT[1], ZEROPOINT[0]], color=&#34;k&#34;, linewidth=1,
                     linestyle=&#34;dotted&#34;)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1]],
                     [-ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE, -ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper right CCD

        # CCD codes

        self.ax.text(-80, 70, self.ccd_id[2])     # Upper left CCD
        self.ax.text(-80, -75, self.ccd_id[3])    # Lower left CCD
        self.ax.text(60, -75, self.ccd_id[0])     # Lower right CCD
        self.ax.text(60, 70, self.ccd_id[1])      # Upper right CCD

        self.ax.text(-30, 10, self.fee_side.LEFT_SIDE.name, rotation=180)       # Upper leftCCD, left side
        self.ax.text(-75, 10, self.fee_side.RIGHT_SIDE.name, rotation=180)      # Upper left CCD, right side
        self.ax.text(-20, -15, self.fee_side.LEFT_SIDE.name, rotation=-90)      # Lower left CCD, left side
        self.ax.text(-20, -75, self.fee_side.RIGHT_SIDE.name, rotation=-90)     # Lower left CCD, right side
        self.ax.text(10, -15, self.fee_side.LEFT_SIDE.name)                     # Lower right CCD, left side
        self.ax.text(50, -15, self.fee_side.RIGHT_SIDE.name)                    # Lower right CCD, right side
        self.ax.text(10, 10, self.fee_side.LEFT_SIDE.name, rotation=90)         # Upper right CCD, left side
        self.ax.text(10, 50, self.fee_side.RIGHT_SIDE.name, rotation=90)        # Upper right CCD, right side

        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0], -ZEROPOINT[0]],
                     [ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1], ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0], -ZEROPOINT[0]],
                     [-ZEROPOINT[0], - ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1]],
                     [-ZEROPOINT[0], - ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1]],
                     [ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1], ZEROPOINT[0]],
                     color=&#34;k&#34;, linewidth=1)  # Upper right CCD

        # Grid lines

        self.ax.grid(color=&#34;lightgray&#34;, linewidth=0.5)

        ticks = np.arange(-80, 90, 20)
        ticks = np.delete(ticks, 4)
        self.ax.set_xticks(ticks)
        self.ax.set_yticks(ticks)

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.

        The draw() method should be called in the sub-classes.
        &#34;&#34;&#34;

        self.coordinate_system = COORDINATE_SYSTEMS[&#34;Pixels&#34;]

        self.figure.delaxes(self.ax)
        self.ax = self.figure.add_subplot(111)
        self.ax.set_aspect(1)

        # Circle indicating the size of the FOV [mm]

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_PIXELS, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
        self.ax.add_artist(self.circle)

        # Range
        # If we do it like this, the circle will have the same size on screen when
        # switching between coordinate systems

        limit = 85 / PIXEL_SIZE
        self.ax.set_xlim([-limit, limit])
        self.ax.set_ylim([-limit, limit])

        self.ax.set_xlabel(&#34;$x_{CCD} [pixels]$&#34;, fontsize=10)
        self.ax.xaxis.set_label_coords(1.085, 0.45)
        self.ax.set_ylabel(&#34;$y_{CCD} [pixels]$&#34;, fontsize=10, rotation=0)
        self.ax.yaxis.set_label_coords(0.47, 1.05)

        # Make sure the axes cross at the origin

        self.ax.axvline(x=0, color=&#34;k&#34;, linewidth=1)
        self.ax.axhline(y=0, color=&#34;k&#34;, linewidth=1)

        self.ax.spines[&#39;left&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
        self.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
        self.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)

        xmin, xmax = self.ax.get_xlim()
        ymin, ymax = self.ax.get_ylim()

        self.ax.arrow(xmin, 0, xmax-xmin+7/PIXEL_SIZE, 0., fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3/PIXEL_SIZE, head_length=5/PIXEL_SIZE,
                      length_includes_head=True, clip_on=False)

        self.ax.arrow(0, ymin, 0., ymax-ymin+7/PIXEL_SIZE, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                      head_width=3/PIXEL_SIZE, head_length=5/PIXEL_SIZE, overhang=0.3,
                      length_includes_head=True, clip_on=False)

        # Readout registers

        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)  # Upper left CCD
        self.ax.plot([ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)    # Lower left CCD
        self.ax.plot([ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)    # Lower right CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=3)  # Upper right CCD

        # CCD middle

        self.ax.plot([ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2, ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2],
                     [-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2, ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2, -ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2],
                     [-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2, -ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2],
                     color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper right CCD

        # CCD codes

        self.ax.text(-80 / PIXEL_SIZE, 70 / PIXEL_SIZE, self.ccd_id[2])     # Upper left CCD
        self.ax.text(-80 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.ccd_id[3])    # Lower left CCD
        self.ax.text(60 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.ccd_id[0])     # Lower right CCD
        self.ax.text(60 / PIXEL_SIZE, 70 / PIXEL_SIZE, self.ccd_id[1])      # Upper right CCD

        self.ax.text(-30 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=180)     # Upper left CCD, left side
        self.ax.text(-75 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=180)    # Upper left CCD, right side
        self.ax.text(-20 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=-90)    # Lower left CCD, left side
        self.ax.text(-20 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=-90)   # Lower left CCD, right side
        self.ax.text(10 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name)   # Lower right CCD, left side
        self.ax.text(50 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name)  # Lower right CCD, right side
        self.ax.text(10 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=90)   # Upper right CCD, left side
        self.ax.text(10 / PIXEL_SIZE, 50 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=90)  # Upper right CCD, right side

        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Upper left CCD
        self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Lower left CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [-ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Lower right CCD
        self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                     [ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                     color=&#34;k&#34;, linewidth=1)  # Upper right CCD

        # Grid lines

        ticks = np.arange(-4000, 5000, 1000)
        ticks = np.delete(ticks, 4)
        self.ax.set_xticks(ticks)
        self.ax.set_yticks(ticks)
        self.ax.grid(color=&#34;lightgray&#34;, linewidth=0.5)

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.

        The draw() method should be called in the sub-classes.
        &#34;&#34;&#34;

        self.coordinate_system = COORDINATE_SYSTEMS[&#34;Angles&#34;]

        self.figure.delaxes(self.ax)
        self.ax = self.figure.add_subplot(111, projection=&#34;polar&#34;)
        self.ax.set_aspect(1)

        # Circle indicating the size of the FOV [mm]

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_DEGREES, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1,
            transform=self.ax.transData._b)
        self.ax.add_artist(self.circle)

        # Range
        # If we do it like this, the circle will have the same size on screen when
        # switching between coordinate systems

        limit = degrees(atan(85 / FOV_SETTINGS.FOCAL_LENGTH))

        self.ax.set_rlim([0, limit])

        # CCD codes

        theta, phi = focal_plane_coordinates_to_angles(-30, 10)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=180)      # Upper left CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(-75, 10)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=180)     # Upper left CCD, right side
        theta, phi = focal_plane_coordinates_to_angles(-20, -15)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=-90)      # Lower left CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(-20, -75)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=-90)     # Lower left CCD, right side
        theta, phi = focal_plane_coordinates_to_angles(10, -15)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name)                    # Lower right CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(50, -15)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name)                   # Lower right CCD, right side
        theta, phi = focal_plane_coordinates_to_angles(10, 10)
        self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=90)       # Upper right CCD, left side
        theta, phi = focal_plane_coordinates_to_angles(10, 50)
        self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=90)      # Upper right CCD, right side

        self.ax.text(radians(135), 22, self.ccd_id[2], ha=&#34;center&#34;)              # Upper left CCD
        self.ax.text(radians(-135), 22, self.ccd_id[3], ha=&#34;center&#34;, va=&#34;top&#34;)   # Lower left CCD
        self.ax.text(radians(-45), 22, self.ccd_id[0], ha=&#34;center&#34;, va=&#34;top&#34;)    # Lower right CCD
        self.ax.text(radians(45), 22, self.ccd_id[1], ha=&#34;center&#34;)               # Upper right CCD

        (theta1_ccd1, phi1_ccd1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], -ZEROPOINT[1])
        (theta2_ccd1, phi2_ccd1) = focal_plane_coordinates_to_angles(ZEROPOINT[1], -ZEROPOINT[1])
        (theta3_ccd1, phi3_ccd1) = focal_plane_coordinates_to_angles(ZEROPOINT[1], ZEROPOINT[0])
        (theta4_ccd1, phi4_ccd1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], ZEROPOINT[0])

        phi1_ccd1 = radians(phi1_ccd1)
        phi2_ccd1 = radians(phi2_ccd1)
        phi3_ccd1 = radians(phi3_ccd1)
        phi4_ccd1 = radians(phi4_ccd1)

        self.ax.plot([phi1_ccd1, phi2_ccd1], [theta1_ccd1, theta2_ccd1], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd1, phi2_ccd1, phi3_ccd1, phi4_ccd1, phi1_ccd1],
                     [theta1_ccd1, theta2_ccd1, theta3_ccd1, theta4_ccd1, theta1_ccd1], color=&#34;k&#34;, linewidth=1)

        (theta1_ccd2, phi1_ccd2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], -ZEROPOINT[0])
        (theta2_ccd2, phi2_ccd2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], ZEROPOINT[1])
        (theta3_ccd2, phi3_ccd2) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], ZEROPOINT[1])
        (theta4_ccd2, phi4_ccd2) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], -ZEROPOINT[0])

        phi1_ccd2 = radians(phi1_ccd2)
        phi2_ccd2 = radians(phi2_ccd2)
        phi3_ccd2 = radians(phi3_ccd2)
        phi4_ccd2 = radians(phi4_ccd2)

        self.ax.plot([phi1_ccd2, phi2_ccd2], [theta1_ccd2, theta2_ccd2], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd2, phi2_ccd2, phi3_ccd2, phi4_ccd2, phi1_ccd2],
                     [theta1_ccd2, theta2_ccd2, theta3_ccd2, theta4_ccd2, theta1_ccd2], color=&#34;k&#34;, linewidth=1)

        (theta1_ccd3, phi1_ccd3) = focal_plane_coordinates_to_angles(ZEROPOINT[0], ZEROPOINT[1])
        (theta2_ccd3, phi2_ccd3) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], ZEROPOINT[1])
        (theta3_ccd3, phi3_ccd3) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -ZEROPOINT[0])
        (theta4_ccd3, phi4_ccd3) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -ZEROPOINT[0])

        phi1_ccd3 = radians(phi1_ccd3)
        phi2_ccd3 = radians(phi2_ccd3)
        phi3_ccd3 = radians(phi3_ccd3)
        phi4_ccd3 = radians(phi4_ccd3)

        self.ax.plot([phi1_ccd3, phi2_ccd3], [theta1_ccd3, theta2_ccd3], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd3, phi2_ccd3, phi3_ccd3, phi4_ccd3, phi1_ccd3],
                     [theta1_ccd3, theta2_ccd3, theta3_ccd3, theta4_ccd3, theta1_ccd3], color=&#34;k&#34;, linewidth=1)

        (theta1_ccd4, phi1_ccd4) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], ZEROPOINT[0])
        (theta2_ccd4, phi2_ccd4) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -ZEROPOINT[1])
        (theta3_ccd4, phi3_ccd4) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -ZEROPOINT[1])
        (theta4_ccd4, phi4_ccd4) = focal_plane_coordinates_to_angles(ZEROPOINT[0], ZEROPOINT[0])

        phi1_ccd4 = radians(phi1_ccd4)
        phi2_ccd4 = radians(phi2_ccd4)
        phi3_ccd4 = radians(phi3_ccd4)
        phi4_ccd4 = radians(phi4_ccd4)

        self.ax.plot([phi1_ccd4, phi2_ccd4], [theta1_ccd4, theta2_ccd4], color=&#34;k&#34;, linewidth=3)
        self.ax.plot([phi1_ccd4, phi2_ccd4, phi3_ccd4, phi4_ccd4, phi1_ccd4],
                     [theta1_ccd4, theta2_ccd4, theta3_ccd4, theta4_ccd4, theta1_ccd4], color=&#34;k&#34;, linewidth=1)

        # CCD middle

        (theta1, phi1) = focal_plane_coordinates_to_angles((ZEROPOINT[1] - ZEROPOINT[0]) / 2, -ZEROPOINT[1])
        (theta2, phi2) = focal_plane_coordinates_to_angles((ZEROPOINT[1] - ZEROPOINT[0]) / 2, ZEROPOINT[0])
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Upper left CCD

        (theta1, phi1) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -(ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        (theta2, phi2) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -(ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Lower left CCD

        (theta1, phi1) = focal_plane_coordinates_to_angles(-(ZEROPOINT[1] - ZEROPOINT[0]) / 2, ZEROPOINT[1])
        (theta2, phi2) = focal_plane_coordinates_to_angles(-(ZEROPOINT[1] - ZEROPOINT[0]) / 2, -ZEROPOINT[0])
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Lower right CCD

        (theta1, phi1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], (ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        (theta2, phi2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], (ZEROPOINT[1] - ZEROPOINT[0]) / 2)
        phi1 = radians(phi1)
        phi2 = radians(phi2)
        self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Uoper right CCD

        # Grid lines

        tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.]
        for t in np.deg2rad(np.arange(0, 360, 15)):
            self.ax.plot([t, t], tick, lw=0.72, color=&#34;lightgray&#34;)

        tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.]
        for t in np.deg2rad(np.arange(0, 360, 45)):
            self.ax.plot([t, t], tick, lw=0.72, color=&#34;k&#34;)

        ticks = np.arange(2, 20, 2)
        self.ax.set_rticks(ticks)

        self.ax.yaxis.set_major_formatter(
            ticker.FuncFormatter(degree_formatter))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlaneWithSourcePosition" href="#egse.gui.focalplane.FocalPlaneWithSourcePosition">FocalPlaneWithSourcePosition</a></li>
<li><a title="egse.gui.focalplane.FocalPlaneWithSubField" href="#egse.gui.focalplane.FocalPlaneWithSubField">FocalPlaneWithSubField</a></li>
<li><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions">FocalPlaneWithVisitedPositions</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlane.change_to_angle_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_angle_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in angle coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes.
</code></pre>
<p>The draw() method should be called in the sub-classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_angle_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in angle coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes.

    The draw() method should be called in the sub-classes.
    &#34;&#34;&#34;

    self.coordinate_system = COORDINATE_SYSTEMS[&#34;Angles&#34;]

    self.figure.delaxes(self.ax)
    self.ax = self.figure.add_subplot(111, projection=&#34;polar&#34;)
    self.ax.set_aspect(1)

    # Circle indicating the size of the FOV [mm]

    self.circle = plt.Circle(
        (0, 0), FOV_SETTINGS.RADIUS_DEGREES, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1,
        transform=self.ax.transData._b)
    self.ax.add_artist(self.circle)

    # Range
    # If we do it like this, the circle will have the same size on screen when
    # switching between coordinate systems

    limit = degrees(atan(85 / FOV_SETTINGS.FOCAL_LENGTH))

    self.ax.set_rlim([0, limit])

    # CCD codes

    theta, phi = focal_plane_coordinates_to_angles(-30, 10)
    self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=180)      # Upper left CCD, left side
    theta, phi = focal_plane_coordinates_to_angles(-75, 10)
    self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=180)     # Upper left CCD, right side
    theta, phi = focal_plane_coordinates_to_angles(-20, -15)
    self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=-90)      # Lower left CCD, left side
    theta, phi = focal_plane_coordinates_to_angles(-20, -75)
    self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=-90)     # Lower left CCD, right side
    theta, phi = focal_plane_coordinates_to_angles(10, -15)
    self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name)                    # Lower right CCD, left side
    theta, phi = focal_plane_coordinates_to_angles(50, -15)
    self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name)                   # Lower right CCD, right side
    theta, phi = focal_plane_coordinates_to_angles(10, 10)
    self.ax.text(radians(phi), theta, self.fee_side.LEFT_SIDE.name, rotation=90)       # Upper right CCD, left side
    theta, phi = focal_plane_coordinates_to_angles(10, 50)
    self.ax.text(radians(phi), theta, self.fee_side.RIGHT_SIDE.name, rotation=90)      # Upper right CCD, right side

    self.ax.text(radians(135), 22, self.ccd_id[2], ha=&#34;center&#34;)              # Upper left CCD
    self.ax.text(radians(-135), 22, self.ccd_id[3], ha=&#34;center&#34;, va=&#34;top&#34;)   # Lower left CCD
    self.ax.text(radians(-45), 22, self.ccd_id[0], ha=&#34;center&#34;, va=&#34;top&#34;)    # Lower right CCD
    self.ax.text(radians(45), 22, self.ccd_id[1], ha=&#34;center&#34;)               # Upper right CCD

    (theta1_ccd1, phi1_ccd1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], -ZEROPOINT[1])
    (theta2_ccd1, phi2_ccd1) = focal_plane_coordinates_to_angles(ZEROPOINT[1], -ZEROPOINT[1])
    (theta3_ccd1, phi3_ccd1) = focal_plane_coordinates_to_angles(ZEROPOINT[1], ZEROPOINT[0])
    (theta4_ccd1, phi4_ccd1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], ZEROPOINT[0])

    phi1_ccd1 = radians(phi1_ccd1)
    phi2_ccd1 = radians(phi2_ccd1)
    phi3_ccd1 = radians(phi3_ccd1)
    phi4_ccd1 = radians(phi4_ccd1)

    self.ax.plot([phi1_ccd1, phi2_ccd1], [theta1_ccd1, theta2_ccd1], color=&#34;k&#34;, linewidth=3)
    self.ax.plot([phi1_ccd1, phi2_ccd1, phi3_ccd1, phi4_ccd1, phi1_ccd1],
                 [theta1_ccd1, theta2_ccd1, theta3_ccd1, theta4_ccd1, theta1_ccd1], color=&#34;k&#34;, linewidth=1)

    (theta1_ccd2, phi1_ccd2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], -ZEROPOINT[0])
    (theta2_ccd2, phi2_ccd2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], ZEROPOINT[1])
    (theta3_ccd2, phi3_ccd2) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], ZEROPOINT[1])
    (theta4_ccd2, phi4_ccd2) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], -ZEROPOINT[0])

    phi1_ccd2 = radians(phi1_ccd2)
    phi2_ccd2 = radians(phi2_ccd2)
    phi3_ccd2 = radians(phi3_ccd2)
    phi4_ccd2 = radians(phi4_ccd2)

    self.ax.plot([phi1_ccd2, phi2_ccd2], [theta1_ccd2, theta2_ccd2], color=&#34;k&#34;, linewidth=3)
    self.ax.plot([phi1_ccd2, phi2_ccd2, phi3_ccd2, phi4_ccd2, phi1_ccd2],
                 [theta1_ccd2, theta2_ccd2, theta3_ccd2, theta4_ccd2, theta1_ccd2], color=&#34;k&#34;, linewidth=1)

    (theta1_ccd3, phi1_ccd3) = focal_plane_coordinates_to_angles(ZEROPOINT[0], ZEROPOINT[1])
    (theta2_ccd3, phi2_ccd3) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], ZEROPOINT[1])
    (theta3_ccd3, phi3_ccd3) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -ZEROPOINT[0])
    (theta4_ccd3, phi4_ccd3) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -ZEROPOINT[0])

    phi1_ccd3 = radians(phi1_ccd3)
    phi2_ccd3 = radians(phi2_ccd3)
    phi3_ccd3 = radians(phi3_ccd3)
    phi4_ccd3 = radians(phi4_ccd3)

    self.ax.plot([phi1_ccd3, phi2_ccd3], [theta1_ccd3, theta2_ccd3], color=&#34;k&#34;, linewidth=3)
    self.ax.plot([phi1_ccd3, phi2_ccd3, phi3_ccd3, phi4_ccd3, phi1_ccd3],
                 [theta1_ccd3, theta2_ccd3, theta3_ccd3, theta4_ccd3, theta1_ccd3], color=&#34;k&#34;, linewidth=1)

    (theta1_ccd4, phi1_ccd4) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], ZEROPOINT[0])
    (theta2_ccd4, phi2_ccd4) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -ZEROPOINT[1])
    (theta3_ccd4, phi3_ccd4) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -ZEROPOINT[1])
    (theta4_ccd4, phi4_ccd4) = focal_plane_coordinates_to_angles(ZEROPOINT[0], ZEROPOINT[0])

    phi1_ccd4 = radians(phi1_ccd4)
    phi2_ccd4 = radians(phi2_ccd4)
    phi3_ccd4 = radians(phi3_ccd4)
    phi4_ccd4 = radians(phi4_ccd4)

    self.ax.plot([phi1_ccd4, phi2_ccd4], [theta1_ccd4, theta2_ccd4], color=&#34;k&#34;, linewidth=3)
    self.ax.plot([phi1_ccd4, phi2_ccd4, phi3_ccd4, phi4_ccd4, phi1_ccd4],
                 [theta1_ccd4, theta2_ccd4, theta3_ccd4, theta4_ccd4, theta1_ccd4], color=&#34;k&#34;, linewidth=1)

    # CCD middle

    (theta1, phi1) = focal_plane_coordinates_to_angles((ZEROPOINT[1] - ZEROPOINT[0]) / 2, -ZEROPOINT[1])
    (theta2, phi2) = focal_plane_coordinates_to_angles((ZEROPOINT[1] - ZEROPOINT[0]) / 2, ZEROPOINT[0])
    phi1 = radians(phi1)
    phi2 = radians(phi2)
    self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Upper left CCD

    (theta1, phi1) = focal_plane_coordinates_to_angles(ZEROPOINT[0], -(ZEROPOINT[1] - ZEROPOINT[0]) / 2)
    (theta2, phi2) = focal_plane_coordinates_to_angles(-ZEROPOINT[1], -(ZEROPOINT[1] - ZEROPOINT[0]) / 2)
    phi1 = radians(phi1)
    phi2 = radians(phi2)
    self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Lower left CCD

    (theta1, phi1) = focal_plane_coordinates_to_angles(-(ZEROPOINT[1] - ZEROPOINT[0]) / 2, ZEROPOINT[1])
    (theta2, phi2) = focal_plane_coordinates_to_angles(-(ZEROPOINT[1] - ZEROPOINT[0]) / 2, -ZEROPOINT[0])
    phi1 = radians(phi1)
    phi2 = radians(phi2)
    self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Lower right CCD

    (theta1, phi1) = focal_plane_coordinates_to_angles(-ZEROPOINT[0], (ZEROPOINT[1] - ZEROPOINT[0]) / 2)
    (theta2, phi2) = focal_plane_coordinates_to_angles(ZEROPOINT[1], (ZEROPOINT[1] - ZEROPOINT[0]) / 2)
    phi1 = radians(phi1)
    phi2 = radians(phi2)
    self.ax.plot([phi1, phi2], [theta1, theta2], color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)    # Uoper right CCD

    # Grid lines

    tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.]
    for t in np.deg2rad(np.arange(0, 360, 15)):
        self.ax.plot([t, t], tick, lw=0.72, color=&#34;lightgray&#34;)

    tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.]
    for t in np.deg2rad(np.arange(0, 360, 45)):
        self.ax.plot([t, t], tick, lw=0.72, color=&#34;k&#34;)

    ticks = np.arange(2, 20, 2)
    self.ax.set_rticks(ticks)

    self.ax.yaxis.set_major_formatter(
        ticker.FuncFormatter(degree_formatter))</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlane.change_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_focal_plane_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in focal-plane coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes.
</code></pre>
<p>The draw() method should be called in the sub-classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_focal_plane_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in focal-plane coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes.

    The draw() method should be called in the sub-classes.
    &#34;&#34;&#34;

    self.coordinate_system = COORDINATE_SYSTEMS[&#34;Focal plane&#34;]

    self.figure.delaxes(self.ax)
    self.ax = self.figure.add_subplot(111)
    self.ax.set_aspect(1)

    # Circle indicating the size of the FOV [mm]

    self.circle = plt.Circle(
        (0, 0), FOV_SETTINGS.RADIUS_MM, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
    self.ax.add_artist(self.circle)

    # Range

    limit = 85
    self.ax.set_xlim([-limit, limit])
    self.ax.set_ylim([-limit, limit])

    self.ax.set_xlabel(&#34;$x_{FP} [mm]$&#34;, fontsize=10)
    self.ax.xaxis.set_label_coords(1.085, 0.45)
    self.ax.set_ylabel(&#34;$y_{FP} [mm]$&#34;, fontsize=10, rotation=0)
    self.ax.yaxis.set_label_coords(0.47, 1.05)

    # Make sure the axes cross at the origin

    self.ax.axvline(x=0, color=&#34;k&#34;, linewidth=1)
    self.ax.axhline(y=0, color=&#34;k&#34;, linewidth=1)

    self.ax.spines[&#39;left&#39;].set_position(&#39;center&#39;)
    self.ax.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
    self.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
    self.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)

    xmin, xmax = self.ax.get_xlim()
    ymin, ymax = self.ax.get_ylim()

    self.ax.arrow(xmin, 0, xmax-xmin+7, 0., fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                  head_width=3, head_length=5, overhang=0.3,
                  length_includes_head=True, clip_on=False)

    self.ax.arrow(0, ymin, 0., ymax-ymin+7, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                  head_width=3, head_length=5, overhang=0.3,
                  length_includes_head=True, clip_on=False)

    # Readout registers

    self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1]], [-ZEROPOINT[1], -
                                                 ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)   # Upper left CCD
    self.ax.plot([ZEROPOINT[1], ZEROPOINT[1]], [-ZEROPOINT[0],
                                                ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)    # Lower left CCD
    self.ax.plot([ZEROPOINT[0], -ZEROPOINT[1]], [ZEROPOINT[1],
                                                 ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)   # Lower right CCD
    self.ax.plot([-ZEROPOINT[1], -ZEROPOINT[1]], [ZEROPOINT[0], -
                                                  ZEROPOINT[1]], color=&#34;k&#34;, linewidth=3)  # Upper right CCD

    # CCD middle

    self.ax.plot([ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE, ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE],
                 [-ZEROPOINT[0], ZEROPOINT[1]], color=&#34;k&#34;, linewidth=1,
                 linestyle=&#34;dotted&#34;)  # Upper left CCD
    self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0]],
                 [ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE, ZEROPOINT[0] - NUM_COLUMNS / 2 * PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower left CCD
    self.ax.plot([-ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE, -ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE],
                 [-ZEROPOINT[1], ZEROPOINT[0]], color=&#34;k&#34;, linewidth=1,
                 linestyle=&#34;dotted&#34;)  # Lower right CCD
    self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1]],
                 [-ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE, -ZEROPOINT[0] + NUM_COLUMNS / 2 * PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper right CCD

    # CCD codes

    self.ax.text(-80, 70, self.ccd_id[2])     # Upper left CCD
    self.ax.text(-80, -75, self.ccd_id[3])    # Lower left CCD
    self.ax.text(60, -75, self.ccd_id[0])     # Lower right CCD
    self.ax.text(60, 70, self.ccd_id[1])      # Upper right CCD

    self.ax.text(-30, 10, self.fee_side.LEFT_SIDE.name, rotation=180)       # Upper leftCCD, left side
    self.ax.text(-75, 10, self.fee_side.RIGHT_SIDE.name, rotation=180)      # Upper left CCD, right side
    self.ax.text(-20, -15, self.fee_side.LEFT_SIDE.name, rotation=-90)      # Lower left CCD, left side
    self.ax.text(-20, -75, self.fee_side.RIGHT_SIDE.name, rotation=-90)     # Lower left CCD, right side
    self.ax.text(10, -15, self.fee_side.LEFT_SIDE.name)                     # Lower right CCD, left side
    self.ax.text(50, -15, self.fee_side.RIGHT_SIDE.name)                    # Lower right CCD, right side
    self.ax.text(10, 10, self.fee_side.LEFT_SIDE.name, rotation=90)         # Upper right CCD, left side
    self.ax.text(10, 50, self.fee_side.RIGHT_SIDE.name, rotation=90)        # Upper right CCD, right side

    self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0], -ZEROPOINT[0]],
                 [ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1], ZEROPOINT[0]],
                 color=&#34;k&#34;, linewidth=1)  # Upper left CCD
    self.ax.plot([-ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0], -ZEROPOINT[0]],
                 [-ZEROPOINT[0], - ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0]],
                 color=&#34;k&#34;, linewidth=1)  # Lower left CCD
    self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1]],
                 [-ZEROPOINT[0], - ZEROPOINT[0], ZEROPOINT[1], ZEROPOINT[1], -ZEROPOINT[0]],
                 color=&#34;k&#34;, linewidth=1)  # Lower right CCD
    self.ax.plot([-ZEROPOINT[1], ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1]],
                 [ZEROPOINT[0], ZEROPOINT[0], -ZEROPOINT[1], -ZEROPOINT[1], ZEROPOINT[0]],
                 color=&#34;k&#34;, linewidth=1)  # Upper right CCD

    # Grid lines

    self.ax.grid(color=&#34;lightgray&#34;, linewidth=0.5)

    ticks = np.arange(-80, 90, 20)
    ticks = np.delete(ticks, 4)
    self.ax.set_xticks(ticks)
    self.ax.set_yticks(ticks)</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlane.change_to_pixel_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_pixel_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in pixel coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes.
</code></pre>
<p>The draw() method should be called in the sub-classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_pixel_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in pixel coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes.

    The draw() method should be called in the sub-classes.
    &#34;&#34;&#34;

    self.coordinate_system = COORDINATE_SYSTEMS[&#34;Pixels&#34;]

    self.figure.delaxes(self.ax)
    self.ax = self.figure.add_subplot(111)
    self.ax.set_aspect(1)

    # Circle indicating the size of the FOV [mm]

    self.circle = plt.Circle(
        (0, 0), FOV_SETTINGS.RADIUS_PIXELS, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
    self.ax.add_artist(self.circle)

    # Range
    # If we do it like this, the circle will have the same size on screen when
    # switching between coordinate systems

    limit = 85 / PIXEL_SIZE
    self.ax.set_xlim([-limit, limit])
    self.ax.set_ylim([-limit, limit])

    self.ax.set_xlabel(&#34;$x_{CCD} [pixels]$&#34;, fontsize=10)
    self.ax.xaxis.set_label_coords(1.085, 0.45)
    self.ax.set_ylabel(&#34;$y_{CCD} [pixels]$&#34;, fontsize=10, rotation=0)
    self.ax.yaxis.set_label_coords(0.47, 1.05)

    # Make sure the axes cross at the origin

    self.ax.axvline(x=0, color=&#34;k&#34;, linewidth=1)
    self.ax.axhline(y=0, color=&#34;k&#34;, linewidth=1)

    self.ax.spines[&#39;left&#39;].set_position(&#39;center&#39;)
    self.ax.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
    self.ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)
    self.ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)

    xmin, xmax = self.ax.get_xlim()
    ymin, ymax = self.ax.get_ylim()

    self.ax.arrow(xmin, 0, xmax-xmin+7/PIXEL_SIZE, 0., fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                  head_width=3/PIXEL_SIZE, head_length=5/PIXEL_SIZE,
                  length_includes_head=True, clip_on=False)

    self.ax.arrow(0, ymin, 0., ymax-ymin+7/PIXEL_SIZE, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1,
                  head_width=3/PIXEL_SIZE, head_length=5/PIXEL_SIZE, overhang=0.3,
                  length_includes_head=True, clip_on=False)

    # Readout registers

    self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                 [-ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=3)  # Upper left CCD
    self.ax.plot([ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                 [-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=3)    # Lower left CCD
    self.ax.plot([ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                 [ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=3)    # Lower right CCD
    self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                 [ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=3)  # Upper right CCD

    # CCD middle

    self.ax.plot([ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2, ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2],
                 [-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper left CCD
    self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                 [ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2, ZEROPOINT[0] / PIXEL_SIZE - NUM_COLUMNS / 2],
                 color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower left CCD
    self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2, -ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2],
                 [-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Lower right CCD
    self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE],
                 [-ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2, -ZEROPOINT[0] / PIXEL_SIZE + NUM_COLUMNS / 2],
                 color=&#34;k&#34;, linewidth=1, linestyle=&#34;dotted&#34;)  # Upper right CCD

    # CCD codes

    self.ax.text(-80 / PIXEL_SIZE, 70 / PIXEL_SIZE, self.ccd_id[2])     # Upper left CCD
    self.ax.text(-80 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.ccd_id[3])    # Lower left CCD
    self.ax.text(60 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.ccd_id[0])     # Lower right CCD
    self.ax.text(60 / PIXEL_SIZE, 70 / PIXEL_SIZE, self.ccd_id[1])      # Upper right CCD

    self.ax.text(-30 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=180)     # Upper left CCD, left side
    self.ax.text(-75 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=180)    # Upper left CCD, right side
    self.ax.text(-20 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=-90)    # Lower left CCD, left side
    self.ax.text(-20 / PIXEL_SIZE, -75 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=-90)   # Lower left CCD, right side
    self.ax.text(10 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name)   # Lower right CCD, left side
    self.ax.text(50 / PIXEL_SIZE, -15 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name)  # Lower right CCD, right side
    self.ax.text(10 / PIXEL_SIZE, 10 / PIXEL_SIZE, self.fee_side.LEFT_SIDE.name, rotation=90)   # Upper right CCD, left side
    self.ax.text(10 / PIXEL_SIZE, 50 / PIXEL_SIZE, self.fee_side.RIGHT_SIDE.name, rotation=90)  # Upper right CCD, right side

    self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                 [ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1)  # Upper left CCD
    self.ax.plot([-ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                 [-ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1)  # Lower left CCD
    self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                 [-ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[0] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1)  # Lower right CCD
    self.ax.plot([-ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE],
                 [ZEROPOINT[0] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, -ZEROPOINT[1] / PIXEL_SIZE, ZEROPOINT[0] / PIXEL_SIZE],
                 color=&#34;k&#34;, linewidth=1)  # Upper right CCD

    # Grid lines

    ticks = np.arange(-4000, 5000, 1000)
    ticks = np.delete(ticks, 4)
    self.ax.set_xticks(ticks)
    self.ax.set_yticks(ticks)
    self.ax.grid(color=&#34;lightgray&#34;, linewidth=0.5)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidget"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWidget</span></span>
</code></dt>
<dd>
<div class="desc"><p>Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
indicating the field-of-view.
Below the plot window, you can find a combobox to choose
the coordinate system to use in the plot.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.
Below the plot you can find a spinner to choose the coordinate
system to be used in the plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWidget(QGroupBox):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.
        &#34;&#34;&#34;

        super(FocalPlaneWidget, self).__init__(&#34;Focal Plane&#34;)

        self.setFont(FONT)

        layout = QGridLayout()

        # Focal plane

        self.focal_plane = self.get_focal_plane()

        # Combobox (coordinate system)

        coordinate_system_combobox = QComboBox(self)
        coordinate_system_combobox.setFont(FONT)
        coordinate_system_combobox.addItem(COORDINATE_SYSTEMS[&#34;Pixels&#34;])
        coordinate_system_combobox.addItem(COORDINATE_SYSTEMS[&#34;Angles&#34;])
        coordinate_system_combobox.addItem(COORDINATE_SYSTEMS[&#34;Focal plane&#34;])
        coordinate_system_combobox.currentTextChanged.connect(self.update_coordinate_system)

        coordinate_label = QLabel(&#34;Coordinate system&#34;)
        coordinate_label.setFont(FONT)
        coordinate_label.setStatusTip(&#34;Coordinate system to use in the plot&#34;)

        # Putting everything together

        layout.addWidget(self.focal_plane)
        layout.addWidget(coordinate_label)
        layout.addWidget(coordinate_system_combobox)

        self.setLayout(layout)

    def update_coordinate_system(self, value):

        &#34;&#34;&#34;
        Switch to the given coordinate system to use in the plot.  Currently implemented are
        focal-plane coordinates, pixel coordinates, and field angles.  This means that the plot
        needs to be cleared and re-built in the specified coordinate system.

        :param value: Name of the coordinate system to switch to.
        &#34;&#34;&#34;

        # Focal-plane coordinates

        if value == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.focal_plane.change_to_focal_plane_coordinates()

        # Field angles

        elif value == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            self.focal_plane.change_to_angle_coordinates()

        # Pixel coordinates

        elif value == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.focal_plane.change_to_pixel_coordinates()

    def get_focal_plane(self):

        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return None

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.
        &#34;&#34;&#34;

        self.focal_plane.change_to_focal_plane_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.
        &#34;&#34;&#34;

        self.focal_plane.change_to_pixel_coordinates()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes.
        &#34;&#34;&#34;

        self.focal_plane.change_to_angle_coordinates()

    def get_widget(self):

        &#34;&#34;&#34;
        Returns the widget itself.

        :return: Widget itself.
        &#34;&#34;&#34;

        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition" href="#egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition">FocalPlaneWidgetWithSourcePosition</a></li>
<li><a title="egse.gui.focalplane.FocalPlaneWidgetWithSubField" href="#egse.gui.focalplane.FocalPlaneWidgetWithSubField">FocalPlaneWidgetWithSubField</a></li>
<li><a title="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions" href="#egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions">FocalPlaneWidgetWithVisitedPositions</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_angle_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in angle coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_angle_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in angle coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes.
    &#34;&#34;&#34;

    self.focal_plane.change_to_angle_coordinates()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_focal_plane_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in focal-plane coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_focal_plane_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in focal-plane coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes.
    &#34;&#34;&#34;

    self.focal_plane.change_to_focal_plane_coordinates()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_pixel_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in pixel coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_pixel_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in pixel coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes.
    &#34;&#34;&#34;

    self.focal_plane.change_to_pixel_coordinates()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidget.get_focal_plane"><code class="name flex">
<span>def <span class="ident">get_focal_plane</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the widget with the focal plane only (so without the combobox to
choose the coordinate system).</p>
<p>:return: Widget with the focal plane only (so without the combobox to
choose the coordinate system).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_focal_plane(self):

    &#34;&#34;&#34;
    Returns the widget with the focal plane only (so without the combobox to
    choose the coordinate system).

    :return: Widget with the focal plane only (so without the combobox to
             choose the coordinate system).
    &#34;&#34;&#34;

    return None</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidget.get_widget"><code class="name flex">
<span>def <span class="ident">get_widget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the widget itself.</p>
<p>:return: Widget itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_widget(self):

    &#34;&#34;&#34;
    Returns the widget itself.

    :return: Widget itself.
    &#34;&#34;&#34;

    return self</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system"><code class="name flex">
<span>def <span class="ident">update_coordinate_system</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Switch to the given coordinate system to use in the plot.
Currently implemented are
focal-plane coordinates, pixel coordinates, and field angles.
This means that the plot
needs to be cleared and re-built in the specified coordinate system.</p>
<p>:param value: Name of the coordinate system to switch to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_coordinate_system(self, value):

    &#34;&#34;&#34;
    Switch to the given coordinate system to use in the plot.  Currently implemented are
    focal-plane coordinates, pixel coordinates, and field angles.  This means that the plot
    needs to be cleared and re-built in the specified coordinate system.

    :param value: Name of the coordinate system to switch to.
    &#34;&#34;&#34;

    # Focal-plane coordinates

    if value == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

        self.focal_plane.change_to_focal_plane_coordinates()

    # Field angles

    elif value == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

        self.focal_plane.change_to_angle_coordinates()

    # Pixel coordinates

    elif value == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

        self.focal_plane.change_to_pixel_coordinates()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWidgetWithSourcePosition</span></span>
</code></dt>
<dd>
<div class="desc"><p>Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
indicating the field-of-view.
Below the plot window, you can find a combobox to choose
the coordinate system to use in the plot.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Possibility to draw the source position on the focal plane.</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.
Below the plot you can find a spinner to choose the coordinate
system to be used in the plot.</p>
<p>In the plot window, the position of tbe sub-field will be plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWidgetWithSourcePosition(FocalPlaneWidget):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the source position on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        In the plot window, the position of tbe sub-field will be plotted.
        &#34;&#34;&#34;

        super(FocalPlaneWidgetWithSourcePosition, self).__init__()

        self.setStatusTip(
            &#34;Position of the source on the focal plane, based on the position of the mechanisms&#34;)

    def update_source_position(self, x_fp, y_fp):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates. In case
        a source position had been marked before, that red dot must be removed first.

        :param x_fp: Focal-plane x-coordinate of the new source position [mm].

        :param y_fp: Focal-plane y-coordinate of the new source position [mm].
        &#34;&#34;&#34;

        self.focal_plane.update_source_position(x_fp, y_fp)

    def get_focal_plane(self):
        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return FocalPlaneWithSourcePosition()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition.update_source_position"><code class="name flex">
<span>def <span class="ident">update_source_position</span></span>(<span>self, x_fp, y_fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a red dot at the position with the given focal-plane coordinates. In case
a source position had been marked before, that red dot must be removed first.</p>
<p>:param x_fp: Focal-plane x-coordinate of the new source position [mm].</p>
<p>:param y_fp: Focal-plane y-coordinate of the new source position [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_source_position(self, x_fp, y_fp):

    &#34;&#34;&#34;
    Add a red dot at the position with the given focal-plane coordinates. In case
    a source position had been marked before, that red dot must be removed first.

    :param x_fp: Focal-plane x-coordinate of the new source position [mm].

    :param y_fp: Focal-plane y-coordinate of the new source position [mm].
    &#34;&#34;&#34;

    self.focal_plane.update_source_position(x_fp, y_fp)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_focal_plane" href="#egse.gui.focalplane.FocalPlaneWidget.get_focal_plane">get_focal_plane</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_widget" href="#egse.gui.focalplane.FocalPlaneWidget.get_widget">get_widget</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system" href="#egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system">update_coordinate_system</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidgetWithSubField"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWidgetWithSubField</span></span>
<span>(</span><span>ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
indicating the field-of-view.
Below the plot window, you can find a combobox to choose
the coordinate system to use in the plot.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Possibility to draw the position of the sub-field on the focal plane.</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.
Below the plot you can find a spinner to choose the coordinate
system to be used in the plot.</p>
<p>In the plot window, the position of tbe sub-field will be plotted.</p>
<p>:param ccd_code: Code of the CCD on which the sub-field is located.</p>
<p>:param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
of the given CCD [pixels].</p>
<p>:param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
of the given CCD [pixels].</p>
<p>:param num_rows: Number of rows in the sub-field [pixels].</p>
<p>:param num_columns: Number of columns in the sub-field [pixels].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWidgetWithSubField(FocalPlaneWidget):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the position of the sub-field on the focal plane.
    &#34;&#34;&#34;

    def __init__(self, ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        In the plot window, the position of tbe sub-field will be plotted.

        :param ccd_code: Code of the CCD on which the sub-field is located.

        :param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
                              of the given CCD [pixels].

        :param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
                                 of the given CCD [pixels].

        :param num_rows: Number of rows in the sub-field [pixels].

        :param num_columns: Number of columns in the sub-field [pixels].
        &#34;&#34;&#34;

        super(FocalPlaneWidgetWithSubField, self).__init__()

        self.setStatusTip(
            &#34;Position of the sub-field on the focal plane, based on the FITS header&#34;)

        self.focal_plane.set_subfield(ccd_code=ccd_code, zeropoint_row=zeropoint_row,
                                      zeropoint_column=zeropoint_column, num_rows=num_rows, num_columns=num_columns)


    def get_focal_plane(self):

        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return FocalPlaneWithSubField()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_focal_plane" href="#egse.gui.focalplane.FocalPlaneWidget.get_focal_plane">get_focal_plane</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_widget" href="#egse.gui.focalplane.FocalPlaneWidget.get_widget">get_widget</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system" href="#egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system">update_coordinate_system</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWidgetWithVisitedPositions</span></span>
</code></dt>
<dd>
<div class="desc"><p>Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
indicating the field-of-view.
Below the plot window, you can find a combobox to choose
the coordinate system to use in the plot.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Possibility to draw the visited positions on the focal plane.</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.
Below the plot you can find a spinner to choose the coordinate
system to be used in the plot.</p>
<p>In the plot window, the visited positions will be plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWidgetWithVisitedPositions(FocalPlaneWidget):

    &#34;&#34;&#34;
    Widget with a FigureCanvas (plot window) showing the focal plane, with a blue circle
    indicating the field-of-view.  Below the plot window, you can find a combobox to choose
    the coordinate system to use in the plot.  The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the visited positions on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        In the plot window, the visited positions will be plotted.
        &#34;&#34;&#34;

        super(FocalPlaneWidgetWithVisitedPositions, self).__init__()

        self.setToolTip(&#34;Visited positions&#34;)

    def visit_position(self, x_fp, y_fp):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates.

        :param x: Focal-plane x-coordinate of the new visited position [mm].

        :param y: Focal-plane y-coordinate of the new visited position [mm].
        &#34;&#34;&#34;

        self.focal_plane.visit_position(x_fp, y_fp)

    def get_focal_plane(self):

        &#34;&#34;&#34;
        Returns the widget with the focal plane only (so without the combobox to
        choose the coordinate system).

        :return: Widget with the focal plane only (so without the combobox to
                 choose the coordinate system).
        &#34;&#34;&#34;

        return FocalPlaneWithVisitedPositions()

    def clear_visited_positions(self):
        &#34;&#34;&#34; Clear all visited positions.&#34;&#34;&#34;

        self.focal_plane.clear_visited_positions()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></li>
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions.clear_visited_positions"><code class="name flex">
<span>def <span class="ident">clear_visited_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all visited positions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_visited_positions(self):
    &#34;&#34;&#34; Clear all visited positions.&#34;&#34;&#34;

    self.focal_plane.clear_visited_positions()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions.visit_position"><code class="name flex">
<span>def <span class="ident">visit_position</span></span>(<span>self, x_fp, y_fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a red dot at the position with the given focal-plane coordinates.</p>
<p>:param x: Focal-plane x-coordinate of the new visited position [mm].</p>
<p>:param y: Focal-plane y-coordinate of the new visited position [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_position(self, x_fp, y_fp):

    &#34;&#34;&#34;
    Add a red dot at the position with the given focal-plane coordinates.

    :param x: Focal-plane x-coordinate of the new visited position [mm].

    :param y: Focal-plane y-coordinate of the new visited position [mm].
    &#34;&#34;&#34;

    self.focal_plane.visit_position(x_fp, y_fp)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_focal_plane" href="#egse.gui.focalplane.FocalPlaneWidget.get_focal_plane">get_focal_plane</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_widget" href="#egse.gui.focalplane.FocalPlaneWidget.get_widget">get_widget</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system" href="#egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system">update_coordinate_system</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSourcePosition"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWithSourcePosition</span></span>
</code></dt>
<dd>
<div class="desc"><p>FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Possibility to draw the source position on the focal plane.</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWithSourcePosition(FocalPlane):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the source position on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;

        super(FocalPlaneWithSourcePosition, self).__init__()

        self.source_position_is_drawn = False
        self.x_fp = None
        self.y_fp = None

        self.change_to_pixel_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the source position (if any).
        &#34;&#34;&#34;

        super().change_to_pixel_coordinates()
        self.source_position_is_drawn = False

        self.update_source_position(self.x_fp, self.y_fp)

        self.draw()

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the source position (if any).
        &#34;&#34;&#34;

        super().change_to_focal_plane_coordinates()
        self.source_position_is_drawn = False

        self.update_source_position(self.x_fp, self.y_fp)

        self.draw()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the source position (if any).
        &#34;&#34;&#34;

        super().change_to_angle_coordinates()
        self.source_position_is_drawn = False

        self.update_source_position(self.x_fp, self.y_fp)

        self.draw()

    def update_source_position(self, x_fp, y_fp):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates. In case
        a source position had been marked before, that red dot must be removed first.

        :param x_fp: Focal-plane x-coordinate of the new source position [mm].

        :param y_fp: Focal-plane y-coordinate of the new source position [mm].
        &#34;&#34;&#34;

        # Remove the previously visited location (if needed)

        if self.source_position_is_drawn:

            del self.ax.lines[-1]
            self.source_position_is_drawn = False

        if (x_fp is None) or (y_fp is None):
            return

        # Outside the FOV

        if abs(x_fp) &gt; FOV_SETTINGS.RADIUS_MM and abs(y_fp) &gt; FOV_SETTINGS.RADIUS_MM:

            self.ax.plot([0], [0], color=&#34;white&#34;)

        # Put a red dot at the new source position

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.ax.plot([x_fp], [y_fp], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.ax.plot([x_fp / PIXEL_SIZE], [y_fp / PIXEL_SIZE], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            (theta, phi) = focal_plane_coordinates_to_angles(x_fp, y_fp)

            self.ax.plot([radians(phi)], [theta], &#34;ro&#34;)

        self.source_position_is_drawn = True
        self.x_fp = x_fp
        self.y_fp = y_fp

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlane" href="#egse.gui.focalplane.FocalPlane">FocalPlane</a></li>
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_angle_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_angle_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in angle coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the source position (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_angle_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in angle coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the source position (if any).
    &#34;&#34;&#34;

    super().change_to_angle_coordinates()
    self.source_position_is_drawn = False

    self.update_source_position(self.x_fp, self.y_fp)

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_focal_plane_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in focal-plane coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the source position (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_focal_plane_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in focal-plane coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the source position (if any).
    &#34;&#34;&#34;

    super().change_to_focal_plane_coordinates()
    self.source_position_is_drawn = False

    self.update_source_position(self.x_fp, self.y_fp)

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_pixel_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_pixel_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in pixel coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the source position (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_pixel_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in pixel coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the source position (if any).
    &#34;&#34;&#34;

    super().change_to_pixel_coordinates()
    self.source_position_is_drawn = False

    self.update_source_position(self.x_fp, self.y_fp)

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSourcePosition.update_source_position"><code class="name flex">
<span>def <span class="ident">update_source_position</span></span>(<span>self, x_fp, y_fp)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a red dot at the position with the given focal-plane coordinates. In case
a source position had been marked before, that red dot must be removed first.</p>
<p>:param x_fp: Focal-plane x-coordinate of the new source position [mm].</p>
<p>:param y_fp: Focal-plane y-coordinate of the new source position [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_source_position(self, x_fp, y_fp):

    &#34;&#34;&#34;
    Add a red dot at the position with the given focal-plane coordinates. In case
    a source position had been marked before, that red dot must be removed first.

    :param x_fp: Focal-plane x-coordinate of the new source position [mm].

    :param y_fp: Focal-plane y-coordinate of the new source position [mm].
    &#34;&#34;&#34;

    # Remove the previously visited location (if needed)

    if self.source_position_is_drawn:

        del self.ax.lines[-1]
        self.source_position_is_drawn = False

    if (x_fp is None) or (y_fp is None):
        return

    # Outside the FOV

    if abs(x_fp) &gt; FOV_SETTINGS.RADIUS_MM and abs(y_fp) &gt; FOV_SETTINGS.RADIUS_MM:

        self.ax.plot([0], [0], color=&#34;white&#34;)

    # Put a red dot at the new source position

    if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

        self.ax.plot([x_fp], [y_fp], &#34;ro&#34;)

    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

        self.ax.plot([x_fp / PIXEL_SIZE], [y_fp / PIXEL_SIZE], &#34;ro&#34;)

    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

        (theta, phi) = focal_plane_coordinates_to_angles(x_fp, y_fp)

        self.ax.plot([radians(phi)], [theta], &#34;ro&#34;)

    self.source_position_is_drawn = True
    self.x_fp = x_fp
    self.y_fp = y_fp

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSubField"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWithSubField</span></span>
</code></dt>
<dd>
<div class="desc"><p>FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Possibility to draw the position of the sub-field on the focal plane.</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWithSubField(FocalPlane):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the position of the sub-field on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;

        super(FocalPlaneWithSubField, self).__init__()

        self.subfield_is_drawn = False
        self.ccd_code = None
        self.zeropoint_row = None
        self.zeropoint_column = None
        self.num_rows = None
        self.num_columns = None

        self.change_to_pixel_coordinates()

    def set_subfield(self, ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None):

        &#34;&#34;&#34;
        First-time drawing of the sub-field (in pixel coordinates).  All information is stored in
        variables and the sub-field is shown as a red rectangle on the focal plane.

        :param ccd_code: Code of the CCD on which the sub-field is located.

        :param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
                              of the given CCD [pixels].

        :param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
                                 of the given CCD [pixels].

        :param num_rows: Number of rows in the sub-field [pixels].

        :param num_columns: Number of columns in the sub-field [pixels].
        &#34;&#34;&#34;

        self.ccd_code = ccd_code
        self.zeropoint_row = zeropoint_row
        self.zeropoint_column = zeropoint_column
        self.num_rows = num_rows
        self.num_columns = num_columns

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:
            self.change_to_focal_plane_coordinates
        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:
            self.change_to_pixel_coordinates()
        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:
            self.change_to_angle_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the sub-field (if any).
        &#34;&#34;&#34;

        super().change_to_pixel_coordinates()
        self.subfield_is_drawn = False

        self.update_subfield()

        self.draw()

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the sub-field (if any).
        &#34;&#34;&#34;

        super().change_to_focal_plane_coordinates()
        self.subfield_is_drawn = False

        self.update_subfield()

        self.draw()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the sub-field (if any).
        &#34;&#34;&#34;

        super().change_to_angle_coordinates()
        self.subfield_is_drawn = False

        self.update_subfield()

        self.draw()

    def update_subfield(self):

        # Remove the sub-field (if needed)

        if self.subfield_is_drawn:

            del self.ax.lines[-1]
            self.subfield_is_drawn = False

        if self.ccd_code is None:
            self.draw()
            return

        # Draw the sub-field

        (x_fp_1, y_fp_1) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row, self.zeropoint_column, self.ccd_code)
        (x_fp_2, y_fp_2) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row + self.num_rows, self.zeropoint_column, self.ccd_code)
        (x_fp_3, y_fp_3) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row + self.num_rows, self.zeropoint_column + self.num_columns, self.ccd_code)
        (x_fp_4, y_fp_4) = ccd_to_focal_plane_coordinates(
            self.zeropoint_row, self.zeropoint_column + self.num_columns, self.ccd_code)

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.ax.plot([x_fp_1, x_fp_2], [y_fp_1, y_fp_2], &#34;r-&#34;)
            self.ax.plot([x_fp_2, x_fp_3], [y_fp_2, y_fp_3], &#34;r-&#34;)
            self.ax.plot([x_fp_3, x_fp_4], [y_fp_3, y_fp_4], &#34;r-&#34;)
            self.ax.plot([x_fp_4, x_fp_1], [y_fp_4, y_fp_1], &#34;r-&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.ax.plot([x_fp_1 / PIXEL_SIZE, x_fp_2 / PIXEL_SIZE], [y_fp_1 / PIXEL_SIZE, y_fp_2 / PIXEL_SIZE], &#34;r-&#34;)
            self.ax.plot([x_fp_2 / PIXEL_SIZE, x_fp_3 / PIXEL_SIZE], [y_fp_2 / PIXEL_SIZE, y_fp_3 / PIXEL_SIZE], &#34;r-&#34;)
            self.ax.plot([x_fp_3 / PIXEL_SIZE, x_fp_4 / PIXEL_SIZE], [y_fp_3 / PIXEL_SIZE, y_fp_4 / PIXEL_SIZE], &#34;r-&#34;)
            self.ax.plot([x_fp_4 / PIXEL_SIZE, x_fp_1 / PIXEL_SIZE], [y_fp_4 / PIXEL_SIZE, y_fp_1 / PIXEL_SIZE], &#34;r-&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            (theta1, phi1) = focal_plane_coordinates_to_angles(x_fp_1, y_fp_1)
            (theta2, phi2) = focal_plane_coordinates_to_angles(x_fp_2, y_fp_2)
            (theta3, phi3) = focal_plane_coordinates_to_angles(x_fp_3, y_fp_3)
            (theta4, phi4) = focal_plane_coordinates_to_angles(x_fp_4, y_fp_4)

            phi1 = radians(phi1)
            phi2 = radians(phi2)
            phi3 = radians(phi3)
            phi4 = radians(phi4)

            self.ax.plot([phi1, phi2], [theta1, theta2], &#34;r-&#34;)
            self.ax.plot([phi2, phi3], [theta2, theta3], &#34;r-&#34;)
            self.ax.plot([phi3, phi4], [theta3, theta4], &#34;r-&#34;)
            self.ax.plot([phi4, phi1], [theta4, theta1], &#34;r-&#34;)

        self.subfield_is_drawn = True

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlane" href="#egse.gui.focalplane.FocalPlane">FocalPlane</a></li>
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlaneWithSubField.change_to_angle_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_angle_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in angle coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the sub-field (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_angle_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in angle coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the sub-field (if any).
    &#34;&#34;&#34;

    super().change_to_angle_coordinates()
    self.subfield_is_drawn = False

    self.update_subfield()

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSubField.change_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_focal_plane_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in focal-plane coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the sub-field (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_focal_plane_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in focal-plane coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the sub-field (if any).
    &#34;&#34;&#34;

    super().change_to_focal_plane_coordinates()
    self.subfield_is_drawn = False

    self.update_subfield()

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSubField.change_to_pixel_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_pixel_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in pixel coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the sub-field (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_pixel_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in pixel coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the sub-field (if any).
    &#34;&#34;&#34;

    super().change_to_pixel_coordinates()
    self.subfield_is_drawn = False

    self.update_subfield()

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSubField.set_subfield"><code class="name flex">
<span>def <span class="ident">set_subfield</span></span>(<span>self, ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>First-time drawing of the sub-field (in pixel coordinates).
All information is stored in
variables and the sub-field is shown as a red rectangle on the focal plane.</p>
<p>:param ccd_code: Code of the CCD on which the sub-field is located.</p>
<p>:param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
of the given CCD [pixels].</p>
<p>:param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
of the given CCD [pixels].</p>
<p>:param num_rows: Number of rows in the sub-field [pixels].</p>
<p>:param num_columns: Number of columns in the sub-field [pixels].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_subfield(self, ccd_code=None, zeropoint_row=None, zeropoint_column=None, num_rows=None, num_columns=None):

    &#34;&#34;&#34;
    First-time drawing of the sub-field (in pixel coordinates).  All information is stored in
    variables and the sub-field is shown as a red rectangle on the focal plane.

    :param ccd_code: Code of the CCD on which the sub-field is located.

    :param zeropoint_row: Row coordinate of the origin of the sub-field in the CCD coordinate system
                          of the given CCD [pixels].

    :param zeropoint_column: Column coordinate of the origin of the sub-field in the CCD coordinate system
                             of the given CCD [pixels].

    :param num_rows: Number of rows in the sub-field [pixels].

    :param num_columns: Number of columns in the sub-field [pixels].
    &#34;&#34;&#34;

    self.ccd_code = ccd_code
    self.zeropoint_row = zeropoint_row
    self.zeropoint_column = zeropoint_column
    self.num_rows = num_rows
    self.num_columns = num_columns

    if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:
        self.change_to_focal_plane_coordinates
    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:
        self.change_to_pixel_coordinates()
    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:
        self.change_to_angle_coordinates()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithSubField.update_subfield"><code class="name flex">
<span>def <span class="ident">update_subfield</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_subfield(self):

    # Remove the sub-field (if needed)

    if self.subfield_is_drawn:

        del self.ax.lines[-1]
        self.subfield_is_drawn = False

    if self.ccd_code is None:
        self.draw()
        return

    # Draw the sub-field

    (x_fp_1, y_fp_1) = ccd_to_focal_plane_coordinates(
        self.zeropoint_row, self.zeropoint_column, self.ccd_code)
    (x_fp_2, y_fp_2) = ccd_to_focal_plane_coordinates(
        self.zeropoint_row + self.num_rows, self.zeropoint_column, self.ccd_code)
    (x_fp_3, y_fp_3) = ccd_to_focal_plane_coordinates(
        self.zeropoint_row + self.num_rows, self.zeropoint_column + self.num_columns, self.ccd_code)
    (x_fp_4, y_fp_4) = ccd_to_focal_plane_coordinates(
        self.zeropoint_row, self.zeropoint_column + self.num_columns, self.ccd_code)

    if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

        self.ax.plot([x_fp_1, x_fp_2], [y_fp_1, y_fp_2], &#34;r-&#34;)
        self.ax.plot([x_fp_2, x_fp_3], [y_fp_2, y_fp_3], &#34;r-&#34;)
        self.ax.plot([x_fp_3, x_fp_4], [y_fp_3, y_fp_4], &#34;r-&#34;)
        self.ax.plot([x_fp_4, x_fp_1], [y_fp_4, y_fp_1], &#34;r-&#34;)

    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

        self.ax.plot([x_fp_1 / PIXEL_SIZE, x_fp_2 / PIXEL_SIZE], [y_fp_1 / PIXEL_SIZE, y_fp_2 / PIXEL_SIZE], &#34;r-&#34;)
        self.ax.plot([x_fp_2 / PIXEL_SIZE, x_fp_3 / PIXEL_SIZE], [y_fp_2 / PIXEL_SIZE, y_fp_3 / PIXEL_SIZE], &#34;r-&#34;)
        self.ax.plot([x_fp_3 / PIXEL_SIZE, x_fp_4 / PIXEL_SIZE], [y_fp_3 / PIXEL_SIZE, y_fp_4 / PIXEL_SIZE], &#34;r-&#34;)
        self.ax.plot([x_fp_4 / PIXEL_SIZE, x_fp_1 / PIXEL_SIZE], [y_fp_4 / PIXEL_SIZE, y_fp_1 / PIXEL_SIZE], &#34;r-&#34;)

    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

        (theta1, phi1) = focal_plane_coordinates_to_angles(x_fp_1, y_fp_1)
        (theta2, phi2) = focal_plane_coordinates_to_angles(x_fp_2, y_fp_2)
        (theta3, phi3) = focal_plane_coordinates_to_angles(x_fp_3, y_fp_3)
        (theta4, phi4) = focal_plane_coordinates_to_angles(x_fp_4, y_fp_4)

        phi1 = radians(phi1)
        phi2 = radians(phi2)
        phi3 = radians(phi3)
        phi4 = radians(phi4)

        self.ax.plot([phi1, phi2], [theta1, theta2], &#34;r-&#34;)
        self.ax.plot([phi2, phi3], [theta2, theta3], &#34;r-&#34;)
        self.ax.plot([phi3, phi4], [theta3, theta4], &#34;r-&#34;)
        self.ax.plot([phi4, phi1], [theta4, theta1], &#34;r-&#34;)

    self.subfield_is_drawn = True

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions"><code class="flex name class">
<span>class <span class="ident">FocalPlaneWithVisitedPositions</span></span>
</code></dt>
<dd>
<div class="desc"><p>FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
The available coordinate systems are:
- pixel coordinates [pixels],
- focal-plane coordinates [mm],
- and field angles [degrees].</p>
<p>Possibility to draw the visited positions of the sub-field on the focal plane.</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocalPlaneWithVisitedPositions(FocalPlane):

    &#34;&#34;&#34;
    FigureCanvas showing the focal plane, with a blue circle indicating the field-of-view.
    The available coordinate systems are:
        - pixel coordinates [pixels],
        - focal-plane coordinates [mm],
        - and field angles [degrees].

    Possibility to draw the visited positions of the sub-field on the focal plane.
    &#34;&#34;&#34;

    def __init__(self):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.
        &#34;&#34;&#34;

        super(FocalPlaneWithVisitedPositions, self).__init__()

        self.visited_x_fp = np.array([])
        self.visited_y_fp = np.array([])

        self.change_to_pixel_coordinates()

    def change_to_pixel_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in pixel coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the visited positions (if any).
        &#34;&#34;&#34;

        super().change_to_pixel_coordinates()

        # Re-draw the visited positions in the new coordinate system

        self.redraw_visited_positions()

        self.draw()

    def change_to_focal_plane_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in focal-plane coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the visited postiions (if any).
        &#34;&#34;&#34;

        super().change_to_focal_plane_coordinates()

        # Re-draw the visited positions in the new coordinate system

        self.redraw_visited_positions()

        self.draw()

    def change_to_angle_coordinates(self):

        &#34;&#34;&#34;
        Preparation of the plot to show the source position in angle coordinates:

            - clear the plot;
            - draw a blue circle, indicating the size of the field-of view;
            - configure the axes and grid lines;
            - draw the CCDs and their readout registers;
            - add the CCD codes;

        and re-draw the visited positions (if any).
        &#34;&#34;&#34;

        super().change_to_angle_coordinates()

        # Re-draw the visited positions in the new coordinate system

        self.redraw_visited_positions()

        self.draw()

    def visit_position(self, x_fp, y_fp, redraw=False):

        &#34;&#34;&#34;
        Add a red dot at the position with the given focal-plane coordinates. If you are not
        in re-drawing mode, keep track of this new position in the list of visited positions.

        :param x: Focal-plane x-coordinate of the new visited position [mm].

        :param y: Focal-plane y-coordinate of the new visited position [mm].

        :param redraw: If False, the given position should not be added to the list of visited
                       positions (as it is already in there); otherwise, the list of visited
                       positions must be expanded with the given position.
        &#34;&#34;&#34;

        if len(self.visited_x_fp) &gt; 0:

            self.ax.lines[-1].set_color(&#34;blue&#34;)

        # Outside the FOV

        if abs(x_fp) &gt; FOV_SETTINGS.RADIUS_MM and abs(y_fp) &gt; FOV_SETTINGS.RADIUS_MM:

            self.ax.plot([0], [0], color=&#34;white&#34;)

        # Put a red dot at the new source position

        if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

            self.ax.plot([x_fp], [y_fp], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

            self.ax.plot([x_fp / PIXEL_SIZE], [y_fp / PIXEL_SIZE], &#34;ro&#34;)

        elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

            (theta, phi) = focal_plane_coordinates_to_angles(x_fp, y_fp)

            self.ax.plot([radians(phi)], [theta], &#34;ro&#34;)

        if not redraw:

            self.visited_x_fp = np.append(self.visited_x_fp, x_fp)
            self.visited_y_fp = np.append(self.visited_y_fp, y_fp)

        self.draw()

    def redraw_visited_positions(self):

        &#34;&#34;&#34;
        Re-draw the visited positions in the current coordinate system.
        &#34;&#34;&#34;

        for (x_fp, y_fp) in zip(self.visited_x_fp, self.visited_y_fp):
            self.visit_position(x_fp, y_fp, redraw=True)

    def clear_visited_positions(self):
        &#34;&#34;&#34; Clear all visited positions.&#34;&#34;&#34;

        num_points = len(self.visited_x_fp)
        while num_points &gt; 0:
            del self.ax.lines[-1]
            num_points -= 1

        self.visited_x_fp = np.array([])
        self.visited_y_fp = np.array([])

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.gui.focalplane.FocalPlane" href="#egse.gui.focalplane.FocalPlane">FocalPlane</a></li>
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_angle_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_angle_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in angle coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the visited positions (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_angle_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in angle coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the visited positions (if any).
    &#34;&#34;&#34;

    super().change_to_angle_coordinates()

    # Re-draw the visited positions in the new coordinate system

    self.redraw_visited_positions()

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_focal_plane_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_focal_plane_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in focal-plane coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the visited postiions (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_focal_plane_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in focal-plane coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the visited postiions (if any).
    &#34;&#34;&#34;

    super().change_to_focal_plane_coordinates()

    # Re-draw the visited positions in the new coordinate system

    self.redraw_visited_positions()

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_pixel_coordinates"><code class="name flex">
<span>def <span class="ident">change_to_pixel_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Preparation of the plot to show the source position in pixel coordinates:</p>
<pre><code>- clear the plot;
- draw a blue circle, indicating the size of the field-of view;
- configure the axes and grid lines;
- draw the CCDs and their readout registers;
- add the CCD codes;
</code></pre>
<p>and re-draw the visited positions (if any).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_to_pixel_coordinates(self):

    &#34;&#34;&#34;
    Preparation of the plot to show the source position in pixel coordinates:

        - clear the plot;
        - draw a blue circle, indicating the size of the field-of view;
        - configure the axes and grid lines;
        - draw the CCDs and their readout registers;
        - add the CCD codes;

    and re-draw the visited positions (if any).
    &#34;&#34;&#34;

    super().change_to_pixel_coordinates()

    # Re-draw the visited positions in the new coordinate system

    self.redraw_visited_positions()

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions.clear_visited_positions"><code class="name flex">
<span>def <span class="ident">clear_visited_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all visited positions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_visited_positions(self):
    &#34;&#34;&#34; Clear all visited positions.&#34;&#34;&#34;

    num_points = len(self.visited_x_fp)
    while num_points &gt; 0:
        del self.ax.lines[-1]
        num_points -= 1

    self.visited_x_fp = np.array([])
    self.visited_y_fp = np.array([])

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions.redraw_visited_positions"><code class="name flex">
<span>def <span class="ident">redraw_visited_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-draw the visited positions in the current coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redraw_visited_positions(self):

    &#34;&#34;&#34;
    Re-draw the visited positions in the current coordinate system.
    &#34;&#34;&#34;

    for (x_fp, y_fp) in zip(self.visited_x_fp, self.visited_y_fp):
        self.visit_position(x_fp, y_fp, redraw=True)</code></pre>
</details>
</dd>
<dt id="egse.gui.focalplane.FocalPlaneWithVisitedPositions.visit_position"><code class="name flex">
<span>def <span class="ident">visit_position</span></span>(<span>self, x_fp, y_fp, redraw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a red dot at the position with the given focal-plane coordinates. If you are not
in re-drawing mode, keep track of this new position in the list of visited positions.</p>
<p>:param x: Focal-plane x-coordinate of the new visited position [mm].</p>
<p>:param y: Focal-plane y-coordinate of the new visited position [mm].</p>
<p>:param redraw: If False, the given position should not be added to the list of visited
positions (as it is already in there); otherwise, the list of visited
positions must be expanded with the given position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_position(self, x_fp, y_fp, redraw=False):

    &#34;&#34;&#34;
    Add a red dot at the position with the given focal-plane coordinates. If you are not
    in re-drawing mode, keep track of this new position in the list of visited positions.

    :param x: Focal-plane x-coordinate of the new visited position [mm].

    :param y: Focal-plane y-coordinate of the new visited position [mm].

    :param redraw: If False, the given position should not be added to the list of visited
                   positions (as it is already in there); otherwise, the list of visited
                   positions must be expanded with the given position.
    &#34;&#34;&#34;

    if len(self.visited_x_fp) &gt; 0:

        self.ax.lines[-1].set_color(&#34;blue&#34;)

    # Outside the FOV

    if abs(x_fp) &gt; FOV_SETTINGS.RADIUS_MM and abs(y_fp) &gt; FOV_SETTINGS.RADIUS_MM:

        self.ax.plot([0], [0], color=&#34;white&#34;)

    # Put a red dot at the new source position

    if self.coordinate_system == COORDINATE_SYSTEMS[&#34;Focal plane&#34;]:

        self.ax.plot([x_fp], [y_fp], &#34;ro&#34;)

    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Pixels&#34;]:

        self.ax.plot([x_fp / PIXEL_SIZE], [y_fp / PIXEL_SIZE], &#34;ro&#34;)

    elif self.coordinate_system == COORDINATE_SYSTEMS[&#34;Angles&#34;]:

        (theta, phi) = focal_plane_coordinates_to_angles(x_fp, y_fp)

        self.ax.plot([radians(phi)], [theta], &#34;ro&#34;)

    if not redraw:

        self.visited_x_fp = np.append(self.visited_x_fp, x_fp)
        self.visited_y_fp = np.append(self.visited_y_fp, y_fp)

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.gui" href="index.html">egse.gui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlane" href="#egse.gui.focalplane.FocalPlane">FocalPlane</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlane.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlane.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlane.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlane.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlane.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlane.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWidget" href="#egse.gui.focalplane.FocalPlaneWidget">FocalPlaneWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWidget.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_focal_plane" href="#egse.gui.focalplane.FocalPlaneWidget.get_focal_plane">get_focal_plane</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.get_widget" href="#egse.gui.focalplane.FocalPlaneWidget.get_widget">get_widget</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system" href="#egse.gui.focalplane.FocalPlaneWidget.update_coordinate_system">update_coordinate_system</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition" href="#egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition">FocalPlaneWidgetWithSourcePosition</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition.update_source_position" href="#egse.gui.focalplane.FocalPlaneWidgetWithSourcePosition.update_source_position">update_source_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWidgetWithSubField" href="#egse.gui.focalplane.FocalPlaneWidgetWithSubField">FocalPlaneWidgetWithSubField</a></code></h4>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions" href="#egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions">FocalPlaneWidgetWithVisitedPositions</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions.clear_visited_positions" href="#egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions.clear_visited_positions">clear_visited_positions</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions.visit_position" href="#egse.gui.focalplane.FocalPlaneWidgetWithVisitedPositions.visit_position">visit_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWithSourcePosition" href="#egse.gui.focalplane.FocalPlaneWithSourcePosition">FocalPlaneWithSourcePosition</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWithSourcePosition.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSourcePosition.update_source_position" href="#egse.gui.focalplane.FocalPlaneWithSourcePosition.update_source_position">update_source_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWithSubField" href="#egse.gui.focalplane.FocalPlaneWithSubField">FocalPlaneWithSubField</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSubField.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWithSubField.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSubField.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWithSubField.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSubField.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWithSubField.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSubField.set_subfield" href="#egse.gui.focalplane.FocalPlaneWithSubField.set_subfield">set_subfield</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithSubField.update_subfield" href="#egse.gui.focalplane.FocalPlaneWithSubField.update_subfield">update_subfield</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions">FocalPlaneWithVisitedPositions</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_angle_coordinates" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_angle_coordinates">change_to_angle_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_focal_plane_coordinates" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_focal_plane_coordinates">change_to_focal_plane_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_pixel_coordinates" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions.change_to_pixel_coordinates">change_to_pixel_coordinates</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions.clear_visited_positions" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions.clear_visited_positions">clear_visited_positions</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions.redraw_visited_positions" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions.redraw_visited_positions">redraw_visited_positions</a></code></li>
<li><code><a title="egse.gui.focalplane.FocalPlaneWithVisitedPositions.visit_position" href="#egse.gui.focalplane.FocalPlaneWithVisitedPositions.visit_position">visit_position</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
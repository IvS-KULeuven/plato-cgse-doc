<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.gui.stripchart API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.gui.stripchart</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import warnings
from datetime import datetime
from datetime import timedelta
from functools import partial

import pyqtgraph as pg
from PyQt5.QtCore import QDateTime
from PyQt5.QtCore import QRegExp
from PyQt5.QtCore import QTime
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QIcon
from PyQt5.QtGui import QIntValidator
from PyQt5.QtGui import QPixmap
from PyQt5.QtGui import QRegExpValidator
from PyQt5.QtWidgets import QAction
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QGridLayout
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QLineEdit
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QPushButton
from PyQt5.QtWidgets import QSizePolicy
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.dates import DateFormatter
from matplotlib.figure import Figure
from pyqtgraph import AxisItem
from pyqtgraph import PlotWidget

from egse.config import find_file
from egse.process import ProcessStatus
from egse.randomwalk import RandomWalk

warnings.filterwarnings(&#34;ignore&#34;)






def cut_range(x, y, interval):

    &#34;&#34;&#34;
    Limit the elements in both lists such that the x-range is not larger
    than interval. The lists are shortened from the start.

    Given two lists of equal length, shorten the lists such that the elements
    in the x-list all fall within the range x[-1] - interval. The function is
    used to simulate a moving window of size interval.

    Args:
        - x: List of x-values in ascending order.
        - y: List of corresponding y-values.
        - interval: Range of x-value to crop to.

    Returns:
        - Cropped x-list.
        - Cropped y-list.
    &#34;&#34;&#34;

    x_min = x[-1] - interval
    idx = next(a[0] for a in enumerate(x) if a[1] &gt;= x_min)

    return x[idx:], y[idx:]

def cut_interval(x, y, start_time, end_time):

    &#34;&#34;&#34;
    Limit the elements in both lists such that the x-values are in the given interval.

    Given two lists of equal lenght, shorten the lists such that the elements in the x-list
    are within the given interval.

    Args:
        - x: List of x-values in ascending order.
        - y: List of corresponding y-values.
        - start_time: Minimum x-value to include in the cropped lists.
        - end_time: Maximum x-value to include in the cropped lists.

    Returns:
        - Cropped x-list.
        - Cropped y-list.
    &#34;&#34;&#34;

    print(type(start_time), type(end_time), type(x[0]))
    idx = next(a[0] for a in enumerate(x) if a[1] &gt;= start_time and a[1] &lt; end_time)

    return x[idx:], y[idx:]

def link(stripchart_widget, stripchart_controller):

    &#34;&#34;&#34;
    Link the given stripchart widget with the given controller.  This means the
    following:

        - the stripchart widget &#34;knows&#34; about the stripchart controller and will update
          the information that is shown there;
        - the stripchart controller &#34;knows&#34; about the stripchart widget and controls what
          is shown.
    &#34;&#34;&#34;

    stripchart_widget.controller = stripchart_controller
    stripchart_controller.stripcharts.append(stripchart_widget)

    if stripchart_controller.toolbar_mode:

        stripchart_controller.play_action.triggered.connect(stripchart_widget.play) # Action to put into the toolbar of the main GUI

    else:

        stripchart_controller.play_button.clicked.connect(stripchart_widget.play)   # Play button in the controller widget

class StripChartControllerWidget(QGroupBox):

    &#34;&#34;&#34;
    Displays the begin and end of the time range that will be shown in the stripchart widgets
    that are linked to this stripchart controller (in the format &#34;d hh:mm:ss&#34;), and the corresponding
    interval length (in seconds).

    You can choose to display either:

        - the last interval (of given duration) of the time series
        - or a specific period in time (from the given start to end time).

    This can be chosen in two different way (you have to pick one):

        - via a button in the stripchart controller widget
        - or via a button/action that can be placed in the toolbar of the main GUI.

    If the button of choice is in &#34;play&#34; mode, the last time interval will be shown, the
    length of which can be specified (in seconds) in the text field in the controller widget. The
    start and end time of this time period is also displayed (but cannot be changed).
    Alternatively, if the button of choice is in &#34;pause&#34; mode, the plot is no longer updated
    in realtime, but you can specify which time period to inspect, by adapting the start and end
    time (in the format &#34;d hh:mm:ss&#34;).  The interval lengths is also displayed (but cannot be
    changed).
    &#34;&#34;&#34;

    def __init__(self, toolbar_mode=True):

        super(StripChartControllerWidget, self).__init__(&#34;&#34;)

        self.stripcharts = []
        self.realtime = True

        self.toolbar_mode = toolbar_mode

        if toolbar_mode:

            self.create_play_action()

        layout = QGridLayout()

        # Button: play/pause

        if not toolbar_mode:

            self.create_play_button()
            layout.addWidget(self.play_button, 0, 0)

        # From ... to ...

        self.create_start_end()

        layout.addWidget(QLabel(&#34;From&#34;), 1, 1)
        layout.addWidget(self.start_time_label, 1, 2)
        layout.addWidget(QLabel(&#34;to&#34;), 1, 3)
        layout.addWidget(self.end_time_label, 1, 4)

        # Interval length

        self.create_interval()

        layout.addWidget(QLabel(&#34;Interval [s]&#34;), 2, 1)
        layout.addWidget(self.interval_label, 2, 2)

        self.setLayout(layout)


    def create_play_action(self):

        &#34;&#34;&#34;
        Create play button/action that will be added to the toolbar of the main GUI.  When this button
        is pushed, the behaviour of the plots of the stripcharts changes accordingly.
        &#34;&#34;&#34;

        play_pix = QPixmap(str(find_file(&#34;play.png&#34;, in_dir=&#34;images&#34;)))
        pause_pix = QPixmap(str(find_file(&#34;pause.png&#34;, in_dir=&#34;images&#34;)))
        play_icon = QIcon()
        play_icon.addPixmap(play_pix, QIcon.Normal, QIcon.On)
        play_icon.addPixmap(pause_pix, QIcon.Normal, QIcon.Off)

        self.play_action = QAction(play_icon, &#34;Play&#34;, self)
        self.play_action.setToolTip(&#34;Sohw specific time interval / show last time interval&#34;)
        self.play_action.setCheckable(True)
        self.play_action.setChecked(False)
        self.play_action.triggered.connect(self.handle_play)

    def create_play_button(self):

        &#34;&#34;&#34;
        Create play button that will be added to the stripchart controller.  When this button is
        pushed, the behaviour of the plots of the stripcharts changes accordingly.
        &#34;&#34;&#34;

        self.play_icon  = QIcon(str(find_file(&#34;play.png&#34;, in_dir=&#34;images&#34;)))
        self.pause_icon = QIcon(str(find_file(&#34;pause.png&#34;, in_dir=&#34;images&#34;)))

        self.play_button = QPushButton(&#34;&#34;)
        self.play_button.setToolTip(&#34;Show specific time interval&#34;)
        self.play_button.setIcon(self.pause_icon)
        self.play_button.clicked.connect(self.play)

    def create_start_end(self):

        &#34;&#34;&#34;
        Create the text fields (incl. validators) for the start and end time.

        Currently, the validator is not set for the text fields, as the values are not accepted then
        when you hit enter.  Still to figure out what the problem is.
        &#34;&#34;&#34;

        time_regex = QRegExp(&#39;^([1-9]|[1-9]\d{1,}) ^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$&#39;)
        time_validator = QRegExpValidator(time_regex)

        # Start time

        self.start_time_label = QLineEdit(self)
        self.start_time_label.setReadOnly(True)

        # self.start_time_label.setValidator(time_validator)
        self.start_time_label.setPlaceholderText(&#34;d hh:mm:ss&#34;)
        self.start_time_label.returnPressed.connect(partial(self.update_start_time, self.start_time_label))

        self.end_time_label = QLineEdit(self)
        self.end_time_label.setReadOnly(True)

        # self.end_time_label.setValidator(time_validator)
        self.end_time_label.setPlaceholderText(&#34;d hh:mm:ss&#34;)
        self.end_time_label.returnPressed.connect(partial(self.update_end_time, self.end_time_label))

    def create_interval(self):

        &#34;&#34;&#34;
        Create the text field for the interval length.
        &#34;&#34;&#34;
        self.interval_label = QLineEdit(self)

        interval_validator = QIntValidator()
        interval_validator.setBottom(1)
        self.interval_label.setValidator(interval_validator)

        self.interval = timedelta(seconds=60)

        self.interval_label.setText(str(self.interval.seconds))
        self.interval_label.returnPressed.connect(partial(self.update_interval, self.interval_label))


    def handle_play(self):

        &#34;&#34;&#34;
        When the play button in the toolbar of the main GUI is pushed (if any), the behaviour of the (plots in the)
        stripchart widget changes.

        In realtime mode (real stripchart):
            - the play-button in the stripchart controller (if any) should show the &#34;pause&#34; icon;
            - the plot is updated immediately when an extra datapoint is added to the time series;
            - the textfields in the stripchart controller (if any) with the start and end time cannot be
              changed by the user but will be updated automatically;
            - the interval length can be adapted via the dedicated text field in the stripchart controller (if any).

        In non-realtime mode (inspection of a specific time period):
            - the play-button in the stripchart controller (if any) should show the &#34;play&#34; icon;
            - the plot is no longer updated when an extra datapoint is added to the time series;
            - the start and end time can be adapted via the dedicated text fields in the stripchart
              controller (if any);
            - the textfield in the stripchart controller (if any) with the interval length cannot be
              changed by the user but will be updated automatically (when returning to realtime mode,
              this new interval length will be used).
        &#34;&#34;&#34;

        self.play()

    def play(self):

        &#34;&#34;&#34;
        When the play button is pushed in the stripchart controller (if any), the behaviour of the (plots in the)
        stripchart widget changes.

        In realtime mode (real stripchart):
            - the play-button in the stripchart controller (if any) should show the &#34;pause&#34; icon;
            - the plot is updated immediately when an extra datapoint is added to the time series;
            - the textfields in the stripchart controller (if any) with the start and end time cannot be
              changed by the user but will be updated automatically;
            - the interval length can be adapted via the dedicated text field in the stripchart controller (if any).

        In non-realtime mode (inspection of a specific time period):
            - the play-button in the stripchart controller (if any) should show the &#34;play&#34; icon;
            - the plot is no longer updated when an extra datapoint is added to the time series;
            - the start and end time can be adapted via the dedicated text fields in the stripchart
              controller (if any);
            - the textfield in the stripchart controller (if any) with the interval length cannot be
              changed by the user but will be updated automatically (when returning to realtime mode,
              this new interval length will be used).
        &#34;&#34;&#34;

        self.realtime = not self.realtime

        # Realtime mode

        if self.realtime:

            if not self.toolbar_mode:

                self.play_button.setIcon(self.pause_icon)   # Change the icon on the play-button to &#34;pause&#34;
                self.play_button.setToolTip(&#34;Show specific time interval&#34;)
                self.play_button.repaint()

            self.start_time_label.setReadOnly(True)     # Disable changing the start time text field
            self.end_time_label.setReadOnly(True)       # Disable changing the start time text field
            self.interval_label.setReadOnly(False)      # Enable changing the interval length

        # Non-realtime mode

        else:

            if not self.toolbar_mode:

                self.play_button.setIcon(self.play_icon)   # Change the icon on the play-button to &#34;play&#34;
                self.play_button.setToolTip(&#34;Show last time interval&#34;)
                self.play_button.repaint()

            self.start_time_label.setReadOnly(False)   # Enable changing the start time text field
            self.end_time_label.setReadOnly(False)     # Enable changing the start time text field
            self.interval_label.setReadOnly(True)      # Disable changing the interval length


    def update_interval(self, interval_label):

        &#34;&#34;&#34;
        If the text field with the interval length is updated, the plots in the stripchart
        widgets are updated.  Only applicable in realtime mode.

        Args:
            - interval_label: Text field where the interval length can be entered (in seconds).
        &#34;&#34;&#34;

        self.interval = timedelta(seconds=int(interval_label.text()))

        # Update all stripchart widgets

        for stripchart in self.stripcharts:

            stripchart.update_interval(self.interval)

    def update_start_time(self, start_time_label):

        &#34;&#34;&#34;
        If the text field with the start time is updated, the plots in the stripchart widgets
        are updated.  Only applicable in non-realtime mode.

        Args:
            - start_time_label: Text field where the start time can be entered (in format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        start_time = datetime.strptime(start_time_label.text(), &#34;%j %H:%M:%S&#34;)
        start_time += timedelta(days=365.25*70-1, hours=12)         # 1900 -&gt; 1970

        # Update all stripchart widgets

        for stripchart in self.stripcharts:

            stripchart.update_start_time(start_time)

    def update_end_time(self, end_time_label):

        &#34;&#34;&#34;
        If the text field with the end time is updated, the plots in the stripchart widgets
        are updated.  Only applicable in non-realtime mode.

        Args:
            - end_time_label: Text field where the end time can be entered (in format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        end_time = datetime.strptime(end_time_label.text(), &#34;%j %H:%M:%S&#34;)
        end_time += timedelta(days=365.25*70 - 1, hours=12)         # 1900 -&gt; 1970

        # Update all stripchart widgets

        for stripchart in self.stripcharts:

            stripchart.update_end_time(end_time)

    def set_time(self, last_timepoint):

        &#34;&#34;&#34;
        Update the content of the textfields with the start and end time (in realtime mode only).
        Only applicable in realtime mode.
        &#34;&#34;&#34;

        self.end_time_label.setText(last_timepoint.strftime(&#34;%-d %H:%M:%S&#34;))
        self.start_time_label.setText((last_timepoint - self.interval).strftime(&#34;%-d %H:%M:%S&#34;))


class StripChartWidget(QGroupBox):

    def __init__(self, quantity, unit):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        Args:
            - quantity: Physical quantity shown by the strip chart.
            - unit: Unit of the physical quantity shown by the strip chart.
        &#34;&#34;&#34;

        super(StripChartWidget, self).__init__(&#34;&#34;)

        self.interval = timedelta(seconds=60)

        self.realtime = True
        self.controller = None

        self.timepoints = []
        self.values = []

        # Plot window

        layout = QGridLayout()

        self.stripchart = TimeSeriesCanvas(quantity, unit)

        layout.addWidget(self.stripchart)

        self.setLayout(layout)

    def update(self, time, value):

        &#34;&#34;&#34;
        Update the plot when the given datapoint is added to the time series, only when in realtime
        mode.

        Args:
            - time: Time [ms].
            - value: Value.
        &#34;&#34;&#34;

        # Convert from double to datetime

        time = datetime.fromtimestamp(time / 1000.0)

        # Append to the time series

        self.timepoints.append(time)
        self.values.append(value)

        # Update the plot (only in realtime mode)

        if self.realtime:

            self.end_time = self.timepoints[-1]                 # New point = new end time
            self.start_time = self.end_time - self.interval     # Update start time

            last_timepoints, last_values = cut_range(self.timepoints, self.values, self.interval)   # Cut out the requested range
            self.stripchart.plot(last_timepoints, last_values, interval=self.interval)              # Update the plot

            if not self.controller is None:

                self.controller.set_time(last_timepoints[-1])       # Update the text fields in the stripchart controller (begin and end time)



    def update_interval(self, interval):

        &#34;&#34;&#34;
        When the text field with the interval is updated in the stripchart controller (if any),
        the range on the x-axis of the plot is adapted accordingly.

        Args:
            - interval: Length of the time period to be displayed in the plot [s].
        &#34;&#34;&#34;

        self.interval = interval

        last_timepoints, lastvalues = cut_range(self.timepoints, self.values, self.interval)
        self.stripchart.plot(last_timepoints, lastvalues, interval=self.interval)

    def update_start_time(self, start_time):

        &#34;&#34;&#34;
        When the text field with the start time is updated in the stripchart controller (if any),
        the range on the x-axis of the plot is adapted accordingly.

        Args:
            - start_time: First timepoint to be displayed in the plot (in the format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        self.start_time = start_time

        self.interval = self.end_time.replace(microsecond=0) - self.start_time.replace(microsecond=0)

        self.controller.interval_label.setText(str(self.interval.seconds))

        t, v = cut_interval(self.timepoints, self.values, self.start_time, self.end_time)
        self.stripchart.plot(t, v, min_time=self.start_time, max_time=self.end_time)



    def update_end_time(self, end_time):

        &#34;&#34;&#34;
        When the text field with the end time is updated in the stripchart controller (if any),
        the range on the x-axis of the plot is adapted accordingly.

        Args:
            - end_time: Last timepoint to be displayed in the plot (in the format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        self.end_time = end_time

        self.interval = self.end_time.replace(microsecond=0) - self.start_time.replace(microsecond=0)

        self.controller.interval_label.setText(str(self.interval.seconds))

        t, v = cut_interval(self.timepoints, self.values, self.start_time, self.end_time)
        self.stripchart.plot(t, v, min_time=self.start_time, max_time=self.end_time)

    def play(self):

        &#34;&#34;&#34;
        When the play button from the stripchart controller (if any) is pushed, the widget is notified
        that the display behaviour (realtime update of the last interval vs. inspecting specific period)
        must change.
        &#34;&#34;&#34;

        self.realtime = not self.realtime





class TimeSeriesCanvas(FigureCanvas):

    def __init__(self, quantity, unit, parent=None, dpi=100):

        &#34;&#34;&#34;
        Initialisation of the plot window, that will be used to plot time series.

        Args:
            - quantity: Physical quantity that will be shown on the y-axis.
            - unit: Unit of the physical quantity that will be shown on the y-axis.
        &#34;&#34;&#34;

        self.quantity = quantity
        self.unit = unit

        self.figure = Figure()
        self.ax = self.figure.add_subplot(111)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)


    def plot(self, timepoints, values, interval=None, min_time = None, max_time = None):

        &#34;&#34;&#34;
        Remove the current content (if any) and plot the given data.

        Args:
            - timepoints: Timepoints as datatime objects.
            - values: Values corresponding to the timepoints.
            - interval: Range of the x-axis (up to the last timepoints) as timedelta object.  If this
                        is None, the x-range will not be set.
            - min_time: Lower end of the interval to show on the x-axis.
            - max_time: Upper end of the interval to show on the x-axis.
        &#34;&#34;&#34;

        # Remove old content (if any)

        try:
            del self.ax.lines[-1]
        except:
            pass

        # Plot the new data

        self.ax.plot(timepoints, values, &#34;b&#34;)

        # On the x-axis: time

        if not interval is None:

            self.ax.set_xlim([timepoints[-1] - interval, timepoints[-1]])

        if not min_time is None and not max_time is None:

            self.ax.set_xlim([min_time, max_time])

        self.ax.set_xlabel(&#34;Time [d hh:mm:ss]&#34;, fontsize=10)
        formatter = DateFormatter(&#34;%-d %H:%M:%S&#34;)
        self.ax.xaxis.set_major_formatter(formatter)
        self.figure.autofmt_xdate()

        # On the y-axis: physical quantity (specified at initialisation)

        self.ax.set_ylabel(self.quantity + &#34; [&#34; + self.unit + &#34;]&#34;, fontsize=10)

        self.draw()




class TimeAxisItem(AxisItem):
    def __init__(self, *args, **kwargs):
        AxisItem.__init__(self, *args, **kwargs)

    def tickStrings(self, values, scale, spacing):
        return [QDateTime.fromMSecsSinceEpoch(value).toString(&#39;d HH:mm:ss&#39;) for value in values]


class StripChart(PlotWidget):
    &#34;&#34;&#34;
    A PlotWidget that represents a StripChart (scatter plot).
    By default the bottom axis is a time axis in milliseconds resolution, but
    the labels are &#39;hh:mm:ss&#39; since midnight.
    By default the left axis is a Position in degrees.
    The default can be changed by using the `axisItems` and `labels` arguments
    as in the following example:
    ```
    stripchart = StripChart(
        axisItems={&#39;bottom&#39;: AxisItem(orientation=&#39;bottom&#39;)},
        labels={&#39;left&#39;  : (&#39;Position&#39;, &#39;millimeter&#39;),
                &#39;bottom&#39;: (&#39;Index&#39;, None)})
    ```
    &#34;&#34;&#34;
    def __init__(self, **kwargs):
        if &#39;axisItems&#39; not in kwargs:
            bottom_axis = TimeAxisItem(orientation=&#39;bottom&#39;)
            left_axis = AxisItem(orientation=&#39;left&#39;)

            # Disable automatic prefix for SI units and axis scaling
            bottom_axis.enableAutoSIPrefix(enable=False)
            left_axis.enableAutoSIPrefix(enable=False)

            kwargs[&#39;axisItems&#39;] = {&#39;bottom&#39;: bottom_axis, &#39;left&#39;: left_axis}

        PlotWidget.__init__(self, **kwargs)

        if &#39;labels&#39; not in kwargs:
            self.setLabel(&#39;left&#39;, &#39;Position&#39;, units=&#39;degrees&#39;)
            self.setLabel(&#39;bottom&#39;, &#39;Time&#39;, units=&#39;d hh:mm:ss&#39;)

        self._plot = self.plot(pen=pg.mkPen(width=4))
        self._x_time = []
        self._y_data = []
        self._interval = 60 * 60   # [s] number of seconds on the bottom axis

    def setInterval(self, interval):
        &#34;&#34;&#34;
        Set the interval for the x-axis.
        Time intervals are in seconds.
        &#34;&#34;&#34;
        self._interval = interval

    def setData(self, *args, **kwargs):
        self._plot.setData(*args, **kwargs)

    def set_yrange(self, ymin, ymax):
        self.setYRange(ymax, ymin)

    def update(self, time, value):

        self._x_time.append(time)
        self._y_data.append(value)

        # We are not cutting the original data, that keeps on growing for the
        # lifetime of the stripchart object. The reason is because we might want
        # to implement panning back and forth in time at some point.
        #
        # x is in milliseconds, so interval shall also be in miliseconds

        x, y = cut_range(self._x_time, self._y_data, self._interval * 1000)

        self._plot.setData(x, y)


if __name__ == &#34;__main__&#34;:

    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.stripchart = StripChart()
            self.random_walk = RandomWalk(scale=0.1, count=0)
            self.process_status = ProcessStatus()

            self.setCentralWidget(self.stripchart)

            self.stripchart_timer = QTimer()
            self.stripchart_timer.timeout.connect(self.update_stripchart)
            self.stripchart_timer.setInterval(100)
            self.stripchart_timer.start()

            self.reporting_timer = QTimer()
            self.reporting_timer.timeout.connect(self.report_system_resources)
            self.reporting_timer.setInterval(10_000)
            self.reporting_timer.start()

        def update_stripchart(self):
            # current_time = datetime.now()
            current_time = QTime.currentTime().msecsSinceStartOfDay()
            value = next(self.random_walk)
            self.stripchart.update(current_time, value)

        def report_system_resources(self):
            print(self.process_status)

    app = QApplication([])

    window = MainWindow()
    window.show()

    sys.exit(app.exec())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.gui.stripchart.cut_interval"><code class="name flex">
<span>def <span class="ident">cut_interval</span></span>(<span>x, y, start_time, end_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Limit the elements in both lists such that the x-values are in the given interval.</p>
<p>Given two lists of equal lenght, shorten the lists such that the elements in the x-list
are within the given interval.</p>
<h2 id="args">Args</h2>
<ul>
<li>x: List of x-values in ascending order.</li>
<li>y: List of corresponding y-values.</li>
<li>start_time: Minimum x-value to include in the cropped lists.</li>
<li>end_time: Maximum x-value to include in the cropped lists.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Cropped x-list.</li>
<li>Cropped y-list.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_interval(x, y, start_time, end_time):

    &#34;&#34;&#34;
    Limit the elements in both lists such that the x-values are in the given interval.

    Given two lists of equal lenght, shorten the lists such that the elements in the x-list
    are within the given interval.

    Args:
        - x: List of x-values in ascending order.
        - y: List of corresponding y-values.
        - start_time: Minimum x-value to include in the cropped lists.
        - end_time: Maximum x-value to include in the cropped lists.

    Returns:
        - Cropped x-list.
        - Cropped y-list.
    &#34;&#34;&#34;

    print(type(start_time), type(end_time), type(x[0]))
    idx = next(a[0] for a in enumerate(x) if a[1] &gt;= start_time and a[1] &lt; end_time)

    return x[idx:], y[idx:]</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.cut_range"><code class="name flex">
<span>def <span class="ident">cut_range</span></span>(<span>x, y, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Limit the elements in both lists such that the x-range is not larger
than interval. The lists are shortened from the start.</p>
<p>Given two lists of equal length, shorten the lists such that the elements
in the x-list all fall within the range x[-1] - interval. The function is
used to simulate a moving window of size interval.</p>
<h2 id="args">Args</h2>
<ul>
<li>x: List of x-values in ascending order.</li>
<li>y: List of corresponding y-values.</li>
<li>interval: Range of x-value to crop to.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Cropped x-list.</li>
<li>Cropped y-list.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_range(x, y, interval):

    &#34;&#34;&#34;
    Limit the elements in both lists such that the x-range is not larger
    than interval. The lists are shortened from the start.

    Given two lists of equal length, shorten the lists such that the elements
    in the x-list all fall within the range x[-1] - interval. The function is
    used to simulate a moving window of size interval.

    Args:
        - x: List of x-values in ascending order.
        - y: List of corresponding y-values.
        - interval: Range of x-value to crop to.

    Returns:
        - Cropped x-list.
        - Cropped y-list.
    &#34;&#34;&#34;

    x_min = x[-1] - interval
    idx = next(a[0] for a in enumerate(x) if a[1] &gt;= x_min)

    return x[idx:], y[idx:]</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>stripchart_widget, stripchart_controller)</span>
</code></dt>
<dd>
<div class="desc"><p>Link the given stripchart widget with the given controller.
This means the
following:</p>
<pre><code>- the stripchart widget "knows" about the stripchart controller and will update
  the information that is shown there;
- the stripchart controller "knows" about the stripchart widget and controls what
  is shown.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(stripchart_widget, stripchart_controller):

    &#34;&#34;&#34;
    Link the given stripchart widget with the given controller.  This means the
    following:

        - the stripchart widget &#34;knows&#34; about the stripchart controller and will update
          the information that is shown there;
        - the stripchart controller &#34;knows&#34; about the stripchart widget and controls what
          is shown.
    &#34;&#34;&#34;

    stripchart_widget.controller = stripchart_controller
    stripchart_controller.stripcharts.append(stripchart_widget)

    if stripchart_controller.toolbar_mode:

        stripchart_controller.play_action.triggered.connect(stripchart_widget.play) # Action to put into the toolbar of the main GUI

    else:

        stripchart_controller.play_button.clicked.connect(stripchart_widget.play)   # Play button in the controller widget</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.gui.stripchart.StripChart"><code class="flex name class">
<span>class <span class="ident">StripChart</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A PlotWidget that represents a StripChart (scatter plot).
By default the bottom axis is a time axis in milliseconds resolution, but
the labels are 'hh:mm:ss' since midnight.
By default the left axis is a Position in degrees.
The default can be changed by using the <code>axisItems</code> and <code>labels</code> arguments
as in the following example:</p>
<pre><code>stripchart = StripChart(
    axisItems={'bottom': AxisItem(orientation='bottom')},
    labels={'left'  : ('Position', 'millimeter'),
            'bottom': ('Index', None)})
</code></pre>
<p>When initializing PlotWidget, <em>parent</em> and <em>background</em> are passed to
:func:<code>GraphicsWidget.__init__() &lt;pyqtgraph.GraphicsWidget.__init__&gt;</code>
and all others are passed
to :func:<code>PlotItem.__init__() &lt;pyqtgraph.PlotItem.__init__&gt;</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StripChart(PlotWidget):
    &#34;&#34;&#34;
    A PlotWidget that represents a StripChart (scatter plot).
    By default the bottom axis is a time axis in milliseconds resolution, but
    the labels are &#39;hh:mm:ss&#39; since midnight.
    By default the left axis is a Position in degrees.
    The default can be changed by using the `axisItems` and `labels` arguments
    as in the following example:
    ```
    stripchart = StripChart(
        axisItems={&#39;bottom&#39;: AxisItem(orientation=&#39;bottom&#39;)},
        labels={&#39;left&#39;  : (&#39;Position&#39;, &#39;millimeter&#39;),
                &#39;bottom&#39;: (&#39;Index&#39;, None)})
    ```
    &#34;&#34;&#34;
    def __init__(self, **kwargs):
        if &#39;axisItems&#39; not in kwargs:
            bottom_axis = TimeAxisItem(orientation=&#39;bottom&#39;)
            left_axis = AxisItem(orientation=&#39;left&#39;)

            # Disable automatic prefix for SI units and axis scaling
            bottom_axis.enableAutoSIPrefix(enable=False)
            left_axis.enableAutoSIPrefix(enable=False)

            kwargs[&#39;axisItems&#39;] = {&#39;bottom&#39;: bottom_axis, &#39;left&#39;: left_axis}

        PlotWidget.__init__(self, **kwargs)

        if &#39;labels&#39; not in kwargs:
            self.setLabel(&#39;left&#39;, &#39;Position&#39;, units=&#39;degrees&#39;)
            self.setLabel(&#39;bottom&#39;, &#39;Time&#39;, units=&#39;d hh:mm:ss&#39;)

        self._plot = self.plot(pen=pg.mkPen(width=4))
        self._x_time = []
        self._y_data = []
        self._interval = 60 * 60   # [s] number of seconds on the bottom axis

    def setInterval(self, interval):
        &#34;&#34;&#34;
        Set the interval for the x-axis.
        Time intervals are in seconds.
        &#34;&#34;&#34;
        self._interval = interval

    def setData(self, *args, **kwargs):
        self._plot.setData(*args, **kwargs)

    def set_yrange(self, ymin, ymax):
        self.setYRange(ymax, ymin)

    def update(self, time, value):

        self._x_time.append(time)
        self._y_data.append(value)

        # We are not cutting the original data, that keeps on growing for the
        # lifetime of the stripchart object. The reason is because we might want
        # to implement panning back and forth in time at some point.
        #
        # x is in milliseconds, so interval shall also be in miliseconds

        x, y = cut_range(self._x_time, self._y_data, self._interval * 1000)

        self._plot.setData(x, y)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyqtgraph.widgets.PlotWidget.PlotWidget</li>
<li>pyqtgraph.widgets.GraphicsView.GraphicsView</li>
<li>PyQt5.QtWidgets.QGraphicsView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.stripchart.StripChart.setData"><code class="name flex">
<span>def <span class="ident">setData</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setData(self, *args, **kwargs):
    self._plot.setData(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChart.setInterval"><code class="name flex">
<span>def <span class="ident">setInterval</span></span>(<span>self, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the interval for the x-axis.
Time intervals are in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInterval(self, interval):
    &#34;&#34;&#34;
    Set the interval for the x-axis.
    Time intervals are in seconds.
    &#34;&#34;&#34;
    self._interval = interval</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChart.set_yrange"><code class="name flex">
<span>def <span class="ident">set_yrange</span></span>(<span>self, ymin, ymax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_yrange(self, ymin, ymax):
    self.setYRange(ymax, ymin)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChart.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, time, value)</span>
</code></dt>
<dd>
<div class="desc"><p>update(self)
update(self, QRect)
update(self, QRegion)
update(self, int, int, int, int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, time, value):

    self._x_time.append(time)
    self._y_data.append(value)

    # We are not cutting the original data, that keeps on growing for the
    # lifetime of the stripchart object. The reason is because we might want
    # to implement panning back and forth in time at some point.
    #
    # x is in milliseconds, so interval shall also be in miliseconds

    x, y = cut_range(self._x_time, self._y_data, self._interval * 1000)

    self._plot.setData(x, y)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget"><code class="flex name class">
<span>class <span class="ident">StripChartControllerWidget</span></span>
<span>(</span><span>toolbar_mode=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the begin and end of the time range that will be shown in the stripchart widgets
that are linked to this stripchart controller (in the format "d hh:mm:ss"), and the corresponding
interval length (in seconds).</p>
<p>You can choose to display either:</p>
<pre><code>- the last interval (of given duration) of the time series
- or a specific period in time (from the given start to end time).
</code></pre>
<p>This can be chosen in two different way (you have to pick one):</p>
<pre><code>- via a button in the stripchart controller widget
- or via a button/action that can be placed in the toolbar of the main GUI.
</code></pre>
<p>If the button of choice is in "play" mode, the last time interval will be shown, the
length of which can be specified (in seconds) in the text field in the controller widget. The
start and end time of this time period is also displayed (but cannot be changed).
Alternatively, if the button of choice is in "pause" mode, the plot is no longer updated
in realtime, but you can specify which time period to inspect, by adapting the start and end
time (in the format "d hh:mm:ss").
The interval lengths is also displayed (but cannot be
changed).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StripChartControllerWidget(QGroupBox):

    &#34;&#34;&#34;
    Displays the begin and end of the time range that will be shown in the stripchart widgets
    that are linked to this stripchart controller (in the format &#34;d hh:mm:ss&#34;), and the corresponding
    interval length (in seconds).

    You can choose to display either:

        - the last interval (of given duration) of the time series
        - or a specific period in time (from the given start to end time).

    This can be chosen in two different way (you have to pick one):

        - via a button in the stripchart controller widget
        - or via a button/action that can be placed in the toolbar of the main GUI.

    If the button of choice is in &#34;play&#34; mode, the last time interval will be shown, the
    length of which can be specified (in seconds) in the text field in the controller widget. The
    start and end time of this time period is also displayed (but cannot be changed).
    Alternatively, if the button of choice is in &#34;pause&#34; mode, the plot is no longer updated
    in realtime, but you can specify which time period to inspect, by adapting the start and end
    time (in the format &#34;d hh:mm:ss&#34;).  The interval lengths is also displayed (but cannot be
    changed).
    &#34;&#34;&#34;

    def __init__(self, toolbar_mode=True):

        super(StripChartControllerWidget, self).__init__(&#34;&#34;)

        self.stripcharts = []
        self.realtime = True

        self.toolbar_mode = toolbar_mode

        if toolbar_mode:

            self.create_play_action()

        layout = QGridLayout()

        # Button: play/pause

        if not toolbar_mode:

            self.create_play_button()
            layout.addWidget(self.play_button, 0, 0)

        # From ... to ...

        self.create_start_end()

        layout.addWidget(QLabel(&#34;From&#34;), 1, 1)
        layout.addWidget(self.start_time_label, 1, 2)
        layout.addWidget(QLabel(&#34;to&#34;), 1, 3)
        layout.addWidget(self.end_time_label, 1, 4)

        # Interval length

        self.create_interval()

        layout.addWidget(QLabel(&#34;Interval [s]&#34;), 2, 1)
        layout.addWidget(self.interval_label, 2, 2)

        self.setLayout(layout)


    def create_play_action(self):

        &#34;&#34;&#34;
        Create play button/action that will be added to the toolbar of the main GUI.  When this button
        is pushed, the behaviour of the plots of the stripcharts changes accordingly.
        &#34;&#34;&#34;

        play_pix = QPixmap(str(find_file(&#34;play.png&#34;, in_dir=&#34;images&#34;)))
        pause_pix = QPixmap(str(find_file(&#34;pause.png&#34;, in_dir=&#34;images&#34;)))
        play_icon = QIcon()
        play_icon.addPixmap(play_pix, QIcon.Normal, QIcon.On)
        play_icon.addPixmap(pause_pix, QIcon.Normal, QIcon.Off)

        self.play_action = QAction(play_icon, &#34;Play&#34;, self)
        self.play_action.setToolTip(&#34;Sohw specific time interval / show last time interval&#34;)
        self.play_action.setCheckable(True)
        self.play_action.setChecked(False)
        self.play_action.triggered.connect(self.handle_play)

    def create_play_button(self):

        &#34;&#34;&#34;
        Create play button that will be added to the stripchart controller.  When this button is
        pushed, the behaviour of the plots of the stripcharts changes accordingly.
        &#34;&#34;&#34;

        self.play_icon  = QIcon(str(find_file(&#34;play.png&#34;, in_dir=&#34;images&#34;)))
        self.pause_icon = QIcon(str(find_file(&#34;pause.png&#34;, in_dir=&#34;images&#34;)))

        self.play_button = QPushButton(&#34;&#34;)
        self.play_button.setToolTip(&#34;Show specific time interval&#34;)
        self.play_button.setIcon(self.pause_icon)
        self.play_button.clicked.connect(self.play)

    def create_start_end(self):

        &#34;&#34;&#34;
        Create the text fields (incl. validators) for the start and end time.

        Currently, the validator is not set for the text fields, as the values are not accepted then
        when you hit enter.  Still to figure out what the problem is.
        &#34;&#34;&#34;

        time_regex = QRegExp(&#39;^([1-9]|[1-9]\d{1,}) ^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$&#39;)
        time_validator = QRegExpValidator(time_regex)

        # Start time

        self.start_time_label = QLineEdit(self)
        self.start_time_label.setReadOnly(True)

        # self.start_time_label.setValidator(time_validator)
        self.start_time_label.setPlaceholderText(&#34;d hh:mm:ss&#34;)
        self.start_time_label.returnPressed.connect(partial(self.update_start_time, self.start_time_label))

        self.end_time_label = QLineEdit(self)
        self.end_time_label.setReadOnly(True)

        # self.end_time_label.setValidator(time_validator)
        self.end_time_label.setPlaceholderText(&#34;d hh:mm:ss&#34;)
        self.end_time_label.returnPressed.connect(partial(self.update_end_time, self.end_time_label))

    def create_interval(self):

        &#34;&#34;&#34;
        Create the text field for the interval length.
        &#34;&#34;&#34;
        self.interval_label = QLineEdit(self)

        interval_validator = QIntValidator()
        interval_validator.setBottom(1)
        self.interval_label.setValidator(interval_validator)

        self.interval = timedelta(seconds=60)

        self.interval_label.setText(str(self.interval.seconds))
        self.interval_label.returnPressed.connect(partial(self.update_interval, self.interval_label))


    def handle_play(self):

        &#34;&#34;&#34;
        When the play button in the toolbar of the main GUI is pushed (if any), the behaviour of the (plots in the)
        stripchart widget changes.

        In realtime mode (real stripchart):
            - the play-button in the stripchart controller (if any) should show the &#34;pause&#34; icon;
            - the plot is updated immediately when an extra datapoint is added to the time series;
            - the textfields in the stripchart controller (if any) with the start and end time cannot be
              changed by the user but will be updated automatically;
            - the interval length can be adapted via the dedicated text field in the stripchart controller (if any).

        In non-realtime mode (inspection of a specific time period):
            - the play-button in the stripchart controller (if any) should show the &#34;play&#34; icon;
            - the plot is no longer updated when an extra datapoint is added to the time series;
            - the start and end time can be adapted via the dedicated text fields in the stripchart
              controller (if any);
            - the textfield in the stripchart controller (if any) with the interval length cannot be
              changed by the user but will be updated automatically (when returning to realtime mode,
              this new interval length will be used).
        &#34;&#34;&#34;

        self.play()

    def play(self):

        &#34;&#34;&#34;
        When the play button is pushed in the stripchart controller (if any), the behaviour of the (plots in the)
        stripchart widget changes.

        In realtime mode (real stripchart):
            - the play-button in the stripchart controller (if any) should show the &#34;pause&#34; icon;
            - the plot is updated immediately when an extra datapoint is added to the time series;
            - the textfields in the stripchart controller (if any) with the start and end time cannot be
              changed by the user but will be updated automatically;
            - the interval length can be adapted via the dedicated text field in the stripchart controller (if any).

        In non-realtime mode (inspection of a specific time period):
            - the play-button in the stripchart controller (if any) should show the &#34;play&#34; icon;
            - the plot is no longer updated when an extra datapoint is added to the time series;
            - the start and end time can be adapted via the dedicated text fields in the stripchart
              controller (if any);
            - the textfield in the stripchart controller (if any) with the interval length cannot be
              changed by the user but will be updated automatically (when returning to realtime mode,
              this new interval length will be used).
        &#34;&#34;&#34;

        self.realtime = not self.realtime

        # Realtime mode

        if self.realtime:

            if not self.toolbar_mode:

                self.play_button.setIcon(self.pause_icon)   # Change the icon on the play-button to &#34;pause&#34;
                self.play_button.setToolTip(&#34;Show specific time interval&#34;)
                self.play_button.repaint()

            self.start_time_label.setReadOnly(True)     # Disable changing the start time text field
            self.end_time_label.setReadOnly(True)       # Disable changing the start time text field
            self.interval_label.setReadOnly(False)      # Enable changing the interval length

        # Non-realtime mode

        else:

            if not self.toolbar_mode:

                self.play_button.setIcon(self.play_icon)   # Change the icon on the play-button to &#34;play&#34;
                self.play_button.setToolTip(&#34;Show last time interval&#34;)
                self.play_button.repaint()

            self.start_time_label.setReadOnly(False)   # Enable changing the start time text field
            self.end_time_label.setReadOnly(False)     # Enable changing the start time text field
            self.interval_label.setReadOnly(True)      # Disable changing the interval length


    def update_interval(self, interval_label):

        &#34;&#34;&#34;
        If the text field with the interval length is updated, the plots in the stripchart
        widgets are updated.  Only applicable in realtime mode.

        Args:
            - interval_label: Text field where the interval length can be entered (in seconds).
        &#34;&#34;&#34;

        self.interval = timedelta(seconds=int(interval_label.text()))

        # Update all stripchart widgets

        for stripchart in self.stripcharts:

            stripchart.update_interval(self.interval)

    def update_start_time(self, start_time_label):

        &#34;&#34;&#34;
        If the text field with the start time is updated, the plots in the stripchart widgets
        are updated.  Only applicable in non-realtime mode.

        Args:
            - start_time_label: Text field where the start time can be entered (in format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        start_time = datetime.strptime(start_time_label.text(), &#34;%j %H:%M:%S&#34;)
        start_time += timedelta(days=365.25*70-1, hours=12)         # 1900 -&gt; 1970

        # Update all stripchart widgets

        for stripchart in self.stripcharts:

            stripchart.update_start_time(start_time)

    def update_end_time(self, end_time_label):

        &#34;&#34;&#34;
        If the text field with the end time is updated, the plots in the stripchart widgets
        are updated.  Only applicable in non-realtime mode.

        Args:
            - end_time_label: Text field where the end time can be entered (in format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        end_time = datetime.strptime(end_time_label.text(), &#34;%j %H:%M:%S&#34;)
        end_time += timedelta(days=365.25*70 - 1, hours=12)         # 1900 -&gt; 1970

        # Update all stripchart widgets

        for stripchart in self.stripcharts:

            stripchart.update_end_time(end_time)

    def set_time(self, last_timepoint):

        &#34;&#34;&#34;
        Update the content of the textfields with the start and end time (in realtime mode only).
        Only applicable in realtime mode.
        &#34;&#34;&#34;

        self.end_time_label.setText(last_timepoint.strftime(&#34;%-d %H:%M:%S&#34;))
        self.start_time_label.setText((last_timepoint - self.interval).strftime(&#34;%-d %H:%M:%S&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.stripchart.StripChartControllerWidget.create_interval"><code class="name flex">
<span>def <span class="ident">create_interval</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the text field for the interval length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_interval(self):

    &#34;&#34;&#34;
    Create the text field for the interval length.
    &#34;&#34;&#34;
    self.interval_label = QLineEdit(self)

    interval_validator = QIntValidator()
    interval_validator.setBottom(1)
    self.interval_label.setValidator(interval_validator)

    self.interval = timedelta(seconds=60)

    self.interval_label.setText(str(self.interval.seconds))
    self.interval_label.returnPressed.connect(partial(self.update_interval, self.interval_label))</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.create_play_action"><code class="name flex">
<span>def <span class="ident">create_play_action</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create play button/action that will be added to the toolbar of the main GUI.
When this button
is pushed, the behaviour of the plots of the stripcharts changes accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_play_action(self):

    &#34;&#34;&#34;
    Create play button/action that will be added to the toolbar of the main GUI.  When this button
    is pushed, the behaviour of the plots of the stripcharts changes accordingly.
    &#34;&#34;&#34;

    play_pix = QPixmap(str(find_file(&#34;play.png&#34;, in_dir=&#34;images&#34;)))
    pause_pix = QPixmap(str(find_file(&#34;pause.png&#34;, in_dir=&#34;images&#34;)))
    play_icon = QIcon()
    play_icon.addPixmap(play_pix, QIcon.Normal, QIcon.On)
    play_icon.addPixmap(pause_pix, QIcon.Normal, QIcon.Off)

    self.play_action = QAction(play_icon, &#34;Play&#34;, self)
    self.play_action.setToolTip(&#34;Sohw specific time interval / show last time interval&#34;)
    self.play_action.setCheckable(True)
    self.play_action.setChecked(False)
    self.play_action.triggered.connect(self.handle_play)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.create_play_button"><code class="name flex">
<span>def <span class="ident">create_play_button</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create play button that will be added to the stripchart controller.
When this button is
pushed, the behaviour of the plots of the stripcharts changes accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_play_button(self):

    &#34;&#34;&#34;
    Create play button that will be added to the stripchart controller.  When this button is
    pushed, the behaviour of the plots of the stripcharts changes accordingly.
    &#34;&#34;&#34;

    self.play_icon  = QIcon(str(find_file(&#34;play.png&#34;, in_dir=&#34;images&#34;)))
    self.pause_icon = QIcon(str(find_file(&#34;pause.png&#34;, in_dir=&#34;images&#34;)))

    self.play_button = QPushButton(&#34;&#34;)
    self.play_button.setToolTip(&#34;Show specific time interval&#34;)
    self.play_button.setIcon(self.pause_icon)
    self.play_button.clicked.connect(self.play)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.create_start_end"><code class="name flex">
<span>def <span class="ident">create_start_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the text fields (incl. validators) for the start and end time.</p>
<p>Currently, the validator is not set for the text fields, as the values are not accepted then
when you hit enter.
Still to figure out what the problem is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_start_end(self):

    &#34;&#34;&#34;
    Create the text fields (incl. validators) for the start and end time.

    Currently, the validator is not set for the text fields, as the values are not accepted then
    when you hit enter.  Still to figure out what the problem is.
    &#34;&#34;&#34;

    time_regex = QRegExp(&#39;^([1-9]|[1-9]\d{1,}) ^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$&#39;)
    time_validator = QRegExpValidator(time_regex)

    # Start time

    self.start_time_label = QLineEdit(self)
    self.start_time_label.setReadOnly(True)

    # self.start_time_label.setValidator(time_validator)
    self.start_time_label.setPlaceholderText(&#34;d hh:mm:ss&#34;)
    self.start_time_label.returnPressed.connect(partial(self.update_start_time, self.start_time_label))

    self.end_time_label = QLineEdit(self)
    self.end_time_label.setReadOnly(True)

    # self.end_time_label.setValidator(time_validator)
    self.end_time_label.setPlaceholderText(&#34;d hh:mm:ss&#34;)
    self.end_time_label.returnPressed.connect(partial(self.update_end_time, self.end_time_label))</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.handle_play"><code class="name flex">
<span>def <span class="ident">handle_play</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the play button in the toolbar of the main GUI is pushed (if any), the behaviour of the (plots in the)
stripchart widget changes.</p>
<p>In realtime mode (real stripchart):
- the play-button in the stripchart controller (if any) should show the "pause" icon;
- the plot is updated immediately when an extra datapoint is added to the time series;
- the textfields in the stripchart controller (if any) with the start and end time cannot be
changed by the user but will be updated automatically;
- the interval length can be adapted via the dedicated text field in the stripchart controller (if any).</p>
<p>In non-realtime mode (inspection of a specific time period):
- the play-button in the stripchart controller (if any) should show the "play" icon;
- the plot is no longer updated when an extra datapoint is added to the time series;
- the start and end time can be adapted via the dedicated text fields in the stripchart
controller (if any);
- the textfield in the stripchart controller (if any) with the interval length cannot be
changed by the user but will be updated automatically (when returning to realtime mode,
this new interval length will be used).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_play(self):

    &#34;&#34;&#34;
    When the play button in the toolbar of the main GUI is pushed (if any), the behaviour of the (plots in the)
    stripchart widget changes.

    In realtime mode (real stripchart):
        - the play-button in the stripchart controller (if any) should show the &#34;pause&#34; icon;
        - the plot is updated immediately when an extra datapoint is added to the time series;
        - the textfields in the stripchart controller (if any) with the start and end time cannot be
          changed by the user but will be updated automatically;
        - the interval length can be adapted via the dedicated text field in the stripchart controller (if any).

    In non-realtime mode (inspection of a specific time period):
        - the play-button in the stripchart controller (if any) should show the &#34;play&#34; icon;
        - the plot is no longer updated when an extra datapoint is added to the time series;
        - the start and end time can be adapted via the dedicated text fields in the stripchart
          controller (if any);
        - the textfield in the stripchart controller (if any) with the interval length cannot be
          changed by the user but will be updated automatically (when returning to realtime mode,
          this new interval length will be used).
    &#34;&#34;&#34;

    self.play()</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the play button is pushed in the stripchart controller (if any), the behaviour of the (plots in the)
stripchart widget changes.</p>
<p>In realtime mode (real stripchart):
- the play-button in the stripchart controller (if any) should show the "pause" icon;
- the plot is updated immediately when an extra datapoint is added to the time series;
- the textfields in the stripchart controller (if any) with the start and end time cannot be
changed by the user but will be updated automatically;
- the interval length can be adapted via the dedicated text field in the stripchart controller (if any).</p>
<p>In non-realtime mode (inspection of a specific time period):
- the play-button in the stripchart controller (if any) should show the "play" icon;
- the plot is no longer updated when an extra datapoint is added to the time series;
- the start and end time can be adapted via the dedicated text fields in the stripchart
controller (if any);
- the textfield in the stripchart controller (if any) with the interval length cannot be
changed by the user but will be updated automatically (when returning to realtime mode,
this new interval length will be used).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self):

    &#34;&#34;&#34;
    When the play button is pushed in the stripchart controller (if any), the behaviour of the (plots in the)
    stripchart widget changes.

    In realtime mode (real stripchart):
        - the play-button in the stripchart controller (if any) should show the &#34;pause&#34; icon;
        - the plot is updated immediately when an extra datapoint is added to the time series;
        - the textfields in the stripchart controller (if any) with the start and end time cannot be
          changed by the user but will be updated automatically;
        - the interval length can be adapted via the dedicated text field in the stripchart controller (if any).

    In non-realtime mode (inspection of a specific time period):
        - the play-button in the stripchart controller (if any) should show the &#34;play&#34; icon;
        - the plot is no longer updated when an extra datapoint is added to the time series;
        - the start and end time can be adapted via the dedicated text fields in the stripchart
          controller (if any);
        - the textfield in the stripchart controller (if any) with the interval length cannot be
          changed by the user but will be updated automatically (when returning to realtime mode,
          this new interval length will be used).
    &#34;&#34;&#34;

    self.realtime = not self.realtime

    # Realtime mode

    if self.realtime:

        if not self.toolbar_mode:

            self.play_button.setIcon(self.pause_icon)   # Change the icon on the play-button to &#34;pause&#34;
            self.play_button.setToolTip(&#34;Show specific time interval&#34;)
            self.play_button.repaint()

        self.start_time_label.setReadOnly(True)     # Disable changing the start time text field
        self.end_time_label.setReadOnly(True)       # Disable changing the start time text field
        self.interval_label.setReadOnly(False)      # Enable changing the interval length

    # Non-realtime mode

    else:

        if not self.toolbar_mode:

            self.play_button.setIcon(self.play_icon)   # Change the icon on the play-button to &#34;play&#34;
            self.play_button.setToolTip(&#34;Show last time interval&#34;)
            self.play_button.repaint()

        self.start_time_label.setReadOnly(False)   # Enable changing the start time text field
        self.end_time_label.setReadOnly(False)     # Enable changing the start time text field
        self.interval_label.setReadOnly(True)      # Disable changing the interval length</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.set_time"><code class="name flex">
<span>def <span class="ident">set_time</span></span>(<span>self, last_timepoint)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the content of the textfields with the start and end time (in realtime mode only).
Only applicable in realtime mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time(self, last_timepoint):

    &#34;&#34;&#34;
    Update the content of the textfields with the start and end time (in realtime mode only).
    Only applicable in realtime mode.
    &#34;&#34;&#34;

    self.end_time_label.setText(last_timepoint.strftime(&#34;%-d %H:%M:%S&#34;))
    self.start_time_label.setText((last_timepoint - self.interval).strftime(&#34;%-d %H:%M:%S&#34;))</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.update_end_time"><code class="name flex">
<span>def <span class="ident">update_end_time</span></span>(<span>self, end_time_label)</span>
</code></dt>
<dd>
<div class="desc"><p>If the text field with the end time is updated, the plots in the stripchart widgets
are updated.
Only applicable in non-realtime mode.</p>
<h2 id="args">Args</h2>
<ul>
<li>end_time_label: Text field where the end time can be entered (in format "d hh:mm:ss").</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_end_time(self, end_time_label):

    &#34;&#34;&#34;
    If the text field with the end time is updated, the plots in the stripchart widgets
    are updated.  Only applicable in non-realtime mode.

    Args:
        - end_time_label: Text field where the end time can be entered (in format &#34;d hh:mm:ss&#34;).
    &#34;&#34;&#34;

    end_time = datetime.strptime(end_time_label.text(), &#34;%j %H:%M:%S&#34;)
    end_time += timedelta(days=365.25*70 - 1, hours=12)         # 1900 -&gt; 1970

    # Update all stripchart widgets

    for stripchart in self.stripcharts:

        stripchart.update_end_time(end_time)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.update_interval"><code class="name flex">
<span>def <span class="ident">update_interval</span></span>(<span>self, interval_label)</span>
</code></dt>
<dd>
<div class="desc"><p>If the text field with the interval length is updated, the plots in the stripchart
widgets are updated.
Only applicable in realtime mode.</p>
<h2 id="args">Args</h2>
<ul>
<li>interval_label: Text field where the interval length can be entered (in seconds).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_interval(self, interval_label):

    &#34;&#34;&#34;
    If the text field with the interval length is updated, the plots in the stripchart
    widgets are updated.  Only applicable in realtime mode.

    Args:
        - interval_label: Text field where the interval length can be entered (in seconds).
    &#34;&#34;&#34;

    self.interval = timedelta(seconds=int(interval_label.text()))

    # Update all stripchart widgets

    for stripchart in self.stripcharts:

        stripchart.update_interval(self.interval)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartControllerWidget.update_start_time"><code class="name flex">
<span>def <span class="ident">update_start_time</span></span>(<span>self, start_time_label)</span>
</code></dt>
<dd>
<div class="desc"><p>If the text field with the start time is updated, the plots in the stripchart widgets
are updated.
Only applicable in non-realtime mode.</p>
<h2 id="args">Args</h2>
<ul>
<li>start_time_label: Text field where the start time can be entered (in format "d hh:mm:ss").</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_start_time(self, start_time_label):

    &#34;&#34;&#34;
    If the text field with the start time is updated, the plots in the stripchart widgets
    are updated.  Only applicable in non-realtime mode.

    Args:
        - start_time_label: Text field where the start time can be entered (in format &#34;d hh:mm:ss&#34;).
    &#34;&#34;&#34;

    start_time = datetime.strptime(start_time_label.text(), &#34;%j %H:%M:%S&#34;)
    start_time += timedelta(days=365.25*70-1, hours=12)         # 1900 -&gt; 1970

    # Update all stripchart widgets

    for stripchart in self.stripcharts:

        stripchart.update_start_time(start_time)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.stripchart.StripChartWidget"><code class="flex name class">
<span>class <span class="ident">StripChartWidget</span></span>
<span>(</span><span>quantity, unit)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a plot of the focal plane, with a blue circle indicating the
field-of-view.
Below the plot you can find a spinner to choose the coordinate
system to be used in the plot.</p>
<h2 id="args">Args</h2>
<ul>
<li>quantity: Physical quantity shown by the strip chart.</li>
<li>unit: Unit of the physical quantity shown by the strip chart.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StripChartWidget(QGroupBox):

    def __init__(self, quantity, unit):

        &#34;&#34;&#34;
        Initialisation of a plot of the focal plane, with a blue circle indicating the
        field-of-view.  Below the plot you can find a spinner to choose the coordinate
        system to be used in the plot.

        Args:
            - quantity: Physical quantity shown by the strip chart.
            - unit: Unit of the physical quantity shown by the strip chart.
        &#34;&#34;&#34;

        super(StripChartWidget, self).__init__(&#34;&#34;)

        self.interval = timedelta(seconds=60)

        self.realtime = True
        self.controller = None

        self.timepoints = []
        self.values = []

        # Plot window

        layout = QGridLayout()

        self.stripchart = TimeSeriesCanvas(quantity, unit)

        layout.addWidget(self.stripchart)

        self.setLayout(layout)

    def update(self, time, value):

        &#34;&#34;&#34;
        Update the plot when the given datapoint is added to the time series, only when in realtime
        mode.

        Args:
            - time: Time [ms].
            - value: Value.
        &#34;&#34;&#34;

        # Convert from double to datetime

        time = datetime.fromtimestamp(time / 1000.0)

        # Append to the time series

        self.timepoints.append(time)
        self.values.append(value)

        # Update the plot (only in realtime mode)

        if self.realtime:

            self.end_time = self.timepoints[-1]                 # New point = new end time
            self.start_time = self.end_time - self.interval     # Update start time

            last_timepoints, last_values = cut_range(self.timepoints, self.values, self.interval)   # Cut out the requested range
            self.stripchart.plot(last_timepoints, last_values, interval=self.interval)              # Update the plot

            if not self.controller is None:

                self.controller.set_time(last_timepoints[-1])       # Update the text fields in the stripchart controller (begin and end time)



    def update_interval(self, interval):

        &#34;&#34;&#34;
        When the text field with the interval is updated in the stripchart controller (if any),
        the range on the x-axis of the plot is adapted accordingly.

        Args:
            - interval: Length of the time period to be displayed in the plot [s].
        &#34;&#34;&#34;

        self.interval = interval

        last_timepoints, lastvalues = cut_range(self.timepoints, self.values, self.interval)
        self.stripchart.plot(last_timepoints, lastvalues, interval=self.interval)

    def update_start_time(self, start_time):

        &#34;&#34;&#34;
        When the text field with the start time is updated in the stripchart controller (if any),
        the range on the x-axis of the plot is adapted accordingly.

        Args:
            - start_time: First timepoint to be displayed in the plot (in the format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        self.start_time = start_time

        self.interval = self.end_time.replace(microsecond=0) - self.start_time.replace(microsecond=0)

        self.controller.interval_label.setText(str(self.interval.seconds))

        t, v = cut_interval(self.timepoints, self.values, self.start_time, self.end_time)
        self.stripchart.plot(t, v, min_time=self.start_time, max_time=self.end_time)



    def update_end_time(self, end_time):

        &#34;&#34;&#34;
        When the text field with the end time is updated in the stripchart controller (if any),
        the range on the x-axis of the plot is adapted accordingly.

        Args:
            - end_time: Last timepoint to be displayed in the plot (in the format &#34;d hh:mm:ss&#34;).
        &#34;&#34;&#34;

        self.end_time = end_time

        self.interval = self.end_time.replace(microsecond=0) - self.start_time.replace(microsecond=0)

        self.controller.interval_label.setText(str(self.interval.seconds))

        t, v = cut_interval(self.timepoints, self.values, self.start_time, self.end_time)
        self.stripchart.plot(t, v, min_time=self.start_time, max_time=self.end_time)

    def play(self):

        &#34;&#34;&#34;
        When the play button from the stripchart controller (if any) is pushed, the widget is notified
        that the display behaviour (realtime update of the last interval vs. inspecting specific period)
        must change.
        &#34;&#34;&#34;

        self.realtime = not self.realtime</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.stripchart.StripChartWidget.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the play button from the stripchart controller (if any) is pushed, the widget is notified
that the display behaviour (realtime update of the last interval vs. inspecting specific period)
must change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self):

    &#34;&#34;&#34;
    When the play button from the stripchart controller (if any) is pushed, the widget is notified
    that the display behaviour (realtime update of the last interval vs. inspecting specific period)
    must change.
    &#34;&#34;&#34;

    self.realtime = not self.realtime</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartWidget.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, time, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the plot when the given datapoint is added to the time series, only when in realtime
mode.</p>
<h2 id="args">Args</h2>
<ul>
<li>time: Time [ms].</li>
<li>value: Value.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, time, value):

    &#34;&#34;&#34;
    Update the plot when the given datapoint is added to the time series, only when in realtime
    mode.

    Args:
        - time: Time [ms].
        - value: Value.
    &#34;&#34;&#34;

    # Convert from double to datetime

    time = datetime.fromtimestamp(time / 1000.0)

    # Append to the time series

    self.timepoints.append(time)
    self.values.append(value)

    # Update the plot (only in realtime mode)

    if self.realtime:

        self.end_time = self.timepoints[-1]                 # New point = new end time
        self.start_time = self.end_time - self.interval     # Update start time

        last_timepoints, last_values = cut_range(self.timepoints, self.values, self.interval)   # Cut out the requested range
        self.stripchart.plot(last_timepoints, last_values, interval=self.interval)              # Update the plot

        if not self.controller is None:

            self.controller.set_time(last_timepoints[-1])       # Update the text fields in the stripchart controller (begin and end time)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartWidget.update_end_time"><code class="name flex">
<span>def <span class="ident">update_end_time</span></span>(<span>self, end_time)</span>
</code></dt>
<dd>
<div class="desc"><p>When the text field with the end time is updated in the stripchart controller (if any),
the range on the x-axis of the plot is adapted accordingly.</p>
<h2 id="args">Args</h2>
<ul>
<li>end_time: Last timepoint to be displayed in the plot (in the format "d hh:mm:ss").</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_end_time(self, end_time):

    &#34;&#34;&#34;
    When the text field with the end time is updated in the stripchart controller (if any),
    the range on the x-axis of the plot is adapted accordingly.

    Args:
        - end_time: Last timepoint to be displayed in the plot (in the format &#34;d hh:mm:ss&#34;).
    &#34;&#34;&#34;

    self.end_time = end_time

    self.interval = self.end_time.replace(microsecond=0) - self.start_time.replace(microsecond=0)

    self.controller.interval_label.setText(str(self.interval.seconds))

    t, v = cut_interval(self.timepoints, self.values, self.start_time, self.end_time)
    self.stripchart.plot(t, v, min_time=self.start_time, max_time=self.end_time)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartWidget.update_interval"><code class="name flex">
<span>def <span class="ident">update_interval</span></span>(<span>self, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>When the text field with the interval is updated in the stripchart controller (if any),
the range on the x-axis of the plot is adapted accordingly.</p>
<h2 id="args">Args</h2>
<ul>
<li>interval: Length of the time period to be displayed in the plot [s].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_interval(self, interval):

    &#34;&#34;&#34;
    When the text field with the interval is updated in the stripchart controller (if any),
    the range on the x-axis of the plot is adapted accordingly.

    Args:
        - interval: Length of the time period to be displayed in the plot [s].
    &#34;&#34;&#34;

    self.interval = interval

    last_timepoints, lastvalues = cut_range(self.timepoints, self.values, self.interval)
    self.stripchart.plot(last_timepoints, lastvalues, interval=self.interval)</code></pre>
</details>
</dd>
<dt id="egse.gui.stripchart.StripChartWidget.update_start_time"><code class="name flex">
<span>def <span class="ident">update_start_time</span></span>(<span>self, start_time)</span>
</code></dt>
<dd>
<div class="desc"><p>When the text field with the start time is updated in the stripchart controller (if any),
the range on the x-axis of the plot is adapted accordingly.</p>
<h2 id="args">Args</h2>
<ul>
<li>start_time: First timepoint to be displayed in the plot (in the format "d hh:mm:ss").</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_start_time(self, start_time):

    &#34;&#34;&#34;
    When the text field with the start time is updated in the stripchart controller (if any),
    the range on the x-axis of the plot is adapted accordingly.

    Args:
        - start_time: First timepoint to be displayed in the plot (in the format &#34;d hh:mm:ss&#34;).
    &#34;&#34;&#34;

    self.start_time = start_time

    self.interval = self.end_time.replace(microsecond=0) - self.start_time.replace(microsecond=0)

    self.controller.interval_label.setText(str(self.interval.seconds))

    t, v = cut_interval(self.timepoints, self.values, self.start_time, self.end_time)
    self.stripchart.plot(t, v, min_time=self.start_time, max_time=self.end_time)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.stripchart.TimeAxisItem"><code class="flex name class">
<span>class <span class="ident">TimeAxisItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>GraphicsItem showing a single plot axis with ticks, values, and label.
Can be configured to fit on any side of a plot,
Can automatically synchronize its displayed scale with ViewBox items.
Ticks can be extended to draw a grid.
If maxTickLength is negative, ticks point into the plot.</p>
<p>=============== ===============================================================
<strong>Arguments:</strong>
orientation
one of 'left', 'right', 'top', or 'bottom'
maxTickLength
(px) maximum length of ticks to draw. Negative values draw
into the plot, positive values draw outward.
linkView
(ViewBox) causes the range of values displayed in the axis
to be linked to the visible range of a ViewBox.
showValues
(bool) Whether to display values adjacent to ticks
pen
(QPen) Pen used when drawing ticks.
textPen
(QPen) Pen used when drawing tick labels.
text
The text (excluding units) to display on the label for this
axis.
units
The units for this axis. Units should generally be given
without any scaling prefix (eg, 'V' instead of 'mV'). The
scaling prefix will be automatically prepended based on the
range of data displayed.
args
All extra keyword arguments become CSS style options for
the <span> tag which will surround the axis label and units.
=============== ===============================================================</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeAxisItem(AxisItem):
    def __init__(self, *args, **kwargs):
        AxisItem.__init__(self, *args, **kwargs)

    def tickStrings(self, values, scale, spacing):
        return [QDateTime.fromMSecsSinceEpoch(value).toString(&#39;d HH:mm:ss&#39;) for value in values]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyqtgraph.graphicsItems.AxisItem.AxisItem</li>
<li>pyqtgraph.graphicsItems.GraphicsWidget.GraphicsWidget</li>
<li>pyqtgraph.graphicsItems.GraphicsItem.GraphicsItem</li>
<li>PyQt5.QtWidgets.QGraphicsWidget</li>
<li>PyQt5.QtWidgets.QGraphicsObject</li>
<li>PyQt5.QtCore.QObject</li>
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>PyQt5.QtWidgets.QGraphicsLayoutItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.stripchart.TimeAxisItem.tickStrings"><code class="name flex">
<span>def <span class="ident">tickStrings</span></span>(<span>self, values, scale, spacing)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the strings that should be placed next to ticks. This method is called
when redrawing the axis and is a good method to override in subclasses.
The method is called with a list of tick values, a scaling factor (see below), and the
spacing between ticks (this is required since, in some instances, there may be only
one tick and thus no other way to determine the tick spacing)</p>
<p>The scale argument is used when the axis label is displaying units which may have an SI scaling prefix.
When determining the text to display, use value*scale to correctly account for this prefix.
For example, if the axis label's units are set to 'V', then a tick value of 0.001 might
be accompanied by a scale value of 1000. This indicates that the label is displaying 'mV', and
thus the tick should display 0.001 * 1000 = 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tickStrings(self, values, scale, spacing):
    return [QDateTime.fromMSecsSinceEpoch(value).toString(&#39;d HH:mm:ss&#39;) for value in values]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.stripchart.TimeSeriesCanvas"><code class="flex name class">
<span>class <span class="ident">TimeSeriesCanvas</span></span>
<span>(</span><span>quantity, unit, parent=None, dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>QWidget(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p>
<p>Initialisation of the plot window, that will be used to plot time series.</p>
<h2 id="args">Args</h2>
<ul>
<li>quantity: Physical quantity that will be shown on the y-axis.</li>
<li>unit: Unit of the physical quantity that will be shown on the y-axis.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeSeriesCanvas(FigureCanvas):

    def __init__(self, quantity, unit, parent=None, dpi=100):

        &#34;&#34;&#34;
        Initialisation of the plot window, that will be used to plot time series.

        Args:
            - quantity: Physical quantity that will be shown on the y-axis.
            - unit: Unit of the physical quantity that will be shown on the y-axis.
        &#34;&#34;&#34;

        self.quantity = quantity
        self.unit = unit

        self.figure = Figure()
        self.ax = self.figure.add_subplot(111)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)


    def plot(self, timepoints, values, interval=None, min_time = None, max_time = None):

        &#34;&#34;&#34;
        Remove the current content (if any) and plot the given data.

        Args:
            - timepoints: Timepoints as datatime objects.
            - values: Values corresponding to the timepoints.
            - interval: Range of the x-axis (up to the last timepoints) as timedelta object.  If this
                        is None, the x-range will not be set.
            - min_time: Lower end of the interval to show on the x-axis.
            - max_time: Upper end of the interval to show on the x-axis.
        &#34;&#34;&#34;

        # Remove old content (if any)

        try:
            del self.ax.lines[-1]
        except:
            pass

        # Plot the new data

        self.ax.plot(timepoints, values, &#34;b&#34;)

        # On the x-axis: time

        if not interval is None:

            self.ax.set_xlim([timepoints[-1] - interval, timepoints[-1]])

        if not min_time is None and not max_time is None:

            self.ax.set_xlim([min_time, max_time])

        self.ax.set_xlabel(&#34;Time [d hh:mm:ss]&#34;, fontsize=10)
        formatter = DateFormatter(&#34;%-d %H:%M:%S&#34;)
        self.ax.xaxis.set_major_formatter(formatter)
        self.figure.autofmt_xdate()

        # On the y-axis: physical quantity (specified at initialisation)

        self.ax.set_ylabel(self.quantity + &#34; [&#34; + self.unit + &#34;]&#34;, fontsize=10)

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.stripchart.TimeSeriesCanvas.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, timepoints, values, interval=None, min_time=None, max_time=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the current content (if any) and plot the given data.</p>
<h2 id="args">Args</h2>
<ul>
<li>timepoints: Timepoints as datatime objects.</li>
<li>values: Values corresponding to the timepoints.</li>
<li>interval: Range of the x-axis (up to the last timepoints) as timedelta object.
If this
is None, the x-range will not be set.</li>
<li>min_time: Lower end of the interval to show on the x-axis.</li>
<li>max_time: Upper end of the interval to show on the x-axis.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, timepoints, values, interval=None, min_time = None, max_time = None):

    &#34;&#34;&#34;
    Remove the current content (if any) and plot the given data.

    Args:
        - timepoints: Timepoints as datatime objects.
        - values: Values corresponding to the timepoints.
        - interval: Range of the x-axis (up to the last timepoints) as timedelta object.  If this
                    is None, the x-range will not be set.
        - min_time: Lower end of the interval to show on the x-axis.
        - max_time: Upper end of the interval to show on the x-axis.
    &#34;&#34;&#34;

    # Remove old content (if any)

    try:
        del self.ax.lines[-1]
    except:
        pass

    # Plot the new data

    self.ax.plot(timepoints, values, &#34;b&#34;)

    # On the x-axis: time

    if not interval is None:

        self.ax.set_xlim([timepoints[-1] - interval, timepoints[-1]])

    if not min_time is None and not max_time is None:

        self.ax.set_xlim([min_time, max_time])

    self.ax.set_xlabel(&#34;Time [d hh:mm:ss]&#34;, fontsize=10)
    formatter = DateFormatter(&#34;%-d %H:%M:%S&#34;)
    self.ax.xaxis.set_major_formatter(formatter)
    self.figure.autofmt_xdate()

    # On the y-axis: physical quantity (specified at initialisation)

    self.ax.set_ylabel(self.quantity + &#34; [&#34; + self.unit + &#34;]&#34;, fontsize=10)

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.gui" href="index.html">egse.gui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.gui.stripchart.cut_interval" href="#egse.gui.stripchart.cut_interval">cut_interval</a></code></li>
<li><code><a title="egse.gui.stripchart.cut_range" href="#egse.gui.stripchart.cut_range">cut_range</a></code></li>
<li><code><a title="egse.gui.stripchart.link" href="#egse.gui.stripchart.link">link</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.gui.stripchart.StripChart" href="#egse.gui.stripchart.StripChart">StripChart</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.stripchart.StripChart.setData" href="#egse.gui.stripchart.StripChart.setData">setData</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChart.setInterval" href="#egse.gui.stripchart.StripChart.setInterval">setInterval</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChart.set_yrange" href="#egse.gui.stripchart.StripChart.set_yrange">set_yrange</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChart.update" href="#egse.gui.stripchart.StripChart.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.stripchart.StripChartControllerWidget" href="#egse.gui.stripchart.StripChartControllerWidget">StripChartControllerWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.create_interval" href="#egse.gui.stripchart.StripChartControllerWidget.create_interval">create_interval</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.create_play_action" href="#egse.gui.stripchart.StripChartControllerWidget.create_play_action">create_play_action</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.create_play_button" href="#egse.gui.stripchart.StripChartControllerWidget.create_play_button">create_play_button</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.create_start_end" href="#egse.gui.stripchart.StripChartControllerWidget.create_start_end">create_start_end</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.handle_play" href="#egse.gui.stripchart.StripChartControllerWidget.handle_play">handle_play</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.play" href="#egse.gui.stripchart.StripChartControllerWidget.play">play</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.set_time" href="#egse.gui.stripchart.StripChartControllerWidget.set_time">set_time</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.update_end_time" href="#egse.gui.stripchart.StripChartControllerWidget.update_end_time">update_end_time</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.update_interval" href="#egse.gui.stripchart.StripChartControllerWidget.update_interval">update_interval</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartControllerWidget.update_start_time" href="#egse.gui.stripchart.StripChartControllerWidget.update_start_time">update_start_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.stripchart.StripChartWidget" href="#egse.gui.stripchart.StripChartWidget">StripChartWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.stripchart.StripChartWidget.play" href="#egse.gui.stripchart.StripChartWidget.play">play</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartWidget.update" href="#egse.gui.stripchart.StripChartWidget.update">update</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartWidget.update_end_time" href="#egse.gui.stripchart.StripChartWidget.update_end_time">update_end_time</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartWidget.update_interval" href="#egse.gui.stripchart.StripChartWidget.update_interval">update_interval</a></code></li>
<li><code><a title="egse.gui.stripchart.StripChartWidget.update_start_time" href="#egse.gui.stripchart.StripChartWidget.update_start_time">update_start_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.stripchart.TimeAxisItem" href="#egse.gui.stripchart.TimeAxisItem">TimeAxisItem</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.stripchart.TimeAxisItem.tickStrings" href="#egse.gui.stripchart.TimeAxisItem.tickStrings">tickStrings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.stripchart.TimeSeriesCanvas" href="#egse.gui.stripchart.TimeSeriesCanvas">TimeSeriesCanvas</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.stripchart.TimeSeriesCanvas.plot" href="#egse.gui.stripchart.TimeSeriesCanvas.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
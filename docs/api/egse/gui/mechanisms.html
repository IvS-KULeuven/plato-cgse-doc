<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.gui.mechanisms API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.gui.mechanisms</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import matplotlib
import matplotlib.patches as patches
import matplotlib.pyplot as plt
import numpy as np
from PyQt5.QtCore import QSize
from PyQt5.QtGui import QFont, QPixmap, QIcon
from PyQt5.QtWidgets import QSizePolicy, QGroupBox, QGridLayout, QLabel, QMainWindow, QFrame, QVBoxLayout, \
    QHBoxLayout, QPushButton
from math import radians, pi
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from egse.config import find_file
from egse.resource import get_resource
from egse.settings import Settings
from egse.setup import get_setup
from egse.state import GlobalState

FONT = QFont(&#34;Helvetica&#34;, 18)

FOV_SETTINGS = Settings.load(&#34;Field-Of-View&#34;)
DEGREE_SYMBOL_PLOT = &#34;$^\circ$&#34;
DEGREE_SYMBOL_LABEL = f&#34;\u00B0&#34;

######################################
# Widgets for the scan mirror assembly
######################################


class HelpButton(QPushButton):
    &#34;&#34;&#34; Help button for the mechanisms widget.&#34;&#34;&#34;

    def __init__(self):

        super(HelpButton, self).__init__()

        help_icon = QIcon(str(get_resource(&#34;:/icons/info.svg&#34;)))

        self.setIcon(help_icon)
        self.setMaximumSize(50, 50)
        self.setIconSize(QSize(30, 30))
        self.setStyleSheet(&#34;border: none;&#34;)


class ExplanationWindow(QMainWindow):

    def __init__(self, title, filename):
        &#34;&#34;&#34; Initialisation of a window with more explanation about the mechanisms.

        Args:
            - title: Window title.
            - filename: Full path to the image to display.
        &#34;&#34;&#34;

        super(ExplanationWindow, self).__init__()

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        self.setWindowTitle(title)

        self.layout = QVBoxLayout()

        label = QLabel()
        pixmap = QPixmap(filename)
        label.setPixmap(pixmap)

        self.layout.addWidget(label)

        app_frame.setLayout(self.layout)

        self.setCentralWidget(app_frame)


class ScanMirrorAssembly(FigureCanvas):
    &#34;&#34;&#34; Display of the Scan Mirror Assembly

    FigureCanvas showing the distance of the scan mirror (along the translation stage) from the optical axis and the
    orientation of the scan mirror (small rotation stage).
    &#34;&#34;&#34;

    def __init__(self, parent=None, width=5, height=4, dpi=100):

        self.figure = Figure(dpi=dpi)
        self.ax = self.figure.add_subplot(111, aspect=&#39;equal&#39;)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        setup = GlobalState.setup
        self.offset_alpha = setup.gse.stages.calibration.offset_alpha
        self.offset_delta_x = setup.gse.stages.calibration.offset_delta_x

        self.plot(0, 0)

    def plot(self, angle, distance):
        &#34;&#34;&#34; Plot the position and orientation angle of the scan mirror w.r.t. the optical axis.

        Args:
            - distance: Distance (along the translation stage) between the scan mirror and the optical axis [mm].
            - angle: Orientation angle of the scan mirror [degrees].
        &#34;&#34;&#34;

        cmd_angle = angle
        total_angle = cmd_angle + self.offset_alpha + 45

        cmd_distance = distance
        total_angle = distance

        # Light path (from collimator to SMA)

        self.ax.annotate(&#34;towards collimator&#34;, (-80, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)
        self.ax.arrow(0, 0, -80, 0, fc=&#39;gray&#39;, ec=&#39;gray&#39;, lw=1,
                      head_width=6, head_length=10,
                      length_includes_head=True, clip_on=False)

        # Optical axis

        self.ax.plot([0.0, 0.0], [-55, 40], &#34;k&#34;, linewidth=1)
        self.ax.annotate(&#34;optical axis&#34;, (0, 50), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)

        # Scan mirror

        self.mirror_thickness = 1
        self.mirror_length = 50

        ts = self.ax.transData
        coords = [distance, 0]  # Rotate around this point
        tr = matplotlib.transforms.Affine2D().rotate_deg_around(coords[0], coords[1], total_angle - 90)
        t = tr + ts
        self.scan_mirror = matplotlib.patches.Rectangle(
            (distance - self.mirror_length / 2, 0), self.mirror_length, self.mirror_thickness, color=&#34;k&#34;, transform=t)
        self.ax.add_patch(self.scan_mirror)

        self.arrow_right = matplotlib.patches.FancyArrow(
            -30, -50, 30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_right)
        self.arrow_left = matplotlib.patches.FancyArrow(
            distance + 30, -50, -30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_left)

        self.distance_annotation = self.ax.annotate(
            &#34;$\Delta x$&#34;, (distance / 2, -65), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)
        self.angle_annotation = self.ax.annotate(
            u&#34;\u03B1&#34;, (distance + 10, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)

        self.ax.plot([distance, distance], [-55, 40], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        # Axes

        self.ax.set_xlim([-110, 200])
        self.ax.set_ylim([-70, 60])

        self.ax.axis(&#34;off&#34;)

        self.draw()

    def update_plot(self, cmd_distance, angle):
        &#34;&#34;&#34;
        Update the orientation of the scan mirror, and the distance (along the
        translation stage) between the scan mirror and the optical axis.

        :param distance: Distance (along the translation stage) between the scan mirror
                         and the optical axis [mm].

        :param angle: Orientation angle of the scan mirror [degrees].
        &#34;&#34;&#34;

        cmd_angle = angle
        total_angle = cmd_angle + self.offset_alpha + 45

        total_distance = cmd_distance + self.offset_delta_x

        self.angle_annotation.remove()
        self.distance_annotation.remove()

        self.scan_mirror.remove()
        self.arrow_right.remove()
        self.arrow_left.remove()

        del self.ax.lines[-1]

        # Scan mirror

        ts = self.ax.transData
        coords = [total_distance, 0]  # Rotate around this point
        tr = matplotlib.transforms.Affine2D().rotate_deg_around(coords[0], coords[1], total_angle - 90)
        t = tr + ts
        self.scan_mirror = matplotlib.patches.Rectangle((total_distance - self.mirror_length / 2, 0),
                                                        self.mirror_length, self.mirror_thickness, color=&#34;k&#34;,
                                                        transform=t)
        self.ax.add_patch(self.scan_mirror)

        self.arrow_right = matplotlib.patches.FancyArrow(-30, -50, 30, 0, length_includes_head=True, head_width=6,
                                                         head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_right)
        # self.arrow_left = matplotlib.patches.FancyArrow(
        #     distance + 30, -50, -30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
        self.arrow_left = matplotlib.patches.FancyArrow(total_distance + 30, -50, -30, 0, length_includes_head=True,
                                                        head_width=6, head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_left)

        distance_text = f&#34;$\Delta x$ = {cmd_distance:.2f} mm + {self.offset_delta_x} mm \n   = {total_distance:.2f} mm&#34;
        self.distance_annotation = self.ax.annotate(distance_text, (cmd_distance / 2, -70), color=&#39;k&#39;, fontsize=10,
                                                    ha=&#39;center&#39;, va=&#39;center&#39;)

        angle_text = u&#34;\u03B1&#34; + f&#34; = {cmd_angle:.2f}{DEGREE_SYMBOL_PLOT} + {self.offset_alpha}{DEGREE_SYMBOL_PLOT} &#34; \
                                 f&#34;+ 45{DEGREE_SYMBOL_PLOT} \n   = {total_angle:.2f}{DEGREE_SYMBOL_PLOT}&#34;
        self.angle_annotation = self.ax.annotate(angle_text, (cmd_distance + 10, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;left&#39;,
                                                 va=&#39;center&#39;)

        self.ax.plot([cmd_distance, cmd_distance], [-55, 40], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        self.draw()


class ScanMirrorAssemblyWidget(QGroupBox):

    def __init__(self):
        &#34;&#34;&#34;
        Initialisation of a plot showing the distance of the scan mirror (along the translation stage)
        from the optical axis and the orientation of the scan mirror (small rotation stage).
        &#34;&#34;&#34;

        super(ScanMirrorAssemblyWidget, self).__init__(&#34;Scan Mirror Assembly&#34;)

        self.setStatusTip(
            &#34;Current configuration of the scan mirror assembly (i.e. small rotation stage and translation stage)&#34;)
        self.setFont(FONT)

        setup = get_setup()
        self.offset_delta_x = setup.gse.stages.calibration.offset_delta_x
        self.offset_alpha = setup.gse.stages.calibration.offset_alpha

        self.explanation_window = ExplanationWindow(&#34;Configuration of the Scan Mirror Assembly&#34;,
                                                    str(find_file(&#34;sma.png&#34;, in_dir=&#34;images&#34;)))
        self.cmd_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.cmd_angle_text_explanation)
        self.explanation_window.layout.addWidget(QLabel(f&#34;offset_alpha: {self.offset_alpha}{DEGREE_SYMBOL_LABEL} &#34;
                                                        f&#34;(see setup)&#34;))
        self.total_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.total_angle_text_explanation)
        self.cmd_distance_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.cmd_distance_text_explanation)
        self.explanation_window.layout.addWidget(QLabel(f&#34;offset_delta_x: {self.offset_delta_x} mm (see setup)&#34;))
        self.total_distance_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.total_distance_text_explanation)

        layout = QVBoxLayout()

        self.sma = ScanMirrorAssembly()
        layout.addWidget(self.sma)

        self.cmd_angle_text = QLabel()
        self.cmd_distance_text = QLabel()

        labels_layout = QVBoxLayout()
        labels_layout.addWidget(self.cmd_angle_text)
        labels_layout.addWidget(self.cmd_distance_text)

        info_layout = QHBoxLayout()
        info_layout.addLayout(labels_layout)

        help_button = HelpButton()
        help_button.clicked.connect(self.explanation_window.show)

        info_layout.addWidget(help_button)
        layout.addLayout(info_layout)

        self.setLayout(layout)

    def update_plot(self, distance, angle):
        &#34;&#34;&#34;
        Update the orientation of the scan mirror, and the distance (along the
        translation stage) between the scan mirror and the optical axis.

        :param distance: Distance (along the translation stage) between the scan mirror
                         and the optical axis [mm].

        :param angle: Orientation angle of the scan mirror [degrees].
        &#34;&#34;&#34;

        self.sma.update_plot(-distance, angle)

        self.cmd_angle_text.setText(f&#34;Commanded position for the small rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.cmd_distance_text.setText(f&#34;Commanded position for the translation stage: {distance:.2f}{DEGREE_SYMBOL_LABEL}&#34;)

        self.cmd_angle_text_explanation.setText(f&#34;Commanded position for the small rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.total_angle_text_explanation.setText(f&#34;Angle \u03B1 shown: {(angle + self.offset_alpha + 45):.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.cmd_distance_text_explanation.setText(f&#34;Commanded position for the translation stage: {distance:.2f} mm&#34;)
        self.total_distance_text_explanation.setText(f&#34;Distance \u0394x shown: {(-distance + self.offset_delta_x):.2f} mm&#34;)

####################################
# Widgets for the big rotation stage
####################################


class BigRotationStage(FigureCanvas):
    &#34;&#34;&#34;
    FigureCanvas showing the orientation of the big rotation stage.
    &#34;&#34;&#34;

    def __init__(self, parent=None, width=5, height=4, dpi=100):

        self.figure = Figure(dpi=dpi)
        self.ax = self.figure.add_subplot(
            111, aspect=&#39;equal&#39;, projection=&#34;polar&#34;)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_DEGREES, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
        self.plot()

    def plot(self, angle=45):
        &#34;&#34;&#34;
        Plot the GL_FIX axes in black and the GL_ROT axes in red.

        :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
                corresponds to a counterclockwise rotation.
        &#34;&#34;&#34;

        self.ax.arrow(0, 0, 0, 1, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1, head_width=.09,
                      head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
        self.ax.arrow(pi / 2, 0, 0, 1, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1, head_width=.09,
                      head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

        self.ax.set_rlim([0, 1])

        self.ax.plot([0], [0], &#34;k&#34;, label=&#34;GL_FIX&#34;)
        self.ax.plot([0], [0], &#34;r&#34;, label=&#34;GL_ROT&#34;)

        # Axes

        self.x_axis_gl_rot = self.ax.arrow(radians(angle), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
        self.y_axis_gl_rot = self.ax.arrow(radians(angle + 90), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

        self.ax.get_yaxis().set_visible(False)

        tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.97]
        for t in np.deg2rad(np.arange(0, 360, 5)):
            self.ax.plot([t, t], tick, lw=0.72, color=&#34;k&#34;)

        # Legend

        box = self.ax.get_position()
        self.ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
        self.ax.legend(loc=&#39;center left&#39;, bbox_to_anchor=(1.2, 0.5))

        self.draw()

    def update_plot(self, angle):
        &#34;&#34;&#34;
        Update the orientation of GL_ROT.

        :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
                corresponds to a counterclockwise rotation.
        &#34;&#34;&#34;

        self.x_axis_gl_rot.remove()
        self.y_axis_gl_rot.remove()

        self.x_axis_gl_rot = self.ax.arrow(radians(angle), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
        self.y_axis_gl_rot = self.ax.arrow(radians(angle + 90), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

        self.draw()


class BigRotationStageWidget(QGroupBox):

    def __init__(self):
        &#34;&#34;&#34;
        Initialisation of a plot showing the orientation of GL_ROT w.r.t.
        GL_FIX, based on the orientation of the big rotation stage.  Below the
        plot you can find the value of the rotation angle.
        &#34;&#34;&#34;

        super(BigRotationStageWidget, self).__init__(&#34;Big Rotation Stage&#34;)

        self.setStatusTip(
            &#34;Current configuration of the big rotation stage (visualised as the rotation of GL_ROT w.r.t. GL_FIX)&#34;)
        self.setFont(FONT)

        setup = get_setup()
        self.offset_phi = setup.gse.stages.calibration.offset_phi

        self.explanation_window = ExplanationWindow(&#34;Configuration of the big rotation stage&#34;,
                                                    str(find_file(&#34;big-rotation-stage.png&#34;, in_dir=&#34;images&#34;)))
        self.cmd_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.cmd_angle_text_explanation)
        self.explanation_window.layout.addWidget(QLabel(f&#34;offset_phi: {self.offset_phi}{DEGREE_SYMBOL_LABEL} (see setup)&#34;))
        self.total_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.total_angle_text_explanation)

        layout = QVBoxLayout()

        self.big_rotation_stage = BigRotationStage()
        layout.addWidget(self.big_rotation_stage)

        self.angle_big_rotation_stage_text = QLabel()

        info_layout = QHBoxLayout()

        help_button = HelpButton()
        help_button.clicked.connect(self.explanation_window.show)

        info_layout.addWidget(self.angle_big_rotation_stage_text)
        info_layout.addWidget(help_button)
        layout.addLayout(info_layout)

        self.setLayout(layout)

    def update_plot(self, angle):
        &#34;&#34;&#34;
        Update the orientation of GL_ROT.

        :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
                corresponds to a counterclockwise rotation.
        &#34;&#34;&#34;
        self.big_rotation_stage.update_plot(angle)

    def update(self, angle):
        &#34;&#34;&#34;
        Update the shown configuration of the big rotation stage.
        &#34;&#34;&#34;

        self.big_rotation_stage.update_plot(angle)

        self.angle_big_rotation_stage_text.setText(f&#34;Commanded position for the big rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)

        self.cmd_angle_text_explanation.setText(f&#34;Commanded position for the big rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.total_angle_text_explanation.setText(f&#34;Angle shown in red: {(-angle + self.offset_phi):.2f}{DEGREE_SYMBOL_LABEL}&#34;)


################################
# Widgets for the focus position
################################


class FocusPosition(FigureCanvas):
    &#34;&#34;&#34;
    FigureCanvas showing the focus position as the distance between L6S2 and FPA_SEN.
    &#34;&#34;&#34;

    def __init__(self, parent=None, width=5, height=4, dpi=100):
        &#34;&#34;&#34;
        Initialisation of a plot showing L6 and FPA_SEN.
        &#34;&#34;&#34;

        self.figure = Figure(dpi=dpi)
        self.ax = self.figure.add_subplot(111, aspect=&#39;equal&#39;)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        self.plot()

    def plot(self, focus_position=0):
        &#34;&#34;&#34;
        Plot a cyan trapezium representing L6 and a black rectangle representing the
        focal plane.  An arrow is drawn, next to which the distance between the two will
        be shown.
        &#34;&#34;&#34;

        # L6

        self.l6_width = 120
        self.l6_thickness = 20

        points = [[-self.l6_width / 2, 0], [self.l6_width / 2, 0], [self.l6_width / 2 -
                                                                    5, self.l6_thickness],
                  [-self.l6_width / 2 + 5, self.l6_thickness], [-60, 0]]
        polygon = plt.Polygon(points, color=&#34;cyan&#34;)
        self.ax.add_patch(polygon)
        self.ax.annotate(&#34;L6&#34;, (0, 10), color=&#39;k&#39;,
                         fontsize=12, va=&#39;center&#39;, ha=&#39;center&#39;)

        self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                     [0, 0], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)
        self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                     [-focus_position, -focus_position], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        # FPA_SEN

        self.fpa_sen_size = 120
        self.fpa_sen_thickness = 1

        self.fpa_sen = patches.Rectangle(
            (-self.fpa_sen_size / 2, focus_position), 2 * self.fpa_sen_size / 2, -self.fpa_sen_thickness, color=&#34;k&#34;)
        self.ax.add_patch(self.fpa_sen)

        # Focus position

        self.arrow_down = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, 15, 0, -15, length_includes_head=True, head_width=3, head_length=5, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_down)
        self.arrow_up = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, -focus_position - 15, 0, 15, length_includes_head=True, head_width=3, head_length=5,
            color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_up)

        self.focus_position_annotation = self.ax.annotate(
            &#34;$\Delta$ z&#34;, (self.l6_width / 2 + 30, -focus_position / 2), color=&#39;k&#39;, fontsize=10, va=&#39;center&#39;)

        # Axes

        self.ax.set_xlim([-70, 150])
        self.ax.set_ylim([-40, 40])

        self.ax.axis(&#34;off&#34;)

        self.draw()

    def update_plot(self, focus_position):
        &#34;&#34;&#34;
        Update the distance between L6S2 and FPA_SEN.

        :focus_position: Distance between L6S2 and FPA_SEN to display [mm].
        &#34;&#34;&#34;

        del self.ax.lines[-1]

        self.fpa_sen.remove()
        self.arrow_down.remove()
        self.arrow_up.remove()
        self.focus_position_annotation.remove()

        self.fpa_sen = patches.Rectangle(
            (-self.fpa_sen_size / 2, -focus_position), 2 * self.fpa_sen_size / 2, -self.fpa_sen_thickness, color=&#34;k&#34;)
        self.ax.add_patch(self.fpa_sen)

        self.arrow_down = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, 15, 0, -15, length_includes_head=True, head_width=3, head_length=5, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_down)
        self.arrow_up = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, -focus_position - 15, 0, 15, length_includes_head=True, head_width=3, head_length=5,
            color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_up)

        self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                     [-focus_position, -focus_position], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        self.focus_position_annotation = self.ax.annotate(&#34;$\Delta$ z = {:.2f} mm&#34;.format(
            focus_position), (self.l6_width / 2 + 30, -focus_position / 2), color=&#39;k&#39;, fontsize=10, va=&#39;center&#39;)

        self.draw()


class FocusPositionWidget(QGroupBox):

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a plot showing L6 and FPA_SEN.&#34;&#34;&#34;

        super(FocusPositionWidget, self).__init__(&#34;Focus Position&#34;)

        self.setStatusTip(&#34;Current focus position, as commanded via the hexapod&#34;)
        self.setFont(FONT)

        layout = QGridLayout()

        self.focus_position = FocusPosition()
        layout.addWidget(self.focus_position)
        self.setLayout(layout)

    def update_plot(self, focus_position):
        &#34;&#34;&#34;
        Update the distance between L6S2 and FPA_SEN.

        :focus_position: Distance between L6S2 and FPA_SEN to display [mm].
        &#34;&#34;&#34;

        self.focus_position.update_plot(focus_position)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.gui.mechanisms.BigRotationStage"><code class="flex name class">
<span>class <span class="ident">BigRotationStage</span></span>
<span>(</span><span>parent=None, width=5, height=4, dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>FigureCanvas showing the orientation of the big rotation stage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BigRotationStage(FigureCanvas):
    &#34;&#34;&#34;
    FigureCanvas showing the orientation of the big rotation stage.
    &#34;&#34;&#34;

    def __init__(self, parent=None, width=5, height=4, dpi=100):

        self.figure = Figure(dpi=dpi)
        self.ax = self.figure.add_subplot(
            111, aspect=&#39;equal&#39;, projection=&#34;polar&#34;)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        self.circle = plt.Circle(
            (0, 0), FOV_SETTINGS.RADIUS_DEGREES, color=&#39;b&#39;, fill=False, label=&#34;FOV&#34;, linewidth=1)
        self.plot()

    def plot(self, angle=45):
        &#34;&#34;&#34;
        Plot the GL_FIX axes in black and the GL_ROT axes in red.

        :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
                corresponds to a counterclockwise rotation.
        &#34;&#34;&#34;

        self.ax.arrow(0, 0, 0, 1, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1, head_width=.09,
                      head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
        self.ax.arrow(pi / 2, 0, 0, 1, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1, head_width=.09,
                      head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

        self.ax.set_rlim([0, 1])

        self.ax.plot([0], [0], &#34;k&#34;, label=&#34;GL_FIX&#34;)
        self.ax.plot([0], [0], &#34;r&#34;, label=&#34;GL_ROT&#34;)

        # Axes

        self.x_axis_gl_rot = self.ax.arrow(radians(angle), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
        self.y_axis_gl_rot = self.ax.arrow(radians(angle + 90), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

        self.ax.get_yaxis().set_visible(False)

        tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.97]
        for t in np.deg2rad(np.arange(0, 360, 5)):
            self.ax.plot([t, t], tick, lw=0.72, color=&#34;k&#34;)

        # Legend

        box = self.ax.get_position()
        self.ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
        self.ax.legend(loc=&#39;center left&#39;, bbox_to_anchor=(1.2, 0.5))

        self.draw()

    def update_plot(self, angle):
        &#34;&#34;&#34;
        Update the orientation of GL_ROT.

        :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
                corresponds to a counterclockwise rotation.
        &#34;&#34;&#34;

        self.x_axis_gl_rot.remove()
        self.y_axis_gl_rot.remove()

        self.x_axis_gl_rot = self.ax.arrow(radians(angle), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
        self.y_axis_gl_rot = self.ax.arrow(radians(angle + 90), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                           head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.mechanisms.BigRotationStage.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, angle=45)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the GL_FIX axes in black and the GL_ROT axes in red.</p>
<p>:angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
corresponds to a counterclockwise rotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, angle=45):
    &#34;&#34;&#34;
    Plot the GL_FIX axes in black and the GL_ROT axes in red.

    :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
            corresponds to a counterclockwise rotation.
    &#34;&#34;&#34;

    self.ax.arrow(0, 0, 0, 1, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1, head_width=.09,
                  head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
    self.ax.arrow(pi / 2, 0, 0, 1, fc=&#39;k&#39;, ec=&#39;k&#39;, lw=1, head_width=.09,
                  head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

    self.ax.set_rlim([0, 1])

    self.ax.plot([0], [0], &#34;k&#34;, label=&#34;GL_FIX&#34;)
    self.ax.plot([0], [0], &#34;r&#34;, label=&#34;GL_ROT&#34;)

    # Axes

    self.x_axis_gl_rot = self.ax.arrow(radians(angle), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                       head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
    self.y_axis_gl_rot = self.ax.arrow(radians(angle + 90), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                       head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

    self.ax.get_yaxis().set_visible(False)

    tick = [self.ax.get_rmax(), self.ax.get_rmax() * 0.97]
    for t in np.deg2rad(np.arange(0, 360, 5)):
        self.ax.plot([t, t], tick, lw=0.72, color=&#34;k&#34;)

    # Legend

    box = self.ax.get_position()
    self.ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
    self.ax.legend(loc=&#39;center left&#39;, bbox_to_anchor=(1.2, 0.5))

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.mechanisms.BigRotationStage.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the orientation of GL_ROT.</p>
<p>:angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
corresponds to a counterclockwise rotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, angle):
    &#34;&#34;&#34;
    Update the orientation of GL_ROT.

    :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
            corresponds to a counterclockwise rotation.
    &#34;&#34;&#34;

    self.x_axis_gl_rot.remove()
    self.y_axis_gl_rot.remove()

    self.x_axis_gl_rot = self.ax.arrow(radians(angle), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                       head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)
    self.y_axis_gl_rot = self.ax.arrow(radians(angle + 90), 0, 0, 1, fc=&#39;r&#39;, ec=&#39;r&#39;, lw=1, head_width=.09,
                                       head_length=.15, overhang=0.01, length_includes_head=True, clip_on=False)

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.mechanisms.BigRotationStageWidget"><code class="flex name class">
<span>class <span class="ident">BigRotationStageWidget</span></span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a plot showing the orientation of GL_ROT w.r.t.
GL_FIX, based on the orientation of the big rotation stage.
Below the
plot you can find the value of the rotation angle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BigRotationStageWidget(QGroupBox):

    def __init__(self):
        &#34;&#34;&#34;
        Initialisation of a plot showing the orientation of GL_ROT w.r.t.
        GL_FIX, based on the orientation of the big rotation stage.  Below the
        plot you can find the value of the rotation angle.
        &#34;&#34;&#34;

        super(BigRotationStageWidget, self).__init__(&#34;Big Rotation Stage&#34;)

        self.setStatusTip(
            &#34;Current configuration of the big rotation stage (visualised as the rotation of GL_ROT w.r.t. GL_FIX)&#34;)
        self.setFont(FONT)

        setup = get_setup()
        self.offset_phi = setup.gse.stages.calibration.offset_phi

        self.explanation_window = ExplanationWindow(&#34;Configuration of the big rotation stage&#34;,
                                                    str(find_file(&#34;big-rotation-stage.png&#34;, in_dir=&#34;images&#34;)))
        self.cmd_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.cmd_angle_text_explanation)
        self.explanation_window.layout.addWidget(QLabel(f&#34;offset_phi: {self.offset_phi}{DEGREE_SYMBOL_LABEL} (see setup)&#34;))
        self.total_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.total_angle_text_explanation)

        layout = QVBoxLayout()

        self.big_rotation_stage = BigRotationStage()
        layout.addWidget(self.big_rotation_stage)

        self.angle_big_rotation_stage_text = QLabel()

        info_layout = QHBoxLayout()

        help_button = HelpButton()
        help_button.clicked.connect(self.explanation_window.show)

        info_layout.addWidget(self.angle_big_rotation_stage_text)
        info_layout.addWidget(help_button)
        layout.addLayout(info_layout)

        self.setLayout(layout)

    def update_plot(self, angle):
        &#34;&#34;&#34;
        Update the orientation of GL_ROT.

        :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
                corresponds to a counterclockwise rotation.
        &#34;&#34;&#34;
        self.big_rotation_stage.update_plot(angle)

    def update(self, angle):
        &#34;&#34;&#34;
        Update the shown configuration of the big rotation stage.
        &#34;&#34;&#34;

        self.big_rotation_stage.update_plot(angle)

        self.angle_big_rotation_stage_text.setText(f&#34;Commanded position for the big rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)

        self.cmd_angle_text_explanation.setText(f&#34;Commanded position for the big rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.total_angle_text_explanation.setText(f&#34;Angle shown in red: {(-angle + self.offset_phi):.2f}{DEGREE_SYMBOL_LABEL}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.mechanisms.BigRotationStageWidget.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the shown configuration of the big rotation stage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, angle):
    &#34;&#34;&#34;
    Update the shown configuration of the big rotation stage.
    &#34;&#34;&#34;

    self.big_rotation_stage.update_plot(angle)

    self.angle_big_rotation_stage_text.setText(f&#34;Commanded position for the big rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)

    self.cmd_angle_text_explanation.setText(f&#34;Commanded position for the big rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
    self.total_angle_text_explanation.setText(f&#34;Angle shown in red: {(-angle + self.offset_phi):.2f}{DEGREE_SYMBOL_LABEL}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.gui.mechanisms.BigRotationStageWidget.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the orientation of GL_ROT.</p>
<p>:angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
corresponds to a counterclockwise rotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, angle):
    &#34;&#34;&#34;
    Update the orientation of GL_ROT.

    :angle: Rotation angle of GL_ROT w.r.t. GL_FIX [degrees]. A positive angle
            corresponds to a counterclockwise rotation.
    &#34;&#34;&#34;
    self.big_rotation_stage.update_plot(angle)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.mechanisms.ExplanationWindow"><code class="flex name class">
<span>class <span class="ident">ExplanationWindow</span></span>
<span>(</span><span>title, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p>
<p>Initialisation of a window with more explanation about the mechanisms.</p>
<h2 id="args">Args</h2>
<ul>
<li>title: Window title.</li>
<li>filename: Full path to the image to display.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExplanationWindow(QMainWindow):

    def __init__(self, title, filename):
        &#34;&#34;&#34; Initialisation of a window with more explanation about the mechanisms.

        Args:
            - title: Window title.
            - filename: Full path to the image to display.
        &#34;&#34;&#34;

        super(ExplanationWindow, self).__init__()

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        self.setWindowTitle(title)

        self.layout = QVBoxLayout()

        label = QLabel()
        pixmap = QPixmap(filename)
        label.setPixmap(pixmap)

        self.layout.addWidget(label)

        app_frame.setLayout(self.layout)

        self.setCentralWidget(app_frame)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.gui.mechanisms.FocusPosition"><code class="flex name class">
<span>class <span class="ident">FocusPosition</span></span>
<span>(</span><span>parent=None, width=5, height=4, dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>FigureCanvas showing the focus position as the distance between L6S2 and FPA_SEN.</p>
<p>Initialisation of a plot showing L6 and FPA_SEN.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocusPosition(FigureCanvas):
    &#34;&#34;&#34;
    FigureCanvas showing the focus position as the distance between L6S2 and FPA_SEN.
    &#34;&#34;&#34;

    def __init__(self, parent=None, width=5, height=4, dpi=100):
        &#34;&#34;&#34;
        Initialisation of a plot showing L6 and FPA_SEN.
        &#34;&#34;&#34;

        self.figure = Figure(dpi=dpi)
        self.ax = self.figure.add_subplot(111, aspect=&#39;equal&#39;)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(
            self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        self.plot()

    def plot(self, focus_position=0):
        &#34;&#34;&#34;
        Plot a cyan trapezium representing L6 and a black rectangle representing the
        focal plane.  An arrow is drawn, next to which the distance between the two will
        be shown.
        &#34;&#34;&#34;

        # L6

        self.l6_width = 120
        self.l6_thickness = 20

        points = [[-self.l6_width / 2, 0], [self.l6_width / 2, 0], [self.l6_width / 2 -
                                                                    5, self.l6_thickness],
                  [-self.l6_width / 2 + 5, self.l6_thickness], [-60, 0]]
        polygon = plt.Polygon(points, color=&#34;cyan&#34;)
        self.ax.add_patch(polygon)
        self.ax.annotate(&#34;L6&#34;, (0, 10), color=&#39;k&#39;,
                         fontsize=12, va=&#39;center&#39;, ha=&#39;center&#39;)

        self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                     [0, 0], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)
        self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                     [-focus_position, -focus_position], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        # FPA_SEN

        self.fpa_sen_size = 120
        self.fpa_sen_thickness = 1

        self.fpa_sen = patches.Rectangle(
            (-self.fpa_sen_size / 2, focus_position), 2 * self.fpa_sen_size / 2, -self.fpa_sen_thickness, color=&#34;k&#34;)
        self.ax.add_patch(self.fpa_sen)

        # Focus position

        self.arrow_down = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, 15, 0, -15, length_includes_head=True, head_width=3, head_length=5, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_down)
        self.arrow_up = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, -focus_position - 15, 0, 15, length_includes_head=True, head_width=3, head_length=5,
            color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_up)

        self.focus_position_annotation = self.ax.annotate(
            &#34;$\Delta$ z&#34;, (self.l6_width / 2 + 30, -focus_position / 2), color=&#39;k&#39;, fontsize=10, va=&#39;center&#39;)

        # Axes

        self.ax.set_xlim([-70, 150])
        self.ax.set_ylim([-40, 40])

        self.ax.axis(&#34;off&#34;)

        self.draw()

    def update_plot(self, focus_position):
        &#34;&#34;&#34;
        Update the distance between L6S2 and FPA_SEN.

        :focus_position: Distance between L6S2 and FPA_SEN to display [mm].
        &#34;&#34;&#34;

        del self.ax.lines[-1]

        self.fpa_sen.remove()
        self.arrow_down.remove()
        self.arrow_up.remove()
        self.focus_position_annotation.remove()

        self.fpa_sen = patches.Rectangle(
            (-self.fpa_sen_size / 2, -focus_position), 2 * self.fpa_sen_size / 2, -self.fpa_sen_thickness, color=&#34;k&#34;)
        self.ax.add_patch(self.fpa_sen)

        self.arrow_down = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, 15, 0, -15, length_includes_head=True, head_width=3, head_length=5, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_down)
        self.arrow_up = matplotlib.patches.FancyArrow(
            self.l6_width / 2 + 10, -focus_position - 15, 0, 15, length_includes_head=True, head_width=3, head_length=5,
            color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_up)

        self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                     [-focus_position, -focus_position], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        self.focus_position_annotation = self.ax.annotate(&#34;$\Delta$ z = {:.2f} mm&#34;.format(
            focus_position), (self.l6_width / 2 + 30, -focus_position / 2), color=&#39;k&#39;, fontsize=10, va=&#39;center&#39;)

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.mechanisms.FocusPosition.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, focus_position=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a cyan trapezium representing L6 and a black rectangle representing the
focal plane.
An arrow is drawn, next to which the distance between the two will
be shown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, focus_position=0):
    &#34;&#34;&#34;
    Plot a cyan trapezium representing L6 and a black rectangle representing the
    focal plane.  An arrow is drawn, next to which the distance between the two will
    be shown.
    &#34;&#34;&#34;

    # L6

    self.l6_width = 120
    self.l6_thickness = 20

    points = [[-self.l6_width / 2, 0], [self.l6_width / 2, 0], [self.l6_width / 2 -
                                                                5, self.l6_thickness],
              [-self.l6_width / 2 + 5, self.l6_thickness], [-60, 0]]
    polygon = plt.Polygon(points, color=&#34;cyan&#34;)
    self.ax.add_patch(polygon)
    self.ax.annotate(&#34;L6&#34;, (0, 10), color=&#39;k&#39;,
                     fontsize=12, va=&#39;center&#39;, ha=&#39;center&#39;)

    self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                 [0, 0], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)
    self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                 [-focus_position, -focus_position], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

    # FPA_SEN

    self.fpa_sen_size = 120
    self.fpa_sen_thickness = 1

    self.fpa_sen = patches.Rectangle(
        (-self.fpa_sen_size / 2, focus_position), 2 * self.fpa_sen_size / 2, -self.fpa_sen_thickness, color=&#34;k&#34;)
    self.ax.add_patch(self.fpa_sen)

    # Focus position

    self.arrow_down = matplotlib.patches.FancyArrow(
        self.l6_width / 2 + 10, 15, 0, -15, length_includes_head=True, head_width=3, head_length=5, color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_down)
    self.arrow_up = matplotlib.patches.FancyArrow(
        self.l6_width / 2 + 10, -focus_position - 15, 0, 15, length_includes_head=True, head_width=3, head_length=5,
        color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_up)

    self.focus_position_annotation = self.ax.annotate(
        &#34;$\Delta$ z&#34;, (self.l6_width / 2 + 30, -focus_position / 2), color=&#39;k&#39;, fontsize=10, va=&#39;center&#39;)

    # Axes

    self.ax.set_xlim([-70, 150])
    self.ax.set_ylim([-40, 40])

    self.ax.axis(&#34;off&#34;)

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.mechanisms.FocusPosition.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, focus_position)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the distance between L6S2 and FPA_SEN.</p>
<p>:focus_position: Distance between L6S2 and FPA_SEN to display [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, focus_position):
    &#34;&#34;&#34;
    Update the distance between L6S2 and FPA_SEN.

    :focus_position: Distance between L6S2 and FPA_SEN to display [mm].
    &#34;&#34;&#34;

    del self.ax.lines[-1]

    self.fpa_sen.remove()
    self.arrow_down.remove()
    self.arrow_up.remove()
    self.focus_position_annotation.remove()

    self.fpa_sen = patches.Rectangle(
        (-self.fpa_sen_size / 2, -focus_position), 2 * self.fpa_sen_size / 2, -self.fpa_sen_thickness, color=&#34;k&#34;)
    self.ax.add_patch(self.fpa_sen)

    self.arrow_down = matplotlib.patches.FancyArrow(
        self.l6_width / 2 + 10, 15, 0, -15, length_includes_head=True, head_width=3, head_length=5, color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_down)
    self.arrow_up = matplotlib.patches.FancyArrow(
        self.l6_width / 2 + 10, -focus_position - 15, 0, 15, length_includes_head=True, head_width=3, head_length=5,
        color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_up)

    self.ax.plot([self.l6_width / 2, self.l6_width / 2 + 20],
                 [-focus_position, -focus_position], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

    self.focus_position_annotation = self.ax.annotate(&#34;$\Delta$ z = {:.2f} mm&#34;.format(
        focus_position), (self.l6_width / 2 + 30, -focus_position / 2), color=&#39;k&#39;, fontsize=10, va=&#39;center&#39;)

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.mechanisms.FocusPositionWidget"><code class="flex name class">
<span>class <span class="ident">FocusPositionWidget</span></span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a plot showing L6 and FPA_SEN.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FocusPositionWidget(QGroupBox):

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a plot showing L6 and FPA_SEN.&#34;&#34;&#34;

        super(FocusPositionWidget, self).__init__(&#34;Focus Position&#34;)

        self.setStatusTip(&#34;Current focus position, as commanded via the hexapod&#34;)
        self.setFont(FONT)

        layout = QGridLayout()

        self.focus_position = FocusPosition()
        layout.addWidget(self.focus_position)
        self.setLayout(layout)

    def update_plot(self, focus_position):
        &#34;&#34;&#34;
        Update the distance between L6S2 and FPA_SEN.

        :focus_position: Distance between L6S2 and FPA_SEN to display [mm].
        &#34;&#34;&#34;

        self.focus_position.update_plot(focus_position)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.mechanisms.FocusPositionWidget.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, focus_position)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the distance between L6S2 and FPA_SEN.</p>
<p>:focus_position: Distance between L6S2 and FPA_SEN to display [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, focus_position):
    &#34;&#34;&#34;
    Update the distance between L6S2 and FPA_SEN.

    :focus_position: Distance between L6S2 and FPA_SEN to display [mm].
    &#34;&#34;&#34;

    self.focus_position.update_plot(focus_position)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.mechanisms.HelpButton"><code class="flex name class">
<span>class <span class="ident">HelpButton</span></span>
</code></dt>
<dd>
<div class="desc"><p>Help button for the mechanisms widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HelpButton(QPushButton):
    &#34;&#34;&#34; Help button for the mechanisms widget.&#34;&#34;&#34;

    def __init__(self):

        super(HelpButton, self).__init__()

        help_icon = QIcon(str(get_resource(&#34;:/icons/info.svg&#34;)))

        self.setIcon(help_icon)
        self.setMaximumSize(50, 50)
        self.setIconSize(QSize(30, 30))
        self.setStyleSheet(&#34;border: none;&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QPushButton</li>
<li>PyQt5.QtWidgets.QAbstractButton</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.gui.mechanisms.ScanMirrorAssembly"><code class="flex name class">
<span>class <span class="ident">ScanMirrorAssembly</span></span>
<span>(</span><span>parent=None, width=5, height=4, dpi=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Display of the Scan Mirror Assembly</p>
<p>FigureCanvas showing the distance of the scan mirror (along the translation stage) from the optical axis and the
orientation of the scan mirror (small rotation stage).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScanMirrorAssembly(FigureCanvas):
    &#34;&#34;&#34; Display of the Scan Mirror Assembly

    FigureCanvas showing the distance of the scan mirror (along the translation stage) from the optical axis and the
    orientation of the scan mirror (small rotation stage).
    &#34;&#34;&#34;

    def __init__(self, parent=None, width=5, height=4, dpi=100):

        self.figure = Figure(dpi=dpi)
        self.ax = self.figure.add_subplot(111, aspect=&#39;equal&#39;)

        FigureCanvas.__init__(self, self.figure)
        self.setParent(parent)

        FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)

        setup = GlobalState.setup
        self.offset_alpha = setup.gse.stages.calibration.offset_alpha
        self.offset_delta_x = setup.gse.stages.calibration.offset_delta_x

        self.plot(0, 0)

    def plot(self, angle, distance):
        &#34;&#34;&#34; Plot the position and orientation angle of the scan mirror w.r.t. the optical axis.

        Args:
            - distance: Distance (along the translation stage) between the scan mirror and the optical axis [mm].
            - angle: Orientation angle of the scan mirror [degrees].
        &#34;&#34;&#34;

        cmd_angle = angle
        total_angle = cmd_angle + self.offset_alpha + 45

        cmd_distance = distance
        total_angle = distance

        # Light path (from collimator to SMA)

        self.ax.annotate(&#34;towards collimator&#34;, (-80, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)
        self.ax.arrow(0, 0, -80, 0, fc=&#39;gray&#39;, ec=&#39;gray&#39;, lw=1,
                      head_width=6, head_length=10,
                      length_includes_head=True, clip_on=False)

        # Optical axis

        self.ax.plot([0.0, 0.0], [-55, 40], &#34;k&#34;, linewidth=1)
        self.ax.annotate(&#34;optical axis&#34;, (0, 50), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)

        # Scan mirror

        self.mirror_thickness = 1
        self.mirror_length = 50

        ts = self.ax.transData
        coords = [distance, 0]  # Rotate around this point
        tr = matplotlib.transforms.Affine2D().rotate_deg_around(coords[0], coords[1], total_angle - 90)
        t = tr + ts
        self.scan_mirror = matplotlib.patches.Rectangle(
            (distance - self.mirror_length / 2, 0), self.mirror_length, self.mirror_thickness, color=&#34;k&#34;, transform=t)
        self.ax.add_patch(self.scan_mirror)

        self.arrow_right = matplotlib.patches.FancyArrow(
            -30, -50, 30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_right)
        self.arrow_left = matplotlib.patches.FancyArrow(
            distance + 30, -50, -30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_left)

        self.distance_annotation = self.ax.annotate(
            &#34;$\Delta x$&#34;, (distance / 2, -65), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)
        self.angle_annotation = self.ax.annotate(
            u&#34;\u03B1&#34;, (distance + 10, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)

        self.ax.plot([distance, distance], [-55, 40], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        # Axes

        self.ax.set_xlim([-110, 200])
        self.ax.set_ylim([-70, 60])

        self.ax.axis(&#34;off&#34;)

        self.draw()

    def update_plot(self, cmd_distance, angle):
        &#34;&#34;&#34;
        Update the orientation of the scan mirror, and the distance (along the
        translation stage) between the scan mirror and the optical axis.

        :param distance: Distance (along the translation stage) between the scan mirror
                         and the optical axis [mm].

        :param angle: Orientation angle of the scan mirror [degrees].
        &#34;&#34;&#34;

        cmd_angle = angle
        total_angle = cmd_angle + self.offset_alpha + 45

        total_distance = cmd_distance + self.offset_delta_x

        self.angle_annotation.remove()
        self.distance_annotation.remove()

        self.scan_mirror.remove()
        self.arrow_right.remove()
        self.arrow_left.remove()

        del self.ax.lines[-1]

        # Scan mirror

        ts = self.ax.transData
        coords = [total_distance, 0]  # Rotate around this point
        tr = matplotlib.transforms.Affine2D().rotate_deg_around(coords[0], coords[1], total_angle - 90)
        t = tr + ts
        self.scan_mirror = matplotlib.patches.Rectangle((total_distance - self.mirror_length / 2, 0),
                                                        self.mirror_length, self.mirror_thickness, color=&#34;k&#34;,
                                                        transform=t)
        self.ax.add_patch(self.scan_mirror)

        self.arrow_right = matplotlib.patches.FancyArrow(-30, -50, 30, 0, length_includes_head=True, head_width=6,
                                                         head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_right)
        # self.arrow_left = matplotlib.patches.FancyArrow(
        #     distance + 30, -50, -30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
        self.arrow_left = matplotlib.patches.FancyArrow(total_distance + 30, -50, -30, 0, length_includes_head=True,
                                                        head_width=6, head_length=10, color=&#34;k&#34;)
        self.ax.add_patch(self.arrow_left)

        distance_text = f&#34;$\Delta x$ = {cmd_distance:.2f} mm + {self.offset_delta_x} mm \n   = {total_distance:.2f} mm&#34;
        self.distance_annotation = self.ax.annotate(distance_text, (cmd_distance / 2, -70), color=&#39;k&#39;, fontsize=10,
                                                    ha=&#39;center&#39;, va=&#39;center&#39;)

        angle_text = u&#34;\u03B1&#34; + f&#34; = {cmd_angle:.2f}{DEGREE_SYMBOL_PLOT} + {self.offset_alpha}{DEGREE_SYMBOL_PLOT} &#34; \
                                 f&#34;+ 45{DEGREE_SYMBOL_PLOT} \n   = {total_angle:.2f}{DEGREE_SYMBOL_PLOT}&#34;
        self.angle_annotation = self.ax.annotate(angle_text, (cmd_distance + 10, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;left&#39;,
                                                 va=&#39;center&#39;)

        self.ax.plot([cmd_distance, cmd_distance], [-55, 40], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

        self.draw()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>matplotlib.backends.backend_qtagg.FigureCanvasQTAgg</li>
<li>matplotlib.backends.backend_agg.FigureCanvasAgg</li>
<li>matplotlib.backends.backend_qt.FigureCanvasQT</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li>matplotlib.backend_bases.FigureCanvasBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.mechanisms.ScanMirrorAssembly.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, angle, distance)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the position and orientation angle of the scan mirror w.r.t. the optical axis.</p>
<h2 id="args">Args</h2>
<ul>
<li>distance: Distance (along the translation stage) between the scan mirror and the optical axis [mm].</li>
<li>angle: Orientation angle of the scan mirror [degrees].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, angle, distance):
    &#34;&#34;&#34; Plot the position and orientation angle of the scan mirror w.r.t. the optical axis.

    Args:
        - distance: Distance (along the translation stage) between the scan mirror and the optical axis [mm].
        - angle: Orientation angle of the scan mirror [degrees].
    &#34;&#34;&#34;

    cmd_angle = angle
    total_angle = cmd_angle + self.offset_alpha + 45

    cmd_distance = distance
    total_angle = distance

    # Light path (from collimator to SMA)

    self.ax.annotate(&#34;towards collimator&#34;, (-80, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)
    self.ax.arrow(0, 0, -80, 0, fc=&#39;gray&#39;, ec=&#39;gray&#39;, lw=1,
                  head_width=6, head_length=10,
                  length_includes_head=True, clip_on=False)

    # Optical axis

    self.ax.plot([0.0, 0.0], [-55, 40], &#34;k&#34;, linewidth=1)
    self.ax.annotate(&#34;optical axis&#34;, (0, 50), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)

    # Scan mirror

    self.mirror_thickness = 1
    self.mirror_length = 50

    ts = self.ax.transData
    coords = [distance, 0]  # Rotate around this point
    tr = matplotlib.transforms.Affine2D().rotate_deg_around(coords[0], coords[1], total_angle - 90)
    t = tr + ts
    self.scan_mirror = matplotlib.patches.Rectangle(
        (distance - self.mirror_length / 2, 0), self.mirror_length, self.mirror_thickness, color=&#34;k&#34;, transform=t)
    self.ax.add_patch(self.scan_mirror)

    self.arrow_right = matplotlib.patches.FancyArrow(
        -30, -50, 30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_right)
    self.arrow_left = matplotlib.patches.FancyArrow(
        distance + 30, -50, -30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_left)

    self.distance_annotation = self.ax.annotate(
        &#34;$\Delta x$&#34;, (distance / 2, -65), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)
    self.angle_annotation = self.ax.annotate(
        u&#34;\u03B1&#34;, (distance + 10, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;center&#39;, va=&#39;center&#39;)

    self.ax.plot([distance, distance], [-55, 40], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

    # Axes

    self.ax.set_xlim([-110, 200])
    self.ax.set_ylim([-70, 60])

    self.ax.axis(&#34;off&#34;)

    self.draw()</code></pre>
</details>
</dd>
<dt id="egse.gui.mechanisms.ScanMirrorAssembly.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, cmd_distance, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the orientation of the scan mirror, and the distance (along the
translation stage) between the scan mirror and the optical axis.</p>
<p>:param distance: Distance (along the translation stage) between the scan mirror
and the optical axis [mm].</p>
<p>:param angle: Orientation angle of the scan mirror [degrees].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, cmd_distance, angle):
    &#34;&#34;&#34;
    Update the orientation of the scan mirror, and the distance (along the
    translation stage) between the scan mirror and the optical axis.

    :param distance: Distance (along the translation stage) between the scan mirror
                     and the optical axis [mm].

    :param angle: Orientation angle of the scan mirror [degrees].
    &#34;&#34;&#34;

    cmd_angle = angle
    total_angle = cmd_angle + self.offset_alpha + 45

    total_distance = cmd_distance + self.offset_delta_x

    self.angle_annotation.remove()
    self.distance_annotation.remove()

    self.scan_mirror.remove()
    self.arrow_right.remove()
    self.arrow_left.remove()

    del self.ax.lines[-1]

    # Scan mirror

    ts = self.ax.transData
    coords = [total_distance, 0]  # Rotate around this point
    tr = matplotlib.transforms.Affine2D().rotate_deg_around(coords[0], coords[1], total_angle - 90)
    t = tr + ts
    self.scan_mirror = matplotlib.patches.Rectangle((total_distance - self.mirror_length / 2, 0),
                                                    self.mirror_length, self.mirror_thickness, color=&#34;k&#34;,
                                                    transform=t)
    self.ax.add_patch(self.scan_mirror)

    self.arrow_right = matplotlib.patches.FancyArrow(-30, -50, 30, 0, length_includes_head=True, head_width=6,
                                                     head_length=10, color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_right)
    # self.arrow_left = matplotlib.patches.FancyArrow(
    #     distance + 30, -50, -30, 0, length_includes_head=True, head_width=6, head_length=10, color=&#34;k&#34;)
    self.arrow_left = matplotlib.patches.FancyArrow(total_distance + 30, -50, -30, 0, length_includes_head=True,
                                                    head_width=6, head_length=10, color=&#34;k&#34;)
    self.ax.add_patch(self.arrow_left)

    distance_text = f&#34;$\Delta x$ = {cmd_distance:.2f} mm + {self.offset_delta_x} mm \n   = {total_distance:.2f} mm&#34;
    self.distance_annotation = self.ax.annotate(distance_text, (cmd_distance / 2, -70), color=&#39;k&#39;, fontsize=10,
                                                ha=&#39;center&#39;, va=&#39;center&#39;)

    angle_text = u&#34;\u03B1&#34; + f&#34; = {cmd_angle:.2f}{DEGREE_SYMBOL_PLOT} + {self.offset_alpha}{DEGREE_SYMBOL_PLOT} &#34; \
                             f&#34;+ 45{DEGREE_SYMBOL_PLOT} \n   = {total_angle:.2f}{DEGREE_SYMBOL_PLOT}&#34;
    self.angle_annotation = self.ax.annotate(angle_text, (cmd_distance + 10, 20), color=&#39;k&#39;, fontsize=10, ha=&#39;left&#39;,
                                             va=&#39;center&#39;)

    self.ax.plot([cmd_distance, cmd_distance], [-55, 40], &#34;--&#34;, color=&#34;gray&#34;, linewidth=1)

    self.draw()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.gui.mechanisms.ScanMirrorAssemblyWidget"><code class="flex name class">
<span>class <span class="ident">ScanMirrorAssemblyWidget</span></span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Initialisation of a plot showing the distance of the scan mirror (along the translation stage)
from the optical axis and the orientation of the scan mirror (small rotation stage).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScanMirrorAssemblyWidget(QGroupBox):

    def __init__(self):
        &#34;&#34;&#34;
        Initialisation of a plot showing the distance of the scan mirror (along the translation stage)
        from the optical axis and the orientation of the scan mirror (small rotation stage).
        &#34;&#34;&#34;

        super(ScanMirrorAssemblyWidget, self).__init__(&#34;Scan Mirror Assembly&#34;)

        self.setStatusTip(
            &#34;Current configuration of the scan mirror assembly (i.e. small rotation stage and translation stage)&#34;)
        self.setFont(FONT)

        setup = get_setup()
        self.offset_delta_x = setup.gse.stages.calibration.offset_delta_x
        self.offset_alpha = setup.gse.stages.calibration.offset_alpha

        self.explanation_window = ExplanationWindow(&#34;Configuration of the Scan Mirror Assembly&#34;,
                                                    str(find_file(&#34;sma.png&#34;, in_dir=&#34;images&#34;)))
        self.cmd_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.cmd_angle_text_explanation)
        self.explanation_window.layout.addWidget(QLabel(f&#34;offset_alpha: {self.offset_alpha}{DEGREE_SYMBOL_LABEL} &#34;
                                                        f&#34;(see setup)&#34;))
        self.total_angle_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.total_angle_text_explanation)
        self.cmd_distance_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.cmd_distance_text_explanation)
        self.explanation_window.layout.addWidget(QLabel(f&#34;offset_delta_x: {self.offset_delta_x} mm (see setup)&#34;))
        self.total_distance_text_explanation = QLabel()
        self.explanation_window.layout.addWidget(self.total_distance_text_explanation)

        layout = QVBoxLayout()

        self.sma = ScanMirrorAssembly()
        layout.addWidget(self.sma)

        self.cmd_angle_text = QLabel()
        self.cmd_distance_text = QLabel()

        labels_layout = QVBoxLayout()
        labels_layout.addWidget(self.cmd_angle_text)
        labels_layout.addWidget(self.cmd_distance_text)

        info_layout = QHBoxLayout()
        info_layout.addLayout(labels_layout)

        help_button = HelpButton()
        help_button.clicked.connect(self.explanation_window.show)

        info_layout.addWidget(help_button)
        layout.addLayout(info_layout)

        self.setLayout(layout)

    def update_plot(self, distance, angle):
        &#34;&#34;&#34;
        Update the orientation of the scan mirror, and the distance (along the
        translation stage) between the scan mirror and the optical axis.

        :param distance: Distance (along the translation stage) between the scan mirror
                         and the optical axis [mm].

        :param angle: Orientation angle of the scan mirror [degrees].
        &#34;&#34;&#34;

        self.sma.update_plot(-distance, angle)

        self.cmd_angle_text.setText(f&#34;Commanded position for the small rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.cmd_distance_text.setText(f&#34;Commanded position for the translation stage: {distance:.2f}{DEGREE_SYMBOL_LABEL}&#34;)

        self.cmd_angle_text_explanation.setText(f&#34;Commanded position for the small rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.total_angle_text_explanation.setText(f&#34;Angle \u03B1 shown: {(angle + self.offset_alpha + 45):.2f}{DEGREE_SYMBOL_LABEL}&#34;)
        self.cmd_distance_text_explanation.setText(f&#34;Commanded position for the translation stage: {distance:.2f} mm&#34;)
        self.total_distance_text_explanation.setText(f&#34;Distance \u0394x shown: {(-distance + self.offset_delta_x):.2f} mm&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gui.mechanisms.ScanMirrorAssemblyWidget.update_plot"><code class="name flex">
<span>def <span class="ident">update_plot</span></span>(<span>self, distance, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the orientation of the scan mirror, and the distance (along the
translation stage) between the scan mirror and the optical axis.</p>
<p>:param distance: Distance (along the translation stage) between the scan mirror
and the optical axis [mm].</p>
<p>:param angle: Orientation angle of the scan mirror [degrees].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plot(self, distance, angle):
    &#34;&#34;&#34;
    Update the orientation of the scan mirror, and the distance (along the
    translation stage) between the scan mirror and the optical axis.

    :param distance: Distance (along the translation stage) between the scan mirror
                     and the optical axis [mm].

    :param angle: Orientation angle of the scan mirror [degrees].
    &#34;&#34;&#34;

    self.sma.update_plot(-distance, angle)

    self.cmd_angle_text.setText(f&#34;Commanded position for the small rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
    self.cmd_distance_text.setText(f&#34;Commanded position for the translation stage: {distance:.2f}{DEGREE_SYMBOL_LABEL}&#34;)

    self.cmd_angle_text_explanation.setText(f&#34;Commanded position for the small rotation stage: {angle:.2f}{DEGREE_SYMBOL_LABEL}&#34;)
    self.total_angle_text_explanation.setText(f&#34;Angle \u03B1 shown: {(angle + self.offset_alpha + 45):.2f}{DEGREE_SYMBOL_LABEL}&#34;)
    self.cmd_distance_text_explanation.setText(f&#34;Commanded position for the translation stage: {distance:.2f} mm&#34;)
    self.total_distance_text_explanation.setText(f&#34;Distance \u0394x shown: {(-distance + self.offset_delta_x):.2f} mm&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.gui" href="index.html">egse.gui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.gui.mechanisms.BigRotationStage" href="#egse.gui.mechanisms.BigRotationStage">BigRotationStage</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.mechanisms.BigRotationStage.plot" href="#egse.gui.mechanisms.BigRotationStage.plot">plot</a></code></li>
<li><code><a title="egse.gui.mechanisms.BigRotationStage.update_plot" href="#egse.gui.mechanisms.BigRotationStage.update_plot">update_plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.BigRotationStageWidget" href="#egse.gui.mechanisms.BigRotationStageWidget">BigRotationStageWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.mechanisms.BigRotationStageWidget.update" href="#egse.gui.mechanisms.BigRotationStageWidget.update">update</a></code></li>
<li><code><a title="egse.gui.mechanisms.BigRotationStageWidget.update_plot" href="#egse.gui.mechanisms.BigRotationStageWidget.update_plot">update_plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.ExplanationWindow" href="#egse.gui.mechanisms.ExplanationWindow">ExplanationWindow</a></code></h4>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.FocusPosition" href="#egse.gui.mechanisms.FocusPosition">FocusPosition</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.mechanisms.FocusPosition.plot" href="#egse.gui.mechanisms.FocusPosition.plot">plot</a></code></li>
<li><code><a title="egse.gui.mechanisms.FocusPosition.update_plot" href="#egse.gui.mechanisms.FocusPosition.update_plot">update_plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.FocusPositionWidget" href="#egse.gui.mechanisms.FocusPositionWidget">FocusPositionWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.mechanisms.FocusPositionWidget.update_plot" href="#egse.gui.mechanisms.FocusPositionWidget.update_plot">update_plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.HelpButton" href="#egse.gui.mechanisms.HelpButton">HelpButton</a></code></h4>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.ScanMirrorAssembly" href="#egse.gui.mechanisms.ScanMirrorAssembly">ScanMirrorAssembly</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.mechanisms.ScanMirrorAssembly.plot" href="#egse.gui.mechanisms.ScanMirrorAssembly.plot">plot</a></code></li>
<li><code><a title="egse.gui.mechanisms.ScanMirrorAssembly.update_plot" href="#egse.gui.mechanisms.ScanMirrorAssembly.update_plot">update_plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.gui.mechanisms.ScanMirrorAssemblyWidget" href="#egse.gui.mechanisms.ScanMirrorAssemblyWidget">ScanMirrorAssemblyWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.gui.mechanisms.ScanMirrorAssemblyWidget.update_plot" href="#egse.gui.mechanisms.ScanMirrorAssemblyWidget.update_plot">update_plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
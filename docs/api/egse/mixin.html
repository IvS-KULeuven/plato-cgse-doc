<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.mixin API documentation</title>
<meta name="description" content="This module defines Mixin classes that can be used for adding methods and properties to
classes without strict inheritance …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.mixin</code></h1>
</header>
<section id="section-intro">
<p>This module defines Mixin classes that can be used for adding methods and properties to
classes without strict inheritance.</p>
<p>Be careful, some of the Mixin classes require certain attributes to be defined in the
outer sub-class. Read the docstrings carefully to understand what is needed.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines Mixin classes that can be used for adding methods and properties to
classes without strict inheritance.

Be careful, some of the Mixin classes require certain attributes to be defined in the
outer sub-class. Read the docstrings carefully to understand what is needed.
&#34;&#34;&#34;
import enum
import functools
import inspect
import logging
import string
from typing import Callable
from typing import Dict

from egse.command import ClientServerCommand
from egse.command import CommandError
from egse.command import CommandExecution
from egse.protocol import DynamicCommandProtocol
from egse.protocol import get_function

LOGGER = logging.getLogger(__name__)

__all__ = [
    &#34;add_lf&#34;,
    &#34;add_cr_lf&#34;,
    &#34;dynamic_command&#34;,
    &#34;DynamicCommandMixin&#34;,
]

# ----- Mixin for dynamic commanding ---------------------------------------------------------------

COMMAND_TYPES = {
    &#34;read&#34;: &#34;__read_command&#34;,
    &#34;write&#34;: &#34;__write_command&#34;,
    &#34;query&#34;: &#34;__query_command&#34;,
    &#34;transaction&#34;: &#34;__transaction_command&#34;,
}
STX = &#34;\x02&#34;  # start-of-text
ETX = &#34;\x03&#34;  # end-of-text
EOT = &#34;\x04&#34;  # end-of-transmission
LINE_FEED = &#34;\x0A&#34;
CARRIAGE_RETURN = &#34;\x0D&#34;


def add_etx(cmd_string: str):
    &#34;&#34;&#34;
    Add an end-of-text ETX (ASCII code 0x03) to the command string.

    Args:
        cmd_string: the unprocessed command string

    Returns:
        The command string with the ETX character appended.
    &#34;&#34;&#34;
    return cmd_string if cmd_string.endswith(ETX) else cmd_string + ETX


def add_eot(cmd_string: str):
    &#34;&#34;&#34;
    Add an end-of-transmission EOT (ASCII code 0x04) to the command string.

    Args:
        cmd_string: the unprocessed command string

    Returns:
        The command string with the EOT character appended.
    &#34;&#34;&#34;
    return cmd_string if cmd_string.endswith(EOT) else cmd_string + EOT


def add_lf(cmd_string: str):
    &#34;&#34;&#34; Add a line feed to the given command string, if not added yet.

    Args:
        - cmd_string: Command string.

    Returns: Given command string with a line feed appended (if not present yet).
    &#34;&#34;&#34;

    if not cmd_string.endswith(LINE_FEED):

        cmd_string += LINE_FEED

    return cmd_string


def add_cr_lf(cmd_string: str):
    &#34;&#34;&#34; Add a carriage return and line feed to the given command string, if not added yet.

    Args:
        - cmd_string: Command string.

    Returns: Given command string with a carriage return and line feed appended (if not present yet).
    &#34;&#34;&#34;

    if not cmd_string.endswith(CARRIAGE_RETURN + LINE_FEED):

        cmd_string += CARRIAGE_RETURN + LINE_FEED

    return cmd_string


def expand_kwargs(kwargs: Dict):
    &#34;&#34;&#34;Expand keyword arguments and their values as &#39;key=value&#39; separated by spaces.&#34;&#34;&#34;
    return &#34; &#34;.join(f&#34;{k}={v}&#34; for k, v in kwargs.items())


def dynamic_command(
        *,
        cmd_type: str,  # required keyword-only argument
        cmd_string: str = None,
        process_response: Callable = None,
        process_cmd_string: Callable = None,
        process_kwargs: Callable = None,
        use_format: bool = False,
):
    &#34;&#34;&#34;Convert an interface method into a dynamic command.

    The arguments define the type of command and how the response shall be processed.

    The command types &#39;write&#39;, &#39;query&#39;, and &#39;transaction&#39; must be accompanied by a `cmd_string`
    argument that defines the formatting of the eventual command string that will be passed to
    the transport functions. The `cmd_string` is a template string that contains `$`-based
    substitutions for the function arguments. When you specify the `use_format=True` keyword,
    the `cmd_string` will be formatted using the format() function instead of the template
    substitution. The format option is less secure, but provides the functionality to format
    the arguments.

    A template string looks like:

        cmd_string=&#34;CREATE:SENS:TEMP ${name} ${type} default=${default}&#34;

    The same `cmd_string` as a format option:

        cmd_string=&#34;CREATE:SENS:TEMP {name} {type} default={default:0.4f}&#34;
        use_format=True

    The process_response and process_cmd_string keywords allow you to specify a pure function to
    process the response before it is returned, and to process the cmd_string before it is sent
    to the transport function.

    This decorator can add the following static attributes to the method:

    * __dynamic_interface
    * __read_command, __write_command, __query_command, __transaction_command
    * __cmd_string
    * __process_response
    * __process_cmd_string
    * __use_format

    Args:
        cmd_type (str): one of &#39;read&#39;, &#39;write&#39;, &#39;query&#39;, or &#39;transaction&#39; [required keyword]
        cmd_string (str): format string for the generation of the instrument command
        process_response (Callable): function to process the response
        process_cmd_string (Callable): function to process the command string after substitution
        process_kwargs (Callable): function to expand the kwargs after substitution
        use_format (bool): use string formatting instead of string templates
    &#34;&#34;&#34;

    # Perform some checks on required arguments

    if cmd_type not in COMMAND_TYPES:
        raise ValueError(f&#34;Unknown type passed into dynamic command decorator: {type=}&#34;)

    if cmd_type in (&#39;write&#39;, &#39;query&#39;, &#39;transaction&#39;) and cmd_string is None:
        raise ValueError(f&#34;No cmd_string was provided for {cmd_type=}.&#34;)

    def func_wrapper(func: Callable):
        &#34;&#34;&#34;Adds the different static attributes.&#34;&#34;&#34;

        setattr(func, &#34;__dynamic_interface&#34;, True)

        setattr(func, COMMAND_TYPES[cmd_type], True)

        if cmd_string is not None:
            setattr(func, &#34;__cmd_string&#34;, cmd_string)

        if process_response is not None:
            setattr(func, &#34;__process_response&#34;, process_response)

        if process_cmd_string is not None:
            setattr(func, &#34;__process_cmd_string&#34;, process_cmd_string)

        if process_kwargs is not None:
            setattr(func, &#34;__process_kwargs&#34;, process_kwargs)

        if use_format:
            setattr(func, &#34;__use_format&#34;, True)

        return func

    return func_wrapper


class DynamicCommandMixin:
    &#34;&#34;&#34;
    This Mixin class defines the functionality to dynamically call specific instrument commands
    from methods that are defined in the Interface classes for device Controllers.

    The mixin uses the `self.transport` instance variables that shall be defined by the
    Controller sub-class. The `self.transport` shall be a DeviceTransport object providing the
    methods to read, write, and query an instrument.

    !!! note
        This mixin overrides the `__getattribute__` method!

    !!! note
        This mixin class shall only be inherited from a Controller class that defines the
        `self.transport` attribute.
    &#34;&#34;&#34;

    def __init__(self):
        if not hasattr(self, &#34;transport&#34;):
            raise AttributeError(&#34;Transport was not defined in sub-class of DynamicInterfaceMixin&#34;)

    @staticmethod
    def create_command_string(func: Callable, template_str: str, *args, **kwargs):
        &#34;&#34;&#34;
        Creates a command string that is understood by the instrument. This can be an SCPI
        command or a specific proprietary command string. The `cmd_str` can contain placeholders
        similar to what is used in string formatting.

        As an example, we have a function with two positional arguments &#39;a&#39;, and &#39;b&#39; and one keyword
        argument flag:

            def func(a, b, flag=True):
                pass

        We have the following template string: `CREATE:FUN:${a} ${b} [${flag}]`.

        When we call the function as follows: `func(&#34;TEMP&#34;, 23)`, we would then expect
        the returned string to be &#34;CREATE:FUN:TEMP 23 [True]&#34;

            DynamicCommandMixin.create_command_string(func, template, &#34;TEMP&#34;, 23)

        Args:
            func (Callable): a function or method that provides the signature
            template_str (str): a template for the command
            args (tuple): positional arguments that will be used in the command string
            kwargs (dict): keywords arguments that will be used in the command string
        &#34;&#34;&#34;
        try:
            process_kwargs = getattr(func, &#34;__process_kwargs&#34;)
        except AttributeError:
            process_kwargs = expand_kwargs

        template = string.Template(template_str)

        sig = inspect.signature(func)
        try:
            bound = sig.bind(*args, **kwargs)
        except TypeError as exc:
            raise CommandError(
                f&#34;Arguments {args}, {kwargs} do not match function signature for &#34;
                f&#34;{func.__name__}{sig}&#34;) from exc

        variables = {}
        for idx, par in enumerate(sig.parameters.values()):
            # if the argument is of signature &#39;**kwargs&#39; then expand the kwargs
            if par.kind == inspect.Parameter.VAR_KEYWORD:
                variables[par.name] = process_kwargs(bound.arguments[par.name])
                continue

            # otherwise, use the argument value or the default
            try:
                variables[par.name] = bound.arguments[par.name]
            except KeyError:
                variables[par.name] = par.default

        if hasattr(func, &#34;__use_format&#34;):
            cmd_string = template_str.format(**variables)
        else:
            variables = {
                k: v.value if isinstance(v, enum.Enum) else v
                for k, v in variables.items()
            }
            cmd_string = template.safe_substitute(variables)

        try:
            process_cmd_string = getattr(func, &#34;__process_cmd_string&#34;)
            cmd_string = process_cmd_string(cmd_string)
        except AttributeError:
            pass

        return cmd_string

    def handle_dynamic_command(self, attr):
        &#34;&#34;&#34;
        Creates a command wrapper calling the appropriate transport methods that are associated
        with the interface definition as passed into this method with the attr argument.

        Args:
            attr: The interface method that is decorated as a dynamic_command.

        Returns:
            Command wrapper with the read or write command, depending on the decorators used
            for that method in the corresponding Interface class.

        Raises:
            AttributeError: If the command is not listed in the YAML file and/or
            has not been listed.
        &#34;&#34;&#34;

        def command_wrapper(*args, **kwargs):
            &#34;&#34;&#34;Generates command strings and executes the transport functions.&#34;&#34;&#34;
            try:
                cmd_str = getattr(attr, &#34;__cmd_string&#34;)
                cmd_str = self.create_command_string(attr, cmd_str, *args, **kwargs)
            except AttributeError:
                cmd_str = None

            response = None

            if hasattr(attr, &#34;__write_command&#34;):
                self.transport.write(cmd_str)
            elif hasattr(attr, &#34;__read_command&#34;):
                response = self.transport.read()
            elif hasattr(attr, &#34;__query_command&#34;):
                response = self.transport.query(cmd_str)
            elif hasattr(attr, &#34;__transaction_command&#34;):
                response = self.transport.trans(cmd_str)
            else:
                raise CommandError(f&#34;Interface method &#39;{attr.__name__}&#39; shall be decorated with &#34;
                                   f&#34;a command type decorator.&#34;)

            try:
                process_response = getattr(attr, &#34;__process_response&#34;)
                response = process_response(response)
            except AttributeError:
                pass

            return response

        # Add a hook to identify the command_wrapper function as a method, instead of a function.

        setattr(command_wrapper, &#34;__method_wrapper&#34;, True)

        # Add the docstring of the interface method

        command_wrapper.__doc__ = attr.__doc__

        return command_wrapper

    def __getattribute__(self, item):
        &#34;&#34;&#34;
        The function __getattribute__() is called unconditionally when calling a method or accessing
        an instance variable. This override of `__getattribute__` additionally checks if the
        attribute is a method which has the `__dynamic_interface` defined and then calls a specific
        function to handle the command dynamically.

        Check if item exists:
            - if `item` exists and has the __dynamic_interface attribute then let the function
              handle_dynamic_command() handle this, i.e. call the instrument command.
            - else: the method has been defined in the Controller class, and we should just call
              that method (because it is overridden).
        &#34;&#34;&#34;

        # If item is not known, an AttributeError will be raised and __getattr__() will be called.

        attr = object.__getattribute__(self, item)

        if hasattr(attr, &#34;__dynamic_interface&#34;):

            # We come here when the method is defined in the Interface class (where it is
            # decorated with the @dynamic_interface), but not in the sub-class. So, the method
            # is not overridden. We let the handle_dynamic_command() method handle this.

            attr = self.handle_dynamic_command(attr)

        return attr


class DynamicClientCommandMixin:
    &#34;&#34;&#34;
    This mixin class contains functionality to forward a device command from a client Proxy class
    to its control server.

    !!! note
        This mixin overrides the `__getattribute__` method!

    &#34;&#34;&#34;
    def __getattribute__(self, item):
        # If item is not known, an AttributeError will be raised and __getattr__() will be called.

        attr = object.__getattribute__(self, item)

        if hasattr(attr, &#34;__dynamic_interface&#34;):

            # We come here when the method is defined in the Interface class (where it is
            # decorated with the @dynamic_interface), but not in the sub-class. So, the method
            # is not overridden. We let the handle_dynamic_command() method handle this.

            attr = self.handle_dynamic_command(attr)

        return attr

    def handle_dynamic_command(self, attr):

        @functools.wraps(attr)
        def command_wrapper(*args, **kwargs):

            attr_name = getattr(attr, &#34;__name__&#34;)

            # This will ensure that the function is called with the proper arguments

            try:
                inspect.signature(attr).bind(*args, **kwargs)
            except TypeError as exc:
                LOGGER.error(f&#34;Arguments do not match the signature of the function &#39;{attr_name}&#39;: {exc}&#34;)
                return None

            # Create a command execution to pass the commanded function and the given arguments
            # to the control server for execution.

            device_method = get_function(self.__class__, attr_name)
            cmd = ClientServerCommand(name=attr_name,
                                      cmd=getattr(attr, &#34;__cmd_string&#34;, &#34;&#34;),
                                      response=DynamicCommandProtocol.handle_device_method,
                                      device_method=device_method)
            ce = CommandExecution(cmd, *args, **kwargs)

            # Send the command to the control server for execution

            rc = self.send(ce)
            return rc

        # rewrite the proper signature for the called function

        command_wrapper.__signature__ = inspect.signature(attr)

        return command_wrapper</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.mixin.add_cr_lf"><code class="name flex">
<span>def <span class="ident">add_cr_lf</span></span>(<span>cmd_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a carriage return and line feed to the given command string, if not added yet.</p>
<h2 id="args">Args</h2>
<ul>
<li>cmd_string: Command string.
Returns: Given command string with a carriage return and line feed appended (if not present yet).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cr_lf(cmd_string: str):
    &#34;&#34;&#34; Add a carriage return and line feed to the given command string, if not added yet.

    Args:
        - cmd_string: Command string.

    Returns: Given command string with a carriage return and line feed appended (if not present yet).
    &#34;&#34;&#34;

    if not cmd_string.endswith(CARRIAGE_RETURN + LINE_FEED):

        cmd_string += CARRIAGE_RETURN + LINE_FEED

    return cmd_string</code></pre>
</details>
</dd>
<dt id="egse.mixin.add_lf"><code class="name flex">
<span>def <span class="ident">add_lf</span></span>(<span>cmd_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a line feed to the given command string, if not added yet.</p>
<h2 id="args">Args</h2>
<ul>
<li>cmd_string: Command string.
Returns: Given command string with a line feed appended (if not present yet).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_lf(cmd_string: str):
    &#34;&#34;&#34; Add a line feed to the given command string, if not added yet.

    Args:
        - cmd_string: Command string.

    Returns: Given command string with a line feed appended (if not present yet).
    &#34;&#34;&#34;

    if not cmd_string.endswith(LINE_FEED):

        cmd_string += LINE_FEED

    return cmd_string</code></pre>
</details>
</dd>
<dt id="egse.mixin.dynamic_command"><code class="name flex">
<span>def <span class="ident">dynamic_command</span></span>(<span>*, cmd_type: str, cmd_string: str = None, process_response: Callable = None, process_cmd_string: Callable = None, process_kwargs: Callable = None, use_format: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an interface method into a dynamic command.</p>
<p>The arguments define the type of command and how the response shall be processed.</p>
<p>The command types 'write', 'query', and 'transaction' must be accompanied by a <code>cmd_string</code>
argument that defines the formatting of the eventual command string that will be passed to
the transport functions. The <code>cmd_string</code> is a template string that contains <code>$</code>-based
substitutions for the function arguments. When you specify the <code>use_format=True</code> keyword,
the <code>cmd_string</code> will be formatted using the format() function instead of the template
substitution. The format option is less secure, but provides the functionality to format
the arguments.</p>
<p>A template string looks like:</p>
<pre><code>cmd_string="CREATE:SENS:TEMP ${name} ${type} default=${default}"
</code></pre>
<p>The same <code>cmd_string</code> as a format option:</p>
<pre><code>cmd_string="CREATE:SENS:TEMP {name} {type} default={default:0.4f}"
use_format=True
</code></pre>
<p>The process_response and process_cmd_string keywords allow you to specify a pure function to
process the response before it is returned, and to process the cmd_string before it is sent
to the transport function.</p>
<p>This decorator can add the following static attributes to the method:</p>
<ul>
<li>__dynamic_interface</li>
<li>__read_command, __write_command, __query_command, __transaction_command</li>
<li>__cmd_string</li>
<li>__process_response</li>
<li>__process_cmd_string</li>
<li>__use_format</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd_type</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'read', 'write', 'query', or 'transaction' [required keyword]</dd>
<dt><strong><code>cmd_string</code></strong> :&ensp;<code>str</code></dt>
<dd>format string for the generation of the instrument command</dd>
<dt><strong><code>process_response</code></strong> :&ensp;<code>Callable</code></dt>
<dd>function to process the response</dd>
<dt><strong><code>process_cmd_string</code></strong> :&ensp;<code>Callable</code></dt>
<dd>function to process the command string after substitution</dd>
<dt><strong><code>process_kwargs</code></strong> :&ensp;<code>Callable</code></dt>
<dd>function to expand the kwargs after substitution</dd>
<dt><strong><code>use_format</code></strong> :&ensp;<code>bool</code></dt>
<dd>use string formatting instead of string templates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_command(
        *,
        cmd_type: str,  # required keyword-only argument
        cmd_string: str = None,
        process_response: Callable = None,
        process_cmd_string: Callable = None,
        process_kwargs: Callable = None,
        use_format: bool = False,
):
    &#34;&#34;&#34;Convert an interface method into a dynamic command.

    The arguments define the type of command and how the response shall be processed.

    The command types &#39;write&#39;, &#39;query&#39;, and &#39;transaction&#39; must be accompanied by a `cmd_string`
    argument that defines the formatting of the eventual command string that will be passed to
    the transport functions. The `cmd_string` is a template string that contains `$`-based
    substitutions for the function arguments. When you specify the `use_format=True` keyword,
    the `cmd_string` will be formatted using the format() function instead of the template
    substitution. The format option is less secure, but provides the functionality to format
    the arguments.

    A template string looks like:

        cmd_string=&#34;CREATE:SENS:TEMP ${name} ${type} default=${default}&#34;

    The same `cmd_string` as a format option:

        cmd_string=&#34;CREATE:SENS:TEMP {name} {type} default={default:0.4f}&#34;
        use_format=True

    The process_response and process_cmd_string keywords allow you to specify a pure function to
    process the response before it is returned, and to process the cmd_string before it is sent
    to the transport function.

    This decorator can add the following static attributes to the method:

    * __dynamic_interface
    * __read_command, __write_command, __query_command, __transaction_command
    * __cmd_string
    * __process_response
    * __process_cmd_string
    * __use_format

    Args:
        cmd_type (str): one of &#39;read&#39;, &#39;write&#39;, &#39;query&#39;, or &#39;transaction&#39; [required keyword]
        cmd_string (str): format string for the generation of the instrument command
        process_response (Callable): function to process the response
        process_cmd_string (Callable): function to process the command string after substitution
        process_kwargs (Callable): function to expand the kwargs after substitution
        use_format (bool): use string formatting instead of string templates
    &#34;&#34;&#34;

    # Perform some checks on required arguments

    if cmd_type not in COMMAND_TYPES:
        raise ValueError(f&#34;Unknown type passed into dynamic command decorator: {type=}&#34;)

    if cmd_type in (&#39;write&#39;, &#39;query&#39;, &#39;transaction&#39;) and cmd_string is None:
        raise ValueError(f&#34;No cmd_string was provided for {cmd_type=}.&#34;)

    def func_wrapper(func: Callable):
        &#34;&#34;&#34;Adds the different static attributes.&#34;&#34;&#34;

        setattr(func, &#34;__dynamic_interface&#34;, True)

        setattr(func, COMMAND_TYPES[cmd_type], True)

        if cmd_string is not None:
            setattr(func, &#34;__cmd_string&#34;, cmd_string)

        if process_response is not None:
            setattr(func, &#34;__process_response&#34;, process_response)

        if process_cmd_string is not None:
            setattr(func, &#34;__process_cmd_string&#34;, process_cmd_string)

        if process_kwargs is not None:
            setattr(func, &#34;__process_kwargs&#34;, process_kwargs)

        if use_format:
            setattr(func, &#34;__use_format&#34;, True)

        return func

    return func_wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.mixin.DynamicCommandMixin"><code class="flex name class">
<span>class <span class="ident">DynamicCommandMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>This Mixin class defines the functionality to dynamically call specific instrument commands
from methods that are defined in the Interface classes for device Controllers.</p>
<p>The mixin uses the <code>self.transport</code> instance variables that shall be defined by the
Controller sub-class. The <code>self.transport</code> shall be a DeviceTransport object providing the
methods to read, write, and query an instrument.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This mixin overrides the <code>__getattribute__</code> method!</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This mixin class shall only be inherited from a Controller class that defines the
<code>self.transport</code> attribute.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicCommandMixin:
    &#34;&#34;&#34;
    This Mixin class defines the functionality to dynamically call specific instrument commands
    from methods that are defined in the Interface classes for device Controllers.

    The mixin uses the `self.transport` instance variables that shall be defined by the
    Controller sub-class. The `self.transport` shall be a DeviceTransport object providing the
    methods to read, write, and query an instrument.

    !!! note
        This mixin overrides the `__getattribute__` method!

    !!! note
        This mixin class shall only be inherited from a Controller class that defines the
        `self.transport` attribute.
    &#34;&#34;&#34;

    def __init__(self):
        if not hasattr(self, &#34;transport&#34;):
            raise AttributeError(&#34;Transport was not defined in sub-class of DynamicInterfaceMixin&#34;)

    @staticmethod
    def create_command_string(func: Callable, template_str: str, *args, **kwargs):
        &#34;&#34;&#34;
        Creates a command string that is understood by the instrument. This can be an SCPI
        command or a specific proprietary command string. The `cmd_str` can contain placeholders
        similar to what is used in string formatting.

        As an example, we have a function with two positional arguments &#39;a&#39;, and &#39;b&#39; and one keyword
        argument flag:

            def func(a, b, flag=True):
                pass

        We have the following template string: `CREATE:FUN:${a} ${b} [${flag}]`.

        When we call the function as follows: `func(&#34;TEMP&#34;, 23)`, we would then expect
        the returned string to be &#34;CREATE:FUN:TEMP 23 [True]&#34;

            DynamicCommandMixin.create_command_string(func, template, &#34;TEMP&#34;, 23)

        Args:
            func (Callable): a function or method that provides the signature
            template_str (str): a template for the command
            args (tuple): positional arguments that will be used in the command string
            kwargs (dict): keywords arguments that will be used in the command string
        &#34;&#34;&#34;
        try:
            process_kwargs = getattr(func, &#34;__process_kwargs&#34;)
        except AttributeError:
            process_kwargs = expand_kwargs

        template = string.Template(template_str)

        sig = inspect.signature(func)
        try:
            bound = sig.bind(*args, **kwargs)
        except TypeError as exc:
            raise CommandError(
                f&#34;Arguments {args}, {kwargs} do not match function signature for &#34;
                f&#34;{func.__name__}{sig}&#34;) from exc

        variables = {}
        for idx, par in enumerate(sig.parameters.values()):
            # if the argument is of signature &#39;**kwargs&#39; then expand the kwargs
            if par.kind == inspect.Parameter.VAR_KEYWORD:
                variables[par.name] = process_kwargs(bound.arguments[par.name])
                continue

            # otherwise, use the argument value or the default
            try:
                variables[par.name] = bound.arguments[par.name]
            except KeyError:
                variables[par.name] = par.default

        if hasattr(func, &#34;__use_format&#34;):
            cmd_string = template_str.format(**variables)
        else:
            variables = {
                k: v.value if isinstance(v, enum.Enum) else v
                for k, v in variables.items()
            }
            cmd_string = template.safe_substitute(variables)

        try:
            process_cmd_string = getattr(func, &#34;__process_cmd_string&#34;)
            cmd_string = process_cmd_string(cmd_string)
        except AttributeError:
            pass

        return cmd_string

    def handle_dynamic_command(self, attr):
        &#34;&#34;&#34;
        Creates a command wrapper calling the appropriate transport methods that are associated
        with the interface definition as passed into this method with the attr argument.

        Args:
            attr: The interface method that is decorated as a dynamic_command.

        Returns:
            Command wrapper with the read or write command, depending on the decorators used
            for that method in the corresponding Interface class.

        Raises:
            AttributeError: If the command is not listed in the YAML file and/or
            has not been listed.
        &#34;&#34;&#34;

        def command_wrapper(*args, **kwargs):
            &#34;&#34;&#34;Generates command strings and executes the transport functions.&#34;&#34;&#34;
            try:
                cmd_str = getattr(attr, &#34;__cmd_string&#34;)
                cmd_str = self.create_command_string(attr, cmd_str, *args, **kwargs)
            except AttributeError:
                cmd_str = None

            response = None

            if hasattr(attr, &#34;__write_command&#34;):
                self.transport.write(cmd_str)
            elif hasattr(attr, &#34;__read_command&#34;):
                response = self.transport.read()
            elif hasattr(attr, &#34;__query_command&#34;):
                response = self.transport.query(cmd_str)
            elif hasattr(attr, &#34;__transaction_command&#34;):
                response = self.transport.trans(cmd_str)
            else:
                raise CommandError(f&#34;Interface method &#39;{attr.__name__}&#39; shall be decorated with &#34;
                                   f&#34;a command type decorator.&#34;)

            try:
                process_response = getattr(attr, &#34;__process_response&#34;)
                response = process_response(response)
            except AttributeError:
                pass

            return response

        # Add a hook to identify the command_wrapper function as a method, instead of a function.

        setattr(command_wrapper, &#34;__method_wrapper&#34;, True)

        # Add the docstring of the interface method

        command_wrapper.__doc__ = attr.__doc__

        return command_wrapper

    def __getattribute__(self, item):
        &#34;&#34;&#34;
        The function __getattribute__() is called unconditionally when calling a method or accessing
        an instance variable. This override of `__getattribute__` additionally checks if the
        attribute is a method which has the `__dynamic_interface` defined and then calls a specific
        function to handle the command dynamically.

        Check if item exists:
            - if `item` exists and has the __dynamic_interface attribute then let the function
              handle_dynamic_command() handle this, i.e. call the instrument command.
            - else: the method has been defined in the Controller class, and we should just call
              that method (because it is overridden).
        &#34;&#34;&#34;

        # If item is not known, an AttributeError will be raised and __getattr__() will be called.

        attr = object.__getattribute__(self, item)

        if hasattr(attr, &#34;__dynamic_interface&#34;):

            # We come here when the method is defined in the Interface class (where it is
            # decorated with the @dynamic_interface), but not in the sub-class. So, the method
            # is not overridden. We let the handle_dynamic_command() method handle this.

            attr = self.handle_dynamic_command(attr)

        return attr</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu.AWGController" href="aeu/aeu.html#egse.aeu.aeu.AWGController">AWGController</a></li>
<li><a title="egse.aeu.aeu.CRIOController" href="aeu/aeu.html#egse.aeu.aeu.CRIOController">CRIOController</a></li>
<li><a title="egse.aeu.aeu.PSUController" href="aeu/aeu.html#egse.aeu.aeu.PSUController">PSUController</a></li>
<li><a title="egse.collimator.fcul.ogse.OGSEController" href="collimator/fcul/ogse.html#egse.collimator.fcul.ogse.OGSEController">OGSEController</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Controller" href="stages/huber/smc9300.html#egse.stages.huber.smc9300.HuberSMC9300Controller">HuberSMC9300Controller</a></li>
<li><a title="egse.tcs.tcs.TCSController" href="tcs/tcs.html#egse.tcs.tcs.TCSController">TCSController</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller" href="tempcontrol/keithley/daq6510.html#egse.tempcontrol.keithley.daq6510.DAQ6510Controller">DAQ6510Controller</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.mixin.DynamicCommandMixin.create_command_string"><code class="name flex">
<span>def <span class="ident">create_command_string</span></span>(<span>func: Callable, template_str: str, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a command string that is understood by the instrument. This can be an SCPI
command or a specific proprietary command string. The <code>cmd_str</code> can contain placeholders
similar to what is used in string formatting.</p>
<p>As an example, we have a function with two positional arguments 'a', and 'b' and one keyword
argument flag:</p>
<pre><code>def func(a, b, flag=True):
    pass
</code></pre>
<p>We have the following template string: <code>CREATE:FUN:${a} ${b} [${flag}]</code>.</p>
<p>When we call the function as follows: <code>func("TEMP", 23)</code>, we would then expect
the returned string to be "CREATE:FUN:TEMP 23 [True]"</p>
<pre><code>DynamicCommandMixin.create_command_string(func, template, "TEMP", 23)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>Callable</code></dt>
<dd>a function or method that provides the signature</dd>
<dt><strong><code>template_str</code></strong> :&ensp;<code>str</code></dt>
<dd>a template for the command</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>tuple</code></dt>
<dd>positional arguments that will be used in the command string</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>keywords arguments that will be used in the command string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_command_string(func: Callable, template_str: str, *args, **kwargs):
    &#34;&#34;&#34;
    Creates a command string that is understood by the instrument. This can be an SCPI
    command or a specific proprietary command string. The `cmd_str` can contain placeholders
    similar to what is used in string formatting.

    As an example, we have a function with two positional arguments &#39;a&#39;, and &#39;b&#39; and one keyword
    argument flag:

        def func(a, b, flag=True):
            pass

    We have the following template string: `CREATE:FUN:${a} ${b} [${flag}]`.

    When we call the function as follows: `func(&#34;TEMP&#34;, 23)`, we would then expect
    the returned string to be &#34;CREATE:FUN:TEMP 23 [True]&#34;

        DynamicCommandMixin.create_command_string(func, template, &#34;TEMP&#34;, 23)

    Args:
        func (Callable): a function or method that provides the signature
        template_str (str): a template for the command
        args (tuple): positional arguments that will be used in the command string
        kwargs (dict): keywords arguments that will be used in the command string
    &#34;&#34;&#34;
    try:
        process_kwargs = getattr(func, &#34;__process_kwargs&#34;)
    except AttributeError:
        process_kwargs = expand_kwargs

    template = string.Template(template_str)

    sig = inspect.signature(func)
    try:
        bound = sig.bind(*args, **kwargs)
    except TypeError as exc:
        raise CommandError(
            f&#34;Arguments {args}, {kwargs} do not match function signature for &#34;
            f&#34;{func.__name__}{sig}&#34;) from exc

    variables = {}
    for idx, par in enumerate(sig.parameters.values()):
        # if the argument is of signature &#39;**kwargs&#39; then expand the kwargs
        if par.kind == inspect.Parameter.VAR_KEYWORD:
            variables[par.name] = process_kwargs(bound.arguments[par.name])
            continue

        # otherwise, use the argument value or the default
        try:
            variables[par.name] = bound.arguments[par.name]
        except KeyError:
            variables[par.name] = par.default

    if hasattr(func, &#34;__use_format&#34;):
        cmd_string = template_str.format(**variables)
    else:
        variables = {
            k: v.value if isinstance(v, enum.Enum) else v
            for k, v in variables.items()
        }
        cmd_string = template.safe_substitute(variables)

    try:
        process_cmd_string = getattr(func, &#34;__process_cmd_string&#34;)
        cmd_string = process_cmd_string(cmd_string)
    except AttributeError:
        pass

    return cmd_string</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.mixin.DynamicCommandMixin.handle_dynamic_command"><code class="name flex">
<span>def <span class="ident">handle_dynamic_command</span></span>(<span>self, attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a command wrapper calling the appropriate transport methods that are associated
with the interface definition as passed into this method with the attr argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attr</code></strong></dt>
<dd>The interface method that is decorated as a dynamic_command.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Command wrapper with the read or write command, depending on the decorators used
for that method in the corresponding Interface class.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If the command is not listed in the YAML file and/or</dd>
</dl>
<p>has not been listed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_dynamic_command(self, attr):
    &#34;&#34;&#34;
    Creates a command wrapper calling the appropriate transport methods that are associated
    with the interface definition as passed into this method with the attr argument.

    Args:
        attr: The interface method that is decorated as a dynamic_command.

    Returns:
        Command wrapper with the read or write command, depending on the decorators used
        for that method in the corresponding Interface class.

    Raises:
        AttributeError: If the command is not listed in the YAML file and/or
        has not been listed.
    &#34;&#34;&#34;

    def command_wrapper(*args, **kwargs):
        &#34;&#34;&#34;Generates command strings and executes the transport functions.&#34;&#34;&#34;
        try:
            cmd_str = getattr(attr, &#34;__cmd_string&#34;)
            cmd_str = self.create_command_string(attr, cmd_str, *args, **kwargs)
        except AttributeError:
            cmd_str = None

        response = None

        if hasattr(attr, &#34;__write_command&#34;):
            self.transport.write(cmd_str)
        elif hasattr(attr, &#34;__read_command&#34;):
            response = self.transport.read()
        elif hasattr(attr, &#34;__query_command&#34;):
            response = self.transport.query(cmd_str)
        elif hasattr(attr, &#34;__transaction_command&#34;):
            response = self.transport.trans(cmd_str)
        else:
            raise CommandError(f&#34;Interface method &#39;{attr.__name__}&#39; shall be decorated with &#34;
                               f&#34;a command type decorator.&#34;)

        try:
            process_response = getattr(attr, &#34;__process_response&#34;)
            response = process_response(response)
        except AttributeError:
            pass

        return response

    # Add a hook to identify the command_wrapper function as a method, instead of a function.

    setattr(command_wrapper, &#34;__method_wrapper&#34;, True)

    # Add the docstring of the interface method

    command_wrapper.__doc__ = attr.__doc__

    return command_wrapper</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.mixin.add_cr_lf" href="#egse.mixin.add_cr_lf">add_cr_lf</a></code></li>
<li><code><a title="egse.mixin.add_lf" href="#egse.mixin.add_lf">add_lf</a></code></li>
<li><code><a title="egse.mixin.dynamic_command" href="#egse.mixin.dynamic_command">dynamic_command</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.mixin.DynamicCommandMixin" href="#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></code></h4>
<ul class="">
<li><code><a title="egse.mixin.DynamicCommandMixin.create_command_string" href="#egse.mixin.DynamicCommandMixin.create_command_string">create_command_string</a></code></li>
<li><code><a title="egse.mixin.DynamicCommandMixin.handle_dynamic_command" href="#egse.mixin.DynamicCommandMixin.handle_dynamic_command">handle_dynamic_command</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.spw API documentation</title>
<meta name="description" content="This module defines classes and functions to work with SpaceWire packets." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.spw</code></h1>
</header>
<section id="section-intro">
<p>This module defines classes and functions to work with SpaceWire packets.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines classes and functions to work with SpaceWire packets.
&#34;&#34;&#34;
import logging
import os
import struct
from enum import IntEnum
from typing import Tuple
from typing import Union

import numpy as np

from egse.bits import clear_bit
from egse.bits import crc_calc
from egse.bits import set_bit
from egse.exceptions import Error
from egse.setup import SetupError
from egse.state import GlobalState

MODULE_LOGGER = logging.getLogger(__name__)

try:
    _ = os.environ[&#34;PLATO_CAMERA_IS_EM&#34;]
    TWOS_COMPLEMENT_OFFSET = 32768 if _.capitalize() in (&#34;1&#34;, &#34;True&#34;, &#34;Yes&#34;) else 0
except KeyError:
    TWOS_COMPLEMENT_OFFSET = 0

# RMAP Error Codes and Constants -------------------------------------------------------------------

RMAP_PROTOCOL_ID = 0x01
RMAP_TARGET_LOGICAL_ADDRESS_DEFAULT = 0xFE
RMAP_TARGET_KEY = 0xD1

# Error and Status Codes

RMAP_SUCCESS = 0
RMAP_GENERAL_ERROR = 1
RMAP_UNUSED_PACKET_TYPE_COMMAND_CODE = 2
RMAP_INVALID_KEY = 3
RMAP_INVALID_DATA_CRC = 4
RMAP_EARLY_EOP = 5
RMAP_TOO_MUCH_DATA = 6
RMAP_EEP = 7
RMAP_RESERVED = 8
RMAP_VERIFY_BUFFER_OVERRUN = 9
RMAP_NOT_IMPLEMENTED_AUTHORISED = 10
RMAP_RMW_DATA_LENGTH_ERROR = 11
RMAP_INVALID_TARGET_LOGICAL_ADDRESS = 12

# Memory Map layout --------------------------------------------------------------------------------

# NOTE: These memory areas are currently equal for N-FEE and F-FEE. Don&#39;t know if this will
#       change in the future.

CRITICAL_AREA_START = 0x0000_0000
CRITICAL_AREA_END = 0x0000_00FC
GENERAL_AREA_START = 0x0000_0100
GENERAL_AREA_END = 0x0000_06FC
HK_AREA_START = 0x0000_0700
HK_AREA_END = 0x0000_07FC
WINDOWING_AREA_START = 0x0080_0000
WINDOWING_AREA_END = 0x00FF_FFFC

class RMAPError(Error):
    &#34;&#34;&#34;An RMAP specific Error.&#34;&#34;&#34;
    pass


class CheckError(RMAPError):
    &#34;&#34;&#34;
    Raised when a check fails and you want to pass a status values along with the message.
    &#34;&#34;&#34;

    def __init__(self, message, status):
        self.message = message
        self.status = status


def update_transaction_identifier(tid: int) -&gt; int:
    &#34;&#34;&#34;
    Updates the transaction identifier and returns the new value.

    FIXME: document more about this identifier, where is it used, when is it checked,
           when does it need to be incremented, who initializes the identifier and
           who updates it, ...

    Args:
        tid (int): The current transaction identifier

    Returns:
        the updated transaction identifier (int).
    &#34;&#34;&#34;
    tid = (tid + 1) &amp; 0xFFFF
    return tid


def create_rmap_read_request_packet(address: int, length: int, tid: int, strict: bool = True) -&gt; bytes:
    &#34;&#34;&#34;
    Creates an RMAP Read Request SpaceWire packet.

    The read request is an RMAP command that read a number of bytes from the FEE register memory.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Address shall be within the 0x0000_0000 and 0x00FF_FFFC. The memory map (register) is divided
    in the following areas:

        0x0000_0000 - 0x0000_00FC   Critical Configuration Area (verified write)
        0x0000_0100 - 0x0000_06FC   General Configuration Area (unverified write)
        0x0000_0700 - 0x0000_07FC   Housekeeping area
        0x0000_0800 - 0x007F_FFFC   Not Supported
        0x0080_0000 - 0x00FF_FFFC   Windowing Area (unverified write)
        0x0010_0000 - 0xFFFF_FFFC   Not Supported

    All read requests to the critical area shall have a fixed data length of 4 bytes.
    All read requests to a general area shall have a maximum data length of 256 bytes.
    All read requests to the housekeeping area shall have a maximum data length of 256 bytes.
    All read requests to the windowing area shall have a maximum data length of 4096 bytes.

    The transaction identifier shall be incremented for each read request. This shall be done by
    the calling function!

    Args:
        address (int): the FEE register memory address
        length (int): the data length
        tid (int): transaction identifier
        strict (bool): perform strict checking of address and length

    Returns:
        a bytes object containing the full RMAP Read Request packet.
    &#34;&#34;&#34;

    check_address_and_data_length(address, length, strict=strict)

    buf = bytearray(16)

    # NOTE: The first bytes would each carry the target SpW address or a destination port,
    #       but this is not used for point-to-point connections, so we&#39;re safe.

    buf[0] = 0x51  # Target N-FEE or F-FEE
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = 0x4C  # Instruction: 0b1001100, RMAP Request, Read, Incrementing address, reply address
    buf[3] = 0xD1  # Destination Key
    buf[4] = 0x50  # Initiator is always the DPU
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = 0x00  # Extended address is not used
    buf[8] = (address &gt;&gt; 24) &amp; 0xFF  # address (MSB)
    buf[9] = (address &gt;&gt; 16) &amp; 0xFF  # address
    buf[10] = (address &gt;&gt; 8) &amp; 0xFF  # address
    buf[11] = address &amp; 0xFF  # address (LSB)
    buf[12] = (length &gt;&gt; 16) &amp; 0xFF  # data length (MSB)
    buf[13] = (length &gt;&gt; 8) &amp; 0xFF  # data length
    buf[14] = length &amp; 0xFF  # data length (LSB)
    buf[15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF
    return bytes(buf)


def create_rmap_read_request_reply_packet(
        instruction_field: int, tid: int, status: int, buffer: bytes, buffer_length: int) -&gt; bytes:
    &#34;&#34;&#34;
    Creates an RMAP Reply to a RMAP Read Request packet.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Args:
        instruction_field (int): the instruction field of the RMAP read request packet
        tid (int): the transaction identifier of the read request packet
        status (int): the status field, 0 on success
        buffer (bytes): the data that was read as indicated by the read request
        buffer_length (int): the data length

    Returns:
        packet: a bytes object containing the full RMAP Reply packet.
    &#34;&#34;&#34;

    buf = bytearray(12 + buffer_length + 1)

    buf[0] = 0x50  # Initiator address N-DPU or F-DPU
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = instruction_field &amp; 0x3F  # Clear the command bit as this is a reply
    buf[3] = status &amp; 0xFF  # Status field: 0 on success
    buf[4] = 0x51  # Target address is always the N-FEE or F-FEE
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = 0x00  # Reserved
    buf[8] = (buffer_length &gt;&gt; 16) &amp; 0xFF  # data length (MSB)
    buf[9] = (buffer_length &gt;&gt; 8) &amp; 0xFF  # data length
    buf[10] = buffer_length &amp; 0xFF  # data length (LSB)
    buf[11] = rmap_crc_check(buf, 0, 11) &amp; 0xFF  # Header CRC

    # Note that we assume here that len(buffer) == buffer_length.

    if len(buffer) != buffer_length:
        MODULE_LOGGER.warning(
            f&#34;While creating an RMAP read reply packet, the length of the buffer ({len(buffer)}) &#34;
            f&#34;not equals the buffer_length ({buffer_length})&#34;
        )

    for idx, value in enumerate(buffer):
        buf[12 + idx] = value

    buf[12 + buffer_length] = rmap_crc_check(buffer, 0, buffer_length) &amp; 0xFF  # data CRC

    return bytes(buf)


def create_rmap_verified_write_packet(address: int, data: bytes, tid: int) -&gt; bytes:
    &#34;&#34;&#34;
    Create an RMAP packet for a verified write request on the FEE. The length of the data is
    by convention always 4 bytes and therefore not passed as an argument.

    Args:
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address [4 bytes]
        tid (int): transaction identifier

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    if len(data) &lt; 4:
        raise ValueError(
            f&#34;The data argument should be at least 4 bytes, but it is only {len(data)} bytes: {data=}.&#34;)

    if address &gt; CRITICAL_AREA_END:
        raise ValueError(&#34;The address range for critical configuration is [0x00 - 0xFC].&#34;)

    tid = update_transaction_identifier(tid)

    # Buffer length is fixed at 24 bytes since the data length is fixed
    # at 4 bytes (32 bit addressing)

    buf = bytearray(21)

    # The values below are taken from the PLATO N-FEE to N-DPU
    # Interface Requirements Document [PLATO-DLR-PL-ICD-0010]

    buf[0] = 0x51  # Logical Address
    buf[1] = 0x01  # Protocol ID
    buf[2] = 0x7C  # Instruction
    buf[3] = 0xD1  # Key
    buf[4] = 0x50  # Initiator Address
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = 0x00  # Extended address
    buf[8] = (address &gt;&gt; 24) &amp; 0xFF  # address (MSB)
    buf[9] = (address &gt;&gt; 16) &amp; 0xFF  # address
    buf[10] = (address &gt;&gt; 8) &amp; 0xFF  # address
    buf[11] = address &amp; 0xFF  # address (LSB)
    buf[12] = 0x00  # data length (MSB)
    buf[13] = 0x00  # data length
    buf[14] = 0x04  # data length (LSB)
    buf[15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC
    buf[16] = data[0]
    buf[17] = data[1]
    buf[18] = data[2]
    buf[19] = data[3]
    buf[20] = rmap_crc_check(buf, 16, 4) &amp; 0xFF  # data CRC

    return bytes(buf)


def create_rmap_unverified_write_packet(address: int, data: bytes, length: int, tid: int) -&gt; bytes:
    &#34;&#34;&#34;
    Create an RMAP packet for a unverified write request on the FEE.

    Args:
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address
        length: the length of the data
        tid (int): transaction identifier

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    # We can only handle data for which the length &gt;= the given length argument.

    if len(data) &lt; length:
        raise ValueError(
            f&#34;The length of the data argument ({len(data)}) is smaller than &#34;
            f&#34;the given length argument ({length}).&#34;
        )

    if len(data) &gt; length:
        MODULE_LOGGER.warning(
            f&#34;The length of the data argument ({len(data)}) is larger than &#34;
            f&#34;the given length argument ({length}). The data will be truncated &#34;
            f&#34;when copied into the packet.&#34;
        )

    if address &lt;= CRITICAL_AREA_END:
        raise ValueError(
            f&#34;The given address (0x{address:08X}) is in the range for critical configuration is &#34;
            f&#34;[0x00 - 0xFC]. Use the verified write function for this.&#34;
        )

    tid = update_transaction_identifier(tid)

    # Buffer length is fixed at 24 bytes since the data length
    # is fixed at 4 bytes (32 bit addressing)

    buf = bytearray(16 + length + 1)
    offset = 0

    buf[offset + 0] = 0x51  # Logical Address
    buf[offset + 1] = 0x01  # Protocol ID
    buf[offset + 2] = 0x6C  # Instruction
    buf[offset + 3] = 0xD1  # Key
    buf[offset + 4] = 0x50  # Initiator Address
    buf[offset + 5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[offset + 6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[offset + 7] = 0x00  # Extended address
    buf[offset + 8] = (address &gt;&gt; 24) &amp; 0xFF  # address (MSB)
    buf[offset + 9] = (address &gt;&gt; 16) &amp; 0xFF  # address
    buf[offset + 10] = (address &gt;&gt; 8) &amp; 0xFF  # address
    buf[offset + 11] = address &amp; 0xFF  # address (LSB)
    buf[offset + 12] = (length &gt;&gt; 16) &amp; 0xFF  # data length (MSB)
    buf[offset + 13] = (length &gt;&gt; 8) &amp; 0xFF  # data length
    buf[offset + 14] = length &amp; 0xFF  # data length (LSB)
    buf[offset + 15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC

    offset += 16

    for idx, value in enumerate(data):
        buf[offset + idx] = value

    buf[offset + length] = rmap_crc_check(buf, offset, length) &amp; 0xFF  # data CRC

    return bytes(buf)


def create_rmap_write_request_reply_packet(instruction_field: int, tid: int, status: int) -&gt; bytes:
    buf = bytearray(8)

    buf[0] = 0x50  # Initiator address N-DPU or F-DPU
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = instruction_field &amp; 0x3F  # Clear the command bit as this is a reply
    buf[3] = status &amp; 0xFF  # Status field: 0 on success
    buf[4] = 0x51  # Target address is always the N-FEE or F-FEE
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = rmap_crc_check(buf, 0, 7) &amp; 0xFF  # Header CRC

    return bytes(buf)


def check_address_and_data_length(address: int, length: int, strict: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Checks the address and length in the range of memory areas used by the FEE.

    The ranges are taken from the PLATO-DLR-PL-ICD-0010 N-FEE to N-DPU IRD.

    Args:
        address (int): the memory address of the FEE Register
        length (int): the number of bytes requested
        strict (bool): strictly apply the rules

    Raises:
        RMAPError: when address + length fall outside any specified area.
    &#34;&#34;&#34;

    if not strict:
        # All these restrictions have been relaxed on the N-FEE.
        # We are returning here immediately instead of removing or commenting out the code.
        # These reason is that we can then bring back restriction easier and gradually.

        MODULE_LOGGER.warning(
            &#34;Address and data length checks have been disabled, because the N-FEE &#34;
            &#34;does not enforce restrictions in the critical memory area.&#34;)
        return

    if length % 4:
        raise RMAPError(
            &#34;The requested data length shall be a multiple of 4 bytes.&#34;, address, length
        )

    if address % 4:
        raise RMAPError(&#34;The address shall be a multiple of 4 bytes.&#34;, address, length)

    # Note that when checking the given data length, at the defined area end,
    # we can still read 4 bytes.

    if CRITICAL_AREA_START &lt;= address &lt;= CRITICAL_AREA_END:
        if length != 4:
            raise RMAPError(
                &#34;Read requests to the critical area have a fixed data length of 4 bytes.&#34;,
                address, length
            )
    elif GENERAL_AREA_START &lt;= address &lt;= GENERAL_AREA_END:
        if length &gt; 256:
            raise RMAPError(
                &#34;Read requests to the general area have a maximum data length of 256 bytes.&#34;,
                address, length
            )
        if address + length &gt; GENERAL_AREA_END + 4:
            raise RMAPError(
                &#34;The requested data length for the general area is too large. &#34;
                &#34;The address + length exceeds the general area boundaries.&#34;,
                address, length
            )

    elif HK_AREA_START &lt;= address &lt;= HK_AREA_END:
        if length &gt; 256:
            raise RMAPError(
                &#34;Read requests to the housekeeping area have a maximum data length of 256 bytes.&#34;,
                address, length
            )
        if address + length &gt; HK_AREA_END + 4:
            raise RMAPError(
                &#34;The requested data length for the housekeeping area is too large. &#34;
                &#34;The address + length exceeds the housekeeping area boundaries.&#34;,
                address, length
            )

    elif WINDOWING_AREA_START &lt;= address &lt;= WINDOWING_AREA_END:
        if length &gt; 4096:
            raise RMAPError(
                &#34;Read requests to the windowing area have a maximum data length of 4096 bytes.&#34;,
                address, length
            )
        if address + length &gt; WINDOWING_AREA_END + 4:
            raise RMAPError(
                &#34;The requested data length for the windowing area is too large. &#34;
                &#34;The address + length exceeds the windowing area boundaries.&#34;, address, length
            )

    else:
        raise RMAPError(&#34;Register address for RMAP read requests is invalid.&#34;, address, length)


class PacketType(IntEnum):
    &#34;&#34;&#34;Enumeration type that defines the SpaceWire packet type.&#34;&#34;&#34;

    DATA_PACKET = 0
    OVERSCAN_DATA = 1
    HOUSEKEEPING_DATA = 2  # N-FEE
    DEB_HOUSEKEEPING_DATA = 2  # F-FEE
    AEB_HOUSEKEEPING_DATA = 3  # F-FEE


class DataPacketType:
    &#34;&#34;&#34;
    Defines the Data Packet Field: Type, which is a bit-field of 16 bits.

    Properties:
      * value: returns the data type as an integer
      * packet_type: the type of data packet, defined in PacketType enum.
      * mode: the FEE mode, defined in n_fee_mode and f_fee_mode enum
      * last_packet: flag which defines the last packet of a type in the current readout cycle
      * ccd_side: 0 for E-side (left), 1 for F-side (right), see egse.fee.fee_side
      * ccd_number: CCD number [0, 3]
      * frame_number: the frame number after sync
    &#34;&#34;&#34;

    def __init__(self, data_type: int = 0):
        self._data_type: int = data_type
        # self.n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

    @property
    def value(self) -&gt; int:
        &#34;&#34;&#34;Returns the data packet type as an int.&#34;&#34;&#34;
        return self._data_type

    @property
    def packet_type(self):
        &#34;&#34;&#34;Returns the packet type: 0 = data packet, 1 = overscan data, 2 = housekeeping packet.&#34;&#34;&#34;
        return self._data_type &amp; 0b0011

    @packet_type.setter
    def packet_type(self, value):
        if not 0 &lt;= value &lt; 3:
            raise ValueError(f&#34;Packet Type can only have the value 0, 1, or 2, {value=} given.&#34;)
        x = self._data_type
        for idx, bit in enumerate([0, 1]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    @property
    def mode(self) -&gt; int:
        return (self._data_type &amp; 0b1111_0000_0000) &gt;&gt; 8

    @mode.setter
    def mode(self, value: int):
        x = self._data_type
        for idx, bit in enumerate([8, 9, 10, 11]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    @property
    def last_packet(self) -&gt; bool:
        return bool(self._data_type &amp; 0b1000_0000)

    @last_packet.setter
    def last_packet(self, flag: bool):
        self._data_type = set_bit(self._data_type, 7) if flag else clear_bit(self._data_type, 7)

    @property
    def ccd_side(self) -&gt; int:
        return (self._data_type &amp; 0b0100_0000) &gt;&gt; 6

    @ccd_side.setter
    def ccd_side(self, value: int):
        self._data_type = set_bit(self._data_type, 6) if value &amp; 0b0001 else clear_bit(self._data_type, 6)

    @property
    def ccd_number(self) -&gt; int:
        return (self._data_type &amp; 0b0011_0000) &gt;&gt; 4

    @ccd_number.setter
    def ccd_number(self, value):
        x = self._data_type
        for idx, bit in enumerate([4, 5]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    @property
    def frame_number(self) -&gt; int:
        return (self._data_type &amp; 0b1100) &gt;&gt; 2

    @frame_number.setter
    def frame_number(self, value):
        x = self._data_type
        for idx, bit in enumerate([2, 3]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    def __str__(self) -&gt; str:
        from egse.fee import n_fee_mode
        n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

        return (
            f&#34;mode:{n_fee_mode(self.mode).name}, last_packet:{self.last_packet}, &#34;
            f&#34;CCD side:{n_fee_side(self.ccd_side).name}, CCD number:{self.ccd_number}, &#34;
            f&#34;Frame number:{self.frame_number}, Packet Type:{PacketType(self.packet_type).name}&#34;
        )


def to_string(data: Union[DataPacketType]) -&gt; str:
    &#34;&#34;&#34;Returns a &#39;user-oriented&#39; string representation of the SpW DataPacketType.

    The purpose of this function is to represent the N-FEE information in a user-oriented way.
    That means for certain values that they will be converted into the form the a user understands
    and that may be different or reverse from the original N-FEE definition. An example is the
    CCD number which is different from the user perspective with respect to the N-FEE.

    If any other object type is passed, the data.__str__() method will be returned without
    processing or conversion.

    Args:
        data: a DataPacketType
    &#34;&#34;&#34;
    from egse.fee import n_fee_mode
    n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

    if isinstance(data, DataPacketType):
        try:
            ccd_bin_to_id = GlobalState.setup.camera.fee.ccd_numbering.CCD_BIN_TO_ID
        except AttributeError:
            raise SetupError(&#34;No entry in the setup for camera.fee.ccd_numbering.CCD_BIN_TO_ID&#34;)
        return (
            f&#34;mode:{n_fee_mode(data.mode).name}, last_packet:{data.last_packet}, &#34;
            f&#34;CCD side:{n_fee_side(data.ccd_side).name}, CCD number:&#34;
            f&#34;{ccd_bin_to_id[data.ccd_number]}, &#34;
            f&#34;Frame number:{data.frame_number}, Packet Type:{PacketType(data.packet_type).name}&#34;
        )
    else:
        return data.__str__()


class DataPacketHeader:
    &#34;&#34;&#34;
    Defines the header of a data packet.

    The full header can be retrieved as a bytes object with the `data_as_bytes()` method.

    Properties:
      * logical_address: fixed value of  0x50
      * protocol_id: fixed value of 0xF0
      * length: length of the data part of the packet, i.e. the packet length - size of the header
      * type: data packet type as defined by DataPacketType
      * frame_counter:
      * sequence_counter: a packet sequence counter per CCD
    &#34;&#34;&#34;
    def __init__(self, header_data: bytes = None):
        self.header_data = bytearray(
            header_data or bytes([0x50, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))

        if len(self.header_data) != 10:
            raise ValueError(f&#34;The length of the header for a data packet shall be 10 bytes, &#34;
                             f&#34;got {len(self.header_data)}.&#34;)

        self.n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

    def data_as_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;Returns the full header as a bytes object.&#34;&#34;&#34;
        return bytes(self.header_data)

    @property
    def logical_address(self) -&gt; int:
        return self.header_data[0]

    @logical_address.setter
    def logical_address(self, value: int):
        self.header_data[0] = value

    @property
    def protocol_id(self) -&gt; int:
        return self.header_data[1]

    @protocol_id.setter
    def protocol_id(self, value: int):
        self.header_data[1] = value

    @property
    def length(self) -&gt; int:
        return int.from_bytes(self.header_data[2:4], byteorder=&#39;big&#39;)

    @length.setter
    def length(self, value: int):
        self.header_data[2:4] = value.to_bytes(2, &#39;big&#39;)

    @property
    def type(self):
        return int.from_bytes(self.header_data[4:6], byteorder=&#39;big&#39;)

    @type.setter
    def type(self, value: Union[int, bytes, DataPacketType]):
        if isinstance(value, bytes):
            self.header_data[4:6] = value
        elif isinstance(value, DataPacketType):
            self.header_data[4:6] = value.value.to_bytes(2, &#39;big&#39;)
        else:
            self.header_data[4:6] = value.to_bytes(2, &#39;big&#39;)

    @property
    def type_as_object(self):
        return DataPacketType(self.type)

    @property
    def packet_type(self):
        return self.type_as_object.packet_type

    @packet_type.setter
    def packet_type(self, value: int):
        type_obj = self.type_as_object
        type_obj.packet_type = value
        self.type = type_obj

    @property
    def last_packet(self):
        return self.type_as_object.last_packet

    @last_packet.setter
    def last_packet(self, flag: bool):
        type_obj = self.type_as_object
        type_obj.last_packet = flag
        self.type = type_obj

    @property
    def frame_counter(self):
        return int.from_bytes(self.header_data[6:8], byteorder=&#39;big&#39;)

    @frame_counter.setter
    def frame_counter(self, value):
        self.header_data[6:8] = value.to_bytes(2, &#39;big&#39;)

    @property
    def sequence_counter(self):
        return int.from_bytes(self.header_data[8:10], byteorder=&#39;big&#39;)

    @sequence_counter.setter
    def sequence_counter(self, value):
        self.header_data[8:10] = value.to_bytes(2, &#39;big&#39;)

    def as_dict(self):
        from egse.fee import n_fee_mode

        data_packet_type = DataPacketType(self.type)
        return dict(
            logical_address=f&#34;0x{self.logical_address:02X}&#34;,
            protocol_id=f&#34;0x{self.protocol_id:02X}&#34;,
            length=self.length,
            type=f&#34;0x{self.type:04X}&#34;,
            frame_counter=self.frame_counter,
            sequence_counter=self.sequence_counter,
            packet_type=data_packet_type.packet_type,
            frame_number=data_packet_type.frame_number,
            ccd_number=data_packet_type.ccd_number,
            ccd_side=self.n_fee_side(data_packet_type.ccd_side).name,
            last_packet=data_packet_type.last_packet,
            mode=n_fee_mode(data_packet_type.mode).name,
        )


class SpaceWirePacket:
    &#34;&#34;&#34;Base class for any packet transmitted over a SpaceWire cable.&#34;&#34;&#34;

    # these settings are used by this class and its sub-classes to configure the print options
    # for the numpy arrays.

    _threshold = 300  # sys.maxsize
    _edgeitems = 10
    _linewidth = 120

    def __init__(self, data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Args:
            data: a bytes object or a numpy array of type np.uint8 (not enforced)
        &#34;&#34;&#34;
        self._bytes = bytes(data)

    def __repr__(self):
        options = np.get_printoptions()
        np.set_printoptions(
            formatter={&#34;int&#34;: lambda x: f&#34;0x{x:02x}&#34;},
            threshold=self._threshold,
            edgeitems=self._edgeitems,
            linewidth=self._linewidth,
        )
        msg = f&#34;{self.__class__.__name__}({self._bytes})&#34;
        np.set_printoptions(**options)
        return msg

    @property
    def packet_as_bytes(self):
        return self._bytes

    @property
    def packet_as_ndarray(self):
        return np.frombuffer(self._bytes, dtype=np.uint8)

    @property
    def logical_address(self):
        # TODO: what about a timecode, that has no logical address?
        return self._bytes[0]

    @property
    def protocol_id(self):
        # TODO: what about a timecode, that has no protocol id?
        return self._bytes[1]

    def header_as_bytes(self) -&gt; bytes:
        # TODO: what about timecode, this has no header, except maybe the first byte: 0x91
        raise NotImplementedError

    @staticmethod
    def create_packet(data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Factory method that returns a SpaceWire packet of the correct type based on the information
        in the header.
        &#34;&#34;&#34;
        if TimecodePacket.is_timecode_packet(data):
            return TimecodePacket(data)
        if HousekeepingPacket.is_housekeeping_packet(data):
            return HousekeepingPacket(data)
        if DataDataPacket.is_data_data_packet(data):
            return DataDataPacket(data)
        if OverscanDataPacket.is_overscan_data_packet(data):
            return OverscanDataPacket(data)
        if WriteRequest.is_write_request(data):
            return WriteRequest(data)
        if WriteRequestReply.is_write_reply(data):
            return WriteRequestReply(data)
        if ReadRequest.is_read_request(data):
            return ReadRequest(data)
        if ReadRequestReply.is_read_reply(data):
            return ReadRequestReply(data)
        return SpaceWirePacket(data)


class DataPacket(SpaceWirePacket):
    &#34;&#34;&#34;
    Base class for proprietary SpaceWire data packets that are exchanged between FEE and DPU.

    .. note::
        This class should not be instantiated directly. Use the SpaceWirePacket.create_packet()
        factory method or the constructors of one of the sub-classes of this DataPacket class.
    &#34;&#34;&#34;

    DATA_HEADER_LENGTH = 10

    def __init__(self, data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Args:
            data: a bytes object or a numpy array
        &#34;&#34;&#34;
        if not self.is_data_packet(data):
            raise ValueError(
                f&#34;Can not create a DataPacket from the given data {[f&#39;0x{x:02x}&#39; for x in data]}&#34;
            )

        super().__init__(data)

        if (data[2] == 0x00 and data[3] == 0x00) or len(data) == self.DATA_HEADER_LENGTH:
            MODULE_LOGGER.warning(
                f&#34;SpaceWire data packet without data found, packet={[f&#39;0x{x:02x}&#39; for x in data]}&#34;
            )

        self._length = (data[2] &lt;&lt; 8) + data[3]

        if len(data) != self._length + self.DATA_HEADER_LENGTH:
            MODULE_LOGGER.warning(
                f&#34;The length of the data argument ({len(data)}) given to &#34;
                f&#34;the constructor of {self.__class__.__name__} (or sub-classes) is inconsistent &#34;
                f&#34;with the length data field ({self._length} + 10) in the packet header.&#34;
            )
            raise ValueError(
                f&#34;{self.__class__.__name__} header: data-length field ({self._length}) not &#34;
                f&#34;consistent with packet length ({len(data)}). Difference should be &#34;
                f&#34;{self.DATA_HEADER_LENGTH}.&#34;
            )

        self._type = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        self._data = None  # lazy loading of data from self._bytes

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;Returns the data length in bytes.

        .. note:: length == len(data_nd_array) * 2
            This length property returns the length of the data area in bytes. This value is
            taken  from the header of the data packet. If you want to compare this with the size
            of the data_as_ndarray property, multiply the length by 2 because the data is 16-bit
            integers, not bytes.

        Returns:
            the size of the data area of the packet in bytes.
        &#34;&#34;&#34;
        return self._length

    @property
    def data_as_ndarray(self):
        &#34;&#34;&#34;
        Returns the data from this data packet as a 16-bit integer Numpy array.

        .. note::
            The data has been converted from the 8-bit packet data into 16-bit integers. That
            means the length of this data array will be half the length of the data field the
            packet, i.e. ``len(data) == length // 2``.
            The reason for this is that pixel data has a size of 16-bit.

        .. todo::
            check if the data-length of HK packets should also be a multiple of 16.

        Returns:
            data: Numpy array with the data from this packet (type is np.uint16)

        &#34;&#34;&#34;

        # We decided to lazy load/construct the data array. The reason is that the packet may be
        # created / transferred without the need to unpack the data field into a 16-bit numpy array.

        if self._data is None:
            # The data is in two&#39;s-complement. The most significant bit (msb) shall be inverted
            # according to Sampie Smit. That is done in the following line where the msb in each
            # byte on an even index is inverted.

            # data = [toggle_bit(b, 7) if not idx % 2 else b for idx, b in enumerate(self._bytes)]
            # data = bytearray(data)
            # data_1 = np.frombuffer(data, offset=10, dtype=&#39;&gt;u2&#39;)

            # Needs further confirmation, but the following line should have the same effect as
            # the previous three lines.
            data_2 = np.frombuffer(self._bytes, offset=10, dtype=&#39;&gt;i2&#39;) + TWOS_COMPLEMENT_OFFSET

            # Test if the results are identical, left the code in until we are fully confident
            # if diff := np.sum(np.cumsum(data_1 - data_2)):
            #     MODULE_LOGGER.info(f&#34;cumsum={diff}&#34;)

            self._data = data_2.astype(&#39;uint16&#39;)
        return self._data

    @property
    def data(self) -&gt; bytes:
        return self._bytes[10: 10 + self._length]

    @property
    def type(self) -&gt; DataPacketType:
        return self._type

    @property
    def frame_counter(self):
        return (self._bytes[6] &lt;&lt; 8) + self._bytes[7]

    @property
    def sequence_counter(self):
        return (self._bytes[8] &lt;&lt; 8) + self._bytes[9]

    @property
    def header(self) -&gt; DataPacketHeader:
        return DataPacketHeader(self.header_as_bytes())

    def header_as_bytes(self):
        return self._bytes[:10]

    @classmethod
    def is_data_packet(cls, data: np.ndarray) -&gt; bool:
        if len(data) &lt; 10 or data[0] != 0x50 or data[1] != 0xF0:
            return False
        return True

    def __str__(self):
        options = np.get_printoptions()
        np.set_printoptions(
            formatter={&#34;int&#34;: lambda x: f&#34;0x{x:04x}&#34;},
            threshold=super()._threshold,
            edgeitems=super()._edgeitems,
            linewidth=super()._linewidth,
        )
        msg = (
            f&#34;{self.__class__.__name__}:\n&#34;
            f&#34;  Logical Address = 0x{self.logical_address:02X}\n&#34;
            f&#34;  Protocol ID = 0x{self.protocol_id:02X}\n&#34;
            f&#34;  Length = {self.length}\n&#34;
            f&#34;  Type = {self._type}\n&#34;
            f&#34;  Frame Counter = {self.frame_counter}\n&#34;
            f&#34;  Sequence Counter = {self.sequence_counter}\n&#34;
            f&#34;  Data = \n{self.data}&#34;
        )
        np.set_printoptions(**options)
        return msg


class DataDataPacket(DataPacket):
    &#34;&#34;&#34;Proprietary Data Packet for N-FEE and F-FEE CCD image data.&#34;&#34;&#34;

    @classmethod
    def is_data_data_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        if len(data) &lt;= 10:
            return False
        if data[0] != 0x50:
            return False
        if data[1] != 0xF0:
            return False
        type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        if type_.packet_type == PacketType.DATA_PACKET:
            return True
        return False


class OverscanDataPacket(DataPacket):
    &#34;&#34;&#34;Proprietary Overscan Data Packet for N-FEE and F-FEE CCD image data.&#34;&#34;&#34;

    @classmethod
    def is_overscan_data_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        if len(data) &lt;= 10:
            return False
        if data[0] != 0x50:
            return False
        if data[1] != 0xF0:
            return False
        type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        if type_.packet_type == PacketType.OVERSCAN_DATA:
            return True
        return False


class HousekeepingPacket(DataPacket):
    &#34;&#34;&#34;Proprietary Housekeeping data packet for the N-FEE and F-FEE.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Args:
            data: a numpy array of type np.uint8 (not enforced)
        &#34;&#34;&#34;
        if not self.is_housekeeping_packet(data):
            raise ValueError(f&#34;Can not create a HousekeepingPacket from the given data {data}&#34;)

        # The __init__ method of DataPacket already checks e.g. data-length against packet length,
        # so there is no need for these tests here.

        super().__init__(data)

    @classmethod
    def is_housekeeping_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        if len(data) &lt;= 10:
            return False
        if data[0] != 0x50:
            return False
        if data[1] != 0xF0:
            return False
        type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        if type_.packet_type == PacketType.HOUSEKEEPING_DATA:
            return True
        return False


class TimecodePacket(SpaceWirePacket):
    &#34;&#34;&#34;A Timecode Packet.

    This packet really is an extended packet which is generated by the Diagnostic SpaceWire
    Interface (DSI) to forward a SpaceWire timecode over the Ethernet connection.
    &#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    @property
    def timecode(self) -&gt; int:
        return self._bytes[1] &amp; 0x3F

    def header_as_bytes(self) -&gt; bytes:
        return self._bytes[0:1]

    @classmethod
    def is_timecode_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        return data[0] == 0x91

    def __str__(self):
        return f&#34;Timecode Packet: timecode = 0x{self.timecode:x}&#34;


class RMAPPacket(SpaceWirePacket):
    &#34;&#34;&#34;Base class for RMAP SpaceWire packets.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        if not self.is_rmap_packet(data):
            raise ValueError(f&#34;Can not create a RMAPPacket from the given data {data}&#34;)
        super().__init__(data)

    def __str__(self):
        return (
            f&#34;{self.__class__.__name__}:\n&#34;
            f&#34;  Logical Address = 0x{self.logical_address:02X}\n&#34;
            f&#34;  Data = {self.data}\n&#34;
        )

    @property
    def instruction(self):
        return get_instruction_field(self._bytes)

    @property
    def transaction_id(self):
        return get_transaction_identifier(self._bytes)

    @classmethod
    def is_rmap_packet(cls, data: Union[bytes, np.ndarray]):
        if data[1] == 0x01:  # Protocol ID
            return True
        return False


class WriteRequest(RMAPPacket):
    &#34;&#34;&#34;A Write Request SpaceWire RMAP Packet.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    def is_verified(self):
        return self._bytes[2] == 0x7C

    def is_unverified(self):
        return self._bytes[2] == 0x6C

    @property
    def address(self):
        return get_address(self._bytes)

    @property
    def data_length(self):
        return get_data_length(self._bytes)

    @property
    def data(self) -&gt; bytes:
        return get_data(self._bytes)

    @classmethod
    def is_write_request(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x51:
            return False
        if (data[2] == 0x7C or data[2] == 0x6C) and data[3] == 0xD1:
            return True
        return False

    def __str__(self):
        prefix = &#34;Verified&#34; if self.is_verified() else &#34;Unverified&#34;
        return f&#34;{prefix} Write Request: {self.transaction_id=}, data=0x{self.data.hex()}&#34;


class WriteRequestReply(RMAPPacket):
    &#34;&#34;&#34;An RMAP Reply packet to a Write Request.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)
        self._status = data[3]

    @classmethod
    def is_write_reply(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x50:
            return False
        if (data[2] == 0x3C or data[2] == 0x2C) and data[4] == 0x51:
            return True

    @property
    def status(self):
        return self._status

    def __str__(self):
        return f&#34;Write Request Reply: status={self.status}&#34;


class ReadRequest(RMAPPacket):
    &#34;&#34;&#34;A Read Request SpaceWire RMAP Packet.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    @classmethod
    def is_read_request(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x51:
            return False
        if data[2] == 0x4C and data[3] == 0xD1:
            return True
        return False

    @property
    def address(self):
        return get_address(self._bytes)

    @property
    def data_length(self):
        return get_data_length(self._bytes)

    def __str__(self):
        return (
            f&#34;Read Request: tid={self.transaction_id}, address=0x{self.address:04x}, &#34;
            f&#34;data length={self.data_length}&#34;
        )


class ReadRequestReply(RMAPPacket):
    &#34;&#34;&#34;An RMAP Reply packet to a Read Request.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    @classmethod
    def is_read_reply(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x50:
            return False
        if data[2] == 0x0C and data[4] == 0x51:
            return True

    @property
    def data(self) -&gt; bytes:
        return get_data(self._bytes)

    @property
    def data_length(self):
        return get_data_length(self._bytes)

    def __str__(self):
        data_length = self.data_length
        return f&#34;Read Request Reply: data length={data_length}, data={self.data[:20]} &#34; \
               f&#34;{&#39;(data is cut to max 20 bytes)&#39; if data_length &gt; 20 else &#39;&#39;}\n&#34;


class SpaceWireInterface:
    &#34;&#34;&#34;
    This interface defines methods that are used by the DPU to communicate with the FEE over
    SpaceWire.
    &#34;&#34;&#34;

    def __enter__(self):
        self.connect()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()

    def connect(self):
        raise NotImplementedError

    def disconnect(self):
        raise NotImplementedError

    def configure(self):
        raise NotImplementedError

    def flush(self):
        raise NotImplementedError

    def send_timecode(self, timecode: int):
        raise NotImplementedError

    def read_packet(self, timeout: int = None) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;
        Read a full packet from the SpaceWire transport layer.

        Args:
            timeout (int): timeout in milliseconds [default=None]
        Returns:
            A tuple with the terminator value and a bytes object containing the packet.
        &#34;&#34;&#34;
        raise NotImplementedError

    def write_packet(self, packet: bytes):
        &#34;&#34;&#34;
        Write a full packet to the SpaceWire transport layer.

        Args:
            packet (bytes): a bytes object containing the SpaceWire packet

        Returns:
            None.
        &#34;&#34;&#34;
        raise NotImplementedError

    def read_register(self, address: int, length: int = 4, strict: bool = True) -&gt; bytes:
        &#34;&#34;&#34;
        Reads the data for the given register from the FEE memory map.

        This function sends an RMAP read request for the register to the FEE.

        Args:
            address: the start address (32-bit aligned) in the remote memory
            length: the number of bytes to read from the remote memory [default = 4]
            strict: perform strict checking of address and length

        Returns:
            data: the 32-bit data that was read from the FEE.
        &#34;&#34;&#34;
        raise NotImplementedError

    def write_register(self, address: int, data: bytes):
        &#34;&#34;&#34;
        Writes the data from the given register to the N-FEE memory map.

        The function reads the data for the registry from the local register map
        and then sends an RMAP write request for the register to the N-FEE.

        .. note:: it is assumed that the local register map is up-to-date.

        Args:
            address: the start address (32-bit aligned) in the remote memory
            data: the data that will be written into the remote memory

        Raises:
            RMAPError: when data can not be written on the target, i.e. the N-FEE.
        &#34;&#34;&#34;

        raise NotImplementedError

    def read_memory_map(self, address: int, size: int):
        &#34;&#34;&#34;
        Read (part of) the memory map from the N-FEE.

        Args:
            address: start address
            size: number of bytes to read

        Returns:
            a bytes object containing the requested memory map.
        &#34;&#34;&#34;

        raise NotImplementedError


# General RMAP helper functions ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

def rmap_crc_check(data, start, length) -&gt; int:
    &#34;&#34;&#34;Calculate the checksum for the given data.&#34;&#34;&#34;
    return crc_calc(data, start, length)


def get_protocol_id(data: bytes) -&gt; int:
    &#34;&#34;&#34;
    Returns the protocol identifier field. The protocol ID is 1 (0x01) for the RMAP protocol.
    &#34;&#34;&#34;
    return data[1]


def get_reply_address_field_length(rx_buffer) -&gt; int:
    &#34;&#34;&#34;Returns the size of reply address field.

    This function returns the actual size of the reply address field. It doesn&#39;t return
    the content of the reply address length field. If you need that information, use the
    reply_address_length() function that work on the instruction field.

    Returns:
         length: the size of the reply address field.
    &#34;&#34;&#34;
    instruction = get_instruction_field(rx_buffer)
    return reply_address_length(instruction) * 4


def get_data(rxbuf) -&gt; bytes:
    &#34;&#34;&#34;
    Return the data from the RMAP packet.

    Raises:
        ValueError: if there is no data section in the packet (TODO: not yet implemented)
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16

    return rxbuf[offset + address_length:offset + address_length + data_length]


def check_data_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16
    idx = offset + address_length

    d_crc = rxbuf[idx + data_length]
    c_crc = rmap_crc_check(rxbuf, idx, data_length) &amp; 0xFF
    if d_crc != c_crc:
        raise CheckError(
            f&#34;Data CRC doesn&#39;t match calculated CRC, d_crc=0x{d_crc:02X} &amp; c_crc=0x{c_crc:02X}&#34;,
            RMAP_GENERAL_ERROR
        )


def check_header_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    if is_command(instruction_field):
        offset = 15
    elif is_write(instruction_field):
        offset = 7
    else:
        offset = 11

    idx = offset + get_reply_address_field_length(rxbuf)
    h_crc = rxbuf[idx]
    c_crc = rmap_crc_check(rxbuf, 0, idx)
    if h_crc != c_crc:
        raise CheckError(
            f&#34;Header CRC doesn&#39;t match calculated CRC, h_crc=0x{h_crc:02X} &amp; c_crc=0x{c_crc:02X}&#34;,
            RMAP_GENERAL_ERROR
        )


def get_data_length(rxbuf) -&gt; int:
    &#34;&#34;&#34;
    Returns the length of the data in bytes.

    Raises:
        TypeError: when this method is used on a Write Request Reply packet (which has no
            data length).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field) and is_write(instruction_field):
        raise TypeError(&#34;There is no data length field for Write Request Reply packets, &#34;
                        &#34;asking for the data length is an invalid operation.&#34;)

    offset = 12 if is_command(instruction_field) else 8
    idx = offset + get_reply_address_field_length(rxbuf)

    # We could use two alternative decoding methods here:
    #   int.from_bytes(rxbuf[idx:idx+3], byteorder=&#39;big&#39;)    (timeit=1.166s)
    #   struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx+3])[0]   (timeit=0.670s)
    data_length = struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx + 3])[0]
    return data_length


def get_address(rxbuf) -&gt; int:
    &#34;&#34;&#34;
    Returns the address field (including the extended address field if the address is 40-bits).

    Raises:
        TypeError: when this method is used on a Reply packet (which has no address field).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field):
        raise TypeError(&#34;There is no address field for Reply packets, asking for the address is &#34;
                        &#34;an invalid operation.&#34;)

    idx = 7 + get_reply_address_field_length(rxbuf)
    extended_address = rxbuf[idx]
    idx += 1
    address = struct.unpack(&#39;&gt;L&#39;, rxbuf[idx:idx + 4])[0]
    if extended_address:
        address = address + (extended_address &lt;&lt; 32)
    return address


def get_instruction_field(rxbuf):
    idx = 2
    return rxbuf[idx]


def get_transaction_identifier(rxbuf):
    idx = 5 + get_reply_address_field_length(rxbuf)
    tid = struct.unpack(&#39;&gt;h&#39;, rxbuf[idx:idx + 2])[0]
    return tid


# Functions to interpret the Instrument Field

def is_reserved(instruction):
    &#34;&#34;&#34;The reserved bit of the 2-bit packet type field from the instruction field.

    For PLATO this bit shall be zero as the 0b10 and 0b11 packet field values are reserved.

    Returns:
        bit value: 1 or 0.
    &#34;&#34;&#34;
    return (instruction &amp; 0b10000000) &gt;&gt; 7


def is_command(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b01000000) &gt;&gt; 6


def is_reply(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a reply to a previous command packet.&#34;&#34;&#34;
    return not is_command(instruction)


def is_write(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a write request command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b00100000) &gt;&gt; 5


def is_read(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a read request command packet.&#34;&#34;&#34;
    return not is_write(instruction)


def is_verify(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet needs to do a verify before write.&#34;&#34;&#34;
    return (instruction &amp; 0b00010000) &gt;&gt; 4


def is_reply_required(instruction):
    &#34;&#34;&#34;Returns True if the reply bit is set in the instruction field.

    Args:
        instruction (int): the instruction field of an RMAP packet

    .. note:: the name of this function might be confusing.

        This function does **not** test if the packet is a reply packet, but it checks
        if the command requests a reply from the target. If you need to test if the
        packet is a command or a reply, use the is_command() or is_reply() function.

    &#34;&#34;&#34;
    return (instruction &amp; 0b00001000) &gt;&gt; 3


def is_increment(instruction):
    &#34;&#34;&#34;Returns True if the data is written to sequential memory addresses.&#34;&#34;&#34;
    return (instruction &amp; 0b00000100) &gt;&gt; 2


def reply_address_length(instruction):
    &#34;&#34;&#34;Returns the content of the reply address length field.

    The size of the reply address field is then decoded from the following table:

        Address Field Length  |  Size of Address Field
        ----------------------+-----------------------
             0b00             |      0 bytes
             0b01             |      4 bytes
             0b10             |      8 bytes
             0b11             |     12 bytes

    &#34;&#34;&#34;
    return (instruction &amp; 0b00000011) &lt;&lt; 2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.spw.check_address_and_data_length"><code class="name flex">
<span>def <span class="ident">check_address_and_data_length</span></span>(<span>address: int, length: int, strict: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the address and length in the range of memory areas used by the FEE.</p>
<p>The ranges are taken from the PLATO-DLR-PL-ICD-0010 N-FEE to N-DPU IRD.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>the memory address of the FEE Register</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of bytes requested</dd>
<dt><strong><code>strict</code></strong> :&ensp;<code>bool</code></dt>
<dd>strictly apply the rules</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="egse.spw.RMAPError" href="#egse.spw.RMAPError">RMAPError</a></code></dt>
<dd>when address + length fall outside any specified area.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_address_and_data_length(address: int, length: int, strict: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Checks the address and length in the range of memory areas used by the FEE.

    The ranges are taken from the PLATO-DLR-PL-ICD-0010 N-FEE to N-DPU IRD.

    Args:
        address (int): the memory address of the FEE Register
        length (int): the number of bytes requested
        strict (bool): strictly apply the rules

    Raises:
        RMAPError: when address + length fall outside any specified area.
    &#34;&#34;&#34;

    if not strict:
        # All these restrictions have been relaxed on the N-FEE.
        # We are returning here immediately instead of removing or commenting out the code.
        # These reason is that we can then bring back restriction easier and gradually.

        MODULE_LOGGER.warning(
            &#34;Address and data length checks have been disabled, because the N-FEE &#34;
            &#34;does not enforce restrictions in the critical memory area.&#34;)
        return

    if length % 4:
        raise RMAPError(
            &#34;The requested data length shall be a multiple of 4 bytes.&#34;, address, length
        )

    if address % 4:
        raise RMAPError(&#34;The address shall be a multiple of 4 bytes.&#34;, address, length)

    # Note that when checking the given data length, at the defined area end,
    # we can still read 4 bytes.

    if CRITICAL_AREA_START &lt;= address &lt;= CRITICAL_AREA_END:
        if length != 4:
            raise RMAPError(
                &#34;Read requests to the critical area have a fixed data length of 4 bytes.&#34;,
                address, length
            )
    elif GENERAL_AREA_START &lt;= address &lt;= GENERAL_AREA_END:
        if length &gt; 256:
            raise RMAPError(
                &#34;Read requests to the general area have a maximum data length of 256 bytes.&#34;,
                address, length
            )
        if address + length &gt; GENERAL_AREA_END + 4:
            raise RMAPError(
                &#34;The requested data length for the general area is too large. &#34;
                &#34;The address + length exceeds the general area boundaries.&#34;,
                address, length
            )

    elif HK_AREA_START &lt;= address &lt;= HK_AREA_END:
        if length &gt; 256:
            raise RMAPError(
                &#34;Read requests to the housekeeping area have a maximum data length of 256 bytes.&#34;,
                address, length
            )
        if address + length &gt; HK_AREA_END + 4:
            raise RMAPError(
                &#34;The requested data length for the housekeeping area is too large. &#34;
                &#34;The address + length exceeds the housekeeping area boundaries.&#34;,
                address, length
            )

    elif WINDOWING_AREA_START &lt;= address &lt;= WINDOWING_AREA_END:
        if length &gt; 4096:
            raise RMAPError(
                &#34;Read requests to the windowing area have a maximum data length of 4096 bytes.&#34;,
                address, length
            )
        if address + length &gt; WINDOWING_AREA_END + 4:
            raise RMAPError(
                &#34;The requested data length for the windowing area is too large. &#34;
                &#34;The address + length exceeds the windowing area boundaries.&#34;, address, length
            )

    else:
        raise RMAPError(&#34;Register address for RMAP read requests is invalid.&#34;, address, length)</code></pre>
</details>
</dd>
<dt id="egse.spw.check_data_crc"><code class="name flex">
<span>def <span class="ident">check_data_crc</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_data_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16
    idx = offset + address_length

    d_crc = rxbuf[idx + data_length]
    c_crc = rmap_crc_check(rxbuf, idx, data_length) &amp; 0xFF
    if d_crc != c_crc:
        raise CheckError(
            f&#34;Data CRC doesn&#39;t match calculated CRC, d_crc=0x{d_crc:02X} &amp; c_crc=0x{c_crc:02X}&#34;,
            RMAP_GENERAL_ERROR
        )</code></pre>
</details>
</dd>
<dt id="egse.spw.check_header_crc"><code class="name flex">
<span>def <span class="ident">check_header_crc</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_header_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    if is_command(instruction_field):
        offset = 15
    elif is_write(instruction_field):
        offset = 7
    else:
        offset = 11

    idx = offset + get_reply_address_field_length(rxbuf)
    h_crc = rxbuf[idx]
    c_crc = rmap_crc_check(rxbuf, 0, idx)
    if h_crc != c_crc:
        raise CheckError(
            f&#34;Header CRC doesn&#39;t match calculated CRC, h_crc=0x{h_crc:02X} &amp; c_crc=0x{c_crc:02X}&#34;,
            RMAP_GENERAL_ERROR
        )</code></pre>
</details>
</dd>
<dt id="egse.spw.create_rmap_read_request_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_read_request_packet</span></span>(<span>address: int, length: int, tid: int, strict: bool = True) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an RMAP Read Request SpaceWire packet.</p>
<p>The read request is an RMAP command that read a number of bytes from the FEE register memory.</p>
<p>The function returns a <code>ctypes</code> character array (which is basically a bytes array) that
can be passed into the EtherSpaceLink library function <code>esl_write_packet()</code>.</p>
<p>Address shall be within the 0x0000_0000 and 0x00FF_FFFC. The memory map (register) is divided
in the following areas:</p>
<pre><code>0x0000_0000 - 0x0000_00FC   Critical Configuration Area (verified write)
0x0000_0100 - 0x0000_06FC   General Configuration Area (unverified write)
0x0000_0700 - 0x0000_07FC   Housekeeping area
0x0000_0800 - 0x007F_FFFC   Not Supported
0x0080_0000 - 0x00FF_FFFC   Windowing Area (unverified write)
0x0010_0000 - 0xFFFF_FFFC   Not Supported
</code></pre>
<p>All read requests to the critical area shall have a fixed data length of 4 bytes.
All read requests to a general area shall have a maximum data length of 256 bytes.
All read requests to the housekeeping area shall have a maximum data length of 256 bytes.
All read requests to the windowing area shall have a maximum data length of 4096 bytes.</p>
<p>The transaction identifier shall be incremented for each read request. This shall be done by
the calling function!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>the FEE register memory address</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the data length</dd>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>transaction identifier</dd>
<dt><strong><code>strict</code></strong> :&ensp;<code>bool</code></dt>
<dd>perform strict checking of address and length</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a bytes object containing the full RMAP Read Request packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_read_request_packet(address: int, length: int, tid: int, strict: bool = True) -&gt; bytes:
    &#34;&#34;&#34;
    Creates an RMAP Read Request SpaceWire packet.

    The read request is an RMAP command that read a number of bytes from the FEE register memory.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Address shall be within the 0x0000_0000 and 0x00FF_FFFC. The memory map (register) is divided
    in the following areas:

        0x0000_0000 - 0x0000_00FC   Critical Configuration Area (verified write)
        0x0000_0100 - 0x0000_06FC   General Configuration Area (unverified write)
        0x0000_0700 - 0x0000_07FC   Housekeeping area
        0x0000_0800 - 0x007F_FFFC   Not Supported
        0x0080_0000 - 0x00FF_FFFC   Windowing Area (unverified write)
        0x0010_0000 - 0xFFFF_FFFC   Not Supported

    All read requests to the critical area shall have a fixed data length of 4 bytes.
    All read requests to a general area shall have a maximum data length of 256 bytes.
    All read requests to the housekeeping area shall have a maximum data length of 256 bytes.
    All read requests to the windowing area shall have a maximum data length of 4096 bytes.

    The transaction identifier shall be incremented for each read request. This shall be done by
    the calling function!

    Args:
        address (int): the FEE register memory address
        length (int): the data length
        tid (int): transaction identifier
        strict (bool): perform strict checking of address and length

    Returns:
        a bytes object containing the full RMAP Read Request packet.
    &#34;&#34;&#34;

    check_address_and_data_length(address, length, strict=strict)

    buf = bytearray(16)

    # NOTE: The first bytes would each carry the target SpW address or a destination port,
    #       but this is not used for point-to-point connections, so we&#39;re safe.

    buf[0] = 0x51  # Target N-FEE or F-FEE
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = 0x4C  # Instruction: 0b1001100, RMAP Request, Read, Incrementing address, reply address
    buf[3] = 0xD1  # Destination Key
    buf[4] = 0x50  # Initiator is always the DPU
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = 0x00  # Extended address is not used
    buf[8] = (address &gt;&gt; 24) &amp; 0xFF  # address (MSB)
    buf[9] = (address &gt;&gt; 16) &amp; 0xFF  # address
    buf[10] = (address &gt;&gt; 8) &amp; 0xFF  # address
    buf[11] = address &amp; 0xFF  # address (LSB)
    buf[12] = (length &gt;&gt; 16) &amp; 0xFF  # data length (MSB)
    buf[13] = (length &gt;&gt; 8) &amp; 0xFF  # data length
    buf[14] = length &amp; 0xFF  # data length (LSB)
    buf[15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF
    return bytes(buf)</code></pre>
</details>
</dd>
<dt id="egse.spw.create_rmap_read_request_reply_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_read_request_reply_packet</span></span>(<span>instruction_field: int, tid: int, status: int, buffer: bytes, buffer_length: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an RMAP Reply to a RMAP Read Request packet.</p>
<p>The function returns a <code>ctypes</code> character array (which is basically a bytes array) that
can be passed into the EtherSpaceLink library function <code>esl_write_packet()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction_field</code></strong> :&ensp;<code>int</code></dt>
<dd>the instruction field of the RMAP read request packet</dd>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>the transaction identifier of the read request packet</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>int</code></dt>
<dd>the status field, 0 on success</dd>
<dt><strong><code>buffer</code></strong> :&ensp;<code>bytes</code></dt>
<dd>the data that was read as indicated by the read request</dd>
<dt><strong><code>buffer_length</code></strong> :&ensp;<code>int</code></dt>
<dd>the data length</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>packet</code></dt>
<dd>a bytes object containing the full RMAP Reply packet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_read_request_reply_packet(
        instruction_field: int, tid: int, status: int, buffer: bytes, buffer_length: int) -&gt; bytes:
    &#34;&#34;&#34;
    Creates an RMAP Reply to a RMAP Read Request packet.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Args:
        instruction_field (int): the instruction field of the RMAP read request packet
        tid (int): the transaction identifier of the read request packet
        status (int): the status field, 0 on success
        buffer (bytes): the data that was read as indicated by the read request
        buffer_length (int): the data length

    Returns:
        packet: a bytes object containing the full RMAP Reply packet.
    &#34;&#34;&#34;

    buf = bytearray(12 + buffer_length + 1)

    buf[0] = 0x50  # Initiator address N-DPU or F-DPU
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = instruction_field &amp; 0x3F  # Clear the command bit as this is a reply
    buf[3] = status &amp; 0xFF  # Status field: 0 on success
    buf[4] = 0x51  # Target address is always the N-FEE or F-FEE
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = 0x00  # Reserved
    buf[8] = (buffer_length &gt;&gt; 16) &amp; 0xFF  # data length (MSB)
    buf[9] = (buffer_length &gt;&gt; 8) &amp; 0xFF  # data length
    buf[10] = buffer_length &amp; 0xFF  # data length (LSB)
    buf[11] = rmap_crc_check(buf, 0, 11) &amp; 0xFF  # Header CRC

    # Note that we assume here that len(buffer) == buffer_length.

    if len(buffer) != buffer_length:
        MODULE_LOGGER.warning(
            f&#34;While creating an RMAP read reply packet, the length of the buffer ({len(buffer)}) &#34;
            f&#34;not equals the buffer_length ({buffer_length})&#34;
        )

    for idx, value in enumerate(buffer):
        buf[12 + idx] = value

    buf[12 + buffer_length] = rmap_crc_check(buffer, 0, buffer_length) &amp; 0xFF  # data CRC

    return bytes(buf)</code></pre>
</details>
</dd>
<dt id="egse.spw.create_rmap_unverified_write_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_unverified_write_packet</span></span>(<span>address: int, data: bytes, length: int, tid: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Create an RMAP packet for a unverified write request on the FEE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>the start memory address on the FEE register map</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data to be written in the register map at address</dd>
<dt><strong><code>length</code></strong></dt>
<dd>the length of the data</dd>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>transaction identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>packet</code></dt>
<dd>a bytes object containing the SpaceWire packet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_unverified_write_packet(address: int, data: bytes, length: int, tid: int) -&gt; bytes:
    &#34;&#34;&#34;
    Create an RMAP packet for a unverified write request on the FEE.

    Args:
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address
        length: the length of the data
        tid (int): transaction identifier

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    # We can only handle data for which the length &gt;= the given length argument.

    if len(data) &lt; length:
        raise ValueError(
            f&#34;The length of the data argument ({len(data)}) is smaller than &#34;
            f&#34;the given length argument ({length}).&#34;
        )

    if len(data) &gt; length:
        MODULE_LOGGER.warning(
            f&#34;The length of the data argument ({len(data)}) is larger than &#34;
            f&#34;the given length argument ({length}). The data will be truncated &#34;
            f&#34;when copied into the packet.&#34;
        )

    if address &lt;= CRITICAL_AREA_END:
        raise ValueError(
            f&#34;The given address (0x{address:08X}) is in the range for critical configuration is &#34;
            f&#34;[0x00 - 0xFC]. Use the verified write function for this.&#34;
        )

    tid = update_transaction_identifier(tid)

    # Buffer length is fixed at 24 bytes since the data length
    # is fixed at 4 bytes (32 bit addressing)

    buf = bytearray(16 + length + 1)
    offset = 0

    buf[offset + 0] = 0x51  # Logical Address
    buf[offset + 1] = 0x01  # Protocol ID
    buf[offset + 2] = 0x6C  # Instruction
    buf[offset + 3] = 0xD1  # Key
    buf[offset + 4] = 0x50  # Initiator Address
    buf[offset + 5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[offset + 6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[offset + 7] = 0x00  # Extended address
    buf[offset + 8] = (address &gt;&gt; 24) &amp; 0xFF  # address (MSB)
    buf[offset + 9] = (address &gt;&gt; 16) &amp; 0xFF  # address
    buf[offset + 10] = (address &gt;&gt; 8) &amp; 0xFF  # address
    buf[offset + 11] = address &amp; 0xFF  # address (LSB)
    buf[offset + 12] = (length &gt;&gt; 16) &amp; 0xFF  # data length (MSB)
    buf[offset + 13] = (length &gt;&gt; 8) &amp; 0xFF  # data length
    buf[offset + 14] = length &amp; 0xFF  # data length (LSB)
    buf[offset + 15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC

    offset += 16

    for idx, value in enumerate(data):
        buf[offset + idx] = value

    buf[offset + length] = rmap_crc_check(buf, offset, length) &amp; 0xFF  # data CRC

    return bytes(buf)</code></pre>
</details>
</dd>
<dt id="egse.spw.create_rmap_verified_write_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_verified_write_packet</span></span>(<span>address: int, data: bytes, tid: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Create an RMAP packet for a verified write request on the FEE. The length of the data is
by convention always 4 bytes and therefore not passed as an argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>the start memory address on the FEE register map</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data to be written in the register map at address [4 bytes]</dd>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>transaction identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>packet</code></dt>
<dd>a bytes object containing the SpaceWire packet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_verified_write_packet(address: int, data: bytes, tid: int) -&gt; bytes:
    &#34;&#34;&#34;
    Create an RMAP packet for a verified write request on the FEE. The length of the data is
    by convention always 4 bytes and therefore not passed as an argument.

    Args:
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address [4 bytes]
        tid (int): transaction identifier

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    if len(data) &lt; 4:
        raise ValueError(
            f&#34;The data argument should be at least 4 bytes, but it is only {len(data)} bytes: {data=}.&#34;)

    if address &gt; CRITICAL_AREA_END:
        raise ValueError(&#34;The address range for critical configuration is [0x00 - 0xFC].&#34;)

    tid = update_transaction_identifier(tid)

    # Buffer length is fixed at 24 bytes since the data length is fixed
    # at 4 bytes (32 bit addressing)

    buf = bytearray(21)

    # The values below are taken from the PLATO N-FEE to N-DPU
    # Interface Requirements Document [PLATO-DLR-PL-ICD-0010]

    buf[0] = 0x51  # Logical Address
    buf[1] = 0x01  # Protocol ID
    buf[2] = 0x7C  # Instruction
    buf[3] = 0xD1  # Key
    buf[4] = 0x50  # Initiator Address
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = 0x00  # Extended address
    buf[8] = (address &gt;&gt; 24) &amp; 0xFF  # address (MSB)
    buf[9] = (address &gt;&gt; 16) &amp; 0xFF  # address
    buf[10] = (address &gt;&gt; 8) &amp; 0xFF  # address
    buf[11] = address &amp; 0xFF  # address (LSB)
    buf[12] = 0x00  # data length (MSB)
    buf[13] = 0x00  # data length
    buf[14] = 0x04  # data length (LSB)
    buf[15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC
    buf[16] = data[0]
    buf[17] = data[1]
    buf[18] = data[2]
    buf[19] = data[3]
    buf[20] = rmap_crc_check(buf, 16, 4) &amp; 0xFF  # data CRC

    return bytes(buf)</code></pre>
</details>
</dd>
<dt id="egse.spw.create_rmap_write_request_reply_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_write_request_reply_packet</span></span>(<span>instruction_field: int, tid: int, status: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_write_request_reply_packet(instruction_field: int, tid: int, status: int) -&gt; bytes:
    buf = bytearray(8)

    buf[0] = 0x50  # Initiator address N-DPU or F-DPU
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = instruction_field &amp; 0x3F  # Clear the command bit as this is a reply
    buf[3] = status &amp; 0xFF  # Status field: 0 on success
    buf[4] = 0x51  # Target address is always the N-FEE or F-FEE
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF  # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF  # LSB of the Transition ID
    buf[7] = rmap_crc_check(buf, 0, 7) &amp; 0xFF  # Header CRC

    return bytes(buf)</code></pre>
</details>
</dd>
<dt id="egse.spw.get_address"><code class="name flex">
<span>def <span class="ident">get_address</span></span>(<span>rxbuf) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the address field (including the extended address field if the address is 40-bits).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>when this method is used on a Reply packet (which has no address field).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_address(rxbuf) -&gt; int:
    &#34;&#34;&#34;
    Returns the address field (including the extended address field if the address is 40-bits).

    Raises:
        TypeError: when this method is used on a Reply packet (which has no address field).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field):
        raise TypeError(&#34;There is no address field for Reply packets, asking for the address is &#34;
                        &#34;an invalid operation.&#34;)

    idx = 7 + get_reply_address_field_length(rxbuf)
    extended_address = rxbuf[idx]
    idx += 1
    address = struct.unpack(&#39;&gt;L&#39;, rxbuf[idx:idx + 4])[0]
    if extended_address:
        address = address + (extended_address &lt;&lt; 32)
    return address</code></pre>
</details>
</dd>
<dt id="egse.spw.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>rxbuf) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Return the data from the RMAP packet.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if there is no data section in the packet (TODO: not yet implemented)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(rxbuf) -&gt; bytes:
    &#34;&#34;&#34;
    Return the data from the RMAP packet.

    Raises:
        ValueError: if there is no data section in the packet (TODO: not yet implemented)
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16

    return rxbuf[offset + address_length:offset + address_length + data_length]</code></pre>
</details>
</dd>
<dt id="egse.spw.get_data_length"><code class="name flex">
<span>def <span class="ident">get_data_length</span></span>(<span>rxbuf) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of the data in bytes.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>when this method is used on a Write Request Reply packet (which has no
data length).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_length(rxbuf) -&gt; int:
    &#34;&#34;&#34;
    Returns the length of the data in bytes.

    Raises:
        TypeError: when this method is used on a Write Request Reply packet (which has no
            data length).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field) and is_write(instruction_field):
        raise TypeError(&#34;There is no data length field for Write Request Reply packets, &#34;
                        &#34;asking for the data length is an invalid operation.&#34;)

    offset = 12 if is_command(instruction_field) else 8
    idx = offset + get_reply_address_field_length(rxbuf)

    # We could use two alternative decoding methods here:
    #   int.from_bytes(rxbuf[idx:idx+3], byteorder=&#39;big&#39;)    (timeit=1.166s)
    #   struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx+3])[0]   (timeit=0.670s)
    data_length = struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx + 3])[0]
    return data_length</code></pre>
</details>
</dd>
<dt id="egse.spw.get_instruction_field"><code class="name flex">
<span>def <span class="ident">get_instruction_field</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instruction_field(rxbuf):
    idx = 2
    return rxbuf[idx]</code></pre>
</details>
</dd>
<dt id="egse.spw.get_protocol_id"><code class="name flex">
<span>def <span class="ident">get_protocol_id</span></span>(<span>data: bytes) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the protocol identifier field. The protocol ID is 1 (0x01) for the RMAP protocol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_protocol_id(data: bytes) -&gt; int:
    &#34;&#34;&#34;
    Returns the protocol identifier field. The protocol ID is 1 (0x01) for the RMAP protocol.
    &#34;&#34;&#34;
    return data[1]</code></pre>
</details>
</dd>
<dt id="egse.spw.get_reply_address_field_length"><code class="name flex">
<span>def <span class="ident">get_reply_address_field_length</span></span>(<span>rx_buffer) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of reply address field.</p>
<p>This function returns the actual size of the reply address field. It doesn't return
the content of the reply address length field. If you need that information, use the
reply_address_length() function that work on the instruction field.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>length</code></dt>
<dd>the size of the reply address field.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reply_address_field_length(rx_buffer) -&gt; int:
    &#34;&#34;&#34;Returns the size of reply address field.

    This function returns the actual size of the reply address field. It doesn&#39;t return
    the content of the reply address length field. If you need that information, use the
    reply_address_length() function that work on the instruction field.

    Returns:
         length: the size of the reply address field.
    &#34;&#34;&#34;
    instruction = get_instruction_field(rx_buffer)
    return reply_address_length(instruction) * 4</code></pre>
</details>
</dd>
<dt id="egse.spw.get_transaction_identifier"><code class="name flex">
<span>def <span class="ident">get_transaction_identifier</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction_identifier(rxbuf):
    idx = 5 + get_reply_address_field_length(rxbuf)
    tid = struct.unpack(&#39;&gt;h&#39;, rxbuf[idx:idx + 2])[0]
    return tid</code></pre>
</details>
</dd>
<dt id="egse.spw.is_command"><code class="name flex">
<span>def <span class="ident">is_command</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_command(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b01000000) &gt;&gt; 6</code></pre>
</details>
</dd>
<dt id="egse.spw.is_increment"><code class="name flex">
<span>def <span class="ident">is_increment</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the data is written to sequential memory addresses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_increment(instruction):
    &#34;&#34;&#34;Returns True if the data is written to sequential memory addresses.&#34;&#34;&#34;
    return (instruction &amp; 0b00000100) &gt;&gt; 2</code></pre>
</details>
</dd>
<dt id="egse.spw.is_read"><code class="name flex">
<span>def <span class="ident">is_read</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a read request command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_read(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a read request command packet.&#34;&#34;&#34;
    return not is_write(instruction)</code></pre>
</details>
</dd>
<dt id="egse.spw.is_reply"><code class="name flex">
<span>def <span class="ident">is_reply</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a reply to a previous command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_reply(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a reply to a previous command packet.&#34;&#34;&#34;
    return not is_command(instruction)</code></pre>
</details>
</dd>
<dt id="egse.spw.is_reply_required"><code class="name flex">
<span>def <span class="ident">is_reply_required</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the reply bit is set in the instruction field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction</code></strong> :&ensp;<code>int</code></dt>
<dd>the instruction field of an RMAP packet</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;the name of this function might be confusing.</p>
<p>This function does <strong>not</strong> test if the packet is a reply packet, but it checks
if the command requests a reply from the target. If you need to test if the
packet is a command or a reply, use the is_command() or is_reply() function.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_reply_required(instruction):
    &#34;&#34;&#34;Returns True if the reply bit is set in the instruction field.

    Args:
        instruction (int): the instruction field of an RMAP packet

    .. note:: the name of this function might be confusing.

        This function does **not** test if the packet is a reply packet, but it checks
        if the command requests a reply from the target. If you need to test if the
        packet is a command or a reply, use the is_command() or is_reply() function.

    &#34;&#34;&#34;
    return (instruction &amp; 0b00001000) &gt;&gt; 3</code></pre>
</details>
</dd>
<dt id="egse.spw.is_reserved"><code class="name flex">
<span>def <span class="ident">is_reserved</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>The reserved bit of the 2-bit packet type field from the instruction field.</p>
<p>For PLATO this bit shall be zero as the 0b10 and 0b11 packet field values are reserved.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bit value</code></dt>
<dd>1 or 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_reserved(instruction):
    &#34;&#34;&#34;The reserved bit of the 2-bit packet type field from the instruction field.

    For PLATO this bit shall be zero as the 0b10 and 0b11 packet field values are reserved.

    Returns:
        bit value: 1 or 0.
    &#34;&#34;&#34;
    return (instruction &amp; 0b10000000) &gt;&gt; 7</code></pre>
</details>
</dd>
<dt id="egse.spw.is_verify"><code class="name flex">
<span>def <span class="ident">is_verify</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet needs to do a verify before write.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_verify(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet needs to do a verify before write.&#34;&#34;&#34;
    return (instruction &amp; 0b00010000) &gt;&gt; 4</code></pre>
</details>
</dd>
<dt id="egse.spw.is_write"><code class="name flex">
<span>def <span class="ident">is_write</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a write request command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_write(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a write request command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b00100000) &gt;&gt; 5</code></pre>
</details>
</dd>
<dt id="egse.spw.reply_address_length"><code class="name flex">
<span>def <span class="ident">reply_address_length</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the content of the reply address length field.</p>
<p>The size of the reply address field is then decoded from the following table:</p>
<pre><code>Address Field Length  |  Size of Address Field
----------------------+-----------------------
     0b00             |      0 bytes
     0b01             |      4 bytes
     0b10             |      8 bytes
     0b11             |     12 bytes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply_address_length(instruction):
    &#34;&#34;&#34;Returns the content of the reply address length field.

    The size of the reply address field is then decoded from the following table:

        Address Field Length  |  Size of Address Field
        ----------------------+-----------------------
             0b00             |      0 bytes
             0b01             |      4 bytes
             0b10             |      8 bytes
             0b11             |     12 bytes

    &#34;&#34;&#34;
    return (instruction &amp; 0b00000011) &lt;&lt; 2</code></pre>
</details>
</dd>
<dt id="egse.spw.rmap_crc_check"><code class="name flex">
<span>def <span class="ident">rmap_crc_check</span></span>(<span>data, start, length) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the checksum for the given data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_crc_check(data, start, length) -&gt; int:
    &#34;&#34;&#34;Calculate the checksum for the given data.&#34;&#34;&#34;
    return crc_calc(data, start, length)</code></pre>
</details>
</dd>
<dt id="egse.spw.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>data: <a title="egse.spw.DataPacketType" href="#egse.spw.DataPacketType">DataPacketType</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a 'user-oriented' string representation of the SpW DataPacketType.</p>
<p>The purpose of this function is to represent the N-FEE information in a user-oriented way.
That means for certain values that they will be converted into the form the a user understands
and that may be different or reverse from the original N-FEE definition. An example is the
CCD number which is different from the user perspective with respect to the N-FEE.</p>
<p>If any other object type is passed, the data.<strong>str</strong>() method will be returned without
processing or conversion.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a DataPacketType</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(data: Union[DataPacketType]) -&gt; str:
    &#34;&#34;&#34;Returns a &#39;user-oriented&#39; string representation of the SpW DataPacketType.

    The purpose of this function is to represent the N-FEE information in a user-oriented way.
    That means for certain values that they will be converted into the form the a user understands
    and that may be different or reverse from the original N-FEE definition. An example is the
    CCD number which is different from the user perspective with respect to the N-FEE.

    If any other object type is passed, the data.__str__() method will be returned without
    processing or conversion.

    Args:
        data: a DataPacketType
    &#34;&#34;&#34;
    from egse.fee import n_fee_mode
    n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

    if isinstance(data, DataPacketType):
        try:
            ccd_bin_to_id = GlobalState.setup.camera.fee.ccd_numbering.CCD_BIN_TO_ID
        except AttributeError:
            raise SetupError(&#34;No entry in the setup for camera.fee.ccd_numbering.CCD_BIN_TO_ID&#34;)
        return (
            f&#34;mode:{n_fee_mode(data.mode).name}, last_packet:{data.last_packet}, &#34;
            f&#34;CCD side:{n_fee_side(data.ccd_side).name}, CCD number:&#34;
            f&#34;{ccd_bin_to_id[data.ccd_number]}, &#34;
            f&#34;Frame number:{data.frame_number}, Packet Type:{PacketType(data.packet_type).name}&#34;
        )
    else:
        return data.__str__()</code></pre>
</details>
</dd>
<dt id="egse.spw.update_transaction_identifier"><code class="name flex">
<span>def <span class="ident">update_transaction_identifier</span></span>(<span>tid: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the transaction identifier and returns the new value.</p>
<p>FIXME: document more about this identifier, where is it used, when is it checked,
when does it need to be incremented, who initializes the identifier and
who updates it, &hellip;</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>The current transaction identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the updated transaction identifier (int).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_transaction_identifier(tid: int) -&gt; int:
    &#34;&#34;&#34;
    Updates the transaction identifier and returns the new value.

    FIXME: document more about this identifier, where is it used, when is it checked,
           when does it need to be incremented, who initializes the identifier and
           who updates it, ...

    Args:
        tid (int): The current transaction identifier

    Returns:
        the updated transaction identifier (int).
    &#34;&#34;&#34;
    tid = (tid + 1) &amp; 0xFFFF
    return tid</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.spw.CheckError"><code class="flex name class">
<span>class <span class="ident">CheckError</span></span>
<span>(</span><span>message, status)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when a check fails and you want to pass a status values along with the message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckError(RMAPError):
    &#34;&#34;&#34;
    Raised when a check fails and you want to pass a status values along with the message.
    &#34;&#34;&#34;

    def __init__(self, message, status):
        self.message = message
        self.status = status</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.RMAPError" href="#egse.spw.RMAPError">RMAPError</a></li>
<li><a title="egse.exceptions.Error" href="exceptions.html#egse.exceptions.Error">Error</a></li>
<li><a title="egse.exceptions.CommonEGSEException" href="exceptions.html#egse.exceptions.CommonEGSEException">CommonEGSEException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.spw.DataDataPacket"><code class="flex name class">
<span>class <span class="ident">DataDataPacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Proprietary Data Packet for N-FEE and F-FEE CCD image data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataDataPacket(DataPacket):
    &#34;&#34;&#34;Proprietary Data Packet for N-FEE and F-FEE CCD image data.&#34;&#34;&#34;

    @classmethod
    def is_data_data_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        if len(data) &lt;= 10:
            return False
        if data[0] != 0x50:
            return False
        if data[1] != 0xF0:
            return False
        type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        if type_.packet_type == PacketType.DATA_PACKET:
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.DataDataPacket.is_data_data_packet"><code class="name flex">
<span>def <span class="ident">is_data_data_packet</span></span>(<span>data: Union[bytes, numpy.ndarray]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_data_data_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
    if len(data) &lt;= 10:
        return False
    if data[0] != 0x50:
        return False
    if data[1] != 0xF0:
        return False
    type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
    if type_.packet_type == PacketType.DATA_PACKET:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.DataPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
<li><code><a title="egse.spw.DataPacket.data_as_ndarray" href="#egse.spw.DataPacket.data_as_ndarray">data_as_ndarray</a></code></li>
<li><code><a title="egse.spw.DataPacket.length" href="#egse.spw.DataPacket.length">length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.DataPacket"><code class="flex name class">
<span>class <span class="ident">DataPacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for proprietary SpaceWire data packets that are exchanged between FEE and DPU.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class should not be instantiated directly. Use the SpaceWirePacket.create_packet()
factory method or the constructors of one of the sub-classes of this DataPacket class.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataPacket(SpaceWirePacket):
    &#34;&#34;&#34;
    Base class for proprietary SpaceWire data packets that are exchanged between FEE and DPU.

    .. note::
        This class should not be instantiated directly. Use the SpaceWirePacket.create_packet()
        factory method or the constructors of one of the sub-classes of this DataPacket class.
    &#34;&#34;&#34;

    DATA_HEADER_LENGTH = 10

    def __init__(self, data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Args:
            data: a bytes object or a numpy array
        &#34;&#34;&#34;
        if not self.is_data_packet(data):
            raise ValueError(
                f&#34;Can not create a DataPacket from the given data {[f&#39;0x{x:02x}&#39; for x in data]}&#34;
            )

        super().__init__(data)

        if (data[2] == 0x00 and data[3] == 0x00) or len(data) == self.DATA_HEADER_LENGTH:
            MODULE_LOGGER.warning(
                f&#34;SpaceWire data packet without data found, packet={[f&#39;0x{x:02x}&#39; for x in data]}&#34;
            )

        self._length = (data[2] &lt;&lt; 8) + data[3]

        if len(data) != self._length + self.DATA_HEADER_LENGTH:
            MODULE_LOGGER.warning(
                f&#34;The length of the data argument ({len(data)}) given to &#34;
                f&#34;the constructor of {self.__class__.__name__} (or sub-classes) is inconsistent &#34;
                f&#34;with the length data field ({self._length} + 10) in the packet header.&#34;
            )
            raise ValueError(
                f&#34;{self.__class__.__name__} header: data-length field ({self._length}) not &#34;
                f&#34;consistent with packet length ({len(data)}). Difference should be &#34;
                f&#34;{self.DATA_HEADER_LENGTH}.&#34;
            )

        self._type = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        self._data = None  # lazy loading of data from self._bytes

    @property
    def length(self) -&gt; int:
        &#34;&#34;&#34;Returns the data length in bytes.

        .. note:: length == len(data_nd_array) * 2
            This length property returns the length of the data area in bytes. This value is
            taken  from the header of the data packet. If you want to compare this with the size
            of the data_as_ndarray property, multiply the length by 2 because the data is 16-bit
            integers, not bytes.

        Returns:
            the size of the data area of the packet in bytes.
        &#34;&#34;&#34;
        return self._length

    @property
    def data_as_ndarray(self):
        &#34;&#34;&#34;
        Returns the data from this data packet as a 16-bit integer Numpy array.

        .. note::
            The data has been converted from the 8-bit packet data into 16-bit integers. That
            means the length of this data array will be half the length of the data field the
            packet, i.e. ``len(data) == length // 2``.
            The reason for this is that pixel data has a size of 16-bit.

        .. todo::
            check if the data-length of HK packets should also be a multiple of 16.

        Returns:
            data: Numpy array with the data from this packet (type is np.uint16)

        &#34;&#34;&#34;

        # We decided to lazy load/construct the data array. The reason is that the packet may be
        # created / transferred without the need to unpack the data field into a 16-bit numpy array.

        if self._data is None:
            # The data is in two&#39;s-complement. The most significant bit (msb) shall be inverted
            # according to Sampie Smit. That is done in the following line where the msb in each
            # byte on an even index is inverted.

            # data = [toggle_bit(b, 7) if not idx % 2 else b for idx, b in enumerate(self._bytes)]
            # data = bytearray(data)
            # data_1 = np.frombuffer(data, offset=10, dtype=&#39;&gt;u2&#39;)

            # Needs further confirmation, but the following line should have the same effect as
            # the previous three lines.
            data_2 = np.frombuffer(self._bytes, offset=10, dtype=&#39;&gt;i2&#39;) + TWOS_COMPLEMENT_OFFSET

            # Test if the results are identical, left the code in until we are fully confident
            # if diff := np.sum(np.cumsum(data_1 - data_2)):
            #     MODULE_LOGGER.info(f&#34;cumsum={diff}&#34;)

            self._data = data_2.astype(&#39;uint16&#39;)
        return self._data

    @property
    def data(self) -&gt; bytes:
        return self._bytes[10: 10 + self._length]

    @property
    def type(self) -&gt; DataPacketType:
        return self._type

    @property
    def frame_counter(self):
        return (self._bytes[6] &lt;&lt; 8) + self._bytes[7]

    @property
    def sequence_counter(self):
        return (self._bytes[8] &lt;&lt; 8) + self._bytes[9]

    @property
    def header(self) -&gt; DataPacketHeader:
        return DataPacketHeader(self.header_as_bytes())

    def header_as_bytes(self):
        return self._bytes[:10]

    @classmethod
    def is_data_packet(cls, data: np.ndarray) -&gt; bool:
        if len(data) &lt; 10 or data[0] != 0x50 or data[1] != 0xF0:
            return False
        return True

    def __str__(self):
        options = np.get_printoptions()
        np.set_printoptions(
            formatter={&#34;int&#34;: lambda x: f&#34;0x{x:04x}&#34;},
            threshold=super()._threshold,
            edgeitems=super()._edgeitems,
            linewidth=super()._linewidth,
        )
        msg = (
            f&#34;{self.__class__.__name__}:\n&#34;
            f&#34;  Logical Address = 0x{self.logical_address:02X}\n&#34;
            f&#34;  Protocol ID = 0x{self.protocol_id:02X}\n&#34;
            f&#34;  Length = {self.length}\n&#34;
            f&#34;  Type = {self._type}\n&#34;
            f&#34;  Frame Counter = {self.frame_counter}\n&#34;
            f&#34;  Sequence Counter = {self.sequence_counter}\n&#34;
            f&#34;  Data = \n{self.data}&#34;
        )
        np.set_printoptions(**options)
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.spw.DataDataPacket" href="#egse.spw.DataDataPacket">DataDataPacket</a></li>
<li><a title="egse.spw.HousekeepingPacket" href="#egse.spw.HousekeepingPacket">HousekeepingPacket</a></li>
<li><a title="egse.spw.OverscanDataPacket" href="#egse.spw.OverscanDataPacket">OverscanDataPacket</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.spw.DataPacket.DATA_HEADER_LENGTH"><code class="name">var <span class="ident">DATA_HEADER_LENGTH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.DataPacket.is_data_packet"><code class="name flex">
<span>def <span class="ident">is_data_packet</span></span>(<span>data: numpy.ndarray) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_data_packet(cls, data: np.ndarray) -&gt; bool:
    if len(data) &lt; 10 or data[0] != 0x50 or data[1] != 0xF0:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.DataPacket.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; bytes:
    return self._bytes[10: 10 + self._length]</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacket.data_as_ndarray"><code class="name">var <span class="ident">data_as_ndarray</span></code></dt>
<dd>
<div class="desc"><p>Returns the data from this data packet as a 16-bit integer Numpy array.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The data has been converted from the 8-bit packet data into 16-bit integers. That
means the length of this data array will be half the length of the data field the
packet, i.e. <code>len(data) == length // 2</code>.
The reason for this is that pixel data has a size of 16-bit.</p>
</div>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>check if the data-length of HK packets should also be a multiple of 16.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>Numpy array with the data from this packet (type is np.uint16)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_as_ndarray(self):
    &#34;&#34;&#34;
    Returns the data from this data packet as a 16-bit integer Numpy array.

    .. note::
        The data has been converted from the 8-bit packet data into 16-bit integers. That
        means the length of this data array will be half the length of the data field the
        packet, i.e. ``len(data) == length // 2``.
        The reason for this is that pixel data has a size of 16-bit.

    .. todo::
        check if the data-length of HK packets should also be a multiple of 16.

    Returns:
        data: Numpy array with the data from this packet (type is np.uint16)

    &#34;&#34;&#34;

    # We decided to lazy load/construct the data array. The reason is that the packet may be
    # created / transferred without the need to unpack the data field into a 16-bit numpy array.

    if self._data is None:
        # The data is in two&#39;s-complement. The most significant bit (msb) shall be inverted
        # according to Sampie Smit. That is done in the following line where the msb in each
        # byte on an even index is inverted.

        # data = [toggle_bit(b, 7) if not idx % 2 else b for idx, b in enumerate(self._bytes)]
        # data = bytearray(data)
        # data_1 = np.frombuffer(data, offset=10, dtype=&#39;&gt;u2&#39;)

        # Needs further confirmation, but the following line should have the same effect as
        # the previous three lines.
        data_2 = np.frombuffer(self._bytes, offset=10, dtype=&#39;&gt;i2&#39;) + TWOS_COMPLEMENT_OFFSET

        # Test if the results are identical, left the code in until we are fully confident
        # if diff := np.sum(np.cumsum(data_1 - data_2)):
        #     MODULE_LOGGER.info(f&#34;cumsum={diff}&#34;)

        self._data = data_2.astype(&#39;uint16&#39;)
    return self._data</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacket.frame_counter"><code class="name">var <span class="ident">frame_counter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_counter(self):
    return (self._bytes[6] &lt;&lt; 8) + self._bytes[7]</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacket.header"><code class="name">var <span class="ident">header</span> : <a title="egse.spw.DataPacketHeader" href="#egse.spw.DataPacketHeader">DataPacketHeader</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; DataPacketHeader:
    return DataPacketHeader(self.header_as_bytes())</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacket.length"><code class="name">var <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the data length in bytes.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;length == len(data_nd_array) * 2</p>
<p>This length property returns the length of the data area in bytes. This value is
taken
from the header of the data packet. If you want to compare this with the size
of the data_as_ndarray property, multiply the length by 2 because the data is 16-bit
integers, not bytes.</p>
</div>
<h2 id="returns">Returns</h2>
<p>the size of the data area of the packet in bytes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    &#34;&#34;&#34;Returns the data length in bytes.

    .. note:: length == len(data_nd_array) * 2
        This length property returns the length of the data area in bytes. This value is
        taken  from the header of the data packet. If you want to compare this with the size
        of the data_as_ndarray property, multiply the length by 2 because the data is 16-bit
        integers, not bytes.

    Returns:
        the size of the data area of the packet in bytes.
    &#34;&#34;&#34;
    return self._length</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacket.sequence_counter"><code class="name">var <span class="ident">sequence_counter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sequence_counter(self):
    return (self._bytes[8] &lt;&lt; 8) + self._bytes[9]</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacket.type"><code class="name">var <span class="ident">type</span> : <a title="egse.spw.DataPacketType" href="#egse.spw.DataPacketType">DataPacketType</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; DataPacketType:
    return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.spw.DataPacket.header_as_bytes"><code class="name flex">
<span>def <span class="ident">header_as_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header_as_bytes(self):
    return self._bytes[:10]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.SpaceWirePacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.DataPacketHeader"><code class="flex name class">
<span>class <span class="ident">DataPacketHeader</span></span>
<span>(</span><span>header_data: bytes = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the header of a data packet.</p>
<p>The full header can be retrieved as a bytes object with the <code>data_as_bytes()</code> method.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>logical_address: fixed value of
0x50</li>
<li>protocol_id: fixed value of 0xF0</li>
<li>length: length of the data part of the packet, i.e. the packet length - size of the header</li>
<li>type: data packet type as defined by DataPacketType</li>
<li>frame_counter:</li>
<li>sequence_counter: a packet sequence counter per CCD</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataPacketHeader:
    &#34;&#34;&#34;
    Defines the header of a data packet.

    The full header can be retrieved as a bytes object with the `data_as_bytes()` method.

    Properties:
      * logical_address: fixed value of  0x50
      * protocol_id: fixed value of 0xF0
      * length: length of the data part of the packet, i.e. the packet length - size of the header
      * type: data packet type as defined by DataPacketType
      * frame_counter:
      * sequence_counter: a packet sequence counter per CCD
    &#34;&#34;&#34;
    def __init__(self, header_data: bytes = None):
        self.header_data = bytearray(
            header_data or bytes([0x50, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))

        if len(self.header_data) != 10:
            raise ValueError(f&#34;The length of the header for a data packet shall be 10 bytes, &#34;
                             f&#34;got {len(self.header_data)}.&#34;)

        self.n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

    def data_as_bytes(self) -&gt; bytes:
        &#34;&#34;&#34;Returns the full header as a bytes object.&#34;&#34;&#34;
        return bytes(self.header_data)

    @property
    def logical_address(self) -&gt; int:
        return self.header_data[0]

    @logical_address.setter
    def logical_address(self, value: int):
        self.header_data[0] = value

    @property
    def protocol_id(self) -&gt; int:
        return self.header_data[1]

    @protocol_id.setter
    def protocol_id(self, value: int):
        self.header_data[1] = value

    @property
    def length(self) -&gt; int:
        return int.from_bytes(self.header_data[2:4], byteorder=&#39;big&#39;)

    @length.setter
    def length(self, value: int):
        self.header_data[2:4] = value.to_bytes(2, &#39;big&#39;)

    @property
    def type(self):
        return int.from_bytes(self.header_data[4:6], byteorder=&#39;big&#39;)

    @type.setter
    def type(self, value: Union[int, bytes, DataPacketType]):
        if isinstance(value, bytes):
            self.header_data[4:6] = value
        elif isinstance(value, DataPacketType):
            self.header_data[4:6] = value.value.to_bytes(2, &#39;big&#39;)
        else:
            self.header_data[4:6] = value.to_bytes(2, &#39;big&#39;)

    @property
    def type_as_object(self):
        return DataPacketType(self.type)

    @property
    def packet_type(self):
        return self.type_as_object.packet_type

    @packet_type.setter
    def packet_type(self, value: int):
        type_obj = self.type_as_object
        type_obj.packet_type = value
        self.type = type_obj

    @property
    def last_packet(self):
        return self.type_as_object.last_packet

    @last_packet.setter
    def last_packet(self, flag: bool):
        type_obj = self.type_as_object
        type_obj.last_packet = flag
        self.type = type_obj

    @property
    def frame_counter(self):
        return int.from_bytes(self.header_data[6:8], byteorder=&#39;big&#39;)

    @frame_counter.setter
    def frame_counter(self, value):
        self.header_data[6:8] = value.to_bytes(2, &#39;big&#39;)

    @property
    def sequence_counter(self):
        return int.from_bytes(self.header_data[8:10], byteorder=&#39;big&#39;)

    @sequence_counter.setter
    def sequence_counter(self, value):
        self.header_data[8:10] = value.to_bytes(2, &#39;big&#39;)

    def as_dict(self):
        from egse.fee import n_fee_mode

        data_packet_type = DataPacketType(self.type)
        return dict(
            logical_address=f&#34;0x{self.logical_address:02X}&#34;,
            protocol_id=f&#34;0x{self.protocol_id:02X}&#34;,
            length=self.length,
            type=f&#34;0x{self.type:04X}&#34;,
            frame_counter=self.frame_counter,
            sequence_counter=self.sequence_counter,
            packet_type=data_packet_type.packet_type,
            frame_number=data_packet_type.frame_number,
            ccd_number=data_packet_type.ccd_number,
            ccd_side=self.n_fee_side(data_packet_type.ccd_side).name,
            last_packet=data_packet_type.last_packet,
            mode=n_fee_mode(data_packet_type.mode).name,
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.DataPacketHeader.frame_counter"><code class="name">var <span class="ident">frame_counter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_counter(self):
    return int.from_bytes(self.header_data[6:8], byteorder=&#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.last_packet"><code class="name">var <span class="ident">last_packet</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_packet(self):
    return self.type_as_object.last_packet</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.length"><code class="name">var <span class="ident">length</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self) -&gt; int:
    return int.from_bytes(self.header_data[2:4], byteorder=&#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.logical_address"><code class="name">var <span class="ident">logical_address</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logical_address(self) -&gt; int:
    return self.header_data[0]</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.packet_type"><code class="name">var <span class="ident">packet_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def packet_type(self):
    return self.type_as_object.packet_type</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.protocol_id"><code class="name">var <span class="ident">protocol_id</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def protocol_id(self) -&gt; int:
    return self.header_data[1]</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.sequence_counter"><code class="name">var <span class="ident">sequence_counter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sequence_counter(self):
    return int.from_bytes(self.header_data[8:10], byteorder=&#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    return int.from_bytes(self.header_data[4:6], byteorder=&#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.type_as_object"><code class="name">var <span class="ident">type_as_object</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type_as_object(self):
    return DataPacketType(self.type)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.spw.DataPacketHeader.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self):
    from egse.fee import n_fee_mode

    data_packet_type = DataPacketType(self.type)
    return dict(
        logical_address=f&#34;0x{self.logical_address:02X}&#34;,
        protocol_id=f&#34;0x{self.protocol_id:02X}&#34;,
        length=self.length,
        type=f&#34;0x{self.type:04X}&#34;,
        frame_counter=self.frame_counter,
        sequence_counter=self.sequence_counter,
        packet_type=data_packet_type.packet_type,
        frame_number=data_packet_type.frame_number,
        ccd_number=data_packet_type.ccd_number,
        ccd_side=self.n_fee_side(data_packet_type.ccd_side).name,
        last_packet=data_packet_type.last_packet,
        mode=n_fee_mode(data_packet_type.mode).name,
    )</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketHeader.data_as_bytes"><code class="name flex">
<span>def <span class="ident">data_as_bytes</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the full header as a bytes object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_as_bytes(self) -&gt; bytes:
    &#34;&#34;&#34;Returns the full header as a bytes object.&#34;&#34;&#34;
    return bytes(self.header_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.spw.DataPacketType"><code class="flex name class">
<span>class <span class="ident">DataPacketType</span></span>
<span>(</span><span>data_type: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the Data Packet Field: Type, which is a bit-field of 16 bits.</p>
<h2 id="properties">Properties</h2>
<ul>
<li>value: returns the data type as an integer</li>
<li>packet_type: the type of data packet, defined in PacketType enum.</li>
<li>mode: the FEE mode, defined in n_fee_mode and f_fee_mode enum</li>
<li>last_packet: flag which defines the last packet of a type in the current readout cycle</li>
<li>ccd_side: 0 for E-side (left), 1 for F-side (right), see egse.fee.fee_side</li>
<li>ccd_number: CCD number [0, 3]</li>
<li>frame_number: the frame number after sync</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataPacketType:
    &#34;&#34;&#34;
    Defines the Data Packet Field: Type, which is a bit-field of 16 bits.

    Properties:
      * value: returns the data type as an integer
      * packet_type: the type of data packet, defined in PacketType enum.
      * mode: the FEE mode, defined in n_fee_mode and f_fee_mode enum
      * last_packet: flag which defines the last packet of a type in the current readout cycle
      * ccd_side: 0 for E-side (left), 1 for F-side (right), see egse.fee.fee_side
      * ccd_number: CCD number [0, 3]
      * frame_number: the frame number after sync
    &#34;&#34;&#34;

    def __init__(self, data_type: int = 0):
        self._data_type: int = data_type
        # self.n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

    @property
    def value(self) -&gt; int:
        &#34;&#34;&#34;Returns the data packet type as an int.&#34;&#34;&#34;
        return self._data_type

    @property
    def packet_type(self):
        &#34;&#34;&#34;Returns the packet type: 0 = data packet, 1 = overscan data, 2 = housekeeping packet.&#34;&#34;&#34;
        return self._data_type &amp; 0b0011

    @packet_type.setter
    def packet_type(self, value):
        if not 0 &lt;= value &lt; 3:
            raise ValueError(f&#34;Packet Type can only have the value 0, 1, or 2, {value=} given.&#34;)
        x = self._data_type
        for idx, bit in enumerate([0, 1]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    @property
    def mode(self) -&gt; int:
        return (self._data_type &amp; 0b1111_0000_0000) &gt;&gt; 8

    @mode.setter
    def mode(self, value: int):
        x = self._data_type
        for idx, bit in enumerate([8, 9, 10, 11]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    @property
    def last_packet(self) -&gt; bool:
        return bool(self._data_type &amp; 0b1000_0000)

    @last_packet.setter
    def last_packet(self, flag: bool):
        self._data_type = set_bit(self._data_type, 7) if flag else clear_bit(self._data_type, 7)

    @property
    def ccd_side(self) -&gt; int:
        return (self._data_type &amp; 0b0100_0000) &gt;&gt; 6

    @ccd_side.setter
    def ccd_side(self, value: int):
        self._data_type = set_bit(self._data_type, 6) if value &amp; 0b0001 else clear_bit(self._data_type, 6)

    @property
    def ccd_number(self) -&gt; int:
        return (self._data_type &amp; 0b0011_0000) &gt;&gt; 4

    @ccd_number.setter
    def ccd_number(self, value):
        x = self._data_type
        for idx, bit in enumerate([4, 5]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    @property
    def frame_number(self) -&gt; int:
        return (self._data_type &amp; 0b1100) &gt;&gt; 2

    @frame_number.setter
    def frame_number(self, value):
        x = self._data_type
        for idx, bit in enumerate([2, 3]):
            x = set_bit(x, bit) if value &amp; (1 &lt;&lt; idx) else clear_bit(x, bit)
        self._data_type = x

    def __str__(self) -&gt; str:
        from egse.fee import n_fee_mode
        n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum

        return (
            f&#34;mode:{n_fee_mode(self.mode).name}, last_packet:{self.last_packet}, &#34;
            f&#34;CCD side:{n_fee_side(self.ccd_side).name}, CCD number:{self.ccd_number}, &#34;
            f&#34;Frame number:{self.frame_number}, Packet Type:{PacketType(self.packet_type).name}&#34;
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.DataPacketType.ccd_number"><code class="name">var <span class="ident">ccd_number</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ccd_number(self) -&gt; int:
    return (self._data_type &amp; 0b0011_0000) &gt;&gt; 4</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketType.ccd_side"><code class="name">var <span class="ident">ccd_side</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ccd_side(self) -&gt; int:
    return (self._data_type &amp; 0b0100_0000) &gt;&gt; 6</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketType.frame_number"><code class="name">var <span class="ident">frame_number</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame_number(self) -&gt; int:
    return (self._data_type &amp; 0b1100) &gt;&gt; 2</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketType.last_packet"><code class="name">var <span class="ident">last_packet</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_packet(self) -&gt; bool:
    return bool(self._data_type &amp; 0b1000_0000)</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketType.mode"><code class="name">var <span class="ident">mode</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self) -&gt; int:
    return (self._data_type &amp; 0b1111_0000_0000) &gt;&gt; 8</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketType.packet_type"><code class="name">var <span class="ident">packet_type</span></code></dt>
<dd>
<div class="desc"><p>Returns the packet type: 0 = data packet, 1 = overscan data, 2 = housekeeping packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def packet_type(self):
    &#34;&#34;&#34;Returns the packet type: 0 = data packet, 1 = overscan data, 2 = housekeeping packet.&#34;&#34;&#34;
    return self._data_type &amp; 0b0011</code></pre>
</details>
</dd>
<dt id="egse.spw.DataPacketType.value"><code class="name">var <span class="ident">value</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the data packet type as an int.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; int:
    &#34;&#34;&#34;Returns the data packet type as an int.&#34;&#34;&#34;
    return self._data_type</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.spw.HousekeepingPacket"><code class="flex name class">
<span>class <span class="ident">HousekeepingPacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Proprietary Housekeeping data packet for the N-FEE and F-FEE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HousekeepingPacket(DataPacket):
    &#34;&#34;&#34;Proprietary Housekeeping data packet for the N-FEE and F-FEE.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Args:
            data: a numpy array of type np.uint8 (not enforced)
        &#34;&#34;&#34;
        if not self.is_housekeeping_packet(data):
            raise ValueError(f&#34;Can not create a HousekeepingPacket from the given data {data}&#34;)

        # The __init__ method of DataPacket already checks e.g. data-length against packet length,
        # so there is no need for these tests here.

        super().__init__(data)

    @classmethod
    def is_housekeeping_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        if len(data) &lt;= 10:
            return False
        if data[0] != 0x50:
            return False
        if data[1] != 0xF0:
            return False
        type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        if type_.packet_type == PacketType.HOUSEKEEPING_DATA:
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.HousekeepingPacket.is_housekeeping_packet"><code class="name flex">
<span>def <span class="ident">is_housekeeping_packet</span></span>(<span>data: Union[bytes, numpy.ndarray]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_housekeeping_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
    if len(data) &lt;= 10:
        return False
    if data[0] != 0x50:
        return False
    if data[1] != 0xF0:
        return False
    type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
    if type_.packet_type == PacketType.HOUSEKEEPING_DATA:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.DataPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
<li><code><a title="egse.spw.DataPacket.data_as_ndarray" href="#egse.spw.DataPacket.data_as_ndarray">data_as_ndarray</a></code></li>
<li><code><a title="egse.spw.DataPacket.length" href="#egse.spw.DataPacket.length">length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.OverscanDataPacket"><code class="flex name class">
<span>class <span class="ident">OverscanDataPacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Proprietary Overscan Data Packet for N-FEE and F-FEE CCD image data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OverscanDataPacket(DataPacket):
    &#34;&#34;&#34;Proprietary Overscan Data Packet for N-FEE and F-FEE CCD image data.&#34;&#34;&#34;

    @classmethod
    def is_overscan_data_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        if len(data) &lt;= 10:
            return False
        if data[0] != 0x50:
            return False
        if data[1] != 0xF0:
            return False
        type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
        if type_.packet_type == PacketType.OVERSCAN_DATA:
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.OverscanDataPacket.is_overscan_data_packet"><code class="name flex">
<span>def <span class="ident">is_overscan_data_packet</span></span>(<span>data: Union[bytes, numpy.ndarray]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_overscan_data_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
    if len(data) &lt;= 10:
        return False
    if data[0] != 0x50:
        return False
    if data[1] != 0xF0:
        return False
    type_ = DataPacketType((data[4] &lt;&lt; 8) + data[5])
    if type_.packet_type == PacketType.OVERSCAN_DATA:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.DataPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
<li><code><a title="egse.spw.DataPacket.data_as_ndarray" href="#egse.spw.DataPacket.data_as_ndarray">data_as_ndarray</a></code></li>
<li><code><a title="egse.spw.DataPacket.length" href="#egse.spw.DataPacket.length">length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.PacketType"><code class="flex name class">
<span>class <span class="ident">PacketType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration type that defines the SpaceWire packet type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PacketType(IntEnum):
    &#34;&#34;&#34;Enumeration type that defines the SpaceWire packet type.&#34;&#34;&#34;

    DATA_PACKET = 0
    OVERSCAN_DATA = 1
    HOUSEKEEPING_DATA = 2  # N-FEE
    DEB_HOUSEKEEPING_DATA = 2  # F-FEE
    AEB_HOUSEKEEPING_DATA = 3  # F-FEE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.spw.PacketType.AEB_HOUSEKEEPING_DATA"><code class="name">var <span class="ident">AEB_HOUSEKEEPING_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.spw.PacketType.DATA_PACKET"><code class="name">var <span class="ident">DATA_PACKET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.spw.PacketType.DEB_HOUSEKEEPING_DATA"><code class="name">var <span class="ident">DEB_HOUSEKEEPING_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.spw.PacketType.HOUSEKEEPING_DATA"><code class="name">var <span class="ident">HOUSEKEEPING_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.spw.PacketType.OVERSCAN_DATA"><code class="name">var <span class="ident">OVERSCAN_DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="egse.spw.RMAPError"><code class="flex name class">
<span>class <span class="ident">RMAPError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An RMAP specific Error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RMAPError(Error):
    &#34;&#34;&#34;An RMAP specific Error.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.exceptions.Error" href="exceptions.html#egse.exceptions.Error">Error</a></li>
<li><a title="egse.exceptions.CommonEGSEException" href="exceptions.html#egse.exceptions.CommonEGSEException">CommonEGSEException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.spw.CheckError" href="#egse.spw.CheckError">CheckError</a></li>
</ul>
</dd>
<dt id="egse.spw.RMAPPacket"><code class="flex name class">
<span>class <span class="ident">RMAPPacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for RMAP SpaceWire packets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RMAPPacket(SpaceWirePacket):
    &#34;&#34;&#34;Base class for RMAP SpaceWire packets.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        if not self.is_rmap_packet(data):
            raise ValueError(f&#34;Can not create a RMAPPacket from the given data {data}&#34;)
        super().__init__(data)

    def __str__(self):
        return (
            f&#34;{self.__class__.__name__}:\n&#34;
            f&#34;  Logical Address = 0x{self.logical_address:02X}\n&#34;
            f&#34;  Data = {self.data}\n&#34;
        )

    @property
    def instruction(self):
        return get_instruction_field(self._bytes)

    @property
    def transaction_id(self):
        return get_transaction_identifier(self._bytes)

    @classmethod
    def is_rmap_packet(cls, data: Union[bytes, np.ndarray]):
        if data[1] == 0x01:  # Protocol ID
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.spw.ReadRequest" href="#egse.spw.ReadRequest">ReadRequest</a></li>
<li><a title="egse.spw.ReadRequestReply" href="#egse.spw.ReadRequestReply">ReadRequestReply</a></li>
<li><a title="egse.spw.WriteRequest" href="#egse.spw.WriteRequest">WriteRequest</a></li>
<li><a title="egse.spw.WriteRequestReply" href="#egse.spw.WriteRequestReply">WriteRequestReply</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.RMAPPacket.is_rmap_packet"><code class="name flex">
<span>def <span class="ident">is_rmap_packet</span></span>(<span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_rmap_packet(cls, data: Union[bytes, np.ndarray]):
    if data[1] == 0x01:  # Protocol ID
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.RMAPPacket.instruction"><code class="name">var <span class="ident">instruction</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def instruction(self):
    return get_instruction_field(self._bytes)</code></pre>
</details>
</dd>
<dt id="egse.spw.RMAPPacket.transaction_id"><code class="name">var <span class="ident">transaction_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transaction_id(self):
    return get_transaction_identifier(self._bytes)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.SpaceWirePacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.ReadRequest"><code class="flex name class">
<span>class <span class="ident">ReadRequest</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>A Read Request SpaceWire RMAP Packet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadRequest(RMAPPacket):
    &#34;&#34;&#34;A Read Request SpaceWire RMAP Packet.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    @classmethod
    def is_read_request(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x51:
            return False
        if data[2] == 0x4C and data[3] == 0xD1:
            return True
        return False

    @property
    def address(self):
        return get_address(self._bytes)

    @property
    def data_length(self):
        return get_data_length(self._bytes)

    def __str__(self):
        return (
            f&#34;Read Request: tid={self.transaction_id}, address=0x{self.address:04x}, &#34;
            f&#34;data length={self.data_length}&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.ReadRequest.is_read_request"><code class="name flex">
<span>def <span class="ident">is_read_request</span></span>(<span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_read_request(cls, data: Union[bytes, np.ndarray]):
    if not RMAPPacket.is_rmap_packet(data):
        return False
    if data[0] != 0x51:
        return False
    if data[2] == 0x4C and data[3] == 0xD1:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.ReadRequest.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self):
    return get_address(self._bytes)</code></pre>
</details>
</dd>
<dt id="egse.spw.ReadRequest.data_length"><code class="name">var <span class="ident">data_length</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_length(self):
    return get_data_length(self._bytes)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.RMAPPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.ReadRequestReply"><code class="flex name class">
<span>class <span class="ident">ReadRequestReply</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>An RMAP Reply packet to a Read Request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadRequestReply(RMAPPacket):
    &#34;&#34;&#34;An RMAP Reply packet to a Read Request.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    @classmethod
    def is_read_reply(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x50:
            return False
        if data[2] == 0x0C and data[4] == 0x51:
            return True

    @property
    def data(self) -&gt; bytes:
        return get_data(self._bytes)

    @property
    def data_length(self):
        return get_data_length(self._bytes)

    def __str__(self):
        data_length = self.data_length
        return f&#34;Read Request Reply: data length={data_length}, data={self.data[:20]} &#34; \
               f&#34;{&#39;(data is cut to max 20 bytes)&#39; if data_length &gt; 20 else &#39;&#39;}\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.ReadRequestReply.is_read_reply"><code class="name flex">
<span>def <span class="ident">is_read_reply</span></span>(<span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_read_reply(cls, data: Union[bytes, np.ndarray]):
    if not RMAPPacket.is_rmap_packet(data):
        return False
    if data[0] != 0x50:
        return False
    if data[2] == 0x0C and data[4] == 0x51:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.ReadRequestReply.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; bytes:
    return get_data(self._bytes)</code></pre>
</details>
</dd>
<dt id="egse.spw.ReadRequestReply.data_length"><code class="name">var <span class="ident">data_length</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_length(self):
    return get_data_length(self._bytes)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.RMAPPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.SpaceWireInterface"><code class="flex name class">
<span>class <span class="ident">SpaceWireInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>This interface defines methods that are used by the DPU to communicate with the FEE over
SpaceWire.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpaceWireInterface:
    &#34;&#34;&#34;
    This interface defines methods that are used by the DPU to communicate with the FEE over
    SpaceWire.
    &#34;&#34;&#34;

    def __enter__(self):
        self.connect()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect()

    def connect(self):
        raise NotImplementedError

    def disconnect(self):
        raise NotImplementedError

    def configure(self):
        raise NotImplementedError

    def flush(self):
        raise NotImplementedError

    def send_timecode(self, timecode: int):
        raise NotImplementedError

    def read_packet(self, timeout: int = None) -&gt; Tuple[int, bytes]:
        &#34;&#34;&#34;
        Read a full packet from the SpaceWire transport layer.

        Args:
            timeout (int): timeout in milliseconds [default=None]
        Returns:
            A tuple with the terminator value and a bytes object containing the packet.
        &#34;&#34;&#34;
        raise NotImplementedError

    def write_packet(self, packet: bytes):
        &#34;&#34;&#34;
        Write a full packet to the SpaceWire transport layer.

        Args:
            packet (bytes): a bytes object containing the SpaceWire packet

        Returns:
            None.
        &#34;&#34;&#34;
        raise NotImplementedError

    def read_register(self, address: int, length: int = 4, strict: bool = True) -&gt; bytes:
        &#34;&#34;&#34;
        Reads the data for the given register from the FEE memory map.

        This function sends an RMAP read request for the register to the FEE.

        Args:
            address: the start address (32-bit aligned) in the remote memory
            length: the number of bytes to read from the remote memory [default = 4]
            strict: perform strict checking of address and length

        Returns:
            data: the 32-bit data that was read from the FEE.
        &#34;&#34;&#34;
        raise NotImplementedError

    def write_register(self, address: int, data: bytes):
        &#34;&#34;&#34;
        Writes the data from the given register to the N-FEE memory map.

        The function reads the data for the registry from the local register map
        and then sends an RMAP write request for the register to the N-FEE.

        .. note:: it is assumed that the local register map is up-to-date.

        Args:
            address: the start address (32-bit aligned) in the remote memory
            data: the data that will be written into the remote memory

        Raises:
            RMAPError: when data can not be written on the target, i.e. the N-FEE.
        &#34;&#34;&#34;

        raise NotImplementedError

    def read_memory_map(self, address: int, size: int):
        &#34;&#34;&#34;
        Read (part of) the memory map from the N-FEE.

        Args:
            address: start address
            size: number of bytes to read

        Returns:
            a bytes object containing the requested memory map.
        &#34;&#34;&#34;

        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.dsi.spw.SpaceWireOverDSI" href="dsi/spw.html#egse.dsi.spw.SpaceWireOverDSI">SpaceWireOverDSI</a></li>
<li><a title="egse.zmq.spw.SpaceWireOverZeroMQ" href="zmq/spw.html#egse.zmq.spw.SpaceWireOverZeroMQ">SpaceWireOverZeroMQ</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.spw.SpaceWireInterface.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.read_memory_map"><code class="name flex">
<span>def <span class="ident">read_memory_map</span></span>(<span>self, address: int, size: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Read (part of) the memory map from the N-FEE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>start address</dd>
<dt><strong><code>size</code></strong></dt>
<dd>number of bytes to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a bytes object containing the requested memory map.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_memory_map(self, address: int, size: int):
    &#34;&#34;&#34;
    Read (part of) the memory map from the N-FEE.

    Args:
        address: start address
        size: number of bytes to read

    Returns:
        a bytes object containing the requested memory map.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.read_packet"><code class="name flex">
<span>def <span class="ident">read_packet</span></span>(<span>self, timeout: int = None) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Read a full packet from the SpaceWire transport layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>timeout in milliseconds [default=None]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with the terminator value and a bytes object containing the packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_packet(self, timeout: int = None) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Read a full packet from the SpaceWire transport layer.

    Args:
        timeout (int): timeout in milliseconds [default=None]
    Returns:
        A tuple with the terminator value and a bytes object containing the packet.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.read_register"><code class="name flex">
<span>def <span class="ident">read_register</span></span>(<span>self, address: int, length: int = 4, strict: bool = True) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the data for the given register from the FEE memory map.</p>
<p>This function sends an RMAP read request for the register to the FEE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>the start address (32-bit aligned) in the remote memory</dd>
<dt><strong><code>length</code></strong></dt>
<dd>the number of bytes to read from the remote memory [default = 4]</dd>
<dt><strong><code>strict</code></strong></dt>
<dd>perform strict checking of address and length</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>the 32-bit data that was read from the FEE.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_register(self, address: int, length: int = 4, strict: bool = True) -&gt; bytes:
    &#34;&#34;&#34;
    Reads the data for the given register from the FEE memory map.

    This function sends an RMAP read request for the register to the FEE.

    Args:
        address: the start address (32-bit aligned) in the remote memory
        length: the number of bytes to read from the remote memory [default = 4]
        strict: perform strict checking of address and length

    Returns:
        data: the 32-bit data that was read from the FEE.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.send_timecode"><code class="name flex">
<span>def <span class="ident">send_timecode</span></span>(<span>self, timecode: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_timecode(self, timecode: int):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.write_packet"><code class="name flex">
<span>def <span class="ident">write_packet</span></span>(<span>self, packet: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a full packet to the SpaceWire transport layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>bytes</code></dt>
<dd>a bytes object containing the SpaceWire packet</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_packet(self, packet: bytes):
    &#34;&#34;&#34;
    Write a full packet to the SpaceWire transport layer.

    Args:
        packet (bytes): a bytes object containing the SpaceWire packet

    Returns:
        None.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWireInterface.write_register"><code class="name flex">
<span>def <span class="ident">write_register</span></span>(<span>self, address: int, data: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the data from the given register to the N-FEE memory map.</p>
<p>The function reads the data for the registry from the local register map
and then sends an RMAP write request for the register to the N-FEE.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;it is assumed that the local register map is up-to-date.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong></dt>
<dd>the start address (32-bit aligned) in the remote memory</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data that will be written into the remote memory</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="egse.spw.RMAPError" href="#egse.spw.RMAPError">RMAPError</a></code></dt>
<dd>when data can not be written on the target, i.e. the N-FEE.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_register(self, address: int, data: bytes):
    &#34;&#34;&#34;
    Writes the data from the given register to the N-FEE memory map.

    The function reads the data for the registry from the local register map
    and then sends an RMAP write request for the register to the N-FEE.

    .. note:: it is assumed that the local register map is up-to-date.

    Args:
        address: the start address (32-bit aligned) in the remote memory
        data: the data that will be written into the remote memory

    Raises:
        RMAPError: when data can not be written on the target, i.e. the N-FEE.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.spw.SpaceWirePacket"><code class="flex name class">
<span>class <span class="ident">SpaceWirePacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for any packet transmitted over a SpaceWire cable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpaceWirePacket:
    &#34;&#34;&#34;Base class for any packet transmitted over a SpaceWire cable.&#34;&#34;&#34;

    # these settings are used by this class and its sub-classes to configure the print options
    # for the numpy arrays.

    _threshold = 300  # sys.maxsize
    _edgeitems = 10
    _linewidth = 120

    def __init__(self, data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Args:
            data: a bytes object or a numpy array of type np.uint8 (not enforced)
        &#34;&#34;&#34;
        self._bytes = bytes(data)

    def __repr__(self):
        options = np.get_printoptions()
        np.set_printoptions(
            formatter={&#34;int&#34;: lambda x: f&#34;0x{x:02x}&#34;},
            threshold=self._threshold,
            edgeitems=self._edgeitems,
            linewidth=self._linewidth,
        )
        msg = f&#34;{self.__class__.__name__}({self._bytes})&#34;
        np.set_printoptions(**options)
        return msg

    @property
    def packet_as_bytes(self):
        return self._bytes

    @property
    def packet_as_ndarray(self):
        return np.frombuffer(self._bytes, dtype=np.uint8)

    @property
    def logical_address(self):
        # TODO: what about a timecode, that has no logical address?
        return self._bytes[0]

    @property
    def protocol_id(self):
        # TODO: what about a timecode, that has no protocol id?
        return self._bytes[1]

    def header_as_bytes(self) -&gt; bytes:
        # TODO: what about timecode, this has no header, except maybe the first byte: 0x91
        raise NotImplementedError

    @staticmethod
    def create_packet(data: Union[bytes, np.ndarray]):
        &#34;&#34;&#34;
        Factory method that returns a SpaceWire packet of the correct type based on the information
        in the header.
        &#34;&#34;&#34;
        if TimecodePacket.is_timecode_packet(data):
            return TimecodePacket(data)
        if HousekeepingPacket.is_housekeeping_packet(data):
            return HousekeepingPacket(data)
        if DataDataPacket.is_data_data_packet(data):
            return DataDataPacket(data)
        if OverscanDataPacket.is_overscan_data_packet(data):
            return OverscanDataPacket(data)
        if WriteRequest.is_write_request(data):
            return WriteRequest(data)
        if WriteRequestReply.is_write_reply(data):
            return WriteRequestReply(data)
        if ReadRequest.is_read_request(data):
            return ReadRequest(data)
        if ReadRequestReply.is_read_reply(data):
            return ReadRequestReply(data)
        return SpaceWirePacket(data)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></li>
<li><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></li>
<li><a title="egse.spw.TimecodePacket" href="#egse.spw.TimecodePacket">TimecodePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.SpaceWirePacket.create_packet"><code class="name flex">
<span>def <span class="ident">create_packet</span></span>(<span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>Factory method that returns a SpaceWire packet of the correct type based on the information
in the header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_packet(data: Union[bytes, np.ndarray]):
    &#34;&#34;&#34;
    Factory method that returns a SpaceWire packet of the correct type based on the information
    in the header.
    &#34;&#34;&#34;
    if TimecodePacket.is_timecode_packet(data):
        return TimecodePacket(data)
    if HousekeepingPacket.is_housekeeping_packet(data):
        return HousekeepingPacket(data)
    if DataDataPacket.is_data_data_packet(data):
        return DataDataPacket(data)
    if OverscanDataPacket.is_overscan_data_packet(data):
        return OverscanDataPacket(data)
    if WriteRequest.is_write_request(data):
        return WriteRequest(data)
    if WriteRequestReply.is_write_reply(data):
        return WriteRequestReply(data)
    if ReadRequest.is_read_request(data):
        return ReadRequest(data)
    if ReadRequestReply.is_read_reply(data):
        return ReadRequestReply(data)
    return SpaceWirePacket(data)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.SpaceWirePacket.logical_address"><code class="name">var <span class="ident">logical_address</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logical_address(self):
    # TODO: what about a timecode, that has no logical address?
    return self._bytes[0]</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWirePacket.packet_as_bytes"><code class="name">var <span class="ident">packet_as_bytes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def packet_as_bytes(self):
    return self._bytes</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWirePacket.packet_as_ndarray"><code class="name">var <span class="ident">packet_as_ndarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def packet_as_ndarray(self):
    return np.frombuffer(self._bytes, dtype=np.uint8)</code></pre>
</details>
</dd>
<dt id="egse.spw.SpaceWirePacket.protocol_id"><code class="name">var <span class="ident">protocol_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def protocol_id(self):
    # TODO: what about a timecode, that has no protocol id?
    return self._bytes[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.spw.SpaceWirePacket.header_as_bytes"><code class="name flex">
<span>def <span class="ident">header_as_bytes</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header_as_bytes(self) -&gt; bytes:
    # TODO: what about timecode, this has no header, except maybe the first byte: 0x91
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.spw.TimecodePacket"><code class="flex name class">
<span>class <span class="ident">TimecodePacket</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>A Timecode Packet.</p>
<p>This packet really is an extended packet which is generated by the Diagnostic SpaceWire
Interface (DSI) to forward a SpaceWire timecode over the Ethernet connection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimecodePacket(SpaceWirePacket):
    &#34;&#34;&#34;A Timecode Packet.

    This packet really is an extended packet which is generated by the Diagnostic SpaceWire
    Interface (DSI) to forward a SpaceWire timecode over the Ethernet connection.
    &#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    @property
    def timecode(self) -&gt; int:
        return self._bytes[1] &amp; 0x3F

    def header_as_bytes(self) -&gt; bytes:
        return self._bytes[0:1]

    @classmethod
    def is_timecode_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
        return data[0] == 0x91

    def __str__(self):
        return f&#34;Timecode Packet: timecode = 0x{self.timecode:x}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.TimecodePacket.is_timecode_packet"><code class="name flex">
<span>def <span class="ident">is_timecode_packet</span></span>(<span>data: Union[bytes, numpy.ndarray]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_timecode_packet(cls, data: Union[bytes, np.ndarray]) -&gt; bool:
    return data[0] == 0x91</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.TimecodePacket.timecode"><code class="name">var <span class="ident">timecode</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timecode(self) -&gt; int:
    return self._bytes[1] &amp; 0x3F</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.spw.TimecodePacket.header_as_bytes"><code class="name flex">
<span>def <span class="ident">header_as_bytes</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header_as_bytes(self) -&gt; bytes:
    return self._bytes[0:1]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.SpaceWirePacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.WriteRequest"><code class="flex name class">
<span>class <span class="ident">WriteRequest</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>A Write Request SpaceWire RMAP Packet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WriteRequest(RMAPPacket):
    &#34;&#34;&#34;A Write Request SpaceWire RMAP Packet.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)

    def is_verified(self):
        return self._bytes[2] == 0x7C

    def is_unverified(self):
        return self._bytes[2] == 0x6C

    @property
    def address(self):
        return get_address(self._bytes)

    @property
    def data_length(self):
        return get_data_length(self._bytes)

    @property
    def data(self) -&gt; bytes:
        return get_data(self._bytes)

    @classmethod
    def is_write_request(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x51:
            return False
        if (data[2] == 0x7C or data[2] == 0x6C) and data[3] == 0xD1:
            return True
        return False

    def __str__(self):
        prefix = &#34;Verified&#34; if self.is_verified() else &#34;Unverified&#34;
        return f&#34;{prefix} Write Request: {self.transaction_id=}, data=0x{self.data.hex()}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.WriteRequest.is_write_request"><code class="name flex">
<span>def <span class="ident">is_write_request</span></span>(<span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_write_request(cls, data: Union[bytes, np.ndarray]):
    if not RMAPPacket.is_rmap_packet(data):
        return False
    if data[0] != 0x51:
        return False
    if (data[2] == 0x7C or data[2] == 0x6C) and data[3] == 0xD1:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.WriteRequest.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self):
    return get_address(self._bytes)</code></pre>
</details>
</dd>
<dt id="egse.spw.WriteRequest.data"><code class="name">var <span class="ident">data</span> : bytes</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; bytes:
    return get_data(self._bytes)</code></pre>
</details>
</dd>
<dt id="egse.spw.WriteRequest.data_length"><code class="name">var <span class="ident">data_length</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_length(self):
    return get_data_length(self._bytes)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.spw.WriteRequest.is_unverified"><code class="name flex">
<span>def <span class="ident">is_unverified</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_unverified(self):
    return self._bytes[2] == 0x6C</code></pre>
</details>
</dd>
<dt id="egse.spw.WriteRequest.is_verified"><code class="name flex">
<span>def <span class="ident">is_verified</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_verified(self):
    return self._bytes[2] == 0x7C</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.RMAPPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.spw.WriteRequestReply"><code class="flex name class">
<span>class <span class="ident">WriteRequestReply</span></span>
<span>(</span><span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"><p>An RMAP Reply packet to a Write Request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>a bytes object or a numpy array of type np.uint8 (not enforced)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WriteRequestReply(RMAPPacket):
    &#34;&#34;&#34;An RMAP Reply packet to a Write Request.&#34;&#34;&#34;

    def __init__(self, data: Union[bytes, np.ndarray]):
        super().__init__(data)
        self._status = data[3]

    @classmethod
    def is_write_reply(cls, data: Union[bytes, np.ndarray]):
        if not RMAPPacket.is_rmap_packet(data):
            return False
        if data[0] != 0x50:
            return False
        if (data[2] == 0x3C or data[2] == 0x2C) and data[4] == 0x51:
            return True

    @property
    def status(self):
        return self._status

    def __str__(self):
        return f&#34;Write Request Reply: status={self.status}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></li>
<li><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.spw.WriteRequestReply.is_write_reply"><code class="name flex">
<span>def <span class="ident">is_write_reply</span></span>(<span>data: Union[bytes, numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_write_reply(cls, data: Union[bytes, np.ndarray]):
    if not RMAPPacket.is_rmap_packet(data):
        return False
    if data[0] != 0x50:
        return False
    if (data[2] == 0x3C or data[2] == 0x2C) and data[4] == 0x51:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.spw.WriteRequestReply.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self):
    return self._status</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.spw.RMAPPacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.spw.check_address_and_data_length" href="#egse.spw.check_address_and_data_length">check_address_and_data_length</a></code></li>
<li><code><a title="egse.spw.check_data_crc" href="#egse.spw.check_data_crc">check_data_crc</a></code></li>
<li><code><a title="egse.spw.check_header_crc" href="#egse.spw.check_header_crc">check_header_crc</a></code></li>
<li><code><a title="egse.spw.create_rmap_read_request_packet" href="#egse.spw.create_rmap_read_request_packet">create_rmap_read_request_packet</a></code></li>
<li><code><a title="egse.spw.create_rmap_read_request_reply_packet" href="#egse.spw.create_rmap_read_request_reply_packet">create_rmap_read_request_reply_packet</a></code></li>
<li><code><a title="egse.spw.create_rmap_unverified_write_packet" href="#egse.spw.create_rmap_unverified_write_packet">create_rmap_unverified_write_packet</a></code></li>
<li><code><a title="egse.spw.create_rmap_verified_write_packet" href="#egse.spw.create_rmap_verified_write_packet">create_rmap_verified_write_packet</a></code></li>
<li><code><a title="egse.spw.create_rmap_write_request_reply_packet" href="#egse.spw.create_rmap_write_request_reply_packet">create_rmap_write_request_reply_packet</a></code></li>
<li><code><a title="egse.spw.get_address" href="#egse.spw.get_address">get_address</a></code></li>
<li><code><a title="egse.spw.get_data" href="#egse.spw.get_data">get_data</a></code></li>
<li><code><a title="egse.spw.get_data_length" href="#egse.spw.get_data_length">get_data_length</a></code></li>
<li><code><a title="egse.spw.get_instruction_field" href="#egse.spw.get_instruction_field">get_instruction_field</a></code></li>
<li><code><a title="egse.spw.get_protocol_id" href="#egse.spw.get_protocol_id">get_protocol_id</a></code></li>
<li><code><a title="egse.spw.get_reply_address_field_length" href="#egse.spw.get_reply_address_field_length">get_reply_address_field_length</a></code></li>
<li><code><a title="egse.spw.get_transaction_identifier" href="#egse.spw.get_transaction_identifier">get_transaction_identifier</a></code></li>
<li><code><a title="egse.spw.is_command" href="#egse.spw.is_command">is_command</a></code></li>
<li><code><a title="egse.spw.is_increment" href="#egse.spw.is_increment">is_increment</a></code></li>
<li><code><a title="egse.spw.is_read" href="#egse.spw.is_read">is_read</a></code></li>
<li><code><a title="egse.spw.is_reply" href="#egse.spw.is_reply">is_reply</a></code></li>
<li><code><a title="egse.spw.is_reply_required" href="#egse.spw.is_reply_required">is_reply_required</a></code></li>
<li><code><a title="egse.spw.is_reserved" href="#egse.spw.is_reserved">is_reserved</a></code></li>
<li><code><a title="egse.spw.is_verify" href="#egse.spw.is_verify">is_verify</a></code></li>
<li><code><a title="egse.spw.is_write" href="#egse.spw.is_write">is_write</a></code></li>
<li><code><a title="egse.spw.reply_address_length" href="#egse.spw.reply_address_length">reply_address_length</a></code></li>
<li><code><a title="egse.spw.rmap_crc_check" href="#egse.spw.rmap_crc_check">rmap_crc_check</a></code></li>
<li><code><a title="egse.spw.to_string" href="#egse.spw.to_string">to_string</a></code></li>
<li><code><a title="egse.spw.update_transaction_identifier" href="#egse.spw.update_transaction_identifier">update_transaction_identifier</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.spw.CheckError" href="#egse.spw.CheckError">CheckError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.spw.DataDataPacket" href="#egse.spw.DataDataPacket">DataDataPacket</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.DataDataPacket.is_data_data_packet" href="#egse.spw.DataDataPacket.is_data_data_packet">is_data_data_packet</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.DataPacket" href="#egse.spw.DataPacket">DataPacket</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.spw.DataPacket.DATA_HEADER_LENGTH" href="#egse.spw.DataPacket.DATA_HEADER_LENGTH">DATA_HEADER_LENGTH</a></code></li>
<li><code><a title="egse.spw.DataPacket.data" href="#egse.spw.DataPacket.data">data</a></code></li>
<li><code><a title="egse.spw.DataPacket.data_as_ndarray" href="#egse.spw.DataPacket.data_as_ndarray">data_as_ndarray</a></code></li>
<li><code><a title="egse.spw.DataPacket.frame_counter" href="#egse.spw.DataPacket.frame_counter">frame_counter</a></code></li>
<li><code><a title="egse.spw.DataPacket.header" href="#egse.spw.DataPacket.header">header</a></code></li>
<li><code><a title="egse.spw.DataPacket.header_as_bytes" href="#egse.spw.DataPacket.header_as_bytes">header_as_bytes</a></code></li>
<li><code><a title="egse.spw.DataPacket.is_data_packet" href="#egse.spw.DataPacket.is_data_packet">is_data_packet</a></code></li>
<li><code><a title="egse.spw.DataPacket.length" href="#egse.spw.DataPacket.length">length</a></code></li>
<li><code><a title="egse.spw.DataPacket.sequence_counter" href="#egse.spw.DataPacket.sequence_counter">sequence_counter</a></code></li>
<li><code><a title="egse.spw.DataPacket.type" href="#egse.spw.DataPacket.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.DataPacketHeader" href="#egse.spw.DataPacketHeader">DataPacketHeader</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.spw.DataPacketHeader.as_dict" href="#egse.spw.DataPacketHeader.as_dict">as_dict</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.data_as_bytes" href="#egse.spw.DataPacketHeader.data_as_bytes">data_as_bytes</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.frame_counter" href="#egse.spw.DataPacketHeader.frame_counter">frame_counter</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.last_packet" href="#egse.spw.DataPacketHeader.last_packet">last_packet</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.length" href="#egse.spw.DataPacketHeader.length">length</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.logical_address" href="#egse.spw.DataPacketHeader.logical_address">logical_address</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.packet_type" href="#egse.spw.DataPacketHeader.packet_type">packet_type</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.protocol_id" href="#egse.spw.DataPacketHeader.protocol_id">protocol_id</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.sequence_counter" href="#egse.spw.DataPacketHeader.sequence_counter">sequence_counter</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.type" href="#egse.spw.DataPacketHeader.type">type</a></code></li>
<li><code><a title="egse.spw.DataPacketHeader.type_as_object" href="#egse.spw.DataPacketHeader.type_as_object">type_as_object</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.DataPacketType" href="#egse.spw.DataPacketType">DataPacketType</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.spw.DataPacketType.ccd_number" href="#egse.spw.DataPacketType.ccd_number">ccd_number</a></code></li>
<li><code><a title="egse.spw.DataPacketType.ccd_side" href="#egse.spw.DataPacketType.ccd_side">ccd_side</a></code></li>
<li><code><a title="egse.spw.DataPacketType.frame_number" href="#egse.spw.DataPacketType.frame_number">frame_number</a></code></li>
<li><code><a title="egse.spw.DataPacketType.last_packet" href="#egse.spw.DataPacketType.last_packet">last_packet</a></code></li>
<li><code><a title="egse.spw.DataPacketType.mode" href="#egse.spw.DataPacketType.mode">mode</a></code></li>
<li><code><a title="egse.spw.DataPacketType.packet_type" href="#egse.spw.DataPacketType.packet_type">packet_type</a></code></li>
<li><code><a title="egse.spw.DataPacketType.value" href="#egse.spw.DataPacketType.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.HousekeepingPacket" href="#egse.spw.HousekeepingPacket">HousekeepingPacket</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.HousekeepingPacket.is_housekeeping_packet" href="#egse.spw.HousekeepingPacket.is_housekeeping_packet">is_housekeeping_packet</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.OverscanDataPacket" href="#egse.spw.OverscanDataPacket">OverscanDataPacket</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.OverscanDataPacket.is_overscan_data_packet" href="#egse.spw.OverscanDataPacket.is_overscan_data_packet">is_overscan_data_packet</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.PacketType" href="#egse.spw.PacketType">PacketType</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.PacketType.AEB_HOUSEKEEPING_DATA" href="#egse.spw.PacketType.AEB_HOUSEKEEPING_DATA">AEB_HOUSEKEEPING_DATA</a></code></li>
<li><code><a title="egse.spw.PacketType.DATA_PACKET" href="#egse.spw.PacketType.DATA_PACKET">DATA_PACKET</a></code></li>
<li><code><a title="egse.spw.PacketType.DEB_HOUSEKEEPING_DATA" href="#egse.spw.PacketType.DEB_HOUSEKEEPING_DATA">DEB_HOUSEKEEPING_DATA</a></code></li>
<li><code><a title="egse.spw.PacketType.HOUSEKEEPING_DATA" href="#egse.spw.PacketType.HOUSEKEEPING_DATA">HOUSEKEEPING_DATA</a></code></li>
<li><code><a title="egse.spw.PacketType.OVERSCAN_DATA" href="#egse.spw.PacketType.OVERSCAN_DATA">OVERSCAN_DATA</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.RMAPError" href="#egse.spw.RMAPError">RMAPError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.spw.RMAPPacket" href="#egse.spw.RMAPPacket">RMAPPacket</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.RMAPPacket.instruction" href="#egse.spw.RMAPPacket.instruction">instruction</a></code></li>
<li><code><a title="egse.spw.RMAPPacket.is_rmap_packet" href="#egse.spw.RMAPPacket.is_rmap_packet">is_rmap_packet</a></code></li>
<li><code><a title="egse.spw.RMAPPacket.transaction_id" href="#egse.spw.RMAPPacket.transaction_id">transaction_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.ReadRequest" href="#egse.spw.ReadRequest">ReadRequest</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.ReadRequest.address" href="#egse.spw.ReadRequest.address">address</a></code></li>
<li><code><a title="egse.spw.ReadRequest.data_length" href="#egse.spw.ReadRequest.data_length">data_length</a></code></li>
<li><code><a title="egse.spw.ReadRequest.is_read_request" href="#egse.spw.ReadRequest.is_read_request">is_read_request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.ReadRequestReply" href="#egse.spw.ReadRequestReply">ReadRequestReply</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.ReadRequestReply.data" href="#egse.spw.ReadRequestReply.data">data</a></code></li>
<li><code><a title="egse.spw.ReadRequestReply.data_length" href="#egse.spw.ReadRequestReply.data_length">data_length</a></code></li>
<li><code><a title="egse.spw.ReadRequestReply.is_read_reply" href="#egse.spw.ReadRequestReply.is_read_reply">is_read_reply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.SpaceWireInterface" href="#egse.spw.SpaceWireInterface">SpaceWireInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.spw.SpaceWireInterface.configure" href="#egse.spw.SpaceWireInterface.configure">configure</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.connect" href="#egse.spw.SpaceWireInterface.connect">connect</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.disconnect" href="#egse.spw.SpaceWireInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.flush" href="#egse.spw.SpaceWireInterface.flush">flush</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.read_memory_map" href="#egse.spw.SpaceWireInterface.read_memory_map">read_memory_map</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.read_packet" href="#egse.spw.SpaceWireInterface.read_packet">read_packet</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.read_register" href="#egse.spw.SpaceWireInterface.read_register">read_register</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.send_timecode" href="#egse.spw.SpaceWireInterface.send_timecode">send_timecode</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.write_packet" href="#egse.spw.SpaceWireInterface.write_packet">write_packet</a></code></li>
<li><code><a title="egse.spw.SpaceWireInterface.write_register" href="#egse.spw.SpaceWireInterface.write_register">write_register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.SpaceWirePacket" href="#egse.spw.SpaceWirePacket">SpaceWirePacket</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.spw.SpaceWirePacket.create_packet" href="#egse.spw.SpaceWirePacket.create_packet">create_packet</a></code></li>
<li><code><a title="egse.spw.SpaceWirePacket.header_as_bytes" href="#egse.spw.SpaceWirePacket.header_as_bytes">header_as_bytes</a></code></li>
<li><code><a title="egse.spw.SpaceWirePacket.logical_address" href="#egse.spw.SpaceWirePacket.logical_address">logical_address</a></code></li>
<li><code><a title="egse.spw.SpaceWirePacket.packet_as_bytes" href="#egse.spw.SpaceWirePacket.packet_as_bytes">packet_as_bytes</a></code></li>
<li><code><a title="egse.spw.SpaceWirePacket.packet_as_ndarray" href="#egse.spw.SpaceWirePacket.packet_as_ndarray">packet_as_ndarray</a></code></li>
<li><code><a title="egse.spw.SpaceWirePacket.protocol_id" href="#egse.spw.SpaceWirePacket.protocol_id">protocol_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.TimecodePacket" href="#egse.spw.TimecodePacket">TimecodePacket</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.TimecodePacket.header_as_bytes" href="#egse.spw.TimecodePacket.header_as_bytes">header_as_bytes</a></code></li>
<li><code><a title="egse.spw.TimecodePacket.is_timecode_packet" href="#egse.spw.TimecodePacket.is_timecode_packet">is_timecode_packet</a></code></li>
<li><code><a title="egse.spw.TimecodePacket.timecode" href="#egse.spw.TimecodePacket.timecode">timecode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.WriteRequest" href="#egse.spw.WriteRequest">WriteRequest</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.spw.WriteRequest.address" href="#egse.spw.WriteRequest.address">address</a></code></li>
<li><code><a title="egse.spw.WriteRequest.data" href="#egse.spw.WriteRequest.data">data</a></code></li>
<li><code><a title="egse.spw.WriteRequest.data_length" href="#egse.spw.WriteRequest.data_length">data_length</a></code></li>
<li><code><a title="egse.spw.WriteRequest.is_unverified" href="#egse.spw.WriteRequest.is_unverified">is_unverified</a></code></li>
<li><code><a title="egse.spw.WriteRequest.is_verified" href="#egse.spw.WriteRequest.is_verified">is_verified</a></code></li>
<li><code><a title="egse.spw.WriteRequest.is_write_request" href="#egse.spw.WriteRequest.is_write_request">is_write_request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.spw.WriteRequestReply" href="#egse.spw.WriteRequestReply">WriteRequestReply</a></code></h4>
<ul class="">
<li><code><a title="egse.spw.WriteRequestReply.is_write_reply" href="#egse.spw.WriteRequestReply.is_write_reply">is_write_reply</a></code></li>
<li><code><a title="egse.spw.WriteRequestReply.status" href="#egse.spw.WriteRequestReply.status">status</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
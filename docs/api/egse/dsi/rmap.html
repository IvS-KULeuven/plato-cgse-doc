<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.dsi.rmap API documentation</title>
<meta name="description" content="This module provides Python wrapper functions to (most of) the library functions from the C library ESL-RMAP.c …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.dsi.rmap</code></h1>
</header>
<section id="section-intro">
<p>This module provides Python wrapper functions to (most of) the library functions from the C library ESL-RMAP.c.</p>
<p>We use one single Exception specific for these wrapper functions. An RMAPError is thrown whenever the C function
returns an error from which we can not recover. This allows to cascade the python functions in a try: except: clause
making the code much more readable.</p>
<p>The C code depends heavily on a C structure which we had to re-define using the Structure class provided by ctypes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides Python wrapper functions to (most of) the library functions from the C library ESL-RMAP.c.

We use one single Exception specific for these wrapper functions. An RMAPError is thrown whenever the C function
returns an error from which we can not recover. This allows to cascade the python functions in a try: except: clause
making the code much more readable.

The C code depends heavily on a C structure which we had to re-define using the Structure class provided by ctypes.

&#34;&#34;&#34;

import ctypes
import logging
import struct
from contextlib import contextmanager
from ctypes import POINTER
from ctypes import Structure
from ctypes import c_char_p
from ctypes import c_int
from ctypes import c_ubyte
from ctypes import c_uint
from ctypes import c_ulonglong
from ctypes import c_void_p as c_int_p
from ctypes import cdll
from pathlib import Path
from typing import Tuple

import egse.dsi.constants as constants
from egse.config import find_file
from egse.dsi.constants import esl_rmap_error_codes
from egse.dsi.esl import esl_flush
from egse.dsi.esl import esl_get_product_string
from egse.dsi.esl import esl_p
from egse.dsi.esl import esl_read_packet
from egse.dsi.esl import esl_write_packet
from egse.dsi.esl import pretty_print_packet
from egse.settings import Settings
from egse.system import get_os_name
from egse.system import get_os_version

logger = logging.getLogger(__name__)

dsi_settings = Settings.load(&#34;DSI&#34;)

# Maintain a transmit and receive buffer

rxbuf = ctypes.create_string_buffer(dsi_settings.RX_BUFFER_LENGTH)
txbuf = ctypes.create_string_buffer(dsi_settings.TX_BUFFER_LENGTH)

# Initialize the status variable which is a c pointer that is set by the library routines to
# pass a status.

status = c_int(0)
status_p = ctypes.pointer(status)

# NOTE: These memory areas are currently equal for N-FEE and F-FEE. Don&#39;t know if this will
#       change in the future.

CRITICAL_AREA_START = 0x0000_0000
CRITICAL_AREA_END = 0x0000_00FC
GENERAL_AREA_START = 0x0000_0100
GENERAL_AREA_END = 0x0000_06FC
HK_AREA_START = 0x0000_0700
HK_AREA_END = 0x0000_07FC
WINDOWING_AREA_START = 0x0080_0000
WINDOWING_AREA_END = 0x00FF_FFFC


class ESL_RMAP(Structure):
    _fields_ = [
        (&#34;spw_device&#34;,                esl_p),
        (&#34;target_key&#34;,                c_ubyte),
        (&#34;target_logical_address&#34;,    c_ubyte),
        (&#34;target_spw_address&#34;,        c_ubyte * 12),
        (&#34;target_spw_address_len&#34;,    c_int),
        (&#34;reply_spw_address&#34;,         c_ubyte * 12),
        (&#34;reply_spw_address_len&#34;,     c_int),
        (&#34;initiator_logical_address&#34;, c_ubyte),
        (&#34;transaction_identifier&#34;,    c_uint),
        (&#34;ESL_RMAP_error&#34;,            c_int)
    ]


rmap_p = POINTER(ESL_RMAP)


class RMAPError(Exception):
    pass


# Depending on the OS, and the OS version, we load the dynamic library from a specific location
# Only some OS/OS-version combinations are supported.

if get_os_name() == &#39;macos&#39;:
    in_dir = &#39;lib/macOS&#39;
elif get_os_name() == &#39;debian&#39;:
    in_dir = &#39;lib/Debian&#39;
elif get_os_name() == &#39;centos&#39;:
    in_dir = &#39;lib/CentOS-7&#39; if get_os_version().startswith(&#39;7&#39;) else &#39;lib/CentOS-8&#39;
elif get_os_name() == &#39;ubuntu&#39;:
    in_dir = &#39;lib/Ubuntu-20&#39; if get_os_version().startswith(&#39;20&#39;) else &#39;lib/Linux&#39;
else:
    in_dir = None

dylib_filename = Path(dsi_settings.RMAP_DYLIB_FILENAME)

logger.debug(f&#34;Locating shared library {dylib_filename} in dir &#39;{in_dir}&#39;&#34;)

dylib_filename = find_file(dylib_filename, in_dir=in_dir)

logger.debug(f&#34;Loading shared library: {dylib_filename}&#34;)

if not dylib_filename:
    raise FileNotFoundError(f&#34;Could not find dynamic library: {dylib_filename}&#34;)

librmap = cdll.LoadLibrary(dylib_filename)

# Mapping of functions.
# Please note that when there is no need to wrap the C library function, we do not take the burden

librmap_open                                = librmap.ESL_RMAP_open
librmap_open.argtypes                       = [esl_p]
librmap_open.restype                        = rmap_p

librmap_set_verbosity                       = librmap.ESL_RMAP_set_verbosity
librmap_set_verbosity.argtypes              = [c_int]

librmap_get_target_key                      = librmap.ESL_RMAP_get_target_key
librmap_get_target_key.argtypes             = [rmap_p]
librmap_get_target_key.restype              = c_ubyte

librmap_set_target_key                      = librmap.ESL_RMAP_set_target_key
librmap_set_target_key.argtypes             = [rmap_p, c_ubyte]

librmap_get_target_logical_address          = librmap.ESL_RMAP_get_target_logical_address
librmap_get_target_logical_address.argtypes = [rmap_p]
librmap_get_target_logical_address.restype  = c_ubyte

librmap_set_target_logical_address          = librmap.ESL_RMAP_set_target_logical_address
librmap_set_target_logical_address.argtypes = [rmap_p, c_ubyte]

librmap_set_target_spw_address              = librmap.ESL_RMAP_set_target_spw_address
librmap_set_target_spw_address.argtypes     = [rmap_p, c_char_p, c_int]

librmap_get_initiator_logical_address          = librmap.ESL_RMAP_get_initiator_logical_address
librmap_get_initiator_logical_address.argtypes = [rmap_p]
librmap_get_initiator_logical_address.restype  = c_ubyte

librmap_set_initiator_logical_address          = librmap.ESL_RMAP_set_initiator_logical_address
librmap_set_initiator_logical_address.argtypes = [rmap_p, c_ubyte]

librmap_crc_check                           = librmap.RMAP_crc_check
librmap_crc_check.argtypes                  = [c_char_p, c_uint, c_uint]
librmap_crc_check.restype                   = c_uint

librmap_read                                = librmap.ESL_RMAP_read
librmap_read.argtypes                       = [rmap_p, c_ulonglong, c_char_p, c_uint, c_int_p]
librmap_read.restype                        = c_int

librmap_read_TO                             = librmap.ESL_RMAP_read_TO
librmap_read_TO.argtypes                    = [rmap_p, c_ulonglong, c_char_p, c_uint, c_int_p, c_int]
librmap_read_TO.restype                     = c_int

librmap_write                                = librmap.ESL_RMAP_write
librmap_write.argtypes                       = [rmap_p, c_ulonglong, c_char_p, c_uint, c_int_p]
librmap_write.restype                        = c_int


@contextmanager
def rmap_connection(esl_link):
    &#34;&#34;&#34;
    Context manager that opens an RMAP connection on the EtherSpaceLink ESL.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        an RMAP link connection
    &#34;&#34;&#34;
    yield rmap_open_connection(esl_link)


def rmap_open_connection(esl_link):

    logger.info(f&#34;Open and setup RMAP connection to {esl_get_product_string(esl_link)}&#34;)

    rmap_link = librmap_open(esl_link)
    if not rmap_link:
        raise RMAPError(f&#34;Couldn&#39;t open RMAP connection to {esl_get_product_string(esl_link)}&#34;)

    rmap_set_verbosity(1)     # 1=normal; 5 or 15 for lots of debugging

    logger.info(&#34;RMAP connection opened successfully.&#34;)

    return rmap_link


def rmap_configure(rmap_link: ESL_RMAP, initiator_logical_address,
                   target_key=constants.RMAP_TARGET_KEY,
                   target_logical_address=constants.RMAP_TARGET_LOGICAL_ADDRESS_DEFAULT):
    &#34;&#34;&#34;
    Configure the RMAP EtherSpaceWire link.

    Args:
        rmap_link: the RMAP link connection
        initiator_logical_address: logical address of the SpaceWire node that starts the transaction
        target_key: the key field used for command authorisation
        target_logical_address: logical address of the target node (default: 0xFE)

    Returns:
        Nothing

    &#34;&#34;&#34;
    rmap_set_initiator_logical_address(rmap_link, initiator_logical_address)
    rmap_set_target_key(rmap_link, target_key)
    rmap_set_target_logical_address(rmap_link, target_logical_address)
    rmap_set_target_spw_address(rmap_link, b&#39;\x00&#39;, 0)


# FIXME: Is this code rmap_read() still needed? We now have rmap_read_request()
#        which handles everything this code does, except it doesn&#39;t use the ESL_RMAP
#        dynamic library!

def rmap_read(rmap_link: ESL_RMAP, address: int, length: int, timeout: int = 1000):
    &#34;&#34;&#34;
    Read `length` bytes from the remote memory starting at `address`. If there is no reply
    after the given `timeout`, TODO: WHAT WILL HAPPEN THEN?

    .. note:: We are using the global ``rxbuf`` read buffer here.
        The content of the buffer will be overwritten by the RMAP read request.

    Args:
        rmap_link: the RMAP link connection
        address: the start address (32-bit aligned) in the remote memory
        length: the number of bytes to read from the remote memory
        timeout: timeout in milli-seconds

    Returns:
        the buffer containing the data read from the remote memory.

    &#34;&#34;&#34;

    data_length = librmap_read_TO(rmap_link, address, rxbuf, length, status_p, timeout)

    # If data_length &lt; 0 it can have the following values:
    # -1 = status was != 0 indicating a read error, the packet was eaten...discarded?
    # -4 = wrong TLA field in header
    # -5 = wrong TID field in header

    # FIXME: Think about if we should raise an RMAPError here instead of returning None when result is negative.
    #        I would go for an Exception, since we loose the information on the error anyway as code information (
    #        None is returned, not data_length), and now the caller must check the return code from this read command.

    if data_length &lt; 0:
        logger.warning(
            f&#34;Couldn&#39;t read data within timeout of {timeout} ms, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} &#34;
            f&#34;[{rmap_link.contents.ESL_RMAP_error}]&#34;
        )
        return None
    else:
        return rxbuf[:data_length]


def rmap_read_request(rmap_link: ESL_RMAP, address: int, length: int, timeout: int = 1000) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Read `length` bytes from the remote memory starting at `address`.

    .. todo:: the timeout parameter is currently not implemented

    Args:
        rmap_link: the RMAP link connection
        address: the start address (32-bit aligned) in the remote memory
        length: the number of bytes to read from the remote memory
        timeout: timeout in milli-seconds

    Returns:
        A tuple containing the terminator value and the RMAP Reply packet with the data read from the remote memory.

    &#34;&#34;&#34;
    buffer = create_rmap_read_request_packet(rmap_link, address, length)

    logger.log(5, &#34;Pretty Print Read Request Packet:\n&#34; + pretty_print_packet(buffer))

    result = esl_write_packet(rmap_link.contents.spw_device, buffer, len(buffer), constants.ESL_EOP)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data within timeout of {timeout} ms, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    result = esl_flush(rmap_link.contents.spw_device)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data or clear buffers, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    # Read the read request reply

    terminator, rx_buffer = esl_read_packet(rmap_link.contents.spw_device)

    logger.log(5, &#34;Pretty Print Read Request Reply Packet:\n&#34; + pretty_print_packet(rx_buffer))

    return terminator, rx_buffer


def rmap_write_request(rmap_link: ESL_RMAP,
                       address: int, data: bytes, length: int = 4, timeout: int = 1000) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Sends an RMAP write command over the SpaceWire link.

    Based on the address this function will decided to send a verified or unverified write request.

    .. todo:: the timeout parameter is currently not implemented

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection
        address: the starting memory address to which the data from buffer will be written
        data: the data that will be written into the targets memory
        length: the number of bytes to write (the buffer maybe longer) [default=4]
        timeout: timeout in milliseconds [default=1000]

    Returns:
        return_code: zero (0) on success.

    Raises:
        RMAPError: when data can not be written on the target.

    &#34;&#34;&#34;

    if CRITICAL_AREA_START &lt;= address &lt;= CRITICAL_AREA_END:
        buffer = create_rmap_verified_write_packet(rmap_link, address, data)
    else:
        buffer = create_rmap_unverified_write_packet(rmap_link, address, data, length)

    logger.log(5, &#34;Pretty Print Write Request Packet:\n&#34; + pretty_print_packet(buffer))

    result = esl_write_packet(rmap_link.contents.spw_device, buffer, len(buffer), constants.ESL_EOP)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data within timeout of {timeout} ms, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    result = esl_flush(rmap_link.contents.spw_device)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data or clear buffers, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    # Read the write reply

    terminator, rx_buffer = esl_read_packet(rmap_link.contents.spw_device)

    logger.log(5, &#34;Pretty Print Write Request Reply Packet:\n&#34; + pretty_print_packet(rx_buffer))

    return terminator, rx_buffer


def create_rmap_read_request_packet(rmap_link: ESL_RMAP, address: int, length: int) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Creates an RMAP Read Request SpaceWire packet.

    The read request is an RMAP command that read a number of bytes from the FEE register memory.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Address shall be within the 0x0000_0000 and 0x00FF_FFFC. The memory map (register) is divided
    in the following areas:

        0x0000_0000 - 0x0000_00FC   Critical Configuration Area (verified write)
        0x0000_0100 - 0x0000_06FC   General Configuration Area (unverified write)
        0x0000_0700 - 0x0000_07FC   Housekeeping area
        0x0000_0800 - 0x007F_FFFC   Not Supported
        0x0080_0000 - 0x00FF_FFFC   Windowing Area (unverified write)
        0x0010_0000 - 0xFFFF_FFFC   Not Supported

    All read requests to the critical area shall have a fixed data length of 4 bytes.
    All read requests to a general area shall have a maximum data length of 256 bytes.
    All read requests to the housekeeping area shall have a maximum data length of 256 bytes.
    All read requests to the windowing area shall have a maximum data length of 4096 bytes.

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection
        address (int): the FEE register memory address
        length (int): the data length

    Returns:
        a bytes array containing the full RMAP Read Request packet.
    &#34;&#34;&#34;

    check_address_and_data_length(address, length)

    buf = ctypes.create_string_buffer(16)

    # The transaction identifier shall be incremented for each read request

    tid = update_transaction_identifier(rmap_link)

    # NOTE: The first bytes would each carry the target SpW address or a destination port,
    #       but this is not used for point-to-point connections, so we&#39;re safe.

    buf[0] = 0x51  # Target N-FEE or F-FEE
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = 0x4C  # Instruction: 0b1001100, RMAP Request, Read, Incrementing address, reply address = 0
    buf[3] = 0xD1  # Destination Key
    buf[4] = 0x50  # Initiator is always the DPU
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[7] = 0x00                     # Extended address is not used
    buf[8] = (address &gt;&gt; 24) &amp; 0xFF   # address (MSB)
    buf[9] = (address &gt;&gt; 16) &amp; 0xFF   # address
    buf[10] = (address &gt;&gt; 8) &amp; 0xFF   # address
    buf[11] = address &amp; 0xFF          # address (LSB)
    buf[12] = (length &gt;&gt; 16) &amp; 0xFF   # data length (MSB)
    buf[13] = (length &gt;&gt; 8) &amp; 0xFF    # data length
    buf[14] = length &amp; 0xFF           # data length (LSB)
    buf[15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF
    return buf


def create_rmap_write_reply_packet(rmap_link: ESL_RMAP) -&gt; ctypes.Array:
    pass


def create_rmap_read_reply_packet(rmap_link: ESL_RMAP, instruction_field: int, tid: int, status: int,
                                  buffer: bytes, buffer_length: int) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Creates an RMAP Reply to a RMAP Read Request packet.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection
        instruction_field (int): the instruction field of the RMAP read request packet
        tid (int): the transaction identifier of the read request packet
        status (int): shall be 0 if the read request was successful, contain an error code otherwise.
        TODO: which error code?
        buffer (bytes): the data that was read as indicated by the read request
        buffer_length (int): the data length

    Returns:
        packet: a ctypes Array containing the full RMAP Reply packet.
    &#34;&#34;&#34;

    buf = ctypes.create_string_buffer(12 + buffer_length + 1)

    buf[0] = 0x50  # Initiator address N-DPU or F-DPU
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = instruction_field &amp; 0x3F  # Clear the command bit as this is a reply
    buf[3] = status &amp; 0xFF  # Status field: 0 on success
    buf[4] = 0x51  # Target address is always the N-FEE or F-FEE
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[7] = 0x00                     # Reserved
    buf[8] = (buffer_length &gt;&gt; 16) &amp; 0xFF    # data length (MSB)
    buf[9] = (buffer_length &gt;&gt; 8) &amp; 0xFF     # data length
    buf[10] = buffer_length &amp; 0xFF           # data length (LSB)
    buf[11] = rmap_crc_check(buf, 0, 11) &amp; 0xFF  # Header CRC

    # Note that we assume here that len(buffer) == buffer_length.

    if len(buffer) != buffer_length:
        logger.warning(
            f&#34;While creating an RMAP read reply packet, the length of the buffer ({len(buffer)}) not equals &#34;
            f&#34;the buffer_length ({buffer_length})&#34;
        )

    for idx, value in enumerate(buffer):
        buf[12+idx] = value

    buf[12 + buffer_length] = rmap_crc_check(buf, 12, 12 + buffer_length) &amp; 0xFF  # data CRC

    return buf


def create_rmap_verified_write_packet(rmap_link: ESL_RMAP, address: int, data: bytes) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Create an RMAP packet for a verified write request on the FEE. The length of the data is by convention always 4
    bytes and therefore not passed as an argument.

    Args:
        rmap_link: the RMAP link structure
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address [4 bytes]

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    if len(data) &lt; 4:
        raise ValueError(f&#34;The data argument should be at least 4 bytes, but it is only {len(data)} bytes.&#34;)

    if address &gt; CRITICAL_AREA_END:
        raise ValueError(f&#34;The address range for critical configuration is [0x00 - 0xFC].&#34;)

    tid = update_transaction_identifier(rmap_link)

    # Buffer length is fixed at 24 bytes since the data length is fixed at 4 bytes (32 bit addressing)

    buf = ctypes.create_string_buffer(21)
    offset = 0

    # The values below are taken from the PLATO N-FEE to N-DPU Interface Requirements Document [PLATO-DLR-PL-ICD-0010]

    buf[offset+0] = 0x51  # Logical Address
    buf[offset+1] = 0x01  # Protocol ID
    buf[offset+2] = 0x7C  # Instruction
    buf[offset+3] = 0xD1  # Key
    buf[offset+4] = 0x50  # Initiator Address
    buf[offset+5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[offset+6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[offset+7] = 0x00                     # Extended address
    buf[offset+8] = (address &gt;&gt; 24) &amp; 0xFF   # address (MSB)
    buf[offset+9] = (address &gt;&gt; 16) &amp; 0xFF   # address
    buf[offset+10] = (address &gt;&gt; 8) &amp; 0xFF   # address
    buf[offset+11] = address &amp; 0xFF          # address (LSB)
    buf[offset+12] = 0x00                    # data length (MSB)
    buf[offset+13] = 0x00                    # data length
    buf[offset+14] = 0x04                    # data length (LSB)
    buf[offset+15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC
    buf[offset+16] = data[0]
    buf[offset+17] = data[1]
    buf[offset+18] = data[2]
    buf[offset+19] = data[3]
    buf[offset+20] = rmap_crc_check(buf, 16, 4) &amp; 0xFF  # data CRC

    return buf


def create_rmap_unverified_write_packet(rmap_link: ESL_RMAP, address: int, data: bytes, length: int) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Create an RMAP packet for a unverified write request on the FEE.

    Args:
        rmap_link: the RMAP link structure
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address
        length: the length of the data

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    # We can only handle data for which the length &gt;= the given length argument.

    if len(data) &lt; length:
        raise ValueError(
            f&#34;The length of the data argument ({len(data)}) is smaller than &#34;
            f&#34;the given length argument ({length}).&#34;
        )

    if len(data) &gt; length:
        logger.warning(
            f&#34;The length of the data argument ({len(data)}) is larger than &#34;
            f&#34;the given length argument ({length}). The data will be truncated &#34;
            f&#34;when copied into the packet.&#34;
        )

    if address &lt;= CRITICAL_AREA_END:
        raise ValueError(f&#34;The given address (0x{address:08X}) is in the range for critical configuration is [0x00 - &#34;
                         f&#34;0xFC]. Use the verified write function for this.&#34;)

    tid = update_transaction_identifier(rmap_link)

    # Buffer length is fixed at 24 bytes since the data length is fixed at 4 bytes (32 bit addressing)

    buf = ctypes.create_string_buffer(16 + length + 1)
    offset = 0

    buf[offset+0] = 0x51  # Logical Address
    buf[offset+1] = 0x01  # Protocol ID
    buf[offset+2] = 0x6C  # Instruction
    buf[offset+3] = 0xD1  # Key
    buf[offset+4] = 0x50  # Initiator Address
    buf[offset+5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[offset+6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[offset+7] = 0x00                     # Extended address
    buf[offset+8] = (address &gt;&gt; 24) &amp; 0xFF   # address (MSB)
    buf[offset+9] = (address &gt;&gt; 16) &amp; 0xFF   # address
    buf[offset+10] = (address &gt;&gt; 8) &amp; 0xFF   # address
    buf[offset+11] = address &amp; 0xFF          # address (LSB)
    buf[offset+12] = (length &gt;&gt; 16) &amp; 0xFF   # data length (MSB)
    buf[offset+13] = (length &gt;&gt; 8) &amp; 0xFF    # data length
    buf[offset+14] = length &amp; 0xFF           # data length (LSB)
    buf[offset+15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC

    offset = offset + 16

    for idx, value in enumerate(data):
        buf[offset+idx] = value

    buf[offset + length] = rmap_crc_check(buf, offset, length) &amp; 0xFF  # data CRC

    return buf


def rmap_set_verbosity(flags):
    &#34;&#34;&#34;
    Set vebosity of the RMAP API.

    Report errors by default:

    * bitval  1 : output textual error messages
    * bitval  2 : output SpaceWire read/write packet tracing
    * bitval  4 : output API function call tracing
    * bitval  8 : output API parameter  / data packet tracing
    * bitval 16 : output API data packet tracing

    Args:
        flags (int): verbosy level

    Returns:
        None

    &#34;&#34;&#34;
    librmap_set_verbosity(flags)


def rmap_get_target_key(rmap_link):
    logger.debug(&#34;Calling rmap_get_target_key(rmap_link)&#34;)
    return librmap_get_target_key(rmap_link)


def rmap_set_target_key(rmap_link, key):
    logger.debug(f&#34;Calling rmap_set_target_key({key})&#34;)
    librmap_set_target_key(rmap_link, key)


def rmap_get_target_logical_address(rmap_link):
    logger.debug(&#34;Calling rmap_get_target_logical_address(rmap_link)&#34;)
    return librmap_get_target_logical_address(rmap_link)


def rmap_set_target_logical_address(rmap_link, address):
    logger.debug(f&#34;Calling rmap_set_target_logical_address(rmap_link, 0x{address:02X})&#34;)
    librmap_set_target_logical_address(rmap_link, address)


def rmap_set_target_spw_address(rmap_link, spw_address, spw_address_length):
    logger.debug(f&#34;Calling rmap_set_target_spw_address(rmap_link, spw_address, {spw_address_length})&#34;)
    librmap_set_target_spw_address(rmap_link, spw_address, spw_address_length)


def rmap_get_initiator_logical_address(rmap_link):
    # logger.debug(&#34;Calling rmap_get_initiator_logical_address(rmap_link)&#34;)
    return librmap_get_initiator_logical_address(rmap_link)


def rmap_set_initiator_logical_address(rmap_link, address):
    # logger.debug(f&#34;Calling rmap_set_initiator_logical_address(rmap_link, 0x{address:02X})&#34;)
    librmap_set_initiator_logical_address(rmap_link, address)


def rmap_crc_check(data, start, length):
    # logger.debug(f&#34;Calling rmap_crc_check(data, {start}, {length})&#34;)
    return librmap_crc_check(data, start, length)


class CheckError(RMAPError):
    &#34;&#34;&#34;
    Raised when a check fails and you want to pass a status values along with the message.
    &#34;&#34;&#34;

    def __init__(self, message, status):
        self.message = message
        self.status  = status


def is_rmap(rx_buffer):
    return get_protocol_id(rx_buffer) == constants.RMAP_PROTOCOL_ID


# Functions to interpret the Instrument Field

def is_reserved(instruction):
    &#34;&#34;&#34;The reserved bit of the 2-bit packet type field from the instruction field.

    For PLATO this bit shall be zero as the 0b10 and 0b11 packet field values are reserved.

    Returns:
        bit value: 1 or 0.
    &#34;&#34;&#34;
    return (instruction &amp; 0b10000000) &gt;&gt; 7


def is_command(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b01000000) &gt;&gt; 6


def is_reply(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a reply to a previous command packet.&#34;&#34;&#34;
    return not is_command(instruction)


def is_write(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a write request command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b00100000) &gt;&gt; 5


def is_read(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a read request command packet.&#34;&#34;&#34;
    return not is_write(instruction)


def is_verify(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet needs to do a verify before write.&#34;&#34;&#34;
    return (instruction &amp; 0b00010000) &gt;&gt; 4


def is_reply_required(instruction):
    &#34;&#34;&#34;Returns True if the reply bit is set in the instruction field.

    Args:
        instruction (int): the instruction field of an RMAP packet

    .. note:: the name of this function might be confusing.

        This function does **not** test if the packet is a reply packet, but it checks
        if the command requests a reply from the target. If you need to test if the
        packet is a command or a reply, use the is_command() or is_reply() function.

    &#34;&#34;&#34;
    return (instruction &amp; 0b00001000) &gt;&gt; 3


def is_increment(instruction):
    &#34;&#34;&#34;Returns True if the data is written to sequential memory addresses.&#34;&#34;&#34;
    return (instruction &amp; 0b00000100) &gt;&gt; 2


def reply_address_length(instruction):
    &#34;&#34;&#34;Returns the content of the replay address length field.

    The size of the replay address field is then decoded from the following table:

        Address Field Length  |  Size of Address Field
        ----------------------+-----------------------
             0b00             |      0 bytes
             0b01             |      4 bytes
             0b10             |      8 bytes
             0b11             |     12 bytes

    &#34;&#34;&#34;
    return (instruction &amp; 0b00000011) &lt;&lt; 2

# Helper Functions ---------------------------------------------------------------------------------


def get_protocol_id(rx_buffer):
    return rx_buffer[1]


def get_reply_address_field_length(rx_buffer) -&gt; int:
    &#34;&#34;&#34;Returns the size of reply address field.

    This function returns the actual size of the reply address field. It doesn&#39;t return the content of the
    reply address length field. If you need that information, use the reply_address_length() function that work on
    the instruction field.

    Returns:
         length: the size of the reply address field.
    &#34;&#34;&#34;
    instruction = get_instruction_field(rx_buffer)
    return reply_address_length(instruction) * 4


def get_data(rxbuf) -&gt; bytes:
    &#34;&#34;&#34;Return the data from the RMAP packet.

    Raises:
        ValueError: if there is no data section in the packet (TODO: not yet implemented)
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16

    return rxbuf[offset + address_length:offset + address_length + data_length]


def check_data_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16
    idx = offset + address_length

    d_crc = rxbuf[idx + data_length]
    c_crc = rmap_crc_check(rxbuf, idx, data_length) &amp; 0xFF
    if d_crc != c_crc:
        raise CheckError(
            f&#34;Data CRC doesn&#39;t match calculated CRC, d_crc=0x{d_crc:02X} &amp; c_crc=0x{c_crc:02X}&#34;,
            constants.RMAP_GENERAL_ERROR
        )


def check_header_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    if is_command(instruction_field):
        offset = 15
    elif is_write(instruction_field):
        offset = 7
    else:
        offset = 11

    idx = offset + get_reply_address_field_length(rxbuf)
    h_crc = rxbuf[idx]
    c_crc = rmap_crc_check(rxbuf, 0, idx)
    if h_crc != c_crc:
        raise CheckError(&#34;Header CRC doesn&#39;t match calculated CRC, h_crc=0x{:X} &amp; c_crc=0x{:X}&#34;
                             .format(h_crc, c_crc), constants.RMAP_GENERAL_ERROR)


def get_data_length(rxbuf) -&gt; int:
    &#34;&#34;&#34;Returns the length of the data in bytes.

    Raises:
        TypeError: when this method is used on a Write Request Reply packet (which has no
            data length).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field) and is_write(instruction_field):
        raise TypeError(&#34;There is no data length field for Write Request Reply packets, &#34;
                        &#34;asking for the data length is an invalid operation.&#34;)

    offset = 12 if is_command(instruction_field) else 8
    idx = offset + get_reply_address_field_length(rxbuf)

    # We could use two alternative decoding methods here:
    #   int.from_bytes(rxbuf[idx:idx+3], byteorder=&#39;big&#39;)    (timeit=1.166s)
    #   struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx+3])[0]   (timeit=0.670s)
    data_length = struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx + 3])[0]
    return data_length


def get_address(rxbuf) -&gt; int:
    &#34;&#34;&#34;Returns the address field (including the extended address field if the address is 40-bits).

    Raises:
        TypeError: when this method is used on a Reply packet (which has no address field).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field):
        raise TypeError(&#34;There is no address field for Reply packets, asking for the address is &#34;
                        &#34;an invalid operation.&#34;)

    idx = 7 + get_reply_address_field_length(rxbuf)
    extended_address = rxbuf[idx]
    idx += 1
    address = struct.unpack(&#39;&gt;L&#39;, rxbuf[idx:idx + 4])[0]
    if extended_address:
        address = address + (extended_address &lt;&lt; 32)
    return address


def get_transaction_identifier(rxbuf):
    idx = 5 + get_reply_address_field_length(rxbuf)
    tid = struct.unpack(&#39;&gt;h&#39;, rxbuf[idx:idx + 2])[0]
    return tid


def get_initiator_logical_address(rxbuf):
    idx = 4 + get_reply_address_field_length(rxbuf)
    ila_rxbuf = rxbuf[idx]
    return ila_rxbuf


def check_initiator_logical_address(rxbuf, ila):
    ila_rxbuf = get_initiator_logical_address(rxbuf)
    if ila != ila_rxbuf:
        raise CheckError(
            f&#34;Initiator Logical Address doesn&#39;t match, ila=0x{ila:02X} &amp; ila_rxbuf=0x{ila_rxbuf:02X}&#34;,
            constants.RMAP_GENERAL_ERROR
        )


def check_key(rmap_link, rxbuf):
    idx = 3
    key = rmap_get_target_key(rmap_link)
    key_rxbuf = rxbuf[idx]
    if key != key_rxbuf:
        raise CheckError(
            f&#34;Key doesn&#39;t match, key={key} &amp; key_rxbuf={key_rxbuf}&#34;, constants.RMAP_INVALID_KEY
        )


def get_instruction_field(rxbuf):
    idx = 2
    return rxbuf[idx]


def check_instruction(rx_buffer) -&gt; None:
    &#34;&#34;&#34;
    Check the instruction field for inconsistencies and report the values in the logger at DEBUG level.


    Args:
        rx_buffer (bytes): The read buffer which contains the SpW packet

    Raises:
        CheckError: when the reserved bit is not zero,

    Returns:
        None.
    &#34;&#34;&#34;
    # The Instruction Field is the third byte (base=0) of the packet buffer.
    # Description of the Instruction Field can be found in ECSS-E-ST-50-52C.

    instruction = get_instruction_field(rx_buffer)
    if is_reserved(instruction):
        raise CheckError(
            f&#34;Instruction field [{instruction:08b}] reserved bit is not 0x00&#34;,
            constants.RMAP_NOT_IMPLEMENTED_AUTHORISED
        )

    msg = &#34;RMAP Instruction Field: &#34;
    msg += &#34;Command; &#34; if is_command(instruction) else &#34;Reply; &#34;
    msg += &#34;write; &#34; if is_write(instruction) else &#34;read; &#34;
    msg += &#34;verify; &#34; if is_verify(instruction) else &#34;don&#39;t verify; &#34;
    msg += &#34;reply; &#34; if is_reply_required(instruction) else &#34;don&#39;t reply; &#34;
    msg += &#34;increment; &#34; if is_increment(instruction) else &#34;no increment; &#34;

    logger.debug(msg)
    if reply_address_length(instruction):
        logger.debug(f&#34;Reply address length = {reply_address_length(instruction)} bytes.&#34;)


def check_protocol_id(rxbuf):
    idx = 1
    protocol_id = rxbuf[idx]
    if protocol_id != constants.RMAP_PROTOCOL_ID:
        raise CheckError(
            f&#34;Protocol id is not the expected value {protocol_id}, expected {constants.RMAP_PROTOCOL_ID}&#34;,
            constants.RMAP_GENERAL_ERROR)


def get_target_logical_address(rmap_link: ESL_RMAP, rxbuf: bytes) -&gt; int:
    tla_idx = 0
    tla_rxbuf = rxbuf[tla_idx]
    return tla_rxbuf


def check_target_logical_address(rmap_link, rxbuf, tla):
    tla_rxbuf = get_target_logical_address(rmap_link, rxbuf)
    if tla != tla_rxbuf:
        raise CheckError(
            f&#34;Target Logical Address doesn&#39;t match, tla=0x{tla:02X} &amp; rxbuf[0]=0x{tla_rxbuf:02X}&#34;,
            constants.RMAP_GENERAL_ERROR
        )


def update_transaction_identifier(rmap_link) -&gt; int:
    &#34;&#34;&#34;
    Updates the transaction identifier and returns the new value.

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection

    Returns:
        the updated transaction identifier (int).
    &#34;&#34;&#34;
    tid = rmap_link.contents.transaction_identifier
    tid = (tid + 1) &amp; 0xFFFF
    rmap_link.contents.transaction_identifier = tid
    return tid


def check_address_and_data_length(address: int, length: int) -&gt; None:
    &#34;&#34;&#34;
    Checks the address and length in the range of memory areas used by the FEE.

    The ranges are taken from the PLATO-DLR-PL-ICD-0010 N-FEE to N-DPU IRD.

    Args:
        address (int): the memory address of the FEE Register
        length (int): the number of bytes requested

    Raises:
        RMAPError: when address + length fall outside any specified area.
    &#34;&#34;&#34;

    # All these restrictions have been relaxed on the N-FEE.
    # We are returning here immediately instead of removing or commenting out the code.
    # These reason is that we can then bring back restriction easier and gradually.

    return

    if length % 4:
        raise RMAPError(&#34;The requested data length shall be a multiple of 4 bytes.&#34;, address, length)

    if address % 4:
        raise RMAPError(&#34;The address shall be a multiple of 4 bytes.&#34;, address, length)

    # Note that when checking the given data length, at the defined area end, we can still read 4 bytes.

    if CRITICAL_AREA_START &lt;= address &lt;= CRITICAL_AREA_END:
        if length != 4:
            raise RMAPError(&#34;Read requests to the critical area have a fixed data length of 4 bytes.&#34;,
                                address, length)

    elif GENERAL_AREA_START &lt;= address &lt;= GENERAL_AREA_END:
        if length &gt; 256:
            raise RMAPError(f&#34;Read requests to the general area have a maximum data length of 256 bytes.&#34;,
                                address, length)
        if address + length &gt; GENERAL_AREA_END + 4:
            raise RMAPError(
                f&#34;The requested data length for the general area is too large.\n&#34;
                f&#34;The address + length exceeds the general area boundaries.\n&#34;, address, length
            )

    elif HK_AREA_START &lt;= address &lt;= HK_AREA_END:
        if length &gt; 256:
            raise RMAPError(f&#34;Read requests to the housekeeping area have a maximum data length of 256 bytes.&#34;,
                                address, length)
        if address + length &gt; HK_AREA_END + 4:
            raise RMAPError(
                f&#34;The requested data length for the housekeeping area is too large.\n&#34;
                f&#34;The address + length exceeds the housekeeping area boundaries.\n&#34;, address, length
            )

    elif WINDOWING_AREA_START &lt;= address &lt;= WINDOWING_AREA_END:
        if length &gt; 4096:
            raise RMAPError(f&#34;Read requests to the windowing area have a maximum data length of 4096 bytes.&#34;,
                                address, length)
        if address + length &gt; WINDOWING_AREA_END + 4:
            raise RMAPError(
                f&#34;The requested data length for the windowing area is too large.\n&#34;
                f&#34;The address + length exceeds the windowing area boundaries.\n&#34;, address, length
            )

    else:
        raise RMAPError(f&#34;Register address for RMAP read requests is invalid.&#34;, address, length)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.dsi.rmap.check_address_and_data_length"><code class="name flex">
<span>def <span class="ident">check_address_and_data_length</span></span>(<span>address: int, length: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the address and length in the range of memory areas used by the FEE.</p>
<p>The ranges are taken from the PLATO-DLR-PL-ICD-0010 N-FEE to N-DPU IRD.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>the memory address of the FEE Register</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of bytes requested</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="egse.dsi.rmap.RMAPError" href="#egse.dsi.rmap.RMAPError">RMAPError</a></code></dt>
<dd>when address + length fall outside any specified area.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_address_and_data_length(address: int, length: int) -&gt; None:
    &#34;&#34;&#34;
    Checks the address and length in the range of memory areas used by the FEE.

    The ranges are taken from the PLATO-DLR-PL-ICD-0010 N-FEE to N-DPU IRD.

    Args:
        address (int): the memory address of the FEE Register
        length (int): the number of bytes requested

    Raises:
        RMAPError: when address + length fall outside any specified area.
    &#34;&#34;&#34;

    # All these restrictions have been relaxed on the N-FEE.
    # We are returning here immediately instead of removing or commenting out the code.
    # These reason is that we can then bring back restriction easier and gradually.

    return

    if length % 4:
        raise RMAPError(&#34;The requested data length shall be a multiple of 4 bytes.&#34;, address, length)

    if address % 4:
        raise RMAPError(&#34;The address shall be a multiple of 4 bytes.&#34;, address, length)

    # Note that when checking the given data length, at the defined area end, we can still read 4 bytes.

    if CRITICAL_AREA_START &lt;= address &lt;= CRITICAL_AREA_END:
        if length != 4:
            raise RMAPError(&#34;Read requests to the critical area have a fixed data length of 4 bytes.&#34;,
                                address, length)

    elif GENERAL_AREA_START &lt;= address &lt;= GENERAL_AREA_END:
        if length &gt; 256:
            raise RMAPError(f&#34;Read requests to the general area have a maximum data length of 256 bytes.&#34;,
                                address, length)
        if address + length &gt; GENERAL_AREA_END + 4:
            raise RMAPError(
                f&#34;The requested data length for the general area is too large.\n&#34;
                f&#34;The address + length exceeds the general area boundaries.\n&#34;, address, length
            )

    elif HK_AREA_START &lt;= address &lt;= HK_AREA_END:
        if length &gt; 256:
            raise RMAPError(f&#34;Read requests to the housekeeping area have a maximum data length of 256 bytes.&#34;,
                                address, length)
        if address + length &gt; HK_AREA_END + 4:
            raise RMAPError(
                f&#34;The requested data length for the housekeeping area is too large.\n&#34;
                f&#34;The address + length exceeds the housekeeping area boundaries.\n&#34;, address, length
            )

    elif WINDOWING_AREA_START &lt;= address &lt;= WINDOWING_AREA_END:
        if length &gt; 4096:
            raise RMAPError(f&#34;Read requests to the windowing area have a maximum data length of 4096 bytes.&#34;,
                                address, length)
        if address + length &gt; WINDOWING_AREA_END + 4:
            raise RMAPError(
                f&#34;The requested data length for the windowing area is too large.\n&#34;
                f&#34;The address + length exceeds the windowing area boundaries.\n&#34;, address, length
            )

    else:
        raise RMAPError(f&#34;Register address for RMAP read requests is invalid.&#34;, address, length)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_data_crc"><code class="name flex">
<span>def <span class="ident">check_data_crc</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_data_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16
    idx = offset + address_length

    d_crc = rxbuf[idx + data_length]
    c_crc = rmap_crc_check(rxbuf, idx, data_length) &amp; 0xFF
    if d_crc != c_crc:
        raise CheckError(
            f&#34;Data CRC doesn&#39;t match calculated CRC, d_crc=0x{d_crc:02X} &amp; c_crc=0x{c_crc:02X}&#34;,
            constants.RMAP_GENERAL_ERROR
        )</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_header_crc"><code class="name flex">
<span>def <span class="ident">check_header_crc</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_header_crc(rxbuf):
    instruction_field = get_instruction_field(rxbuf)
    if is_command(instruction_field):
        offset = 15
    elif is_write(instruction_field):
        offset = 7
    else:
        offset = 11

    idx = offset + get_reply_address_field_length(rxbuf)
    h_crc = rxbuf[idx]
    c_crc = rmap_crc_check(rxbuf, 0, idx)
    if h_crc != c_crc:
        raise CheckError(&#34;Header CRC doesn&#39;t match calculated CRC, h_crc=0x{:X} &amp; c_crc=0x{:X}&#34;
                             .format(h_crc, c_crc), constants.RMAP_GENERAL_ERROR)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_initiator_logical_address"><code class="name flex">
<span>def <span class="ident">check_initiator_logical_address</span></span>(<span>rxbuf, ila)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_initiator_logical_address(rxbuf, ila):
    ila_rxbuf = get_initiator_logical_address(rxbuf)
    if ila != ila_rxbuf:
        raise CheckError(
            f&#34;Initiator Logical Address doesn&#39;t match, ila=0x{ila:02X} &amp; ila_rxbuf=0x{ila_rxbuf:02X}&#34;,
            constants.RMAP_GENERAL_ERROR
        )</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_instruction"><code class="name flex">
<span>def <span class="ident">check_instruction</span></span>(<span>rx_buffer) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check the instruction field for inconsistencies and report the values in the logger at DEBUG level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rx_buffer</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The read buffer which contains the SpW packet</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="egse.dsi.rmap.CheckError" href="#egse.dsi.rmap.CheckError">CheckError</a></code></dt>
<dd>when the reserved bit is not zero,</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_instruction(rx_buffer) -&gt; None:
    &#34;&#34;&#34;
    Check the instruction field for inconsistencies and report the values in the logger at DEBUG level.


    Args:
        rx_buffer (bytes): The read buffer which contains the SpW packet

    Raises:
        CheckError: when the reserved bit is not zero,

    Returns:
        None.
    &#34;&#34;&#34;
    # The Instruction Field is the third byte (base=0) of the packet buffer.
    # Description of the Instruction Field can be found in ECSS-E-ST-50-52C.

    instruction = get_instruction_field(rx_buffer)
    if is_reserved(instruction):
        raise CheckError(
            f&#34;Instruction field [{instruction:08b}] reserved bit is not 0x00&#34;,
            constants.RMAP_NOT_IMPLEMENTED_AUTHORISED
        )

    msg = &#34;RMAP Instruction Field: &#34;
    msg += &#34;Command; &#34; if is_command(instruction) else &#34;Reply; &#34;
    msg += &#34;write; &#34; if is_write(instruction) else &#34;read; &#34;
    msg += &#34;verify; &#34; if is_verify(instruction) else &#34;don&#39;t verify; &#34;
    msg += &#34;reply; &#34; if is_reply_required(instruction) else &#34;don&#39;t reply; &#34;
    msg += &#34;increment; &#34; if is_increment(instruction) else &#34;no increment; &#34;

    logger.debug(msg)
    if reply_address_length(instruction):
        logger.debug(f&#34;Reply address length = {reply_address_length(instruction)} bytes.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_key"><code class="name flex">
<span>def <span class="ident">check_key</span></span>(<span>rmap_link, rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_key(rmap_link, rxbuf):
    idx = 3
    key = rmap_get_target_key(rmap_link)
    key_rxbuf = rxbuf[idx]
    if key != key_rxbuf:
        raise CheckError(
            f&#34;Key doesn&#39;t match, key={key} &amp; key_rxbuf={key_rxbuf}&#34;, constants.RMAP_INVALID_KEY
        )</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_protocol_id"><code class="name flex">
<span>def <span class="ident">check_protocol_id</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_protocol_id(rxbuf):
    idx = 1
    protocol_id = rxbuf[idx]
    if protocol_id != constants.RMAP_PROTOCOL_ID:
        raise CheckError(
            f&#34;Protocol id is not the expected value {protocol_id}, expected {constants.RMAP_PROTOCOL_ID}&#34;,
            constants.RMAP_GENERAL_ERROR)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.check_target_logical_address"><code class="name flex">
<span>def <span class="ident">check_target_logical_address</span></span>(<span>rmap_link, rxbuf, tla)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_target_logical_address(rmap_link, rxbuf, tla):
    tla_rxbuf = get_target_logical_address(rmap_link, rxbuf)
    if tla != tla_rxbuf:
        raise CheckError(
            f&#34;Target Logical Address doesn&#39;t match, tla=0x{tla:02X} &amp; rxbuf[0]=0x{tla_rxbuf:02X}&#34;,
            constants.RMAP_GENERAL_ERROR
        )</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.create_rmap_read_reply_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_read_reply_packet</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, instruction_field: int, tid: int, status: int, buffer: bytes, buffer_length: int) ‑> _ctypes.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an RMAP Reply to a RMAP Read Request packet.</p>
<p>The function returns a <code>ctypes</code> character array (which is basically a bytes array) that
can be passed into the EtherSpaceLink library function <code>esl_write_packet()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong> :&ensp;<code><a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a></code></dt>
<dd>the RMAP link connection</dd>
<dt><strong><code>instruction_field</code></strong> :&ensp;<code>int</code></dt>
<dd>the instruction field of the RMAP read request packet</dd>
<dt><strong><code>tid</code></strong> :&ensp;<code>int</code></dt>
<dd>the transaction identifier of the read request packet</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>int</code></dt>
<dd>shall be 0 if the read request was successful, contain an error code otherwise.</dd>
<dt><strong><code>TODO</code></strong></dt>
<dd>which error code?</dd>
<dt><strong><code>buffer</code></strong> :&ensp;<code>bytes</code></dt>
<dd>the data that was read as indicated by the read request</dd>
<dt><strong><code>buffer_length</code></strong> :&ensp;<code>int</code></dt>
<dd>the data length</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>packet</code></dt>
<dd>a ctypes Array containing the full RMAP Reply packet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_read_reply_packet(rmap_link: ESL_RMAP, instruction_field: int, tid: int, status: int,
                                  buffer: bytes, buffer_length: int) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Creates an RMAP Reply to a RMAP Read Request packet.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection
        instruction_field (int): the instruction field of the RMAP read request packet
        tid (int): the transaction identifier of the read request packet
        status (int): shall be 0 if the read request was successful, contain an error code otherwise.
        TODO: which error code?
        buffer (bytes): the data that was read as indicated by the read request
        buffer_length (int): the data length

    Returns:
        packet: a ctypes Array containing the full RMAP Reply packet.
    &#34;&#34;&#34;

    buf = ctypes.create_string_buffer(12 + buffer_length + 1)

    buf[0] = 0x50  # Initiator address N-DPU or F-DPU
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = instruction_field &amp; 0x3F  # Clear the command bit as this is a reply
    buf[3] = status &amp; 0xFF  # Status field: 0 on success
    buf[4] = 0x51  # Target address is always the N-FEE or F-FEE
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[7] = 0x00                     # Reserved
    buf[8] = (buffer_length &gt;&gt; 16) &amp; 0xFF    # data length (MSB)
    buf[9] = (buffer_length &gt;&gt; 8) &amp; 0xFF     # data length
    buf[10] = buffer_length &amp; 0xFF           # data length (LSB)
    buf[11] = rmap_crc_check(buf, 0, 11) &amp; 0xFF  # Header CRC

    # Note that we assume here that len(buffer) == buffer_length.

    if len(buffer) != buffer_length:
        logger.warning(
            f&#34;While creating an RMAP read reply packet, the length of the buffer ({len(buffer)}) not equals &#34;
            f&#34;the buffer_length ({buffer_length})&#34;
        )

    for idx, value in enumerate(buffer):
        buf[12+idx] = value

    buf[12 + buffer_length] = rmap_crc_check(buf, 12, 12 + buffer_length) &amp; 0xFF  # data CRC

    return buf</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.create_rmap_read_request_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_read_request_packet</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, address: int, length: int) ‑> _ctypes.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an RMAP Read Request SpaceWire packet.</p>
<p>The read request is an RMAP command that read a number of bytes from the FEE register memory.</p>
<p>The function returns a <code>ctypes</code> character array (which is basically a bytes array) that
can be passed into the EtherSpaceLink library function <code>esl_write_packet()</code>.</p>
<p>Address shall be within the 0x0000_0000 and 0x00FF_FFFC. The memory map (register) is divided
in the following areas:</p>
<pre><code>0x0000_0000 - 0x0000_00FC   Critical Configuration Area (verified write)
0x0000_0100 - 0x0000_06FC   General Configuration Area (unverified write)
0x0000_0700 - 0x0000_07FC   Housekeeping area
0x0000_0800 - 0x007F_FFFC   Not Supported
0x0080_0000 - 0x00FF_FFFC   Windowing Area (unverified write)
0x0010_0000 - 0xFFFF_FFFC   Not Supported
</code></pre>
<p>All read requests to the critical area shall have a fixed data length of 4 bytes.
All read requests to a general area shall have a maximum data length of 256 bytes.
All read requests to the housekeeping area shall have a maximum data length of 256 bytes.
All read requests to the windowing area shall have a maximum data length of 4096 bytes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong> :&ensp;<code><a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a></code></dt>
<dd>the RMAP link connection</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>int</code></dt>
<dd>the FEE register memory address</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the data length</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a bytes array containing the full RMAP Read Request packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_read_request_packet(rmap_link: ESL_RMAP, address: int, length: int) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Creates an RMAP Read Request SpaceWire packet.

    The read request is an RMAP command that read a number of bytes from the FEE register memory.

    The function returns a ``ctypes`` character array (which is basically a bytes array) that
    can be passed into the EtherSpaceLink library function ``esl_write_packet()``.

    Address shall be within the 0x0000_0000 and 0x00FF_FFFC. The memory map (register) is divided
    in the following areas:

        0x0000_0000 - 0x0000_00FC   Critical Configuration Area (verified write)
        0x0000_0100 - 0x0000_06FC   General Configuration Area (unverified write)
        0x0000_0700 - 0x0000_07FC   Housekeeping area
        0x0000_0800 - 0x007F_FFFC   Not Supported
        0x0080_0000 - 0x00FF_FFFC   Windowing Area (unverified write)
        0x0010_0000 - 0xFFFF_FFFC   Not Supported

    All read requests to the critical area shall have a fixed data length of 4 bytes.
    All read requests to a general area shall have a maximum data length of 256 bytes.
    All read requests to the housekeeping area shall have a maximum data length of 256 bytes.
    All read requests to the windowing area shall have a maximum data length of 4096 bytes.

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection
        address (int): the FEE register memory address
        length (int): the data length

    Returns:
        a bytes array containing the full RMAP Read Request packet.
    &#34;&#34;&#34;

    check_address_and_data_length(address, length)

    buf = ctypes.create_string_buffer(16)

    # The transaction identifier shall be incremented for each read request

    tid = update_transaction_identifier(rmap_link)

    # NOTE: The first bytes would each carry the target SpW address or a destination port,
    #       but this is not used for point-to-point connections, so we&#39;re safe.

    buf[0] = 0x51  # Target N-FEE or F-FEE
    buf[1] = 0x01  # RMAP Protocol ID
    buf[2] = 0x4C  # Instruction: 0b1001100, RMAP Request, Read, Incrementing address, reply address = 0
    buf[3] = 0xD1  # Destination Key
    buf[4] = 0x50  # Initiator is always the DPU
    buf[5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[7] = 0x00                     # Extended address is not used
    buf[8] = (address &gt;&gt; 24) &amp; 0xFF   # address (MSB)
    buf[9] = (address &gt;&gt; 16) &amp; 0xFF   # address
    buf[10] = (address &gt;&gt; 8) &amp; 0xFF   # address
    buf[11] = address &amp; 0xFF          # address (LSB)
    buf[12] = (length &gt;&gt; 16) &amp; 0xFF   # data length (MSB)
    buf[13] = (length &gt;&gt; 8) &amp; 0xFF    # data length
    buf[14] = length &amp; 0xFF           # data length (LSB)
    buf[15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF
    return buf</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.create_rmap_unverified_write_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_unverified_write_packet</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, address: int, data: bytes, length: int) ‑> _ctypes.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Create an RMAP packet for a unverified write request on the FEE.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong></dt>
<dd>the RMAP link structure</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the start memory address on the FEE register map</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data to be written in the register map at address</dd>
<dt><strong><code>length</code></strong></dt>
<dd>the length of the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>packet</code></dt>
<dd>a bytes object containing the SpaceWire packet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_unverified_write_packet(rmap_link: ESL_RMAP, address: int, data: bytes, length: int) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Create an RMAP packet for a unverified write request on the FEE.

    Args:
        rmap_link: the RMAP link structure
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address
        length: the length of the data

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    # We can only handle data for which the length &gt;= the given length argument.

    if len(data) &lt; length:
        raise ValueError(
            f&#34;The length of the data argument ({len(data)}) is smaller than &#34;
            f&#34;the given length argument ({length}).&#34;
        )

    if len(data) &gt; length:
        logger.warning(
            f&#34;The length of the data argument ({len(data)}) is larger than &#34;
            f&#34;the given length argument ({length}). The data will be truncated &#34;
            f&#34;when copied into the packet.&#34;
        )

    if address &lt;= CRITICAL_AREA_END:
        raise ValueError(f&#34;The given address (0x{address:08X}) is in the range for critical configuration is [0x00 - &#34;
                         f&#34;0xFC]. Use the verified write function for this.&#34;)

    tid = update_transaction_identifier(rmap_link)

    # Buffer length is fixed at 24 bytes since the data length is fixed at 4 bytes (32 bit addressing)

    buf = ctypes.create_string_buffer(16 + length + 1)
    offset = 0

    buf[offset+0] = 0x51  # Logical Address
    buf[offset+1] = 0x01  # Protocol ID
    buf[offset+2] = 0x6C  # Instruction
    buf[offset+3] = 0xD1  # Key
    buf[offset+4] = 0x50  # Initiator Address
    buf[offset+5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[offset+6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[offset+7] = 0x00                     # Extended address
    buf[offset+8] = (address &gt;&gt; 24) &amp; 0xFF   # address (MSB)
    buf[offset+9] = (address &gt;&gt; 16) &amp; 0xFF   # address
    buf[offset+10] = (address &gt;&gt; 8) &amp; 0xFF   # address
    buf[offset+11] = address &amp; 0xFF          # address (LSB)
    buf[offset+12] = (length &gt;&gt; 16) &amp; 0xFF   # data length (MSB)
    buf[offset+13] = (length &gt;&gt; 8) &amp; 0xFF    # data length
    buf[offset+14] = length &amp; 0xFF           # data length (LSB)
    buf[offset+15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC

    offset = offset + 16

    for idx, value in enumerate(data):
        buf[offset+idx] = value

    buf[offset + length] = rmap_crc_check(buf, offset, length) &amp; 0xFF  # data CRC

    return buf</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.create_rmap_verified_write_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_verified_write_packet</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, address: int, data: bytes) ‑> _ctypes.Array</span>
</code></dt>
<dd>
<div class="desc"><p>Create an RMAP packet for a verified write request on the FEE. The length of the data is by convention always 4
bytes and therefore not passed as an argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong></dt>
<dd>the RMAP link structure</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the start memory address on the FEE register map</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data to be written in the register map at address [4 bytes]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>packet</code></dt>
<dd>a bytes object containing the SpaceWire packet.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_verified_write_packet(rmap_link: ESL_RMAP, address: int, data: bytes) -&gt; ctypes.Array:
    &#34;&#34;&#34;
    Create an RMAP packet for a verified write request on the FEE. The length of the data is by convention always 4
    bytes and therefore not passed as an argument.

    Args:
        rmap_link: the RMAP link structure
        address: the start memory address on the FEE register map
        data: the data to be written in the register map at address [4 bytes]

    Returns:
        packet: a bytes object containing the SpaceWire packet.
    &#34;&#34;&#34;

    if len(data) &lt; 4:
        raise ValueError(f&#34;The data argument should be at least 4 bytes, but it is only {len(data)} bytes.&#34;)

    if address &gt; CRITICAL_AREA_END:
        raise ValueError(f&#34;The address range for critical configuration is [0x00 - 0xFC].&#34;)

    tid = update_transaction_identifier(rmap_link)

    # Buffer length is fixed at 24 bytes since the data length is fixed at 4 bytes (32 bit addressing)

    buf = ctypes.create_string_buffer(21)
    offset = 0

    # The values below are taken from the PLATO N-FEE to N-DPU Interface Requirements Document [PLATO-DLR-PL-ICD-0010]

    buf[offset+0] = 0x51  # Logical Address
    buf[offset+1] = 0x01  # Protocol ID
    buf[offset+2] = 0x7C  # Instruction
    buf[offset+3] = 0xD1  # Key
    buf[offset+4] = 0x50  # Initiator Address
    buf[offset+5] = (tid &gt;&gt; 8) &amp; 0xFF        # MSB of the Transition ID
    buf[offset+6] = tid &amp; 0xFF               # LSB of the Transition ID
    buf[offset+7] = 0x00                     # Extended address
    buf[offset+8] = (address &gt;&gt; 24) &amp; 0xFF   # address (MSB)
    buf[offset+9] = (address &gt;&gt; 16) &amp; 0xFF   # address
    buf[offset+10] = (address &gt;&gt; 8) &amp; 0xFF   # address
    buf[offset+11] = address &amp; 0xFF          # address (LSB)
    buf[offset+12] = 0x00                    # data length (MSB)
    buf[offset+13] = 0x00                    # data length
    buf[offset+14] = 0x04                    # data length (LSB)
    buf[offset+15] = rmap_crc_check(buf, 0, 15) &amp; 0xFF  # header CRC
    buf[offset+16] = data[0]
    buf[offset+17] = data[1]
    buf[offset+18] = data[2]
    buf[offset+19] = data[3]
    buf[offset+20] = rmap_crc_check(buf, 16, 4) &amp; 0xFF  # data CRC

    return buf</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.create_rmap_write_reply_packet"><code class="name flex">
<span>def <span class="ident">create_rmap_write_reply_packet</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>) ‑> _ctypes.Array</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rmap_write_reply_packet(rmap_link: ESL_RMAP) -&gt; ctypes.Array:
    pass</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_address"><code class="name flex">
<span>def <span class="ident">get_address</span></span>(<span>rxbuf) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the address field (including the extended address field if the address is 40-bits).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>when this method is used on a Reply packet (which has no address field).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_address(rxbuf) -&gt; int:
    &#34;&#34;&#34;Returns the address field (including the extended address field if the address is 40-bits).

    Raises:
        TypeError: when this method is used on a Reply packet (which has no address field).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field):
        raise TypeError(&#34;There is no address field for Reply packets, asking for the address is &#34;
                        &#34;an invalid operation.&#34;)

    idx = 7 + get_reply_address_field_length(rxbuf)
    extended_address = rxbuf[idx]
    idx += 1
    address = struct.unpack(&#39;&gt;L&#39;, rxbuf[idx:idx + 4])[0]
    if extended_address:
        address = address + (extended_address &lt;&lt; 32)
    return address</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>rxbuf) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Return the data from the RMAP packet.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if there is no data section in the packet (TODO: not yet implemented)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(rxbuf) -&gt; bytes:
    &#34;&#34;&#34;Return the data from the RMAP packet.

    Raises:
        ValueError: if there is no data section in the packet (TODO: not yet implemented)
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)
    address_length = get_reply_address_field_length(rxbuf)
    data_length = get_data_length(rxbuf)

    offset = 12 if is_read(instruction_field) else 16

    return rxbuf[offset + address_length:offset + address_length + data_length]</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_data_length"><code class="name flex">
<span>def <span class="ident">get_data_length</span></span>(<span>rxbuf) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of the data in bytes.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>when this method is used on a Write Request Reply packet (which has no
data length).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_length(rxbuf) -&gt; int:
    &#34;&#34;&#34;Returns the length of the data in bytes.

    Raises:
        TypeError: when this method is used on a Write Request Reply packet (which has no
            data length).
    &#34;&#34;&#34;
    instruction_field = get_instruction_field(rxbuf)

    if not is_command(instruction_field) and is_write(instruction_field):
        raise TypeError(&#34;There is no data length field for Write Request Reply packets, &#34;
                        &#34;asking for the data length is an invalid operation.&#34;)

    offset = 12 if is_command(instruction_field) else 8
    idx = offset + get_reply_address_field_length(rxbuf)

    # We could use two alternative decoding methods here:
    #   int.from_bytes(rxbuf[idx:idx+3], byteorder=&#39;big&#39;)    (timeit=1.166s)
    #   struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx+3])[0]   (timeit=0.670s)
    data_length = struct.unpack(&#39;&gt;L&#39;, b&#39;\x00&#39; + rxbuf[idx:idx + 3])[0]
    return data_length</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_initiator_logical_address"><code class="name flex">
<span>def <span class="ident">get_initiator_logical_address</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_initiator_logical_address(rxbuf):
    idx = 4 + get_reply_address_field_length(rxbuf)
    ila_rxbuf = rxbuf[idx]
    return ila_rxbuf</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_instruction_field"><code class="name flex">
<span>def <span class="ident">get_instruction_field</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instruction_field(rxbuf):
    idx = 2
    return rxbuf[idx]</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_protocol_id"><code class="name flex">
<span>def <span class="ident">get_protocol_id</span></span>(<span>rx_buffer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_protocol_id(rx_buffer):
    return rx_buffer[1]</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_reply_address_field_length"><code class="name flex">
<span>def <span class="ident">get_reply_address_field_length</span></span>(<span>rx_buffer) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of reply address field.</p>
<p>This function returns the actual size of the reply address field. It doesn't return the content of the
reply address length field. If you need that information, use the reply_address_length() function that work on
the instruction field.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>length</code></dt>
<dd>the size of the reply address field.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reply_address_field_length(rx_buffer) -&gt; int:
    &#34;&#34;&#34;Returns the size of reply address field.

    This function returns the actual size of the reply address field. It doesn&#39;t return the content of the
    reply address length field. If you need that information, use the reply_address_length() function that work on
    the instruction field.

    Returns:
         length: the size of the reply address field.
    &#34;&#34;&#34;
    instruction = get_instruction_field(rx_buffer)
    return reply_address_length(instruction) * 4</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_target_logical_address"><code class="name flex">
<span>def <span class="ident">get_target_logical_address</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, rxbuf: bytes) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_target_logical_address(rmap_link: ESL_RMAP, rxbuf: bytes) -&gt; int:
    tla_idx = 0
    tla_rxbuf = rxbuf[tla_idx]
    return tla_rxbuf</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.get_transaction_identifier"><code class="name flex">
<span>def <span class="ident">get_transaction_identifier</span></span>(<span>rxbuf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction_identifier(rxbuf):
    idx = 5 + get_reply_address_field_length(rxbuf)
    tid = struct.unpack(&#39;&gt;h&#39;, rxbuf[idx:idx + 2])[0]
    return tid</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_command"><code class="name flex">
<span>def <span class="ident">is_command</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_command(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b01000000) &gt;&gt; 6</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_increment"><code class="name flex">
<span>def <span class="ident">is_increment</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the data is written to sequential memory addresses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_increment(instruction):
    &#34;&#34;&#34;Returns True if the data is written to sequential memory addresses.&#34;&#34;&#34;
    return (instruction &amp; 0b00000100) &gt;&gt; 2</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_read"><code class="name flex">
<span>def <span class="ident">is_read</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a read request command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_read(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a read request command packet.&#34;&#34;&#34;
    return not is_write(instruction)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_reply"><code class="name flex">
<span>def <span class="ident">is_reply</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a reply to a previous command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_reply(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a reply to a previous command packet.&#34;&#34;&#34;
    return not is_command(instruction)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_reply_required"><code class="name flex">
<span>def <span class="ident">is_reply_required</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the reply bit is set in the instruction field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction</code></strong> :&ensp;<code>int</code></dt>
<dd>the instruction field of an RMAP packet</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;the name of this function might be confusing.</p>
<p>This function does <strong>not</strong> test if the packet is a reply packet, but it checks
if the command requests a reply from the target. If you need to test if the
packet is a command or a reply, use the is_command() or is_reply() function.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_reply_required(instruction):
    &#34;&#34;&#34;Returns True if the reply bit is set in the instruction field.

    Args:
        instruction (int): the instruction field of an RMAP packet

    .. note:: the name of this function might be confusing.

        This function does **not** test if the packet is a reply packet, but it checks
        if the command requests a reply from the target. If you need to test if the
        packet is a command or a reply, use the is_command() or is_reply() function.

    &#34;&#34;&#34;
    return (instruction &amp; 0b00001000) &gt;&gt; 3</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_reserved"><code class="name flex">
<span>def <span class="ident">is_reserved</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>The reserved bit of the 2-bit packet type field from the instruction field.</p>
<p>For PLATO this bit shall be zero as the 0b10 and 0b11 packet field values are reserved.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bit value</code></dt>
<dd>1 or 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_reserved(instruction):
    &#34;&#34;&#34;The reserved bit of the 2-bit packet type field from the instruction field.

    For PLATO this bit shall be zero as the 0b10 and 0b11 packet field values are reserved.

    Returns:
        bit value: 1 or 0.
    &#34;&#34;&#34;
    return (instruction &amp; 0b10000000) &gt;&gt; 7</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_rmap"><code class="name flex">
<span>def <span class="ident">is_rmap</span></span>(<span>rx_buffer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_rmap(rx_buffer):
    return get_protocol_id(rx_buffer) == constants.RMAP_PROTOCOL_ID</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_verify"><code class="name flex">
<span>def <span class="ident">is_verify</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet needs to do a verify before write.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_verify(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet needs to do a verify before write.&#34;&#34;&#34;
    return (instruction &amp; 0b00010000) &gt;&gt; 4</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.is_write"><code class="name flex">
<span>def <span class="ident">is_write</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the RMAP packet is a write request command packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_write(instruction):
    &#34;&#34;&#34;Returns True if the RMAP packet is a write request command packet.&#34;&#34;&#34;
    return (instruction &amp; 0b00100000) &gt;&gt; 5</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.reply_address_length"><code class="name flex">
<span>def <span class="ident">reply_address_length</span></span>(<span>instruction)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the content of the replay address length field.</p>
<p>The size of the replay address field is then decoded from the following table:</p>
<pre><code>Address Field Length  |  Size of Address Field
----------------------+-----------------------
     0b00             |      0 bytes
     0b01             |      4 bytes
     0b10             |      8 bytes
     0b11             |     12 bytes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply_address_length(instruction):
    &#34;&#34;&#34;Returns the content of the replay address length field.

    The size of the replay address field is then decoded from the following table:

        Address Field Length  |  Size of Address Field
        ----------------------+-----------------------
             0b00             |      0 bytes
             0b01             |      4 bytes
             0b10             |      8 bytes
             0b11             |     12 bytes

    &#34;&#34;&#34;
    return (instruction &amp; 0b00000011) &lt;&lt; 2</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_configure"><code class="name flex">
<span>def <span class="ident">rmap_configure</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, initiator_logical_address, target_key=209, target_logical_address=254)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the RMAP EtherSpaceWire link.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong></dt>
<dd>the RMAP link connection</dd>
<dt><strong><code>initiator_logical_address</code></strong></dt>
<dd>logical address of the SpaceWire node that starts the transaction</dd>
<dt><strong><code>target_key</code></strong></dt>
<dd>the key field used for command authorisation</dd>
<dt><strong><code>target_logical_address</code></strong></dt>
<dd>logical address of the target node (default: 0xFE)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_configure(rmap_link: ESL_RMAP, initiator_logical_address,
                   target_key=constants.RMAP_TARGET_KEY,
                   target_logical_address=constants.RMAP_TARGET_LOGICAL_ADDRESS_DEFAULT):
    &#34;&#34;&#34;
    Configure the RMAP EtherSpaceWire link.

    Args:
        rmap_link: the RMAP link connection
        initiator_logical_address: logical address of the SpaceWire node that starts the transaction
        target_key: the key field used for command authorisation
        target_logical_address: logical address of the target node (default: 0xFE)

    Returns:
        Nothing

    &#34;&#34;&#34;
    rmap_set_initiator_logical_address(rmap_link, initiator_logical_address)
    rmap_set_target_key(rmap_link, target_key)
    rmap_set_target_logical_address(rmap_link, target_logical_address)
    rmap_set_target_spw_address(rmap_link, b&#39;\x00&#39;, 0)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_connection"><code class="name flex">
<span>def <span class="ident">rmap_connection</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager that opens an RMAP connection on the EtherSpaceLink ESL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>an RMAP link connection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def rmap_connection(esl_link):
    &#34;&#34;&#34;
    Context manager that opens an RMAP connection on the EtherSpaceLink ESL.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        an RMAP link connection
    &#34;&#34;&#34;
    yield rmap_open_connection(esl_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_crc_check"><code class="name flex">
<span>def <span class="ident">rmap_crc_check</span></span>(<span>data, start, length)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_crc_check(data, start, length):
    # logger.debug(f&#34;Calling rmap_crc_check(data, {start}, {length})&#34;)
    return librmap_crc_check(data, start, length)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_get_initiator_logical_address"><code class="name flex">
<span>def <span class="ident">rmap_get_initiator_logical_address</span></span>(<span>rmap_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_get_initiator_logical_address(rmap_link):
    # logger.debug(&#34;Calling rmap_get_initiator_logical_address(rmap_link)&#34;)
    return librmap_get_initiator_logical_address(rmap_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_get_target_key"><code class="name flex">
<span>def <span class="ident">rmap_get_target_key</span></span>(<span>rmap_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_get_target_key(rmap_link):
    logger.debug(&#34;Calling rmap_get_target_key(rmap_link)&#34;)
    return librmap_get_target_key(rmap_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_get_target_logical_address"><code class="name flex">
<span>def <span class="ident">rmap_get_target_logical_address</span></span>(<span>rmap_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_get_target_logical_address(rmap_link):
    logger.debug(&#34;Calling rmap_get_target_logical_address(rmap_link)&#34;)
    return librmap_get_target_logical_address(rmap_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_open_connection"><code class="name flex">
<span>def <span class="ident">rmap_open_connection</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_open_connection(esl_link):

    logger.info(f&#34;Open and setup RMAP connection to {esl_get_product_string(esl_link)}&#34;)

    rmap_link = librmap_open(esl_link)
    if not rmap_link:
        raise RMAPError(f&#34;Couldn&#39;t open RMAP connection to {esl_get_product_string(esl_link)}&#34;)

    rmap_set_verbosity(1)     # 1=normal; 5 or 15 for lots of debugging

    logger.info(&#34;RMAP connection opened successfully.&#34;)

    return rmap_link</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_read"><code class="name flex">
<span>def <span class="ident">rmap_read</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, address: int, length: int, timeout: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Read <code>length</code> bytes from the remote memory starting at <code>address</code>. If there is no reply
after the given <code>timeout</code>, TODO: WHAT WILL HAPPEN THEN?</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;We are using the global <code>rxbuf</code> read buffer here.</p>
<p>The content of the buffer will be overwritten by the RMAP read request.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong></dt>
<dd>the RMAP link connection</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the start address (32-bit aligned) in the remote memory</dd>
<dt><strong><code>length</code></strong></dt>
<dd>the number of bytes to read from the remote memory</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in milli-seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the buffer containing the data read from the remote memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_read(rmap_link: ESL_RMAP, address: int, length: int, timeout: int = 1000):
    &#34;&#34;&#34;
    Read `length` bytes from the remote memory starting at `address`. If there is no reply
    after the given `timeout`, TODO: WHAT WILL HAPPEN THEN?

    .. note:: We are using the global ``rxbuf`` read buffer here.
        The content of the buffer will be overwritten by the RMAP read request.

    Args:
        rmap_link: the RMAP link connection
        address: the start address (32-bit aligned) in the remote memory
        length: the number of bytes to read from the remote memory
        timeout: timeout in milli-seconds

    Returns:
        the buffer containing the data read from the remote memory.

    &#34;&#34;&#34;

    data_length = librmap_read_TO(rmap_link, address, rxbuf, length, status_p, timeout)

    # If data_length &lt; 0 it can have the following values:
    # -1 = status was != 0 indicating a read error, the packet was eaten...discarded?
    # -4 = wrong TLA field in header
    # -5 = wrong TID field in header

    # FIXME: Think about if we should raise an RMAPError here instead of returning None when result is negative.
    #        I would go for an Exception, since we loose the information on the error anyway as code information (
    #        None is returned, not data_length), and now the caller must check the return code from this read command.

    if data_length &lt; 0:
        logger.warning(
            f&#34;Couldn&#39;t read data within timeout of {timeout} ms, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} &#34;
            f&#34;[{rmap_link.contents.ESL_RMAP_error}]&#34;
        )
        return None
    else:
        return rxbuf[:data_length]</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_read_request"><code class="name flex">
<span>def <span class="ident">rmap_read_request</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, address: int, length: int, timeout: int = 1000) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Read <code>length</code> bytes from the remote memory starting at <code>address</code>.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>the timeout parameter is currently not implemented</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong></dt>
<dd>the RMAP link connection</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the start address (32-bit aligned) in the remote memory</dd>
<dt><strong><code>length</code></strong></dt>
<dd>the number of bytes to read from the remote memory</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in milli-seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple containing the terminator value and the RMAP Reply packet with the data read from the remote memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_read_request(rmap_link: ESL_RMAP, address: int, length: int, timeout: int = 1000) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Read `length` bytes from the remote memory starting at `address`.

    .. todo:: the timeout parameter is currently not implemented

    Args:
        rmap_link: the RMAP link connection
        address: the start address (32-bit aligned) in the remote memory
        length: the number of bytes to read from the remote memory
        timeout: timeout in milli-seconds

    Returns:
        A tuple containing the terminator value and the RMAP Reply packet with the data read from the remote memory.

    &#34;&#34;&#34;
    buffer = create_rmap_read_request_packet(rmap_link, address, length)

    logger.log(5, &#34;Pretty Print Read Request Packet:\n&#34; + pretty_print_packet(buffer))

    result = esl_write_packet(rmap_link.contents.spw_device, buffer, len(buffer), constants.ESL_EOP)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data within timeout of {timeout} ms, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    result = esl_flush(rmap_link.contents.spw_device)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data or clear buffers, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    # Read the read request reply

    terminator, rx_buffer = esl_read_packet(rmap_link.contents.spw_device)

    logger.log(5, &#34;Pretty Print Read Request Reply Packet:\n&#34; + pretty_print_packet(rx_buffer))

    return terminator, rx_buffer</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_set_initiator_logical_address"><code class="name flex">
<span>def <span class="ident">rmap_set_initiator_logical_address</span></span>(<span>rmap_link, address)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_set_initiator_logical_address(rmap_link, address):
    # logger.debug(f&#34;Calling rmap_set_initiator_logical_address(rmap_link, 0x{address:02X})&#34;)
    librmap_set_initiator_logical_address(rmap_link, address)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_set_target_key"><code class="name flex">
<span>def <span class="ident">rmap_set_target_key</span></span>(<span>rmap_link, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_set_target_key(rmap_link, key):
    logger.debug(f&#34;Calling rmap_set_target_key({key})&#34;)
    librmap_set_target_key(rmap_link, key)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_set_target_logical_address"><code class="name flex">
<span>def <span class="ident">rmap_set_target_logical_address</span></span>(<span>rmap_link, address)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_set_target_logical_address(rmap_link, address):
    logger.debug(f&#34;Calling rmap_set_target_logical_address(rmap_link, 0x{address:02X})&#34;)
    librmap_set_target_logical_address(rmap_link, address)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_set_target_spw_address"><code class="name flex">
<span>def <span class="ident">rmap_set_target_spw_address</span></span>(<span>rmap_link, spw_address, spw_address_length)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_set_target_spw_address(rmap_link, spw_address, spw_address_length):
    logger.debug(f&#34;Calling rmap_set_target_spw_address(rmap_link, spw_address, {spw_address_length})&#34;)
    librmap_set_target_spw_address(rmap_link, spw_address, spw_address_length)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_set_verbosity"><code class="name flex">
<span>def <span class="ident">rmap_set_verbosity</span></span>(<span>flags)</span>
</code></dt>
<dd>
<div class="desc"><p>Set vebosity of the RMAP API.</p>
<p>Report errors by default:</p>
<ul>
<li>bitval
1 : output textual error messages</li>
<li>bitval
2 : output SpaceWire read/write packet tracing</li>
<li>bitval
4 : output API function call tracing</li>
<li>bitval
8 : output API parameter
/ data packet tracing</li>
<li>bitval 16 : output API data packet tracing</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flags</code></strong> :&ensp;<code>int</code></dt>
<dd>verbosy level</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_set_verbosity(flags):
    &#34;&#34;&#34;
    Set vebosity of the RMAP API.

    Report errors by default:

    * bitval  1 : output textual error messages
    * bitval  2 : output SpaceWire read/write packet tracing
    * bitval  4 : output API function call tracing
    * bitval  8 : output API parameter  / data packet tracing
    * bitval 16 : output API data packet tracing

    Args:
        flags (int): verbosy level

    Returns:
        None

    &#34;&#34;&#34;
    librmap_set_verbosity(flags)</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.rmap_write_request"><code class="name flex">
<span>def <span class="ident">rmap_write_request</span></span>(<span>rmap_link: <a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a>, address: int, data: bytes, length: int = 4, timeout: int = 1000) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends an RMAP write command over the SpaceWire link.</p>
<p>Based on the address this function will decided to send a verified or unverified write request.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>the timeout parameter is currently not implemented</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong> :&ensp;<code><a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a></code></dt>
<dd>the RMAP link connection</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the starting memory address to which the data from buffer will be written</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data that will be written into the targets memory</dd>
<dt><strong><code>length</code></strong></dt>
<dd>the number of bytes to write (the buffer maybe longer) [default=4]</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in milliseconds [default=1000]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>return_code</code></dt>
<dd>zero (0) on success.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="egse.dsi.rmap.RMAPError" href="#egse.dsi.rmap.RMAPError">RMAPError</a></code></dt>
<dd>when data can not be written on the target.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmap_write_request(rmap_link: ESL_RMAP,
                       address: int, data: bytes, length: int = 4, timeout: int = 1000) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Sends an RMAP write command over the SpaceWire link.

    Based on the address this function will decided to send a verified or unverified write request.

    .. todo:: the timeout parameter is currently not implemented

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection
        address: the starting memory address to which the data from buffer will be written
        data: the data that will be written into the targets memory
        length: the number of bytes to write (the buffer maybe longer) [default=4]
        timeout: timeout in milliseconds [default=1000]

    Returns:
        return_code: zero (0) on success.

    Raises:
        RMAPError: when data can not be written on the target.

    &#34;&#34;&#34;

    if CRITICAL_AREA_START &lt;= address &lt;= CRITICAL_AREA_END:
        buffer = create_rmap_verified_write_packet(rmap_link, address, data)
    else:
        buffer = create_rmap_unverified_write_packet(rmap_link, address, data, length)

    logger.log(5, &#34;Pretty Print Write Request Packet:\n&#34; + pretty_print_packet(buffer))

    result = esl_write_packet(rmap_link.contents.spw_device, buffer, len(buffer), constants.ESL_EOP)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data within timeout of {timeout} ms, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    result = esl_flush(rmap_link.contents.spw_device)
    if result:
        raise RMAPError(
            f&#34;Couldn&#39;t send data or clear buffers, &#34;
            f&#34;ESL RMAP Error Code = {esl_rmap_error_codes[rmap_link.contents.ESL_RMAP_error]} [&#34;
            f&#34;{rmap_link.contents.ESL_RMAP_error}]&#34;)

    # Read the write reply

    terminator, rx_buffer = esl_read_packet(rmap_link.contents.spw_device)

    logger.log(5, &#34;Pretty Print Write Request Reply Packet:\n&#34; + pretty_print_packet(rx_buffer))

    return terminator, rx_buffer</code></pre>
</details>
</dd>
<dt id="egse.dsi.rmap.update_transaction_identifier"><code class="name flex">
<span>def <span class="ident">update_transaction_identifier</span></span>(<span>rmap_link) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the transaction identifier and returns the new value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rmap_link</code></strong> :&ensp;<code><a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a></code></dt>
<dd>the RMAP link connection</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the updated transaction identifier (int).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_transaction_identifier(rmap_link) -&gt; int:
    &#34;&#34;&#34;
    Updates the transaction identifier and returns the new value.

    Args:
        rmap_link (ESL_RMAP): the RMAP link connection

    Returns:
        the updated transaction identifier (int).
    &#34;&#34;&#34;
    tid = rmap_link.contents.transaction_identifier
    tid = (tid + 1) &amp; 0xFFFF
    rmap_link.contents.transaction_identifier = tid
    return tid</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.dsi.rmap.CheckError"><code class="flex name class">
<span>class <span class="ident">CheckError</span></span>
<span>(</span><span>message, status)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when a check fails and you want to pass a status values along with the message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckError(RMAPError):
    &#34;&#34;&#34;
    Raised when a check fails and you want to pass a status values along with the message.
    &#34;&#34;&#34;

    def __init__(self, message, status):
        self.message = message
        self.status  = status</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.dsi.rmap.RMAPError" href="#egse.dsi.rmap.RMAPError">RMAPError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP"><code class="flex name class">
<span>class <span class="ident">ESL_RMAP</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Structure base class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ESL_RMAP(Structure):
    _fields_ = [
        (&#34;spw_device&#34;,                esl_p),
        (&#34;target_key&#34;,                c_ubyte),
        (&#34;target_logical_address&#34;,    c_ubyte),
        (&#34;target_spw_address&#34;,        c_ubyte * 12),
        (&#34;target_spw_address_len&#34;,    c_int),
        (&#34;reply_spw_address&#34;,         c_ubyte * 12),
        (&#34;reply_spw_address_len&#34;,     c_int),
        (&#34;initiator_logical_address&#34;, c_ubyte),
        (&#34;transaction_identifier&#34;,    c_uint),
        (&#34;ESL_RMAP_error&#34;,            c_int)
    ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ctypes.Structure</li>
<li>_ctypes._CData</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="egse.dsi.rmap.ESL_RMAP.ESL_RMAP_error"><code class="name">var <span class="ident">ESL_RMAP_error</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.initiator_logical_address"><code class="name">var <span class="ident">initiator_logical_address</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.reply_spw_address"><code class="name">var <span class="ident">reply_spw_address</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.reply_spw_address_len"><code class="name">var <span class="ident">reply_spw_address_len</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.spw_device"><code class="name">var <span class="ident">spw_device</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.target_key"><code class="name">var <span class="ident">target_key</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.target_logical_address"><code class="name">var <span class="ident">target_logical_address</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.target_spw_address"><code class="name">var <span class="ident">target_spw_address</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.target_spw_address_len"><code class="name">var <span class="ident">target_spw_address_len</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
<dt id="egse.dsi.rmap.ESL_RMAP.transaction_identifier"><code class="name">var <span class="ident">transaction_identifier</span></code></dt>
<dd>
<div class="desc"><p>Structure/Union member</p></div>
</dd>
</dl>
</dd>
<dt id="egse.dsi.rmap.LP_ESL_RMAP"><code class="flex name class">
<span>class <span class="ident">rmap_p</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>XXX to be provided</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ctypes._Pointer</li>
<li>_ctypes._CData</li>
</ul>
</dd>
<dt id="egse.dsi.rmap.RMAPError"><code class="flex name class">
<span>class <span class="ident">RMAPError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RMAPError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.dsi.rmap.CheckError" href="#egse.dsi.rmap.CheckError">CheckError</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.dsi" href="index.html">egse.dsi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.dsi.rmap.check_address_and_data_length" href="#egse.dsi.rmap.check_address_and_data_length">check_address_and_data_length</a></code></li>
<li><code><a title="egse.dsi.rmap.check_data_crc" href="#egse.dsi.rmap.check_data_crc">check_data_crc</a></code></li>
<li><code><a title="egse.dsi.rmap.check_header_crc" href="#egse.dsi.rmap.check_header_crc">check_header_crc</a></code></li>
<li><code><a title="egse.dsi.rmap.check_initiator_logical_address" href="#egse.dsi.rmap.check_initiator_logical_address">check_initiator_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.check_instruction" href="#egse.dsi.rmap.check_instruction">check_instruction</a></code></li>
<li><code><a title="egse.dsi.rmap.check_key" href="#egse.dsi.rmap.check_key">check_key</a></code></li>
<li><code><a title="egse.dsi.rmap.check_protocol_id" href="#egse.dsi.rmap.check_protocol_id">check_protocol_id</a></code></li>
<li><code><a title="egse.dsi.rmap.check_target_logical_address" href="#egse.dsi.rmap.check_target_logical_address">check_target_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.create_rmap_read_reply_packet" href="#egse.dsi.rmap.create_rmap_read_reply_packet">create_rmap_read_reply_packet</a></code></li>
<li><code><a title="egse.dsi.rmap.create_rmap_read_request_packet" href="#egse.dsi.rmap.create_rmap_read_request_packet">create_rmap_read_request_packet</a></code></li>
<li><code><a title="egse.dsi.rmap.create_rmap_unverified_write_packet" href="#egse.dsi.rmap.create_rmap_unverified_write_packet">create_rmap_unverified_write_packet</a></code></li>
<li><code><a title="egse.dsi.rmap.create_rmap_verified_write_packet" href="#egse.dsi.rmap.create_rmap_verified_write_packet">create_rmap_verified_write_packet</a></code></li>
<li><code><a title="egse.dsi.rmap.create_rmap_write_reply_packet" href="#egse.dsi.rmap.create_rmap_write_reply_packet">create_rmap_write_reply_packet</a></code></li>
<li><code><a title="egse.dsi.rmap.get_address" href="#egse.dsi.rmap.get_address">get_address</a></code></li>
<li><code><a title="egse.dsi.rmap.get_data" href="#egse.dsi.rmap.get_data">get_data</a></code></li>
<li><code><a title="egse.dsi.rmap.get_data_length" href="#egse.dsi.rmap.get_data_length">get_data_length</a></code></li>
<li><code><a title="egse.dsi.rmap.get_initiator_logical_address" href="#egse.dsi.rmap.get_initiator_logical_address">get_initiator_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.get_instruction_field" href="#egse.dsi.rmap.get_instruction_field">get_instruction_field</a></code></li>
<li><code><a title="egse.dsi.rmap.get_protocol_id" href="#egse.dsi.rmap.get_protocol_id">get_protocol_id</a></code></li>
<li><code><a title="egse.dsi.rmap.get_reply_address_field_length" href="#egse.dsi.rmap.get_reply_address_field_length">get_reply_address_field_length</a></code></li>
<li><code><a title="egse.dsi.rmap.get_target_logical_address" href="#egse.dsi.rmap.get_target_logical_address">get_target_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.get_transaction_identifier" href="#egse.dsi.rmap.get_transaction_identifier">get_transaction_identifier</a></code></li>
<li><code><a title="egse.dsi.rmap.is_command" href="#egse.dsi.rmap.is_command">is_command</a></code></li>
<li><code><a title="egse.dsi.rmap.is_increment" href="#egse.dsi.rmap.is_increment">is_increment</a></code></li>
<li><code><a title="egse.dsi.rmap.is_read" href="#egse.dsi.rmap.is_read">is_read</a></code></li>
<li><code><a title="egse.dsi.rmap.is_reply" href="#egse.dsi.rmap.is_reply">is_reply</a></code></li>
<li><code><a title="egse.dsi.rmap.is_reply_required" href="#egse.dsi.rmap.is_reply_required">is_reply_required</a></code></li>
<li><code><a title="egse.dsi.rmap.is_reserved" href="#egse.dsi.rmap.is_reserved">is_reserved</a></code></li>
<li><code><a title="egse.dsi.rmap.is_rmap" href="#egse.dsi.rmap.is_rmap">is_rmap</a></code></li>
<li><code><a title="egse.dsi.rmap.is_verify" href="#egse.dsi.rmap.is_verify">is_verify</a></code></li>
<li><code><a title="egse.dsi.rmap.is_write" href="#egse.dsi.rmap.is_write">is_write</a></code></li>
<li><code><a title="egse.dsi.rmap.reply_address_length" href="#egse.dsi.rmap.reply_address_length">reply_address_length</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_configure" href="#egse.dsi.rmap.rmap_configure">rmap_configure</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_connection" href="#egse.dsi.rmap.rmap_connection">rmap_connection</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_crc_check" href="#egse.dsi.rmap.rmap_crc_check">rmap_crc_check</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_get_initiator_logical_address" href="#egse.dsi.rmap.rmap_get_initiator_logical_address">rmap_get_initiator_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_get_target_key" href="#egse.dsi.rmap.rmap_get_target_key">rmap_get_target_key</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_get_target_logical_address" href="#egse.dsi.rmap.rmap_get_target_logical_address">rmap_get_target_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_open_connection" href="#egse.dsi.rmap.rmap_open_connection">rmap_open_connection</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_read" href="#egse.dsi.rmap.rmap_read">rmap_read</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_read_request" href="#egse.dsi.rmap.rmap_read_request">rmap_read_request</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_set_initiator_logical_address" href="#egse.dsi.rmap.rmap_set_initiator_logical_address">rmap_set_initiator_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_set_target_key" href="#egse.dsi.rmap.rmap_set_target_key">rmap_set_target_key</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_set_target_logical_address" href="#egse.dsi.rmap.rmap_set_target_logical_address">rmap_set_target_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_set_target_spw_address" href="#egse.dsi.rmap.rmap_set_target_spw_address">rmap_set_target_spw_address</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_set_verbosity" href="#egse.dsi.rmap.rmap_set_verbosity">rmap_set_verbosity</a></code></li>
<li><code><a title="egse.dsi.rmap.rmap_write_request" href="#egse.dsi.rmap.rmap_write_request">rmap_write_request</a></code></li>
<li><code><a title="egse.dsi.rmap.update_transaction_identifier" href="#egse.dsi.rmap.update_transaction_identifier">update_transaction_identifier</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.dsi.rmap.CheckError" href="#egse.dsi.rmap.CheckError">CheckError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.dsi.rmap.ESL_RMAP" href="#egse.dsi.rmap.ESL_RMAP">ESL_RMAP</a></code></h4>
<ul class="">
<li><code><a title="egse.dsi.rmap.ESL_RMAP.ESL_RMAP_error" href="#egse.dsi.rmap.ESL_RMAP.ESL_RMAP_error">ESL_RMAP_error</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.initiator_logical_address" href="#egse.dsi.rmap.ESL_RMAP.initiator_logical_address">initiator_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.reply_spw_address" href="#egse.dsi.rmap.ESL_RMAP.reply_spw_address">reply_spw_address</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.reply_spw_address_len" href="#egse.dsi.rmap.ESL_RMAP.reply_spw_address_len">reply_spw_address_len</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.spw_device" href="#egse.dsi.rmap.ESL_RMAP.spw_device">spw_device</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.target_key" href="#egse.dsi.rmap.ESL_RMAP.target_key">target_key</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.target_logical_address" href="#egse.dsi.rmap.ESL_RMAP.target_logical_address">target_logical_address</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.target_spw_address" href="#egse.dsi.rmap.ESL_RMAP.target_spw_address">target_spw_address</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.target_spw_address_len" href="#egse.dsi.rmap.ESL_RMAP.target_spw_address_len">target_spw_address_len</a></code></li>
<li><code><a title="egse.dsi.rmap.ESL_RMAP.transaction_identifier" href="#egse.dsi.rmap.ESL_RMAP.transaction_identifier">transaction_identifier</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.dsi.rmap.LP_ESL_RMAP" href="#egse.dsi.rmap.LP_ESL_RMAP">LP_ESL_RMAP</a></code></h4>
</li>
<li>
<h4><code><a title="egse.dsi.rmap.RMAPError" href="#egse.dsi.rmap.RMAPError">RMAPError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
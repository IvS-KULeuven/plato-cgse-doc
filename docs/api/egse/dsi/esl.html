<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.dsi.esl API documentation</title>
<meta name="description" content="This module provides Python wrapper functions to (most of) the library functions from
the C library `EtherSpaceLink.c` …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.dsi.esl</code></h1>
</header>
<section id="section-intro">
<p>This module provides Python wrapper functions to (most of) the library functions from
the C library <code>EtherSpaceLink.c</code>.</p>
<p>Basic Usage</p>
<p>For accessing the EtherSpaceLink interface, use the context manager to get an ESL connection:</p>
<pre><code>with esl_connection(dsi_address) as esl_link:
    # do your configuration and commanding here
</code></pre>
<p>For special cases it might be useful to open and close the ESL connection yourself. Be careful
however to close the connection with every exception that is thrown.</p>
<pre><code>    try:
        esl_link = esl_open_connection(dsi_address)
        # do your configuration and commanding
    finally:
        if esl_link:
            esl_close_connection(esl_link)
</code></pre>
<p>It should be clear that using the context manager is preferred and should be considered the normal usage.</p>
<p>We use one single Exception (<code><a title="egse.dsi.esl.ESLError" href="#egse.dsi.esl.ESLError">ESLError</a></code>) specific for these wrapper functions.
An <code><a title="egse.dsi.esl.ESLError" href="#egse.dsi.esl.ESLError">ESLError</a></code> is thrown whenever the C function returns an error from which we can not recover.
This allows to cascade the python functions in a <code>try: except:</code> clause making
the code much more readable.</p>
<p>Developer Info</p>
<p>The C interface depends heavily on a C structure which we had to re-define using
the Structure class provided by ctypes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides Python wrapper functions to (most of) the library functions from
the C library `EtherSpaceLink.c`.

Basic Usage

For accessing the EtherSpaceLink interface, use the context manager to get an ESL connection:

    with esl_connection(dsi_address) as esl_link:
        # do your configuration and commanding here

For special cases it might be useful to open and close the ESL connection yourself. Be careful
however to close the connection with every exception that is thrown.

        try:
            esl_link = esl_open_connection(dsi_address)
            # do your configuration and commanding
        finally:
            if esl_link:
                esl_close_connection(esl_link)

It should be clear that using the context manager is preferred and should be considered the normal usage.

We use one single Exception (`ESLError`) specific for these wrapper functions.
An `ESLError` is thrown whenever the C function returns an error from which we can not recover.
This allows to cascade the python functions in a `try: except:` clause making
the code much more readable.

Developer Info

The C interface depends heavily on a C structure which we had to re-define using
the Structure class provided by ctypes.

&#34;&#34;&#34;
import ctypes
import logging
import time
import typing
from contextlib import contextmanager
from ctypes import c_char_p
from ctypes import c_int
from typing import Tuple

import egse
from egse.dsi import constants
from egse.dsi.constants import esl_error_codes
from egse.dsi.constants import esl_extension_codes
from egse.dsi.constants import esl_link_mode
from egse.dsi.constants import esl_terminator_codes
from egse.settings import Settings

if typing.TYPE_CHECKING:
    from egse.dsi._libesl import ESL

logger = logging.getLogger(__name__)

dsi_settings = Settings.load(&#34;DSI&#34;)

# Create and initialize a memory buffer for transmissions

rx_buffer = ctypes.create_string_buffer(dsi_settings.RX_BUFFER_LENGTH)
tx_buffer = ctypes.create_string_buffer(dsi_settings.TX_BUFFER_LENGTH)


class ESLError(Exception):
    pass


def esl_read_packet(esl_link: &#39;ESL&#39;, timeout: int = None) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Reads a full packet from the SpaceWire link.

    .. note:: since this function returns a packet as a bytes object, the content of the packet can not be changed.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        timeout (int): the maximum timeout that read_packet() will wait for data before returning [milliseconds]

    Returns:
        A tuple with the terminator value and a bytes object containing the packet.
        When an error occurred, the first value in the tuple will be negative and contains the error number,
        the second item in the tuple will then be an empty buffer.

    &#34;&#34;&#34;
    terminator = c_int(0)
    terminator_p = ctypes.pointer(terminator)

    bytes_received = esl_read_packet_full(
        esl_link, rx_buffer, dsi_settings.RX_BUFFER_LENGTH, terminator_p,
        constants.ESL_RETURN_EXTENSION_DATA | constants.ESL_RETURN_SPECIAL_DATA, timeout=timeout)

    # logger.debug(f&#34;Number of bytes received: {bytes_received}&#34;)

    if bytes_received &lt; 0:
        return bytes_received, bytes()

    return terminator.value, rx_buffer[:bytes_received]


@contextmanager
def esl_connection(dsi_address: str) -&gt; &#39;ESL&#39;:
    &#34;&#34;&#34;
    Context Manager that opens a EtherSpaceLink connection with the DSI (Diagnostic SpaceWire Interface).

    Args:
        dsi_address (str): the IP address of the DSI

    Returns:
        a pointer to the ESL structure
    &#34;&#34;&#34;
    esl_link = None
    try:
        esl_link = esl_open_connection(dsi_address)
        yield esl_link
    finally:
        if esl_link:
            esl_close_connection(esl_link)


def esl_open_connection(dsi_address: str) -&gt; &#39;ESL&#39;:
    &#34;&#34;&#34;
    Open a connection to the EtherSpaceLink DSI on the given IP address.
    This function will keep trying to connect for 10 seconds before aborting
    and throwing an `ESLError`.

    Args:
        dsi_address (str): the IP address of the DSI

    Returns:
        a pointer to the ESL structure

    &#34;&#34;&#34;
    logger.info(f&#34;Open and setup EtherSpaceLink connection on {dsi_address}.&#34;)

    retry = 20  # number of retries before failing to open connection
    esl_link = None

    while retry:
        esl_link = egse.dsi._libesl.libesl_open(c_char_p(dsi_address.encode()))
        if esl_link:
            break
        else:
            time.sleep(0.5)  # wait half a second before trying again
            logger.info(f&#34;Trying to connect to {dsi_address}, {retry / 2.0} sec before shutdown.&#34;)
            retry -= 1

    if not esl_link:
        raise ESLError(f&#34;Couldn&#39;t open connection to DSI on {dsi_address}.&#34;)

    logger.info(f&#34;EtherSpaceLink connection to {dsi_address} opened successfully.&#34;)

    return esl_link


def esl_close_connection(esl_link):
    &#34;&#34;&#34;
    Close the connection to the EtherSpaceLink DSI.

    This also flushes and closes the log and record files if they were used.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        Nothing
    &#34;&#34;&#34;
    egse.dsi._libesl.libesl_close(esl_link)
    logger.info(&#34;EtherSpaceLink connection closed successfully.&#34;)


def esl_flush(esl_link) -&gt; int:
    &#34;&#34;&#34;
    Flush all outstanding data to the destination. This function puts queued data onto the wire.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        0 on success, !0 otherwise
    &#34;&#34;&#34;
    result = egse.dsi._libesl.libesl_flush(esl_link)
    # We don&#39;t want this to raise an exception, the result value should be checked by the caller instead.
    # if result:
    #     raise ESLError(
    #         f&#34;Could not flush/send transmit buffer, &#34;
    #         f&#34;ESL error code={esl_error_codes[esl_link.contents.ESL_error]} [{esl_link.contents.ESL_error}]&#34;
    #     )
    return result


def esl_configure(esl_link: &#39;ESL&#39;,
                  active_link: int = 1, speed: int = 50, mode: int = constants.ESL_LINK_MODE_NORMAL,
                  report: int = 0):
    &#34;&#34;&#34;
    Configure the `esl_link` EtherSpaceWire link to the DSI.

    The reporting parameter is used to enable reporting for the following events:

        ESL_ER_REPORT_PARITY_ERROR
        ESL_ER_REPORT_TIME_CODE
        ESL_ER_REPORT_ESC_EOP
        ESL_ER_REPORT_ESC_EEP
        ESL_ER_REPORT_ESC_ESC
        ESL_ER_REPORT_TIMEOUT

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        active_link: the port number on the DSI where the SpW link shall be activated (default=1)
        speed: the speed in Mbps
        mode: the link mode [DISABLED, NORMAL, LEGACY or MASTER]
        report: enable reporting [default=0]

    Returns:
        Nothing
    &#34;&#34;&#34;
    status = esl_set_active_link(esl_link, active_link)
    logger.info(f&#34;esl_set_active_link({active_link}) -&gt; {status = }&#34;)
    status = esl_set_speed(esl_link, speed)
    logger.info(f&#34;esl_set_speed({speed}) -&gt; {status = }&#34;)

    if report:
        status = esl_er_enable_reporting(esl_link, report)
        logger.info(f&#34;esl_er_enable_reporting(0b{report:b}) -&gt; {status = }&#34;)

    status = esl_set_mode(esl_link, mode)
    logger.info(f&#34;esl_set_mode({esl_link_mode[mode]}={mode}) -&gt; {status = }&#34;)

    status = esl_flush(esl_link)
    logger.info(f&#34;esl_flush() -&gt; {status = }&#34;)


def esl_set_active_link(esl_link, active_link):
    return egse.dsi._libesl.libesl_set_active_link(esl_link, active_link)


def esl_get_active_link(esl_link):
    return esl_link.contents.current_port


def esl_is_link_connected(esl_link):
    return egse.dsi._libesl.libesl_link_connected(esl_link)


def esl_set_speed(esl_link, speed):
    result = egse.dsi._libesl.libesl_set_speed(esl_link, speed)
    if result:
        raise ESLError(&#34;Could not set speed to {}, ESL error code={} [{}]&#34;.format(speed, esl_error_codes[
            esl_link.contents.ESL_error], esl_link.contents.ESL_error))
    return result


def esl_set_mode(esl_link: &#39;ESL&#39;, mode: int) -&gt; int:
    &#34;&#34;&#34;
    Set the operating mode of the currently active SpaceWire link.

    After opening a connection, the link is disabled; it must then
    be enabled into one of its operational modes before data can
    be transferred.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        mode (int): the link mode [DISABLED, NORMAL, LEGACY or MASTER]

    Returns:
        0 if the request has been queued, not 0 if not.

    &#34;&#34;&#34;
    result = egse.dsi._libesl.libesl_set_mode(esl_link, mode)
    if result:
        raise ESLError(f&#34;Could not set mode {esl_link_mode[mode]}.&#34;)

    return result


def esl_send_timecode(esl_link: &#39;ESL&#39;, timecode: int) -&gt; int:
    &#34;&#34;&#34;
    Send a timecode over the SpaceWire link.

    The 8-bit timecode argument contains six-bit of system time (time-field) and two control flags.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        timecode (int): an 8-bit timecode field

    Returns:
        0 if the request has been queued, not 0 if not.

    &#34;&#34;&#34;
    result = egse.dsi._libesl.libesl_send_timecode(esl_link, timecode)

    if result:
        raise ESLError(
            f&#34;Could not send timecode, ESL error code={esl_error_codes[esl_link.contents.ESL_error]} &#34;
            f&#34;[{esl_link.contents.ESL_error}]&#34;
        )

    result = egse.dsi._libesl.libesl_flush(esl_link)

    return result


def esl_get_rx_timeout(esl_link):
    return esl_link.contents.rx_timeout


def esl_set_rx_timeout(esl_link, timeout: int):
    esl_link.contents.rx_timeout = timeout


def esl_get_receive_speed(esl_link: &#39;ESL&#39;) -&gt; int:
    &#34;&#34;&#34;
    Gets the receive speed of the currently active link.

    Note that this function has the ability to cause frames to be dropped and the esl_request_rx_speed() function
    should be used instead.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        the speed of the active link in Mbits/s. In case of an error a value &lt; 0 will be returned.
    &#34;&#34;&#34;
    return egse.dsi._libesl.libesl_get_receive_speed(esl_link)


def esl_set_log_file(esl_link, filename):
    result = egse.dsi._libesl.libesl_set_log_file(esl_link, c_char_p(filename.encode()))
    if result:
        raise ESLError(f&#34;Could not write to or open log file {filename}.&#34;)
    return result


def esl_set_record_file(esl_link, filename):
    result = egse.dsi._libesl.libesl_set_record_file(esl_link, c_char_p(filename.encode()))
    if result:
        raise ESLError(f&#34;Could not write to or open record file {filename}.&#34;)
    return result


def esl_get_manufacturer_string(esl_link):
    return egse.dsi._libesl.libesl_get_manufacturer_string(esl_link).decode()


def esl_get_product_string(esl_link):
    return egse.dsi._libesl.libesl_get_product_string(esl_link).decode()


def esl_get_esl_error(esl_link):
    return egse.dsi._libesl.libesl_get_esl_error(esl_link)


def esl_get_hwa(esl_link):
    hwa = b&#39;012345&#39;  # Pre-allocate the character buffer
    egse.dsi._libesl.libesl_get_hwa(esl_link, hwa)
    return hwa


def esl_get_serial_number(esl_link):
    hwa = esl_get_hwa(esl_link)
    return egse.dsi._libesl.libesl_hwa_to_serial_number_string(hwa)


def esl_get_number_of_links(esl_link):
    return egse.dsi._libesl.libesl_get_number_of_links(esl_link)


def esl_read_packet_full(esl_link, buffer, buffer_length, rx_terminator, special_data_action, timeout: int = None):

    if timeout:
        saved_timeout = esl_get_rx_timeout(esl_link)
        egse.dsi._libesl.libesl_set_rx_timeout(esl_link, timeout)

    result = egse.dsi._libesl.libesl_read_packet_full(esl_link, buffer, buffer_length, rx_terminator, special_data_action)

    if timeout:
        egse.dsi._libesl.libesl_set_rx_timeout(esl_link, saved_timeout)

    # This error handling is (or should be) done in the calling application, see for example egse.feesim.py
    # if result == -1:
    #     raise ESLError(
    #         f&#34;Could not read full packet, &#34;
    #         f&#34;ESL error code = {esl_error_codes[esl_link.contents.ESL_error]} [{esl_link.contents.ESL_error}]&#34;
    #     )

    return result


def esl_write_packet(esl_link: &#39;ESL&#39;, buffer, buffer_length: int, tx_terminator: int) -&gt; int:
    &#34;&#34;&#34;
    Queue data for transmission over the SpaceWire cable. If there is no room left in the buffer,
    the buffer is transmitted.

    Note, that even when the queued data is transmitted, the data added to it may not be.
    To guarantee transmission of this data you need to call the esl_flush() function.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        buffer: the data to send
        buffer_length: the size of the buffer to send (the actual buffer size might be longer)
        tx_terminator: additional metadata about the frame we are transmitting (EOP, EEP, PART_EOP_EEP, EXTN)

    Returns:
        return_code: 0 on success, &lt; 0 when an error occurred.
    &#34;&#34;&#34;

    result = egse.dsi._libesl.libesl_write_packet(esl_link, buffer, buffer_length, tx_terminator)

    return result


def esl_er_enable_reporting(esl_link, flags):
    result = egse.dsi._libesl.libesl_er_enable_reporting(esl_link, flags)
    if result:
        raise ESLError(
            f&#34;Could not enable error reporting, &#34;
            f&#34;ESL error code = {esl_error_codes[esl_link.contents.ESL_error]} [{esl_link.contents.ESL_error}]&#34;
        )
    return result


def esl_print_info(esl_link: &#39;ESL&#39;) -&gt; None:
    &#34;&#34;&#34;
    Prints information about the connected device to the console.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        nothing
    &#34;&#34;&#34;
    print(f&#34;Manufacturer        {esl_get_manufacturer_string(esl_link)}&#34;)
    print(f&#34;Product             {esl_get_product_string(esl_link)}&#34;)
    print(f&#34;Number of links     {esl_get_number_of_links(esl_link)} [active port={esl_get_active_link(esl_link)}]&#34;)

    hwa = esl_get_hwa(esl_link)
    serial_number = esl_get_serial_number(esl_link)

    print(f&#34;Serial number       {serial_number}&#34;)
    print(f&#34;Hardware Address    0x{hwa[0]:02X}-{hwa[1]:02X}-{hwa[2]:02X}-{hwa[3]:02X}-{hwa[4]:02X}-{hwa[5]:02X}&#34;)


def esl_print_summary_of_structure(esl):
    print(&#34;EtherSpaceLink structure:&#34;)
    print(&#34;sock                {}&#34;.format(esl.contents.sock))
    print(&#34;tx_buffer_length    {}&#34;.format(esl.contents.tx_buffer_length))
    print(&#34;tx_buffer_content   {}&#34;.format(esl.contents.tx_buffer_content))
    print(&#34;rx_buffer_length    {}&#34;.format(esl.contents.rx_buffer_length))
    print(&#34;rx_buffer_content   {}&#34;.format(esl.contents.rx_buffer_content))
    print(&#34;rx_state            {}&#34;.format(esl.contents.rx_state))
    print(&#34;rx_count            {}&#34;.format(esl.contents.rx_count))
    print(&#34;rx_param            {}&#34;.format(esl.contents.rx_param))
    #print(&#34;rx_size             {}&#34;.format(esl.contents.rx_size))
    print(&#34;rx_timeout          {}&#34;.format(esl.contents.rx_timeout))
    #print(&#34;rx_final_terminator {}&#34;.format(esl.contents.rx_final_terminator))
    print(&#34;extn_count          {}&#34;.format(esl.contents.extn_count))
    print(&#34;number_of_slots     {}&#34;.format(esl.contents.number_of_slots))
    #print(&#34;id                  {}&#34;.format(esl.contents.id))


# Helper Functions ---------------------------------------------------------------------------------


def is_terminator_code(code):
    return True if code in esl_terminator_codes else False


def get_terminator_name(code):
    if code in esl_terminator_codes:
        return esl_terminator_codes[code]
    else:
        return None


def is_extension_code(code):
    return True if code in esl_extension_codes else False


def get_extension_name(code):
    if code in esl_extension_codes:
        return esl_extension_codes[code]
    else:
        return None


def get_protocol_id(packet) -&gt; int:
    if isinstance(packet[1], bytes):
        value = int.from_bytes(packet[1], byteorder=&#39;big&#39;)
    else:
        value = packet[1]  # value assumed to be of type &#39;int&#39;
    return value


def is_timecode(packet) -&gt; bool:
    &#34;&#34;&#34;Returns True if the packet is a timecode reported as an extension from the DSI.&#34;&#34;&#34;
    return packet[0] == 0x91


RMAP_PROTOCOL_ID = 0x01
CCSDS_PROTOCOL_ID = 0x02
DATA_HK_PROTOCOL_ID = 0xF0


def pretty_print_read_request_packet(packet):
    msg = (
        f&#34;RMAP Read Request  ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:0x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:0x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:0x}\n&#34;
        f&#34;Key:               0x{packet[3]:0x}\n&#34;
        f&#34;Initiator address: 0x{packet[4]:0x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Extended address:  0x{packet[7]:0x}\n&#34;
        f&#34;Address Field:     0x{packet[8:12].hex()}\n&#34;
        f&#34;Data Length:       0x{packet[12:15].hex()}\n&#34;
        f&#34;Header CRC:        0x{packet[15]:0x}\n&#34;
    )
    return msg


def pretty_print_read_request_reply_packet(packet):
    data_length = int.from_bytes(packet[8:11], byteorder=&#39;big&#39;)
    msg = (
        f&#34;RMAP Read Request Reply ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:0x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:0x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:0x}\n&#34;
        f&#34;Status:            0x{packet[3]:0x}\n&#34;
        f&#34;Target address:    0x{packet[4]:0x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Reserved:          0x{packet[7]:0x}\n&#34;
        f&#34;Data Length:       {data_length}\n&#34;
        f&#34;Header CRC:        0x{packet[11]:0x}\n&#34;
        f&#34;data:              0x{packet[12:12 + min(32, data_length)].hex()}\n&#34;
        f&#34;                   note: maximum 32 bytes will be printed for the data.\n&#34;
        f&#34;Data CRC:          0x{packet[-1]:0x}\n&#34;
    )
    return msg


def pretty_print_write_request_reply_packet(packet):
    data_length = int.from_bytes(packet[8:11], byteorder=&#39;big&#39;)
    msg = (
        f&#34;RMAP Write Request Reply ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:0x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:0x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:0x}\n&#34;
        f&#34;Status:            0x{packet[3]:0x}\n&#34;
        f&#34;Target address:    0x{packet[4]:0x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Header CRC:        0x{packet[7]:0x}\n&#34;
    )
    return msg


def pretty_print_verified_write_request_packet(packet):
    msg = (
        f&#34;RMAP Verified Write Request ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:02x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:02x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:02x}\n&#34;
        f&#34;Key:               0x{packet[3]:02x}\n&#34;
        f&#34;Initiator address: 0x{packet[4]:02x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Address:           0x{packet[7:12].hex()}\n&#34;
        f&#34;Data Length:       0x04\n&#34;
        f&#34;Header CRC:        0x{packet[15]:02x}\n&#34;
        f&#34;data:              0x{packet[16:20].hex()}\n&#34;
        f&#34;Data CRC:          0x{packet[20]:02x}\n&#34;
    )
    return msg


def pretty_print_unverified_write_request_packet(packet):
    data_length = int.from_bytes(packet[12:15], byteorder=&#39;big&#39;)
    msg = (
        f&#34;RMAP Unverified Write Request ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:02x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:02x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:02x}\n&#34;
        f&#34;Key:               0x{packet[3]:02x}\n&#34;
        f&#34;Initiator address: 0x{packet[4]:02x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Address:           0x{packet[7:12].hex()}\n&#34;
        f&#34;Data Length:       {data_length}\n&#34;
        f&#34;Header CRC:        0x{packet[15]:02x}\n&#34;
        f&#34;data:              {packet[16:16 + min(32, data_length)]}\n&#34;
        f&#34;                   note: maximum 32 bytes will be printed for the data.\n&#34;
        f&#34;Data CRC:          0x{packet[-1]:0x}\n&#34;
    )
    return msg


def pp_packet(packet) -&gt; str:
    &#34;&#34;&#34;
    Returns a one-line representation of a SpW packet.

    Args:
        packet (bytes): the raw packet

    Returns:
        a one-line representation of a SpW packet
    &#34;&#34;&#34;
    RMAP_PROTOCOL_ID = 0x01
    CCSDS_PROTOCOL_ID = 0x02

    if hasattr(packet, &#39;raw&#39;):
        packet = packet.raw

    if get_protocol_id(packet) == RMAP_PROTOCOL_ID:
        msg = (
            f&#34;RMAP: &#34;
            f&#34;0x{packet[0]:0x}:&#34;
            f&#34;0x{packet[1]:0x}:&#34;
            f&#34;0x{packet[2]:0x}:&#34;
            f&#34;0x{packet[3]:0x}:&#34;
            f&#34;0x{packet[4]:0x}:&#34;
            f&#34;0x{packet[5:7].hex()}:&#34;
            f&#34;0x{packet[7]:0x}:&#34;
            f&#34;0x{packet[8:12].hex()}:&#34;
            f&#34;0x{packet[12:15].hex()}:&#34;
            f&#34;0x{packet[15]:0x}&#34;
        )
    elif get_protocol_id(packet) == CCSDS_PROTOCOL_ID:
        msg = (
            &#34;CCSDS Packet&#34;
        )
    else:
        msg = &#34;Extended Protocol Identifier is not supported&#34;

    return msg</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.dsi.esl.esl_close_connection"><code class="name flex">
<span>def <span class="ident">esl_close_connection</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the connection to the EtherSpaceLink DSI.</p>
<p>This also flushes and closes the log and record files if they were used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_close_connection(esl_link):
    &#34;&#34;&#34;
    Close the connection to the EtherSpaceLink DSI.

    This also flushes and closes the log and record files if they were used.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        Nothing
    &#34;&#34;&#34;
    egse.dsi._libesl.libesl_close(esl_link)
    logger.info(&#34;EtherSpaceLink connection closed successfully.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_configure"><code class="name flex">
<span>def <span class="ident">esl_configure</span></span>(<span>esl_link: ESL, active_link: int = 1, speed: int = 50, mode: int = 2, report: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the <code>esl_link</code> EtherSpaceWire link to the DSI.</p>
<p>The reporting parameter is used to enable reporting for the following events:</p>
<pre><code>ESL_ER_REPORT_PARITY_ERROR
ESL_ER_REPORT_TIME_CODE
ESL_ER_REPORT_ESC_EOP
ESL_ER_REPORT_ESC_EEP
ESL_ER_REPORT_ESC_ESC
ESL_ER_REPORT_TIMEOUT
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
<dt><strong><code>active_link</code></strong></dt>
<dd>the port number on the DSI where the SpW link shall be activated (default=1)</dd>
<dt><strong><code>speed</code></strong></dt>
<dd>the speed in Mbps</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>the link mode [DISABLED, NORMAL, LEGACY or MASTER]</dd>
<dt><strong><code>report</code></strong></dt>
<dd>enable reporting [default=0]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_configure(esl_link: &#39;ESL&#39;,
                  active_link: int = 1, speed: int = 50, mode: int = constants.ESL_LINK_MODE_NORMAL,
                  report: int = 0):
    &#34;&#34;&#34;
    Configure the `esl_link` EtherSpaceWire link to the DSI.

    The reporting parameter is used to enable reporting for the following events:

        ESL_ER_REPORT_PARITY_ERROR
        ESL_ER_REPORT_TIME_CODE
        ESL_ER_REPORT_ESC_EOP
        ESL_ER_REPORT_ESC_EEP
        ESL_ER_REPORT_ESC_ESC
        ESL_ER_REPORT_TIMEOUT

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        active_link: the port number on the DSI where the SpW link shall be activated (default=1)
        speed: the speed in Mbps
        mode: the link mode [DISABLED, NORMAL, LEGACY or MASTER]
        report: enable reporting [default=0]

    Returns:
        Nothing
    &#34;&#34;&#34;
    status = esl_set_active_link(esl_link, active_link)
    logger.info(f&#34;esl_set_active_link({active_link}) -&gt; {status = }&#34;)
    status = esl_set_speed(esl_link, speed)
    logger.info(f&#34;esl_set_speed({speed}) -&gt; {status = }&#34;)

    if report:
        status = esl_er_enable_reporting(esl_link, report)
        logger.info(f&#34;esl_er_enable_reporting(0b{report:b}) -&gt; {status = }&#34;)

    status = esl_set_mode(esl_link, mode)
    logger.info(f&#34;esl_set_mode({esl_link_mode[mode]}={mode}) -&gt; {status = }&#34;)

    status = esl_flush(esl_link)
    logger.info(f&#34;esl_flush() -&gt; {status = }&#34;)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_connection"><code class="name flex">
<span>def <span class="ident">esl_connection</span></span>(<span>dsi_address: str) ‑> ESL</span>
</code></dt>
<dd>
<div class="desc"><p>Context Manager that opens a EtherSpaceLink connection with the DSI (Diagnostic SpaceWire Interface).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dsi_address</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address of the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a pointer to the ESL structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def esl_connection(dsi_address: str) -&gt; &#39;ESL&#39;:
    &#34;&#34;&#34;
    Context Manager that opens a EtherSpaceLink connection with the DSI (Diagnostic SpaceWire Interface).

    Args:
        dsi_address (str): the IP address of the DSI

    Returns:
        a pointer to the ESL structure
    &#34;&#34;&#34;
    esl_link = None
    try:
        esl_link = esl_open_connection(dsi_address)
        yield esl_link
    finally:
        if esl_link:
            esl_close_connection(esl_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_er_enable_reporting"><code class="name flex">
<span>def <span class="ident">esl_er_enable_reporting</span></span>(<span>esl_link, flags)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_er_enable_reporting(esl_link, flags):
    result = egse.dsi._libesl.libesl_er_enable_reporting(esl_link, flags)
    if result:
        raise ESLError(
            f&#34;Could not enable error reporting, &#34;
            f&#34;ESL error code = {esl_error_codes[esl_link.contents.ESL_error]} [{esl_link.contents.ESL_error}]&#34;
        )
    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_flush"><code class="name flex">
<span>def <span class="ident">esl_flush</span></span>(<span>esl_link) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Flush all outstanding data to the destination. This function puts queued data onto the wire.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success, !0 otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_flush(esl_link) -&gt; int:
    &#34;&#34;&#34;
    Flush all outstanding data to the destination. This function puts queued data onto the wire.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        0 on success, !0 otherwise
    &#34;&#34;&#34;
    result = egse.dsi._libesl.libesl_flush(esl_link)
    # We don&#39;t want this to raise an exception, the result value should be checked by the caller instead.
    # if result:
    #     raise ESLError(
    #         f&#34;Could not flush/send transmit buffer, &#34;
    #         f&#34;ESL error code={esl_error_codes[esl_link.contents.ESL_error]} [{esl_link.contents.ESL_error}]&#34;
    #     )
    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_active_link"><code class="name flex">
<span>def <span class="ident">esl_get_active_link</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_active_link(esl_link):
    return esl_link.contents.current_port</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_esl_error"><code class="name flex">
<span>def <span class="ident">esl_get_esl_error</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_esl_error(esl_link):
    return egse.dsi._libesl.libesl_get_esl_error(esl_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_hwa"><code class="name flex">
<span>def <span class="ident">esl_get_hwa</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_hwa(esl_link):
    hwa = b&#39;012345&#39;  # Pre-allocate the character buffer
    egse.dsi._libesl.libesl_get_hwa(esl_link, hwa)
    return hwa</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_manufacturer_string"><code class="name flex">
<span>def <span class="ident">esl_get_manufacturer_string</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_manufacturer_string(esl_link):
    return egse.dsi._libesl.libesl_get_manufacturer_string(esl_link).decode()</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_number_of_links"><code class="name flex">
<span>def <span class="ident">esl_get_number_of_links</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_number_of_links(esl_link):
    return egse.dsi._libesl.libesl_get_number_of_links(esl_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_product_string"><code class="name flex">
<span>def <span class="ident">esl_get_product_string</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_product_string(esl_link):
    return egse.dsi._libesl.libesl_get_product_string(esl_link).decode()</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_receive_speed"><code class="name flex">
<span>def <span class="ident">esl_get_receive_speed</span></span>(<span>esl_link: ESL) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the receive speed of the currently active link.</p>
<p>Note that this function has the ability to cause frames to be dropped and the esl_request_rx_speed() function
should be used instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the speed of the active link in Mbits/s. In case of an error a value &lt; 0 will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_receive_speed(esl_link: &#39;ESL&#39;) -&gt; int:
    &#34;&#34;&#34;
    Gets the receive speed of the currently active link.

    Note that this function has the ability to cause frames to be dropped and the esl_request_rx_speed() function
    should be used instead.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        the speed of the active link in Mbits/s. In case of an error a value &lt; 0 will be returned.
    &#34;&#34;&#34;
    return egse.dsi._libesl.libesl_get_receive_speed(esl_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_rx_timeout"><code class="name flex">
<span>def <span class="ident">esl_get_rx_timeout</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_rx_timeout(esl_link):
    return esl_link.contents.rx_timeout</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_get_serial_number"><code class="name flex">
<span>def <span class="ident">esl_get_serial_number</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_get_serial_number(esl_link):
    hwa = esl_get_hwa(esl_link)
    return egse.dsi._libesl.libesl_hwa_to_serial_number_string(hwa)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_is_link_connected"><code class="name flex">
<span>def <span class="ident">esl_is_link_connected</span></span>(<span>esl_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_is_link_connected(esl_link):
    return egse.dsi._libesl.libesl_link_connected(esl_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_open_connection"><code class="name flex">
<span>def <span class="ident">esl_open_connection</span></span>(<span>dsi_address: str) ‑> ESL</span>
</code></dt>
<dd>
<div class="desc"><p>Open a connection to the EtherSpaceLink DSI on the given IP address.
This function will keep trying to connect for 10 seconds before aborting
and throwing an <code><a title="egse.dsi.esl.ESLError" href="#egse.dsi.esl.ESLError">ESLError</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dsi_address</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address of the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a pointer to the ESL structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_open_connection(dsi_address: str) -&gt; &#39;ESL&#39;:
    &#34;&#34;&#34;
    Open a connection to the EtherSpaceLink DSI on the given IP address.
    This function will keep trying to connect for 10 seconds before aborting
    and throwing an `ESLError`.

    Args:
        dsi_address (str): the IP address of the DSI

    Returns:
        a pointer to the ESL structure

    &#34;&#34;&#34;
    logger.info(f&#34;Open and setup EtherSpaceLink connection on {dsi_address}.&#34;)

    retry = 20  # number of retries before failing to open connection
    esl_link = None

    while retry:
        esl_link = egse.dsi._libesl.libesl_open(c_char_p(dsi_address.encode()))
        if esl_link:
            break
        else:
            time.sleep(0.5)  # wait half a second before trying again
            logger.info(f&#34;Trying to connect to {dsi_address}, {retry / 2.0} sec before shutdown.&#34;)
            retry -= 1

    if not esl_link:
        raise ESLError(f&#34;Couldn&#39;t open connection to DSI on {dsi_address}.&#34;)

    logger.info(f&#34;EtherSpaceLink connection to {dsi_address} opened successfully.&#34;)

    return esl_link</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_print_info"><code class="name flex">
<span>def <span class="ident">esl_print_info</span></span>(<span>esl_link: ESL)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints information about the connected device to the console.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_print_info(esl_link: &#39;ESL&#39;) -&gt; None:
    &#34;&#34;&#34;
    Prints information about the connected device to the console.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI

    Returns:
        nothing
    &#34;&#34;&#34;
    print(f&#34;Manufacturer        {esl_get_manufacturer_string(esl_link)}&#34;)
    print(f&#34;Product             {esl_get_product_string(esl_link)}&#34;)
    print(f&#34;Number of links     {esl_get_number_of_links(esl_link)} [active port={esl_get_active_link(esl_link)}]&#34;)

    hwa = esl_get_hwa(esl_link)
    serial_number = esl_get_serial_number(esl_link)

    print(f&#34;Serial number       {serial_number}&#34;)
    print(f&#34;Hardware Address    0x{hwa[0]:02X}-{hwa[1]:02X}-{hwa[2]:02X}-{hwa[3]:02X}-{hwa[4]:02X}-{hwa[5]:02X}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_print_summary_of_structure"><code class="name flex">
<span>def <span class="ident">esl_print_summary_of_structure</span></span>(<span>esl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_print_summary_of_structure(esl):
    print(&#34;EtherSpaceLink structure:&#34;)
    print(&#34;sock                {}&#34;.format(esl.contents.sock))
    print(&#34;tx_buffer_length    {}&#34;.format(esl.contents.tx_buffer_length))
    print(&#34;tx_buffer_content   {}&#34;.format(esl.contents.tx_buffer_content))
    print(&#34;rx_buffer_length    {}&#34;.format(esl.contents.rx_buffer_length))
    print(&#34;rx_buffer_content   {}&#34;.format(esl.contents.rx_buffer_content))
    print(&#34;rx_state            {}&#34;.format(esl.contents.rx_state))
    print(&#34;rx_count            {}&#34;.format(esl.contents.rx_count))
    print(&#34;rx_param            {}&#34;.format(esl.contents.rx_param))
    #print(&#34;rx_size             {}&#34;.format(esl.contents.rx_size))
    print(&#34;rx_timeout          {}&#34;.format(esl.contents.rx_timeout))
    #print(&#34;rx_final_terminator {}&#34;.format(esl.contents.rx_final_terminator))
    print(&#34;extn_count          {}&#34;.format(esl.contents.extn_count))
    print(&#34;number_of_slots     {}&#34;.format(esl.contents.number_of_slots))
    #print(&#34;id                  {}&#34;.format(esl.contents.id))</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_read_packet"><code class="name flex">
<span>def <span class="ident">esl_read_packet</span></span>(<span>esl_link: ESL, timeout: int = None) ‑> Tuple[int, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a full packet from the SpaceWire link.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;since this function returns a packet as a bytes object, the content of the packet can not be changed.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>the maximum timeout that read_packet() will wait for data before returning [milliseconds]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with the terminator value and a bytes object containing the packet.
When an error occurred, the first value in the tuple will be negative and contains the error number,
the second item in the tuple will then be an empty buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_read_packet(esl_link: &#39;ESL&#39;, timeout: int = None) -&gt; Tuple[int, bytes]:
    &#34;&#34;&#34;
    Reads a full packet from the SpaceWire link.

    .. note:: since this function returns a packet as a bytes object, the content of the packet can not be changed.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        timeout (int): the maximum timeout that read_packet() will wait for data before returning [milliseconds]

    Returns:
        A tuple with the terminator value and a bytes object containing the packet.
        When an error occurred, the first value in the tuple will be negative and contains the error number,
        the second item in the tuple will then be an empty buffer.

    &#34;&#34;&#34;
    terminator = c_int(0)
    terminator_p = ctypes.pointer(terminator)

    bytes_received = esl_read_packet_full(
        esl_link, rx_buffer, dsi_settings.RX_BUFFER_LENGTH, terminator_p,
        constants.ESL_RETURN_EXTENSION_DATA | constants.ESL_RETURN_SPECIAL_DATA, timeout=timeout)

    # logger.debug(f&#34;Number of bytes received: {bytes_received}&#34;)

    if bytes_received &lt; 0:
        return bytes_received, bytes()

    return terminator.value, rx_buffer[:bytes_received]</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_read_packet_full"><code class="name flex">
<span>def <span class="ident">esl_read_packet_full</span></span>(<span>esl_link, buffer, buffer_length, rx_terminator, special_data_action, timeout: int = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_read_packet_full(esl_link, buffer, buffer_length, rx_terminator, special_data_action, timeout: int = None):

    if timeout:
        saved_timeout = esl_get_rx_timeout(esl_link)
        egse.dsi._libesl.libesl_set_rx_timeout(esl_link, timeout)

    result = egse.dsi._libesl.libesl_read_packet_full(esl_link, buffer, buffer_length, rx_terminator, special_data_action)

    if timeout:
        egse.dsi._libesl.libesl_set_rx_timeout(esl_link, saved_timeout)

    # This error handling is (or should be) done in the calling application, see for example egse.feesim.py
    # if result == -1:
    #     raise ESLError(
    #         f&#34;Could not read full packet, &#34;
    #         f&#34;ESL error code = {esl_error_codes[esl_link.contents.ESL_error]} [{esl_link.contents.ESL_error}]&#34;
    #     )

    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_send_timecode"><code class="name flex">
<span>def <span class="ident">esl_send_timecode</span></span>(<span>esl_link: ESL, timecode: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Send a timecode over the SpaceWire link.</p>
<p>The 8-bit timecode argument contains six-bit of system time (time-field) and two control flags.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
<dt><strong><code>timecode</code></strong> :&ensp;<code>int</code></dt>
<dd>an 8-bit timecode field</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 if the request has been queued, not 0 if not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_send_timecode(esl_link: &#39;ESL&#39;, timecode: int) -&gt; int:
    &#34;&#34;&#34;
    Send a timecode over the SpaceWire link.

    The 8-bit timecode argument contains six-bit of system time (time-field) and two control flags.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        timecode (int): an 8-bit timecode field

    Returns:
        0 if the request has been queued, not 0 if not.

    &#34;&#34;&#34;
    result = egse.dsi._libesl.libesl_send_timecode(esl_link, timecode)

    if result:
        raise ESLError(
            f&#34;Could not send timecode, ESL error code={esl_error_codes[esl_link.contents.ESL_error]} &#34;
            f&#34;[{esl_link.contents.ESL_error}]&#34;
        )

    result = egse.dsi._libesl.libesl_flush(esl_link)

    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_set_active_link"><code class="name flex">
<span>def <span class="ident">esl_set_active_link</span></span>(<span>esl_link, active_link)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_set_active_link(esl_link, active_link):
    return egse.dsi._libesl.libesl_set_active_link(esl_link, active_link)</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_set_log_file"><code class="name flex">
<span>def <span class="ident">esl_set_log_file</span></span>(<span>esl_link, filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_set_log_file(esl_link, filename):
    result = egse.dsi._libesl.libesl_set_log_file(esl_link, c_char_p(filename.encode()))
    if result:
        raise ESLError(f&#34;Could not write to or open log file {filename}.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_set_mode"><code class="name flex">
<span>def <span class="ident">esl_set_mode</span></span>(<span>esl_link: ESL, mode: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Set the operating mode of the currently active SpaceWire link.</p>
<p>After opening a connection, the link is disabled; it must then
be enabled into one of its operational modes before data can
be transferred.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>int</code></dt>
<dd>the link mode [DISABLED, NORMAL, LEGACY or MASTER]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 if the request has been queued, not 0 if not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_set_mode(esl_link: &#39;ESL&#39;, mode: int) -&gt; int:
    &#34;&#34;&#34;
    Set the operating mode of the currently active SpaceWire link.

    After opening a connection, the link is disabled; it must then
    be enabled into one of its operational modes before data can
    be transferred.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        mode (int): the link mode [DISABLED, NORMAL, LEGACY or MASTER]

    Returns:
        0 if the request has been queued, not 0 if not.

    &#34;&#34;&#34;
    result = egse.dsi._libesl.libesl_set_mode(esl_link, mode)
    if result:
        raise ESLError(f&#34;Could not set mode {esl_link_mode[mode]}.&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_set_record_file"><code class="name flex">
<span>def <span class="ident">esl_set_record_file</span></span>(<span>esl_link, filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_set_record_file(esl_link, filename):
    result = egse.dsi._libesl.libesl_set_record_file(esl_link, c_char_p(filename.encode()))
    if result:
        raise ESLError(f&#34;Could not write to or open record file {filename}.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_set_rx_timeout"><code class="name flex">
<span>def <span class="ident">esl_set_rx_timeout</span></span>(<span>esl_link, timeout: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_set_rx_timeout(esl_link, timeout: int):
    esl_link.contents.rx_timeout = timeout</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_set_speed"><code class="name flex">
<span>def <span class="ident">esl_set_speed</span></span>(<span>esl_link, speed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_set_speed(esl_link, speed):
    result = egse.dsi._libesl.libesl_set_speed(esl_link, speed)
    if result:
        raise ESLError(&#34;Could not set speed to {}, ESL error code={} [{}]&#34;.format(speed, esl_error_codes[
            esl_link.contents.ESL_error], esl_link.contents.ESL_error))
    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.esl_write_packet"><code class="name flex">
<span>def <span class="ident">esl_write_packet</span></span>(<span>esl_link: ESL, buffer, buffer_length: int, tx_terminator: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Queue data for transmission over the SpaceWire cable. If there is no room left in the buffer,
the buffer is transmitted.</p>
<p>Note, that even when the queued data is transmitted, the data added to it may not be.
To guarantee transmission of this data you need to call the esl_flush() function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>esl_link</code></strong> :&ensp;<code>ESL</code></dt>
<dd>the ESL structure that defines the connection to the DSI</dd>
<dt><strong><code>buffer</code></strong></dt>
<dd>the data to send</dd>
<dt><strong><code>buffer_length</code></strong></dt>
<dd>the size of the buffer to send (the actual buffer size might be longer)</dd>
<dt><strong><code>tx_terminator</code></strong></dt>
<dd>additional metadata about the frame we are transmitting (EOP, EEP, PART_EOP_EEP, EXTN)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>return_code</code></dt>
<dd>0 on success, &lt; 0 when an error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esl_write_packet(esl_link: &#39;ESL&#39;, buffer, buffer_length: int, tx_terminator: int) -&gt; int:
    &#34;&#34;&#34;
    Queue data for transmission over the SpaceWire cable. If there is no room left in the buffer,
    the buffer is transmitted.

    Note, that even when the queued data is transmitted, the data added to it may not be.
    To guarantee transmission of this data you need to call the esl_flush() function.

    Args:
        esl_link (ESL): the ESL structure that defines the connection to the DSI
        buffer: the data to send
        buffer_length: the size of the buffer to send (the actual buffer size might be longer)
        tx_terminator: additional metadata about the frame we are transmitting (EOP, EEP, PART_EOP_EEP, EXTN)

    Returns:
        return_code: 0 on success, &lt; 0 when an error occurred.
    &#34;&#34;&#34;

    result = egse.dsi._libesl.libesl_write_packet(esl_link, buffer, buffer_length, tx_terminator)

    return result</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.get_extension_name"><code class="name flex">
<span>def <span class="ident">get_extension_name</span></span>(<span>code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extension_name(code):
    if code in esl_extension_codes:
        return esl_extension_codes[code]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.get_protocol_id"><code class="name flex">
<span>def <span class="ident">get_protocol_id</span></span>(<span>packet) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_protocol_id(packet) -&gt; int:
    if isinstance(packet[1], bytes):
        value = int.from_bytes(packet[1], byteorder=&#39;big&#39;)
    else:
        value = packet[1]  # value assumed to be of type &#39;int&#39;
    return value</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.get_terminator_name"><code class="name flex">
<span>def <span class="ident">get_terminator_name</span></span>(<span>code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_terminator_name(code):
    if code in esl_terminator_codes:
        return esl_terminator_codes[code]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.is_extension_code"><code class="name flex">
<span>def <span class="ident">is_extension_code</span></span>(<span>code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_extension_code(code):
    return True if code in esl_extension_codes else False</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.is_terminator_code"><code class="name flex">
<span>def <span class="ident">is_terminator_code</span></span>(<span>code)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_terminator_code(code):
    return True if code in esl_terminator_codes else False</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.is_timecode"><code class="name flex">
<span>def <span class="ident">is_timecode</span></span>(<span>packet) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the packet is a timecode reported as an extension from the DSI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_timecode(packet) -&gt; bool:
    &#34;&#34;&#34;Returns True if the packet is a timecode reported as an extension from the DSI.&#34;&#34;&#34;
    return packet[0] == 0x91</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.pp_packet"><code class="name flex">
<span>def <span class="ident">pp_packet</span></span>(<span>packet) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a one-line representation of a SpW packet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>bytes</code></dt>
<dd>the raw packet</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a one-line representation of a SpW packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pp_packet(packet) -&gt; str:
    &#34;&#34;&#34;
    Returns a one-line representation of a SpW packet.

    Args:
        packet (bytes): the raw packet

    Returns:
        a one-line representation of a SpW packet
    &#34;&#34;&#34;
    RMAP_PROTOCOL_ID = 0x01
    CCSDS_PROTOCOL_ID = 0x02

    if hasattr(packet, &#39;raw&#39;):
        packet = packet.raw

    if get_protocol_id(packet) == RMAP_PROTOCOL_ID:
        msg = (
            f&#34;RMAP: &#34;
            f&#34;0x{packet[0]:0x}:&#34;
            f&#34;0x{packet[1]:0x}:&#34;
            f&#34;0x{packet[2]:0x}:&#34;
            f&#34;0x{packet[3]:0x}:&#34;
            f&#34;0x{packet[4]:0x}:&#34;
            f&#34;0x{packet[5:7].hex()}:&#34;
            f&#34;0x{packet[7]:0x}:&#34;
            f&#34;0x{packet[8:12].hex()}:&#34;
            f&#34;0x{packet[12:15].hex()}:&#34;
            f&#34;0x{packet[15]:0x}&#34;
        )
    elif get_protocol_id(packet) == CCSDS_PROTOCOL_ID:
        msg = (
            &#34;CCSDS Packet&#34;
        )
    else:
        msg = &#34;Extended Protocol Identifier is not supported&#34;

    return msg</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.pretty_print_read_request_packet"><code class="name flex">
<span>def <span class="ident">pretty_print_read_request_packet</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_read_request_packet(packet):
    msg = (
        f&#34;RMAP Read Request  ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:0x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:0x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:0x}\n&#34;
        f&#34;Key:               0x{packet[3]:0x}\n&#34;
        f&#34;Initiator address: 0x{packet[4]:0x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Extended address:  0x{packet[7]:0x}\n&#34;
        f&#34;Address Field:     0x{packet[8:12].hex()}\n&#34;
        f&#34;Data Length:       0x{packet[12:15].hex()}\n&#34;
        f&#34;Header CRC:        0x{packet[15]:0x}\n&#34;
    )
    return msg</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.pretty_print_read_request_reply_packet"><code class="name flex">
<span>def <span class="ident">pretty_print_read_request_reply_packet</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_read_request_reply_packet(packet):
    data_length = int.from_bytes(packet[8:11], byteorder=&#39;big&#39;)
    msg = (
        f&#34;RMAP Read Request Reply ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:0x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:0x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:0x}\n&#34;
        f&#34;Status:            0x{packet[3]:0x}\n&#34;
        f&#34;Target address:    0x{packet[4]:0x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Reserved:          0x{packet[7]:0x}\n&#34;
        f&#34;Data Length:       {data_length}\n&#34;
        f&#34;Header CRC:        0x{packet[11]:0x}\n&#34;
        f&#34;data:              0x{packet[12:12 + min(32, data_length)].hex()}\n&#34;
        f&#34;                   note: maximum 32 bytes will be printed for the data.\n&#34;
        f&#34;Data CRC:          0x{packet[-1]:0x}\n&#34;
    )
    return msg</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.pretty_print_unverified_write_request_packet"><code class="name flex">
<span>def <span class="ident">pretty_print_unverified_write_request_packet</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_unverified_write_request_packet(packet):
    data_length = int.from_bytes(packet[12:15], byteorder=&#39;big&#39;)
    msg = (
        f&#34;RMAP Unverified Write Request ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:02x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:02x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:02x}\n&#34;
        f&#34;Key:               0x{packet[3]:02x}\n&#34;
        f&#34;Initiator address: 0x{packet[4]:02x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Address:           0x{packet[7:12].hex()}\n&#34;
        f&#34;Data Length:       {data_length}\n&#34;
        f&#34;Header CRC:        0x{packet[15]:02x}\n&#34;
        f&#34;data:              {packet[16:16 + min(32, data_length)]}\n&#34;
        f&#34;                   note: maximum 32 bytes will be printed for the data.\n&#34;
        f&#34;Data CRC:          0x{packet[-1]:0x}\n&#34;
    )
    return msg</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.pretty_print_verified_write_request_packet"><code class="name flex">
<span>def <span class="ident">pretty_print_verified_write_request_packet</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_verified_write_request_packet(packet):
    msg = (
        f&#34;RMAP Verified Write Request ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:02x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:02x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:02x}\n&#34;
        f&#34;Key:               0x{packet[3]:02x}\n&#34;
        f&#34;Initiator address: 0x{packet[4]:02x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Address:           0x{packet[7:12].hex()}\n&#34;
        f&#34;Data Length:       0x04\n&#34;
        f&#34;Header CRC:        0x{packet[15]:02x}\n&#34;
        f&#34;data:              0x{packet[16:20].hex()}\n&#34;
        f&#34;Data CRC:          0x{packet[20]:02x}\n&#34;
    )
    return msg</code></pre>
</details>
</dd>
<dt id="egse.dsi.esl.pretty_print_write_request_reply_packet"><code class="name flex">
<span>def <span class="ident">pretty_print_write_request_reply_packet</span></span>(<span>packet)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print_write_request_reply_packet(packet):
    data_length = int.from_bytes(packet[8:11], byteorder=&#39;big&#39;)
    msg = (
        f&#34;RMAP Write Request Reply ({len(packet)} bytes)\n&#34;
        f&#34;Logical address:   0x{packet[0]:0x}\n&#34;
        f&#34;Protocol ID:       0x{packet[1]:0x}\n&#34;
        f&#34;Instruction:       0x{packet[2]:0x}\n&#34;
        f&#34;Status:            0x{packet[3]:0x}\n&#34;
        f&#34;Target address:    0x{packet[4]:0x}\n&#34;
        f&#34;Transaction ID:    0x{packet[5:7].hex()}\n&#34;
        f&#34;Header CRC:        0x{packet[7]:0x}\n&#34;
    )
    return msg</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.dsi.esl.ESLError"><code class="flex name class">
<span>class <span class="ident">ESLError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ESLError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.dsi" href="index.html">egse.dsi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.dsi.esl.esl_close_connection" href="#egse.dsi.esl.esl_close_connection">esl_close_connection</a></code></li>
<li><code><a title="egse.dsi.esl.esl_configure" href="#egse.dsi.esl.esl_configure">esl_configure</a></code></li>
<li><code><a title="egse.dsi.esl.esl_connection" href="#egse.dsi.esl.esl_connection">esl_connection</a></code></li>
<li><code><a title="egse.dsi.esl.esl_er_enable_reporting" href="#egse.dsi.esl.esl_er_enable_reporting">esl_er_enable_reporting</a></code></li>
<li><code><a title="egse.dsi.esl.esl_flush" href="#egse.dsi.esl.esl_flush">esl_flush</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_active_link" href="#egse.dsi.esl.esl_get_active_link">esl_get_active_link</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_esl_error" href="#egse.dsi.esl.esl_get_esl_error">esl_get_esl_error</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_hwa" href="#egse.dsi.esl.esl_get_hwa">esl_get_hwa</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_manufacturer_string" href="#egse.dsi.esl.esl_get_manufacturer_string">esl_get_manufacturer_string</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_number_of_links" href="#egse.dsi.esl.esl_get_number_of_links">esl_get_number_of_links</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_product_string" href="#egse.dsi.esl.esl_get_product_string">esl_get_product_string</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_receive_speed" href="#egse.dsi.esl.esl_get_receive_speed">esl_get_receive_speed</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_rx_timeout" href="#egse.dsi.esl.esl_get_rx_timeout">esl_get_rx_timeout</a></code></li>
<li><code><a title="egse.dsi.esl.esl_get_serial_number" href="#egse.dsi.esl.esl_get_serial_number">esl_get_serial_number</a></code></li>
<li><code><a title="egse.dsi.esl.esl_is_link_connected" href="#egse.dsi.esl.esl_is_link_connected">esl_is_link_connected</a></code></li>
<li><code><a title="egse.dsi.esl.esl_open_connection" href="#egse.dsi.esl.esl_open_connection">esl_open_connection</a></code></li>
<li><code><a title="egse.dsi.esl.esl_print_info" href="#egse.dsi.esl.esl_print_info">esl_print_info</a></code></li>
<li><code><a title="egse.dsi.esl.esl_print_summary_of_structure" href="#egse.dsi.esl.esl_print_summary_of_structure">esl_print_summary_of_structure</a></code></li>
<li><code><a title="egse.dsi.esl.esl_read_packet" href="#egse.dsi.esl.esl_read_packet">esl_read_packet</a></code></li>
<li><code><a title="egse.dsi.esl.esl_read_packet_full" href="#egse.dsi.esl.esl_read_packet_full">esl_read_packet_full</a></code></li>
<li><code><a title="egse.dsi.esl.esl_send_timecode" href="#egse.dsi.esl.esl_send_timecode">esl_send_timecode</a></code></li>
<li><code><a title="egse.dsi.esl.esl_set_active_link" href="#egse.dsi.esl.esl_set_active_link">esl_set_active_link</a></code></li>
<li><code><a title="egse.dsi.esl.esl_set_log_file" href="#egse.dsi.esl.esl_set_log_file">esl_set_log_file</a></code></li>
<li><code><a title="egse.dsi.esl.esl_set_mode" href="#egse.dsi.esl.esl_set_mode">esl_set_mode</a></code></li>
<li><code><a title="egse.dsi.esl.esl_set_record_file" href="#egse.dsi.esl.esl_set_record_file">esl_set_record_file</a></code></li>
<li><code><a title="egse.dsi.esl.esl_set_rx_timeout" href="#egse.dsi.esl.esl_set_rx_timeout">esl_set_rx_timeout</a></code></li>
<li><code><a title="egse.dsi.esl.esl_set_speed" href="#egse.dsi.esl.esl_set_speed">esl_set_speed</a></code></li>
<li><code><a title="egse.dsi.esl.esl_write_packet" href="#egse.dsi.esl.esl_write_packet">esl_write_packet</a></code></li>
<li><code><a title="egse.dsi.esl.get_extension_name" href="#egse.dsi.esl.get_extension_name">get_extension_name</a></code></li>
<li><code><a title="egse.dsi.esl.get_protocol_id" href="#egse.dsi.esl.get_protocol_id">get_protocol_id</a></code></li>
<li><code><a title="egse.dsi.esl.get_terminator_name" href="#egse.dsi.esl.get_terminator_name">get_terminator_name</a></code></li>
<li><code><a title="egse.dsi.esl.is_extension_code" href="#egse.dsi.esl.is_extension_code">is_extension_code</a></code></li>
<li><code><a title="egse.dsi.esl.is_terminator_code" href="#egse.dsi.esl.is_terminator_code">is_terminator_code</a></code></li>
<li><code><a title="egse.dsi.esl.is_timecode" href="#egse.dsi.esl.is_timecode">is_timecode</a></code></li>
<li><code><a title="egse.dsi.esl.pp_packet" href="#egse.dsi.esl.pp_packet">pp_packet</a></code></li>
<li><code><a title="egse.dsi.esl.pretty_print_read_request_packet" href="#egse.dsi.esl.pretty_print_read_request_packet">pretty_print_read_request_packet</a></code></li>
<li><code><a title="egse.dsi.esl.pretty_print_read_request_reply_packet" href="#egse.dsi.esl.pretty_print_read_request_reply_packet">pretty_print_read_request_reply_packet</a></code></li>
<li><code><a title="egse.dsi.esl.pretty_print_unverified_write_request_packet" href="#egse.dsi.esl.pretty_print_unverified_write_request_packet">pretty_print_unverified_write_request_packet</a></code></li>
<li><code><a title="egse.dsi.esl.pretty_print_verified_write_request_packet" href="#egse.dsi.esl.pretty_print_verified_write_request_packet">pretty_print_verified_write_request_packet</a></code></li>
<li><code><a title="egse.dsi.esl.pretty_print_write_request_reply_packet" href="#egse.dsi.esl.pretty_print_write_request_reply_packet">pretty_print_write_request_reply_packet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.dsi.esl.ESLError" href="#egse.dsi.esl.ESLError">ESLError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
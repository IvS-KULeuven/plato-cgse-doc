<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.fov.fov_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.fov.fov_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pickle
from pathlib import Path

import sys
import zmq
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot, QThread, QLockFile
from PyQt5.QtGui import QCloseEvent, QFont, QIcon
from PyQt5.QtWidgets import QMainWindow, QLabel, QFrame, QHBoxLayout, QGridLayout, QVBoxLayout, QApplication, QAction, \
    QWidget, QSizePolicy, QMessageBox
from math import tan, radians

from egse import coordinates
from egse.config import find_file
from egse.control import is_control_server_active
from egse.coordinates import focal_plane_to_ccd_coordinates
from egse.gui import VLine
from egse.gui.focalplane import FocalPlaneWidgetWithSourcePosition
from egse.gui.mechanisms import ScanMirrorAssemblyWidget, BigRotationStageWidget, FocusPositionWidget
from egse.help.help_ui import HelpWindow, HELP_TOPICS
from egse.observer import Observer, Observable
from egse.resource import get_resource
from egse.settings import Settings
from egse.setup import load_setup
from egse.zmq_ser import connect_address

FONT = QFont(&#34;Helvetica&#34;, 18)

STAGES_SETTINGS = Settings.load(&#34;Huber Control Server&#34;)
HEXAPOD_SETTINGS = Settings.load(&#34;Hexapod PUNA Control Server&#34;)


class MonitoringWorker(QObject):

    def __init__(self, settings):
        &#34;&#34;&#34; Initialisation of a monitoring worker.

        This monitoring worker will listen on the monitoring port of the Control Server, based on the given settings.

        Args:
            - settings: Settings with the connection information (which was loaded from the settings file).
        &#34;&#34;&#34;

        super(MonitoringWorker, self).__init__()

        self.active = False

        self.monitoring_socket = None
        self.monitoring_timeout = 0.5  # [s]
        self.commanding_address = None
        self.is_socket_connected = False

        self.connect_socket(settings)

    def connect_socket(self, settings):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.

        Args:
            - settings: Settings with the connection information (which was loaded from the settings file).
        &#34;&#34;&#34;

        try:

            # Ctrl settings:
            #   - transport protocol
            #   - hostname
            #   - commanding port (to check whether the CS is active)
            #   - monitoring port (to ask for process information)

            transport = settings.PROTOCOL
            hostname = settings.HOSTNAME
            commanding_port = settings.COMMANDING_PORT
            monitoring_port = settings.MONITORING_PORT

            # Create a socket and connect to the monitoring port

            monitoring_address = connect_address(transport, hostname, monitoring_port)
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

            # Address of the commanding port
            # This is needed when checking whether or not the CS is active

            self.commanding_address = connect_address(transport, hostname, commanding_port)

            self.is_socket_connected = True

        except AttributeError:

            self.is_socket_connected = False

    def stop(self):
        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;

        self.is_socket_connected = False
        self.monitoring_socket.close()

        # self.monitoring_socket.disconnect(self.monitoring_address)
        # self.monitoring_socket.close(linger=0)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.

        If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
        to notify the GUI.
        &#34;&#34;&#34;

        self.run()

    # @pyqtSlot()
    def run(self):

        raise NotImplementedError


class StagesMonitoringWorker(MonitoringWorker):
    &#34;&#34;&#34; Worker for monitoring the position of the stages.&#34;&#34;&#34;

    # The worker will send a signal with three floats and one dictionaries:
    # The floats will be:
    #   - Commanded position of the big rotation stage [degrees]
    #   - Commanded position of the small rotation stage [degrees]
    #   - Commanded position of the translation stage [mm]
    # The dictionary will have the following entries:
    #   - &#34;angles&#34;: Tuple with the field angles (theta, phi) [degrees]
    #   - &#34;pixels&#34;: Tuple with the CCD coordinates (row, column) [pixels] and the CCD code
    #   - &#34;mm&#34;: Tuple with the focal-plane coordinates (x, y) [pixels]

    stages_position_signal = pyqtSignal(float, float, float, dict)

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker for the stages.

        This monitoring worker will listen on the monitoring port of the Huber Control Server.
        &#34;&#34;&#34;

        super(StagesMonitoringWorker, self).__init__(STAGES_SETTINGS)

        # When new monitoring information comes in, these variables will contain the previous values for the position
        # of the stages (as currently displayed in the GUI).  Once we have checked whether changes have occurred since
        # the last time monitoring information was received, these values will be overwritten by the new ones.

        self.position_big_rotation_stage = None
        self.position_small_rotation_stage = None
        self.position_translation_stage = None

        # Information from the setup

        setup = load_setup()

        self.focal_length = setup.camera.fov.focal_length_mm
        self.offset_alpha = setup.gse.stages.calibration.offset_alpha
        self.offset_phi = setup.gse.stages.calibration.offset_phi
        self.offset_delta_x = setup.gse.stages.calibration.offset_delta_x
        self.alpha_correction_coefficients = setup.gse.stages.calibration.alpha_correction_coefficients
        self.phi_correction_coefficients = setup.gse.stages.calibration.phi_correction_coefficients

        self.distortion_coefficients = setup.camera.fov.distortion_coefficients
        self.height_collimated_beam = setup.gse.stages.calibration.height_collimated_beam

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port of the stages.

        If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
        Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
        process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
        0.5s).
        &#34;&#34;&#34;

        self.active = True

        while self.is_socket_connected and self.active:

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Update the timeout, to be more in line with the monitoring frequency of the CS (i.e. the delay).
                    # Take 0.5s extra to be on the safe side.

                    self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                    if self.position_has_changed(monitoring_info):

                        self.stages_position_signal.emit(self.position_big_rotation_stage,
                                                         self.position_small_rotation_stage,
                                                         self.position_translation_stage,
                                                         self.get_position())

            except zmq.ZMQError:

                pass

            # Timeout occurred

            else:

                # The CS is not active

                if not is_control_server_active(self.commanding_address):

                    # TODO
                    pass

                # The CS is active, but the timeout was too strict

                else:

                    self.monitoring_timeout += 0.5

    def position_has_changed(self, monitoring_info: dict):
        &#34;&#34;&#34; Check whether the position of at least one of the stages has changed.

        Check whether the position of at least one of the changes has changed since the previous time monitoring
        information was received.

        If the position of the stages has changed, the previous values are updated.

        Args:
            - monitoring_info: Monitoring information for the stages.

        Returns: True if the position of at least one of the stages has changed; False otherwise.
        &#34;&#34;&#34;

        position_has_changed = False

        # Big rotation stage

        position_big_rotation_stage = monitoring_info[&#34;big_rotation_stage_position&#34;]

        if position_big_rotation_stage != self.position_big_rotation_stage:

            self.position_big_rotation_stage = position_big_rotation_stage
            position_has_changed = True

        # Small rotation stage

        position_small_rotation_stage = monitoring_info[&#34;small_rotation_stage_position&#34;]

        if position_small_rotation_stage != self.position_small_rotation_stage:

            self.position_small_rotation_stage = position_small_rotation_stage
            position_has_changed = True

        # Translation stage

        position_translation_stage = monitoring_info[&#34;translation_stage_position&#34;]

        if position_translation_stage != self.position_translation_stage:

            self.position_translation_stage = position_translation_stage
            position_has_changed = True

        return position_has_changed

    def get_position(self):
        &#34;&#34;&#34; Calculates the coordinate of the source.

        Calculates the coordinate of the source, given the position of the associated hexapod and stages, and taking
        the field distortion into account.

        :return: Dictionary with the following entries:
                    - &#34;angles&#34;: gnomonic distance from the optical axis and in-field angle [degrees]
                    - &#34;pixels&#34;: CCD coordinates (row, column) [pixels] and the corresponding CCD code
                    - &#34;mm&#34;: focal-plane coordinates (x, y) [mm]
        &#34;&#34;&#34;

        # TODO Check whether the light beam passes through the entrance pupil

        # Gnomonic distance to optical axis and in-field angle [degrees]

        theta = (self.position_small_rotation_stage + self.offset_alpha - self.alpha_correction_coefficients[0]) \
            / self.alpha_correction_coefficients[1]

        phi_correction = self.phi_correction_coefficients[1] * theta + self.phi_correction_coefficients[0]
        phi = -self.position_big_rotation_stage - self.offset_phi - phi_correction

        # Focal-plane coordinates [mm]

        x, y = coordinates.angles_to_focal_plane_coordinates(theta, phi)

        # CCD coordinates [pixels]

        (row, column, ccd_code) = focal_plane_to_ccd_coordinates(x, y, setup)

        position = {
            &#34;angles&#34;: (theta, phi),
            &#34;pixels&#34;: (row, column, ccd_code),
            &#34;mm&#34;: (x, y)
        }

        return position

    def light_beam_through_entrance_pupil(self):
        &#34;&#34;&#34; Check whether the light beam goes through the entrance pupil.

        Returns: True of the light beam passes through the entrance pupil; False otherwise.
        &#34;&#34;&#34;

        distance_sma = -self.position_translation_stage + self.offset_delta_x

        return distance_sma / self.height_collimated_beam == \
            tan(radians(self.position_small_rotation_stage + self.offset_alpha + 45))

    # def get_focal_plane_position(self):
    #
    #     &#34;&#34;&#34;
    #     Calculates and returns the focal-plane coordinates (x, y) [mm] of the source, given the
    #     position of the associated hexapod and stages, and taking the field distortion into account.
    #
    #     :return: Focal-plane coordinates (x, y) [mm] of the source, given the position of the
    #              associated hexapod and stages, and taking the field distortion into account.
    #     &#34;&#34;&#34;
    #
    #     angle_big_rotation_stage = self.position_big_rotation_stage

        # # Rotation angle of the big rotation stage [degrees]
        # # - counterclockwise rotation
        # # - 0° -&gt; axis of the focal plane aligned with GL_FIX
        #
        # angle_big_rotation_stage = self.position_big_rotation_stage
        #
        # # Rotation angle of the small rotation stage [degrees]
        # # - clockwise rotation
        # # - 0° -&gt; ?
        #
        # angle_small_rotation_stage = self.position_small_rotation_stage
        #
        # # Radial distance without field distortion [mm] and corresponding focal-plane coordinates [mm]
        # # Note that the height of the lower triangle is very close to the focal length
        #
        # theta = 2 * angle_small_rotation_stage  # [degrees]
        #
        # radial_distance_undistorted = self.focal_length * tan(radians(theta))
        #
        # x_undistorted = -radial_distance_undistorted * cos(-radians(angle_big_rotation_stage))
        # y_undistorted = -radial_distance_undistorted * sin(-radians(angle_big_rotation_stage))
        #
        # x_distorted, y_distorted = \
        #     undistorted_to_distorted_focal_plane_coordinates(x_undistorted, y_undistorted,
        #                                                      self.distortion_coefficients, self.focal_length)
        #
        # return x_distorted, y_distorted


class HexapodMonitoringWorker(MonitoringWorker):
    &#34;&#34;&#34; Worker for monitoring the position of the hexapod.&#34;&#34;&#34;

    # The worker will send a signal with the following information:
    #   - focus positions [mm]

    hexapod_position_signal = pyqtSignal(float)

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker for the hexapod.

        This monitoring worker will listen on the monitoring port of the Hexapod PUNA Control Server.
        &#34;&#34;&#34;

        super(HexapodMonitoringWorker, self).__init__(HEXAPOD_SETTINGS)

        self.focus_position = None

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port of the hexapod.

        If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
        Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
        process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
        0.5s).
        &#34;&#34;&#34;
        self.active = True

        while self.is_socket_connected and self.active:

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Update the timeout, to be more in line with the monitoring frequency of the CS (i.e. the delay).
                    # Take 0.5s extra to be on the safe side.

                    self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                    if self.position_has_changed(monitoring_info):
                        self.hexapod_position_signal.emit(self.focus_position)

            except zmq.ZMQError:

                pass

            # Timeout occurred

            else:

                # The CS is not active

                if not is_control_server_active(self.commanding_address):

                    pass

                # The CS is active, but the timeout was too strict

                else:

                    self.monitoring_timeout += 0.5

    @staticmethod
    def get_focus_position(monitoring_info: dict):

        return -monitoring_info[&#34;user&#34;][2]

    def position_has_changed(self, monitoring_info: dict):
        &#34;&#34;&#34; Check whether the focus position has changed.

        Check whether the focus position has changed since the previous time monitoring information was received.

        If the focus position has changed, the previous value is updated.

        Args:
            - monitoring_info: Monitoring information for the hexapod.

        Returns: True if the focus position has changed; False otherwise.
        &#34;&#34;&#34;

        focus_position = self.get_focus_position(monitoring_info)

        if focus_position != self.focus_position:

            self.focus_position = focus_position
            return True

        return False


class FOVUIView(QMainWindow, Observable):

    def __init__(self):

        &#34;&#34;&#34;
        Open a window and initialiase the GUI.  The GUI is divided into two parts.  On the
        left there are three widgets, showing the current setting of the stages and the focus
        position.  On the right the focal plane is shown, together with a blue circle indicating
        the size of the field-of-view, and a red dot indicating the current position of the source.
        &#34;&#34;&#34;

        super().__init__()

        self.setGeometry(300, 300, 1500, 1000)
        self.setWindowTitle(&#34;FOV Position GUI&#34;)

        setup = load_setup()
        self.fov_radius_mm = setup.camera.fov.radius_mm

        # Monitoring the stages

        self.stages_monitoring_thread = QThread(self)
        self.stages_monitoring_worker = StagesMonitoringWorker()
        self.stages_monitoring_worker.moveToThread(self.stages_monitoring_thread)

        self.stages_monitoring_worker.stages_position_signal.connect(self.on_stages_position_change_signal)
        self.stages_monitoring_thread.started.connect(self.stages_monitoring_worker.start_process)
        self.stages_monitoring_thread.start()

        # Monitoring the hexapod

        self.hexapod_monitoring_thread = QThread(self)
        self.hexapod_monitoring_worker = HexapodMonitoringWorker()
        self.hexapod_monitoring_worker.moveToThread(self.hexapod_monitoring_thread)

        self.hexapod_monitoring_worker.hexapod_position_signal.connect(self.on_hexapod_position_change_signal)
        self.hexapod_monitoring_thread.started.connect(self.hexapod_monitoring_worker.start_process)
        self.hexapod_monitoring_thread.start()

        # Build up the GUI

        self.source_position_text = QLabel()        # &#34;Current source position&#34;
        self.source_position_angles_text = QLabel()  # (theta, phi)
        self.source_position_pixels_text = QLabel()  # (row, column)
        self.source_position_mm_text = QLabel()  # (xFP, yFP)

        self.sma = ScanMirrorAssemblyWidget()
        self.big_rotation_stage = BigRotationStageWidget()
        self.focus_position = FocusPositionWidget()
        self.focal_plane = FocalPlaneWidgetWithSourcePosition()

        self.init_ui()

    def init_ui(self):
        &#34;&#34;&#34; Initialisation of the GUI.

        The GUI is divided into two parts.  On the left there are three widgets, showing the current setting of the
        stages and the focus position. On the right the focal plane is shown, together with a blue circle indicating the
        size of the field-of-view, and a red dot indicating the current position of the source.
        &#34;&#34;&#34;

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        hbox = QHBoxLayout()

        self.create_toolbar()
        self.create_statusbar()

        # Mechanisms

        mechanisms_frame = QFrame()
        mechanisms_frame.setObjectName(&#34;Mechanisms&#34;)

        vbox_left = QGridLayout()
        vbox_left.addWidget(self.sma)
        vbox_left.addWidget(self.big_rotation_stage)
        vbox_left.addWidget(self.focus_position)

        mechanisms_frame.setLayout(vbox_left)

        # FOV

        fpa_frame = QFrame()
        fpa_frame.setObjectName(&#34;FOV&#34;)

        vbox_right = QVBoxLayout()
        vbox_right.addWidget(self.focal_plane)

        # Current source position

        self.source_position_text.setFont(FONT)
        vbox_right.addWidget(self.source_position_text)

        self.source_position_angles_text.setIndent(50)
        self.source_position_angles_text.setFont(FONT)
        self.source_position_angles_text.setStatusTip(
            &#34;Gnomonic distance to the optical axis &#34; + u&#34;\u03B8 and in-field angle &#34; + u&#34;\u03C6&#34;)
        vbox_right.addWidget(self.source_position_angles_text)

        self.source_position_pixels_text.setIndent(50)
        self.source_position_pixels_text.setFont(FONT)
        self.source_position_pixels_text.setStatusTip(&#34;Pixel coordinates on specified CCD&#34;)
        vbox_right.addWidget(self.source_position_pixels_text)

        self.source_position_mm_text.setIndent(50)
        self.source_position_mm_text.setFont(FONT)
        self.source_position_mm_text.setStatusTip(&#34;Focal-plane coordinates&#34;)
        vbox_right.addWidget(self.source_position_mm_text)

        fpa_frame.setLayout(vbox_right)

        # Putting everything in place

        hbox.addWidget(mechanisms_frame)
        hbox.addWidget(fpa_frame)

        app_frame.setLayout(hbox)

        self.setCentralWidget(app_frame)

    def create_toolbar(self):

        # # The Home action is used to command the Homing to the Hexapod.
        #
        # self.homing = TouchButton(
        #     name=&#34;HOMING&#34;,
        #     status_tip=&#34;perform a homing operation (ON ALL THE STAGES)&#34;,
        #     selected=get_resource(&#34;:/icons/home.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/home-disabled.svg&#34;),
        # )
        # self.homing.clicked.connect(self.onClick)
        #
        # # The Clear action is used to command the ClearErrors to the Hexapod.
        #
        # self.clear_errors = TouchButton(
        #     name=&#34;CLEAR-ERRORS&#34;,
        #     status_tip=&#34;clear the error list on the controller (FOR ALL STAGES)&#34;,
        #     selected=get_resource(&#34;:/icons/erase.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/erase-disabled.svg&#34;),
        # )
        # self.clear_errors.clicked.connect(self.onClick)
        #
        # # The Reconnect action is used to reconnect to the control server
        #
        # self.cs_connection = ToggleButton(
        #     name=&#34;CS-CONNECT&#34;,
        #     status_tip=&#34;connect-disconnect huber stages control server.&#34;,
        #     selected=get_resource(&#34;:/icons/cs-connected.svg&#34;),
        #     not_selected=get_resource(&#34;:/icons/cs-not-connected.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/cs-connected-disabled.svg&#34;)
        # )
        # self.cs_connection.clicked.connect(self.onClick)
        #
        # # The Reconnect action is used to reconnect the device
        #
        # self.device_connection = ToggleButton(
        #     name=&#34;DEVICE-CONNECT&#34;,
        #     status_tip=&#34;connect-disconnect the huber stages controller&#34;,
        #     selected=get_resource(&#34;:/icons/plugged.svg&#34;),
        #     not_selected=get_resource(&#34;:/icons/unplugged.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/plugged-disabled.svg&#34;)
        # )
        # self.device_connection.clicked.connect(self.onClick)
        #
        # # The STOP button is used to immediately stop the current motion
        #
        # stop_button = QIcon(str(get_resource(&#34;:/icons/stop.svg&#34;)))
        #
        # self.stop_action = QAction(stop_button, &#34;STOP&#34;, self)
        # self.stop_action.setToolTip(&#34;STOP Movement&#34;)
        # self.stop_action.triggered.connect(self.onClick)

        # The HELP button is used to show the on-line help in a browser window

        help_button = QIcon(str(get_resource(&#34;:/icons/info.svg&#34;)))

        self.help_action = QAction(help_button, &#34;INFO&#34;, self)
        self.help_action.setToolTip(&#34;Browse the on-line documentation&#34;)
        self.help_action.triggered.connect(self.on_click)

        # spacer widget to help with aligning STOP button to the right

        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        self.toolbar = self.addToolBar(&#34;MainToolbar&#34;)
        # self.toolbar.addWidget(self.homing)
        # self.toolbar.addWidget(self.clear_errors)
        # self.toolbar.addWidget(self.device_connection)
        # self.toolbar.addWidget(self.cs_connection)
        self.toolbar.addWidget(spacer)
        # self.toolbar.addAction(self.stop_action)
        self.toolbar.addAction(self.help_action)

        return self.toolbar

    def create_statusbar(self):
        &#34;&#34;&#34; Create a status bar.

        Returns: Status bar.
        &#34;&#34;&#34;

        self.statusBar().setStyleSheet(&#34;border: 0; background-color: #FFF8DC;&#34;)
        self.statusBar().setStyleSheet(&#34;QStatusBar::item {border: none;}&#34;)
        self.statusBar().addPermanentWidget(VLine())
        # self.statusBar().addPermanentWidget(self.mode_label)

    def on_click(self):

        sender = self.sender()
        self.notifyObservers(sender)

    def on_stages_position_change_signal(self, position_big_rotation_stage: float, position_small_rotation_stage: float,
                                         position_translation_stage: float, source_position: dict):
        &#34;&#34;&#34; Update the GUI for changes in the position of the stages.

        Args:
            - position_big_rotation_stage: Rotation angle for the new configuration of the big rotation stage [degrees].
                                           This does not include the offset!
            - position_small_rotation_stage: Orientation angle of the scan mirror [degrees].  This does not include the
                                             offset!
            - position_translation_stage: Distance between the scan mirror and the optical axis (along the translation
                                          stage) for the new configuration of the scan mirror assembly [mm].  This does
                                          not include the offset!
            - source_position: Dictionary with the following entries:
                    - &#34;angles&#34;: tuple with the field angles (theta, phi) [degrees];
                    - &#34;pixels&#34;: tuple with the pixel coordinates (row, column) [pixels] and CCD code;
                    - &#34;mm&#34;: tuple with the focal-plane coordinates (x, y) [mm].
        &#34;&#34;&#34;

        # Mechanisms

        self.update_sma(position_translation_stage, position_small_rotation_stage)
        self.update_big_rotation_stage(position_big_rotation_stage)

        # Source position

        self.update_source_position(source_position)

    def on_hexapod_position_change_signal(self, focus_position: float):
        &#34;&#34;&#34; Update the GUI for changes in the position of the hexapod.&#34;&#34;&#34;

        self.update_focus_position(focus_position)

    def update_sma(self, distance, angle):
        &#34;&#34;&#34; Update the shown configuration of the scan mirror assembly.

        The orientation of the scan mirror must be changed, and the labels showing the distance from the scan
        mirror to the optical axis (along the translation stage) and the orientation angle of the scan mirror must be
        updated.

        Args
            - distance: Distance between the scan mirror and the optical axis (along the translation stage) for the new
                        configuration of the scan mirror assembly [mm].  This does not include the offset!
            - angle: Orientation angle of the scan mirror [degrees].  This does not include the offset!
        &#34;&#34;&#34;

        self.sma.update_plot(distance, angle)

    def update_big_rotation_stage(self, angle):
        &#34;&#34;&#34; Update the shown configuration of the big rotation stage.

        The orientation of GL_ROT w.r.t. GL_FIX must be set to the given angle.

        Args:
            - angle: Rotation angle for the new configuration of the big rotation stage [degrees].  This does not
                     include the offset!
        &#34;&#34;&#34;

        self.big_rotation_stage.update(angle)

    def update_focus_position(self, focus_position):
        &#34;&#34;&#34; Update the shown focus position.

        Args:
            - focus_position: New focus position [mm].
        &#34;&#34;&#34;

        self.focus_position.update_plot(focus_position)

    def update_source_position(self, position: dict):
        &#34;&#34;&#34; Update the position of the source in the focal plane to the given position.

        The red dot must move on the focal plane (movement may not be visible) and the text label with the focal-plane
        coordinates must be updated.

        Args:
            - position: Dictionary with the following entries:

                - &#34;angles&#34;: tuple with the field angles (theta, phi) [degrees];
                - &#34;pixels&#34;: tuple with the pixel coordinates (row, column) [pixels] and CCD code;
                - &#34;mm&#34;: tuple with the focal-plane coordinates (x, y) [mm].
        &#34;&#34;&#34;

        (theta, phi) = position[&#34;angles&#34;]
        (row, column, ccd_code) = position[&#34;pixels&#34;]
        (x_fp, y_fp) = position[&#34;mm&#34;]

        # Update the red dot in the plot

        self.focal_plane.update_source_position(x_fp, y_fp)

        # Update the text label

        if abs(x_fp) &gt; self.fov_radius_mm or abs(y_fp) &gt; self.fov_radius_mm:

            # MODULE_LOGGER.debug(&#34;Current source position: outside FOV&#34;)

            self.source_position_text.setText(&#34;Current source position: outside FOV&#34;)
            self.source_position_angles_text.setText(&#34;&#34;)
            self.source_position_pixels_text.setText(&#34;&#34;)
            self.source_position_mm_text.setText(&#34;&#34;)

        else:

            self.source_position_text.setText(&#34;Current source position:&#34;)
            self.source_position_angles_text.setText(
                u&#34;\u2022&#34; + &#34;(&#34; + u&#34;\u03B8&#34; + &#34;, &#34; + u&#34;\u03C6&#34; + &#34;) [&#34; + u&#34;\u00B0&#34; + &#34;] = ({:.2f}, {:.2f})&#34;
                .format(theta, phi))

            if ccd_code is None:

                self.source_position_pixels_text.setText(u&#34;\u2022&#34; + &#34; source doesn&#39;t fall on any CCD&#34;)

            else:

                self.source_position_pixels_text.setText(
                    u&#34;\u2022&#34; + &#34;(x&lt;sub&gt;CCD&lt;/sub&gt;, y&lt;sub&gt;CCD&lt;/sub&gt;) [pixels] = ({:.2f}, {:.2f}) on CCD &#34;
                    .format(column, row) + str(ccd_code))

            self.source_position_mm_text.setText(
                u&#34;\u2022&#34; + &#34;(x&lt;sub&gt;FP&lt;/sub&gt;, y&lt;sub&gt;FP&lt;/sub&gt;) [mm] = ({:.2f}, {:.2f})&#34;.format(x_fp, y_fp))

    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

        Args:
            - close_event: Close event received when the GUI is closed.
        &#34;&#34;&#34;

        # Stages

        self.stages_monitoring_worker.active = False
        self.stages_monitoring_thread.quit()
        self.stages_monitoring_thread.wait()

        # Hexapod

        self.hexapod_monitoring_worker.active = False
        self.hexapod_monitoring_thread.quit()
        self.hexapod_monitoring_thread.wait()


class FOVUIController(Observer):

    def __init__(self, view):

        self.view = view
        self.view.addObserver(self)

        self.help_window = HelpWindow(topic_url=HELP_TOPICS[&#34;smc9300_ui&#34;])

    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;INFO&#34;:

            self.help_window.show()

    def do(self, actions):

        pass


def main():
    lock_file = QLockFile(str(Path(&#34;~/fov_ui.app.lock&#34;).expanduser()))

    styles_location = find_file(&#34;styles.qss&#34;, in_dir=&#34;egse/gui&#34;)

    args = list(sys.argv)
    args[1:1] = [&#39;-stylesheet&#39;, str(styles_location)]

    app = QApplication(args)
    app.setWindowIcon(QIcon(str(get_resource(&#34;:/icons/location-marker.svg&#34;))))

    if lock_file.tryLock(100):
        view = FOVUIView()
        FOVUIController(view)
        view.show()

        return app.exec_()
    else:
        error_message = QMessageBox()
        error_message.setIcon(QMessageBox.Warning)
        error_message.setWindowTitle(&#34;Error&#34;)
        error_message.setText(&#34;The FOV GUI application is already running!&#34;)
        error_message.setStandardButtons(QMessageBox.Ok)

        return error_message.exec()


if __name__ == &#34;__main__&#34;:
    sys.exit(main())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.fov.fov_ui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    lock_file = QLockFile(str(Path(&#34;~/fov_ui.app.lock&#34;).expanduser()))

    styles_location = find_file(&#34;styles.qss&#34;, in_dir=&#34;egse/gui&#34;)

    args = list(sys.argv)
    args[1:1] = [&#39;-stylesheet&#39;, str(styles_location)]

    app = QApplication(args)
    app.setWindowIcon(QIcon(str(get_resource(&#34;:/icons/location-marker.svg&#34;))))

    if lock_file.tryLock(100):
        view = FOVUIView()
        FOVUIController(view)
        view.show()

        return app.exec_()
    else:
        error_message = QMessageBox()
        error_message.setIcon(QMessageBox.Warning)
        error_message.setWindowTitle(&#34;Error&#34;)
        error_message.setText(&#34;The FOV GUI application is already running!&#34;)
        error_message.setStandardButtons(QMessageBox.Ok)

        return error_message.exec()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.fov.fov_ui.FOVUIController"><code class="flex name class">
<span>class <span class="ident">FOVUIController</span></span>
<span>(</span><span>view)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FOVUIController(Observer):

    def __init__(self, view):

        self.view = view
        self.view.addObserver(self)

        self.help_window = HelpWindow(topic_url=HELP_TOPICS[&#34;smc9300_ui&#34;])

    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;INFO&#34;:

            self.help_window.show()

    def do(self, actions):

        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.observer.Observer" href="../observer.html#egse.observer.Observer">Observer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fov.fov_ui.FOVUIController.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, actions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, actions):

    pass</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIController.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, changed_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, changed_object):

    text = changed_object.text()

    if text == &#34;INFO&#34;:

        self.help_window.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView"><code class="flex name class">
<span>class <span class="ident">FOVUIView</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p>
<p>Open a window and initialiase the GUI.
The GUI is divided into two parts.
On the
left there are three widgets, showing the current setting of the stages and the focus
position.
On the right the focal plane is shown, together with a blue circle indicating
the size of the field-of-view, and a red dot indicating the current position of the source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FOVUIView(QMainWindow, Observable):

    def __init__(self):

        &#34;&#34;&#34;
        Open a window and initialiase the GUI.  The GUI is divided into two parts.  On the
        left there are three widgets, showing the current setting of the stages and the focus
        position.  On the right the focal plane is shown, together with a blue circle indicating
        the size of the field-of-view, and a red dot indicating the current position of the source.
        &#34;&#34;&#34;

        super().__init__()

        self.setGeometry(300, 300, 1500, 1000)
        self.setWindowTitle(&#34;FOV Position GUI&#34;)

        setup = load_setup()
        self.fov_radius_mm = setup.camera.fov.radius_mm

        # Monitoring the stages

        self.stages_monitoring_thread = QThread(self)
        self.stages_monitoring_worker = StagesMonitoringWorker()
        self.stages_monitoring_worker.moveToThread(self.stages_monitoring_thread)

        self.stages_monitoring_worker.stages_position_signal.connect(self.on_stages_position_change_signal)
        self.stages_monitoring_thread.started.connect(self.stages_monitoring_worker.start_process)
        self.stages_monitoring_thread.start()

        # Monitoring the hexapod

        self.hexapod_monitoring_thread = QThread(self)
        self.hexapod_monitoring_worker = HexapodMonitoringWorker()
        self.hexapod_monitoring_worker.moveToThread(self.hexapod_monitoring_thread)

        self.hexapod_monitoring_worker.hexapod_position_signal.connect(self.on_hexapod_position_change_signal)
        self.hexapod_monitoring_thread.started.connect(self.hexapod_monitoring_worker.start_process)
        self.hexapod_monitoring_thread.start()

        # Build up the GUI

        self.source_position_text = QLabel()        # &#34;Current source position&#34;
        self.source_position_angles_text = QLabel()  # (theta, phi)
        self.source_position_pixels_text = QLabel()  # (row, column)
        self.source_position_mm_text = QLabel()  # (xFP, yFP)

        self.sma = ScanMirrorAssemblyWidget()
        self.big_rotation_stage = BigRotationStageWidget()
        self.focus_position = FocusPositionWidget()
        self.focal_plane = FocalPlaneWidgetWithSourcePosition()

        self.init_ui()

    def init_ui(self):
        &#34;&#34;&#34; Initialisation of the GUI.

        The GUI is divided into two parts.  On the left there are three widgets, showing the current setting of the
        stages and the focus position. On the right the focal plane is shown, together with a blue circle indicating the
        size of the field-of-view, and a red dot indicating the current position of the source.
        &#34;&#34;&#34;

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        hbox = QHBoxLayout()

        self.create_toolbar()
        self.create_statusbar()

        # Mechanisms

        mechanisms_frame = QFrame()
        mechanisms_frame.setObjectName(&#34;Mechanisms&#34;)

        vbox_left = QGridLayout()
        vbox_left.addWidget(self.sma)
        vbox_left.addWidget(self.big_rotation_stage)
        vbox_left.addWidget(self.focus_position)

        mechanisms_frame.setLayout(vbox_left)

        # FOV

        fpa_frame = QFrame()
        fpa_frame.setObjectName(&#34;FOV&#34;)

        vbox_right = QVBoxLayout()
        vbox_right.addWidget(self.focal_plane)

        # Current source position

        self.source_position_text.setFont(FONT)
        vbox_right.addWidget(self.source_position_text)

        self.source_position_angles_text.setIndent(50)
        self.source_position_angles_text.setFont(FONT)
        self.source_position_angles_text.setStatusTip(
            &#34;Gnomonic distance to the optical axis &#34; + u&#34;\u03B8 and in-field angle &#34; + u&#34;\u03C6&#34;)
        vbox_right.addWidget(self.source_position_angles_text)

        self.source_position_pixels_text.setIndent(50)
        self.source_position_pixels_text.setFont(FONT)
        self.source_position_pixels_text.setStatusTip(&#34;Pixel coordinates on specified CCD&#34;)
        vbox_right.addWidget(self.source_position_pixels_text)

        self.source_position_mm_text.setIndent(50)
        self.source_position_mm_text.setFont(FONT)
        self.source_position_mm_text.setStatusTip(&#34;Focal-plane coordinates&#34;)
        vbox_right.addWidget(self.source_position_mm_text)

        fpa_frame.setLayout(vbox_right)

        # Putting everything in place

        hbox.addWidget(mechanisms_frame)
        hbox.addWidget(fpa_frame)

        app_frame.setLayout(hbox)

        self.setCentralWidget(app_frame)

    def create_toolbar(self):

        # # The Home action is used to command the Homing to the Hexapod.
        #
        # self.homing = TouchButton(
        #     name=&#34;HOMING&#34;,
        #     status_tip=&#34;perform a homing operation (ON ALL THE STAGES)&#34;,
        #     selected=get_resource(&#34;:/icons/home.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/home-disabled.svg&#34;),
        # )
        # self.homing.clicked.connect(self.onClick)
        #
        # # The Clear action is used to command the ClearErrors to the Hexapod.
        #
        # self.clear_errors = TouchButton(
        #     name=&#34;CLEAR-ERRORS&#34;,
        #     status_tip=&#34;clear the error list on the controller (FOR ALL STAGES)&#34;,
        #     selected=get_resource(&#34;:/icons/erase.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/erase-disabled.svg&#34;),
        # )
        # self.clear_errors.clicked.connect(self.onClick)
        #
        # # The Reconnect action is used to reconnect to the control server
        #
        # self.cs_connection = ToggleButton(
        #     name=&#34;CS-CONNECT&#34;,
        #     status_tip=&#34;connect-disconnect huber stages control server.&#34;,
        #     selected=get_resource(&#34;:/icons/cs-connected.svg&#34;),
        #     not_selected=get_resource(&#34;:/icons/cs-not-connected.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/cs-connected-disabled.svg&#34;)
        # )
        # self.cs_connection.clicked.connect(self.onClick)
        #
        # # The Reconnect action is used to reconnect the device
        #
        # self.device_connection = ToggleButton(
        #     name=&#34;DEVICE-CONNECT&#34;,
        #     status_tip=&#34;connect-disconnect the huber stages controller&#34;,
        #     selected=get_resource(&#34;:/icons/plugged.svg&#34;),
        #     not_selected=get_resource(&#34;:/icons/unplugged.svg&#34;),
        #     disabled=get_resource(&#34;:/icons/plugged-disabled.svg&#34;)
        # )
        # self.device_connection.clicked.connect(self.onClick)
        #
        # # The STOP button is used to immediately stop the current motion
        #
        # stop_button = QIcon(str(get_resource(&#34;:/icons/stop.svg&#34;)))
        #
        # self.stop_action = QAction(stop_button, &#34;STOP&#34;, self)
        # self.stop_action.setToolTip(&#34;STOP Movement&#34;)
        # self.stop_action.triggered.connect(self.onClick)

        # The HELP button is used to show the on-line help in a browser window

        help_button = QIcon(str(get_resource(&#34;:/icons/info.svg&#34;)))

        self.help_action = QAction(help_button, &#34;INFO&#34;, self)
        self.help_action.setToolTip(&#34;Browse the on-line documentation&#34;)
        self.help_action.triggered.connect(self.on_click)

        # spacer widget to help with aligning STOP button to the right

        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        self.toolbar = self.addToolBar(&#34;MainToolbar&#34;)
        # self.toolbar.addWidget(self.homing)
        # self.toolbar.addWidget(self.clear_errors)
        # self.toolbar.addWidget(self.device_connection)
        # self.toolbar.addWidget(self.cs_connection)
        self.toolbar.addWidget(spacer)
        # self.toolbar.addAction(self.stop_action)
        self.toolbar.addAction(self.help_action)

        return self.toolbar

    def create_statusbar(self):
        &#34;&#34;&#34; Create a status bar.

        Returns: Status bar.
        &#34;&#34;&#34;

        self.statusBar().setStyleSheet(&#34;border: 0; background-color: #FFF8DC;&#34;)
        self.statusBar().setStyleSheet(&#34;QStatusBar::item {border: none;}&#34;)
        self.statusBar().addPermanentWidget(VLine())
        # self.statusBar().addPermanentWidget(self.mode_label)

    def on_click(self):

        sender = self.sender()
        self.notifyObservers(sender)

    def on_stages_position_change_signal(self, position_big_rotation_stage: float, position_small_rotation_stage: float,
                                         position_translation_stage: float, source_position: dict):
        &#34;&#34;&#34; Update the GUI for changes in the position of the stages.

        Args:
            - position_big_rotation_stage: Rotation angle for the new configuration of the big rotation stage [degrees].
                                           This does not include the offset!
            - position_small_rotation_stage: Orientation angle of the scan mirror [degrees].  This does not include the
                                             offset!
            - position_translation_stage: Distance between the scan mirror and the optical axis (along the translation
                                          stage) for the new configuration of the scan mirror assembly [mm].  This does
                                          not include the offset!
            - source_position: Dictionary with the following entries:
                    - &#34;angles&#34;: tuple with the field angles (theta, phi) [degrees];
                    - &#34;pixels&#34;: tuple with the pixel coordinates (row, column) [pixels] and CCD code;
                    - &#34;mm&#34;: tuple with the focal-plane coordinates (x, y) [mm].
        &#34;&#34;&#34;

        # Mechanisms

        self.update_sma(position_translation_stage, position_small_rotation_stage)
        self.update_big_rotation_stage(position_big_rotation_stage)

        # Source position

        self.update_source_position(source_position)

    def on_hexapod_position_change_signal(self, focus_position: float):
        &#34;&#34;&#34; Update the GUI for changes in the position of the hexapod.&#34;&#34;&#34;

        self.update_focus_position(focus_position)

    def update_sma(self, distance, angle):
        &#34;&#34;&#34; Update the shown configuration of the scan mirror assembly.

        The orientation of the scan mirror must be changed, and the labels showing the distance from the scan
        mirror to the optical axis (along the translation stage) and the orientation angle of the scan mirror must be
        updated.

        Args
            - distance: Distance between the scan mirror and the optical axis (along the translation stage) for the new
                        configuration of the scan mirror assembly [mm].  This does not include the offset!
            - angle: Orientation angle of the scan mirror [degrees].  This does not include the offset!
        &#34;&#34;&#34;

        self.sma.update_plot(distance, angle)

    def update_big_rotation_stage(self, angle):
        &#34;&#34;&#34; Update the shown configuration of the big rotation stage.

        The orientation of GL_ROT w.r.t. GL_FIX must be set to the given angle.

        Args:
            - angle: Rotation angle for the new configuration of the big rotation stage [degrees].  This does not
                     include the offset!
        &#34;&#34;&#34;

        self.big_rotation_stage.update(angle)

    def update_focus_position(self, focus_position):
        &#34;&#34;&#34; Update the shown focus position.

        Args:
            - focus_position: New focus position [mm].
        &#34;&#34;&#34;

        self.focus_position.update_plot(focus_position)

    def update_source_position(self, position: dict):
        &#34;&#34;&#34; Update the position of the source in the focal plane to the given position.

        The red dot must move on the focal plane (movement may not be visible) and the text label with the focal-plane
        coordinates must be updated.

        Args:
            - position: Dictionary with the following entries:

                - &#34;angles&#34;: tuple with the field angles (theta, phi) [degrees];
                - &#34;pixels&#34;: tuple with the pixel coordinates (row, column) [pixels] and CCD code;
                - &#34;mm&#34;: tuple with the focal-plane coordinates (x, y) [mm].
        &#34;&#34;&#34;

        (theta, phi) = position[&#34;angles&#34;]
        (row, column, ccd_code) = position[&#34;pixels&#34;]
        (x_fp, y_fp) = position[&#34;mm&#34;]

        # Update the red dot in the plot

        self.focal_plane.update_source_position(x_fp, y_fp)

        # Update the text label

        if abs(x_fp) &gt; self.fov_radius_mm or abs(y_fp) &gt; self.fov_radius_mm:

            # MODULE_LOGGER.debug(&#34;Current source position: outside FOV&#34;)

            self.source_position_text.setText(&#34;Current source position: outside FOV&#34;)
            self.source_position_angles_text.setText(&#34;&#34;)
            self.source_position_pixels_text.setText(&#34;&#34;)
            self.source_position_mm_text.setText(&#34;&#34;)

        else:

            self.source_position_text.setText(&#34;Current source position:&#34;)
            self.source_position_angles_text.setText(
                u&#34;\u2022&#34; + &#34;(&#34; + u&#34;\u03B8&#34; + &#34;, &#34; + u&#34;\u03C6&#34; + &#34;) [&#34; + u&#34;\u00B0&#34; + &#34;] = ({:.2f}, {:.2f})&#34;
                .format(theta, phi))

            if ccd_code is None:

                self.source_position_pixels_text.setText(u&#34;\u2022&#34; + &#34; source doesn&#39;t fall on any CCD&#34;)

            else:

                self.source_position_pixels_text.setText(
                    u&#34;\u2022&#34; + &#34;(x&lt;sub&gt;CCD&lt;/sub&gt;, y&lt;sub&gt;CCD&lt;/sub&gt;) [pixels] = ({:.2f}, {:.2f}) on CCD &#34;
                    .format(column, row) + str(ccd_code))

            self.source_position_mm_text.setText(
                u&#34;\u2022&#34; + &#34;(x&lt;sub&gt;FP&lt;/sub&gt;, y&lt;sub&gt;FP&lt;/sub&gt;) [mm] = ({:.2f}, {:.2f})&#34;.format(x_fp, y_fp))

    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

        Args:
            - close_event: Close event received when the GUI is closed.
        &#34;&#34;&#34;

        # Stages

        self.stages_monitoring_worker.active = False
        self.stages_monitoring_thread.quit()
        self.stages_monitoring_thread.wait()

        # Hexapod

        self.hexapod_monitoring_worker.active = False
        self.hexapod_monitoring_thread.quit()
        self.hexapod_monitoring_thread.wait()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li><a title="egse.observer.Observable" href="../observer.html#egse.observer.Observable">Observable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fov.fov_ui.FOVUIView.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, close_event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure that all threads are stopped when the GUI is closed.</p>
<h2 id="args">Args</h2>
<ul>
<li>close_event: Close event received when the GUI is closed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, close_event: QCloseEvent) -&gt; None:
    &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

    Args:
        - close_event: Close event received when the GUI is closed.
    &#34;&#34;&#34;

    # Stages

    self.stages_monitoring_worker.active = False
    self.stages_monitoring_thread.quit()
    self.stages_monitoring_thread.wait()

    # Hexapod

    self.hexapod_monitoring_worker.active = False
    self.hexapod_monitoring_thread.quit()
    self.hexapod_monitoring_thread.wait()</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.create_statusbar"><code class="name flex">
<span>def <span class="ident">create_statusbar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a status bar.</p>
<p>Returns: Status bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_statusbar(self):
    &#34;&#34;&#34; Create a status bar.

    Returns: Status bar.
    &#34;&#34;&#34;

    self.statusBar().setStyleSheet(&#34;border: 0; background-color: #FFF8DC;&#34;)
    self.statusBar().setStyleSheet(&#34;QStatusBar::item {border: none;}&#34;)
    self.statusBar().addPermanentWidget(VLine())
    # self.statusBar().addPermanentWidget(self.mode_label)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.create_toolbar"><code class="name flex">
<span>def <span class="ident">create_toolbar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_toolbar(self):

    # # The Home action is used to command the Homing to the Hexapod.
    #
    # self.homing = TouchButton(
    #     name=&#34;HOMING&#34;,
    #     status_tip=&#34;perform a homing operation (ON ALL THE STAGES)&#34;,
    #     selected=get_resource(&#34;:/icons/home.svg&#34;),
    #     disabled=get_resource(&#34;:/icons/home-disabled.svg&#34;),
    # )
    # self.homing.clicked.connect(self.onClick)
    #
    # # The Clear action is used to command the ClearErrors to the Hexapod.
    #
    # self.clear_errors = TouchButton(
    #     name=&#34;CLEAR-ERRORS&#34;,
    #     status_tip=&#34;clear the error list on the controller (FOR ALL STAGES)&#34;,
    #     selected=get_resource(&#34;:/icons/erase.svg&#34;),
    #     disabled=get_resource(&#34;:/icons/erase-disabled.svg&#34;),
    # )
    # self.clear_errors.clicked.connect(self.onClick)
    #
    # # The Reconnect action is used to reconnect to the control server
    #
    # self.cs_connection = ToggleButton(
    #     name=&#34;CS-CONNECT&#34;,
    #     status_tip=&#34;connect-disconnect huber stages control server.&#34;,
    #     selected=get_resource(&#34;:/icons/cs-connected.svg&#34;),
    #     not_selected=get_resource(&#34;:/icons/cs-not-connected.svg&#34;),
    #     disabled=get_resource(&#34;:/icons/cs-connected-disabled.svg&#34;)
    # )
    # self.cs_connection.clicked.connect(self.onClick)
    #
    # # The Reconnect action is used to reconnect the device
    #
    # self.device_connection = ToggleButton(
    #     name=&#34;DEVICE-CONNECT&#34;,
    #     status_tip=&#34;connect-disconnect the huber stages controller&#34;,
    #     selected=get_resource(&#34;:/icons/plugged.svg&#34;),
    #     not_selected=get_resource(&#34;:/icons/unplugged.svg&#34;),
    #     disabled=get_resource(&#34;:/icons/plugged-disabled.svg&#34;)
    # )
    # self.device_connection.clicked.connect(self.onClick)
    #
    # # The STOP button is used to immediately stop the current motion
    #
    # stop_button = QIcon(str(get_resource(&#34;:/icons/stop.svg&#34;)))
    #
    # self.stop_action = QAction(stop_button, &#34;STOP&#34;, self)
    # self.stop_action.setToolTip(&#34;STOP Movement&#34;)
    # self.stop_action.triggered.connect(self.onClick)

    # The HELP button is used to show the on-line help in a browser window

    help_button = QIcon(str(get_resource(&#34;:/icons/info.svg&#34;)))

    self.help_action = QAction(help_button, &#34;INFO&#34;, self)
    self.help_action.setToolTip(&#34;Browse the on-line documentation&#34;)
    self.help_action.triggered.connect(self.on_click)

    # spacer widget to help with aligning STOP button to the right

    spacer = QWidget()
    spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

    self.toolbar = self.addToolBar(&#34;MainToolbar&#34;)
    # self.toolbar.addWidget(self.homing)
    # self.toolbar.addWidget(self.clear_errors)
    # self.toolbar.addWidget(self.device_connection)
    # self.toolbar.addWidget(self.cs_connection)
    self.toolbar.addWidget(spacer)
    # self.toolbar.addAction(self.stop_action)
    self.toolbar.addAction(self.help_action)

    return self.toolbar</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.init_ui"><code class="name flex">
<span>def <span class="ident">init_ui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialisation of the GUI.</p>
<p>The GUI is divided into two parts.
On the left there are three widgets, showing the current setting of the
stages and the focus position. On the right the focal plane is shown, together with a blue circle indicating the
size of the field-of-view, and a red dot indicating the current position of the source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_ui(self):
    &#34;&#34;&#34; Initialisation of the GUI.

    The GUI is divided into two parts.  On the left there are three widgets, showing the current setting of the
    stages and the focus position. On the right the focal plane is shown, together with a blue circle indicating the
    size of the field-of-view, and a red dot indicating the current position of the source.
    &#34;&#34;&#34;

    app_frame = QFrame()
    app_frame.setObjectName(&#34;AppFrame&#34;)

    hbox = QHBoxLayout()

    self.create_toolbar()
    self.create_statusbar()

    # Mechanisms

    mechanisms_frame = QFrame()
    mechanisms_frame.setObjectName(&#34;Mechanisms&#34;)

    vbox_left = QGridLayout()
    vbox_left.addWidget(self.sma)
    vbox_left.addWidget(self.big_rotation_stage)
    vbox_left.addWidget(self.focus_position)

    mechanisms_frame.setLayout(vbox_left)

    # FOV

    fpa_frame = QFrame()
    fpa_frame.setObjectName(&#34;FOV&#34;)

    vbox_right = QVBoxLayout()
    vbox_right.addWidget(self.focal_plane)

    # Current source position

    self.source_position_text.setFont(FONT)
    vbox_right.addWidget(self.source_position_text)

    self.source_position_angles_text.setIndent(50)
    self.source_position_angles_text.setFont(FONT)
    self.source_position_angles_text.setStatusTip(
        &#34;Gnomonic distance to the optical axis &#34; + u&#34;\u03B8 and in-field angle &#34; + u&#34;\u03C6&#34;)
    vbox_right.addWidget(self.source_position_angles_text)

    self.source_position_pixels_text.setIndent(50)
    self.source_position_pixels_text.setFont(FONT)
    self.source_position_pixels_text.setStatusTip(&#34;Pixel coordinates on specified CCD&#34;)
    vbox_right.addWidget(self.source_position_pixels_text)

    self.source_position_mm_text.setIndent(50)
    self.source_position_mm_text.setFont(FONT)
    self.source_position_mm_text.setStatusTip(&#34;Focal-plane coordinates&#34;)
    vbox_right.addWidget(self.source_position_mm_text)

    fpa_frame.setLayout(vbox_right)

    # Putting everything in place

    hbox.addWidget(mechanisms_frame)
    hbox.addWidget(fpa_frame)

    app_frame.setLayout(hbox)

    self.setCentralWidget(app_frame)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.on_click"><code class="name flex">
<span>def <span class="ident">on_click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_click(self):

    sender = self.sender()
    self.notifyObservers(sender)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.on_hexapod_position_change_signal"><code class="name flex">
<span>def <span class="ident">on_hexapod_position_change_signal</span></span>(<span>self, focus_position: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the GUI for changes in the position of the hexapod.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_hexapod_position_change_signal(self, focus_position: float):
    &#34;&#34;&#34; Update the GUI for changes in the position of the hexapod.&#34;&#34;&#34;

    self.update_focus_position(focus_position)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.on_stages_position_change_signal"><code class="name flex">
<span>def <span class="ident">on_stages_position_change_signal</span></span>(<span>self, position_big_rotation_stage: float, position_small_rotation_stage: float, position_translation_stage: float, source_position: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the GUI for changes in the position of the stages.</p>
<h2 id="args">Args</h2>
<ul>
<li>position_big_rotation_stage: Rotation angle for the new configuration of the big rotation stage [degrees].
This does not include the offset!</li>
<li>position_small_rotation_stage: Orientation angle of the scan mirror [degrees].
This does not include the
offset!</li>
<li>position_translation_stage: Distance between the scan mirror and the optical axis (along the translation
stage) for the new configuration of the scan mirror assembly [mm].
This does
not include the offset!</li>
<li>source_position: Dictionary with the following entries:
- "angles": tuple with the field angles (theta, phi) [degrees];
- "pixels": tuple with the pixel coordinates (row, column) [pixels] and CCD code;
- "mm": tuple with the focal-plane coordinates (x, y) [mm].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_stages_position_change_signal(self, position_big_rotation_stage: float, position_small_rotation_stage: float,
                                     position_translation_stage: float, source_position: dict):
    &#34;&#34;&#34; Update the GUI for changes in the position of the stages.

    Args:
        - position_big_rotation_stage: Rotation angle for the new configuration of the big rotation stage [degrees].
                                       This does not include the offset!
        - position_small_rotation_stage: Orientation angle of the scan mirror [degrees].  This does not include the
                                         offset!
        - position_translation_stage: Distance between the scan mirror and the optical axis (along the translation
                                      stage) for the new configuration of the scan mirror assembly [mm].  This does
                                      not include the offset!
        - source_position: Dictionary with the following entries:
                - &#34;angles&#34;: tuple with the field angles (theta, phi) [degrees];
                - &#34;pixels&#34;: tuple with the pixel coordinates (row, column) [pixels] and CCD code;
                - &#34;mm&#34;: tuple with the focal-plane coordinates (x, y) [mm].
    &#34;&#34;&#34;

    # Mechanisms

    self.update_sma(position_translation_stage, position_small_rotation_stage)
    self.update_big_rotation_stage(position_big_rotation_stage)

    # Source position

    self.update_source_position(source_position)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.update_big_rotation_stage"><code class="name flex">
<span>def <span class="ident">update_big_rotation_stage</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the shown configuration of the big rotation stage.</p>
<p>The orientation of GL_ROT w.r.t. GL_FIX must be set to the given angle.</p>
<h2 id="args">Args</h2>
<ul>
<li>angle: Rotation angle for the new configuration of the big rotation stage [degrees].
This does not
include the offset!</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_big_rotation_stage(self, angle):
    &#34;&#34;&#34; Update the shown configuration of the big rotation stage.

    The orientation of GL_ROT w.r.t. GL_FIX must be set to the given angle.

    Args:
        - angle: Rotation angle for the new configuration of the big rotation stage [degrees].  This does not
                 include the offset!
    &#34;&#34;&#34;

    self.big_rotation_stage.update(angle)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.update_focus_position"><code class="name flex">
<span>def <span class="ident">update_focus_position</span></span>(<span>self, focus_position)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the shown focus position.</p>
<h2 id="args">Args</h2>
<ul>
<li>focus_position: New focus position [mm].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_focus_position(self, focus_position):
    &#34;&#34;&#34; Update the shown focus position.

    Args:
        - focus_position: New focus position [mm].
    &#34;&#34;&#34;

    self.focus_position.update_plot(focus_position)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.update_sma"><code class="name flex">
<span>def <span class="ident">update_sma</span></span>(<span>self, distance, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the shown configuration of the scan mirror assembly.</p>
<p>The orientation of the scan mirror must be changed, and the labels showing the distance from the scan
mirror to the optical axis (along the translation stage) and the orientation angle of the scan mirror must be
updated.</p>
<p>Args
- distance: Distance between the scan mirror and the optical axis (along the translation stage) for the new
configuration of the scan mirror assembly [mm].
This does not include the offset!
- angle: Orientation angle of the scan mirror [degrees].
This does not include the offset!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_sma(self, distance, angle):
    &#34;&#34;&#34; Update the shown configuration of the scan mirror assembly.

    The orientation of the scan mirror must be changed, and the labels showing the distance from the scan
    mirror to the optical axis (along the translation stage) and the orientation angle of the scan mirror must be
    updated.

    Args
        - distance: Distance between the scan mirror and the optical axis (along the translation stage) for the new
                    configuration of the scan mirror assembly [mm].  This does not include the offset!
        - angle: Orientation angle of the scan mirror [degrees].  This does not include the offset!
    &#34;&#34;&#34;

    self.sma.update_plot(distance, angle)</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.FOVUIView.update_source_position"><code class="name flex">
<span>def <span class="ident">update_source_position</span></span>(<span>self, position: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the position of the source in the focal plane to the given position.</p>
<p>The red dot must move on the focal plane (movement may not be visible) and the text label with the focal-plane
coordinates must be updated.</p>
<h2 id="args">Args</h2>
<ul>
<li>
<p>position: Dictionary with the following entries:</p>
<ul>
<li>"angles": tuple with the field angles (theta, phi) [degrees];</li>
<li>"pixels": tuple with the pixel coordinates (row, column) [pixels] and CCD code;</li>
<li>"mm": tuple with the focal-plane coordinates (x, y) [mm].</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_source_position(self, position: dict):
    &#34;&#34;&#34; Update the position of the source in the focal plane to the given position.

    The red dot must move on the focal plane (movement may not be visible) and the text label with the focal-plane
    coordinates must be updated.

    Args:
        - position: Dictionary with the following entries:

            - &#34;angles&#34;: tuple with the field angles (theta, phi) [degrees];
            - &#34;pixels&#34;: tuple with the pixel coordinates (row, column) [pixels] and CCD code;
            - &#34;mm&#34;: tuple with the focal-plane coordinates (x, y) [mm].
    &#34;&#34;&#34;

    (theta, phi) = position[&#34;angles&#34;]
    (row, column, ccd_code) = position[&#34;pixels&#34;]
    (x_fp, y_fp) = position[&#34;mm&#34;]

    # Update the red dot in the plot

    self.focal_plane.update_source_position(x_fp, y_fp)

    # Update the text label

    if abs(x_fp) &gt; self.fov_radius_mm or abs(y_fp) &gt; self.fov_radius_mm:

        # MODULE_LOGGER.debug(&#34;Current source position: outside FOV&#34;)

        self.source_position_text.setText(&#34;Current source position: outside FOV&#34;)
        self.source_position_angles_text.setText(&#34;&#34;)
        self.source_position_pixels_text.setText(&#34;&#34;)
        self.source_position_mm_text.setText(&#34;&#34;)

    else:

        self.source_position_text.setText(&#34;Current source position:&#34;)
        self.source_position_angles_text.setText(
            u&#34;\u2022&#34; + &#34;(&#34; + u&#34;\u03B8&#34; + &#34;, &#34; + u&#34;\u03C6&#34; + &#34;) [&#34; + u&#34;\u00B0&#34; + &#34;] = ({:.2f}, {:.2f})&#34;
            .format(theta, phi))

        if ccd_code is None:

            self.source_position_pixels_text.setText(u&#34;\u2022&#34; + &#34; source doesn&#39;t fall on any CCD&#34;)

        else:

            self.source_position_pixels_text.setText(
                u&#34;\u2022&#34; + &#34;(x&lt;sub&gt;CCD&lt;/sub&gt;, y&lt;sub&gt;CCD&lt;/sub&gt;) [pixels] = ({:.2f}, {:.2f}) on CCD &#34;
                .format(column, row) + str(ccd_code))

        self.source_position_mm_text.setText(
            u&#34;\u2022&#34; + &#34;(x&lt;sub&gt;FP&lt;/sub&gt;, y&lt;sub&gt;FP&lt;/sub&gt;) [mm] = ({:.2f}, {:.2f})&#34;.format(x_fp, y_fp))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fov.fov_ui.HexapodMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">HexapodMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the position of the hexapod.</p>
<p>Initialisation of a monitoring worker for the hexapod.</p>
<p>This monitoring worker will listen on the monitoring port of the Hexapod PUNA Control Server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HexapodMonitoringWorker(MonitoringWorker):
    &#34;&#34;&#34; Worker for monitoring the position of the hexapod.&#34;&#34;&#34;

    # The worker will send a signal with the following information:
    #   - focus positions [mm]

    hexapod_position_signal = pyqtSignal(float)

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker for the hexapod.

        This monitoring worker will listen on the monitoring port of the Hexapod PUNA Control Server.
        &#34;&#34;&#34;

        super(HexapodMonitoringWorker, self).__init__(HEXAPOD_SETTINGS)

        self.focus_position = None

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port of the hexapod.

        If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
        Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
        process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
        0.5s).
        &#34;&#34;&#34;
        self.active = True

        while self.is_socket_connected and self.active:

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Update the timeout, to be more in line with the monitoring frequency of the CS (i.e. the delay).
                    # Take 0.5s extra to be on the safe side.

                    self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                    if self.position_has_changed(monitoring_info):
                        self.hexapod_position_signal.emit(self.focus_position)

            except zmq.ZMQError:

                pass

            # Timeout occurred

            else:

                # The CS is not active

                if not is_control_server_active(self.commanding_address):

                    pass

                # The CS is active, but the timeout was too strict

                else:

                    self.monitoring_timeout += 0.5

    @staticmethod
    def get_focus_position(monitoring_info: dict):

        return -monitoring_info[&#34;user&#34;][2]

    def position_has_changed(self, monitoring_info: dict):
        &#34;&#34;&#34; Check whether the focus position has changed.

        Check whether the focus position has changed since the previous time monitoring information was received.

        If the focus position has changed, the previous value is updated.

        Args:
            - monitoring_info: Monitoring information for the hexapod.

        Returns: True if the focus position has changed; False otherwise.
        &#34;&#34;&#34;

        focus_position = self.get_focus_position(monitoring_info)

        if focus_position != self.focus_position:

            self.focus_position = focus_position
            return True

        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.fov.fov_ui.MonitoringWorker" href="#egse.fov.fov_ui.MonitoringWorker">MonitoringWorker</a></li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="egse.fov.fov_ui.HexapodMonitoringWorker.get_focus_position"><code class="name flex">
<span>def <span class="ident">get_focus_position</span></span>(<span>monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_focus_position(monitoring_info: dict):

    return -monitoring_info[&#34;user&#34;][2]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.fov.fov_ui.HexapodMonitoringWorker.hexapod_position_signal"><code class="name flex">
<span>def <span class="ident">hexapod_position_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.fov.fov_ui.HexapodMonitoringWorker.position_has_changed"><code class="name flex">
<span>def <span class="ident">position_has_changed</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the focus position has changed.</p>
<p>Check whether the focus position has changed since the previous time monitoring information was received.</p>
<p>If the focus position has changed, the previous value is updated.</p>
<h2 id="args">Args</h2>
<ul>
<li>monitoring_info: Monitoring information for the hexapod.
Returns: True if the focus position has changed; False otherwise.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_has_changed(self, monitoring_info: dict):
    &#34;&#34;&#34; Check whether the focus position has changed.

    Check whether the focus position has changed since the previous time monitoring information was received.

    If the focus position has changed, the previous value is updated.

    Args:
        - monitoring_info: Monitoring information for the hexapod.

    Returns: True if the focus position has changed; False otherwise.
    &#34;&#34;&#34;

    focus_position = self.get_focus_position(monitoring_info)

    if focus_position != self.focus_position:

        self.focus_position = focus_position
        return True

    return False</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.HexapodMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on listening on the monitoring port of the hexapod.</p>
<p>If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
Otherwise, it is checked whether or not the Control Server is active.
If not, a signal is emitted with the
process name.
Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
0.5s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34; Keep on listening on the monitoring port of the hexapod.

    If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
    Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
    process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
    0.5s).
    &#34;&#34;&#34;
    self.active = True

    while self.is_socket_connected and self.active:

        try:

            socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            # Monitoring information was received (before timeout)

            if self.monitoring_socket in socket_list:

                pickle_string = self.monitoring_socket.recv()
                monitoring_info = pickle.loads(pickle_string)

                # Update the timeout, to be more in line with the monitoring frequency of the CS (i.e. the delay).
                # Take 0.5s extra to be on the safe side.

                self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                if self.position_has_changed(monitoring_info):
                    self.hexapod_position_signal.emit(self.focus_position)

        except zmq.ZMQError:

            pass

        # Timeout occurred

        else:

            # The CS is not active

            if not is_control_server_active(self.commanding_address):

                pass

            # The CS is active, but the timeout was too strict

            else:

                self.monitoring_timeout += 0.5</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.fov.fov_ui.MonitoringWorker" href="#egse.fov.fov_ui.MonitoringWorker">MonitoringWorker</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.connect_socket" href="#egse.fov.fov_ui.MonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.start_process" href="#egse.fov.fov_ui.MonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.stop" href="#egse.fov.fov_ui.MonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.fov.fov_ui.MonitoringWorker"><code class="flex name class">
<span>class <span class="ident">MonitoringWorker</span></span>
<span>(</span><span>settings)</span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: typing.Optional[QObject] = None)</p>
<p>Initialisation of a monitoring worker.</p>
<p>This monitoring worker will listen on the monitoring port of the Control Server, based on the given settings.</p>
<h2 id="args">Args</h2>
<ul>
<li>settings: Settings with the connection information (which was loaded from the settings file).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MonitoringWorker(QObject):

    def __init__(self, settings):
        &#34;&#34;&#34; Initialisation of a monitoring worker.

        This monitoring worker will listen on the monitoring port of the Control Server, based on the given settings.

        Args:
            - settings: Settings with the connection information (which was loaded from the settings file).
        &#34;&#34;&#34;

        super(MonitoringWorker, self).__init__()

        self.active = False

        self.monitoring_socket = None
        self.monitoring_timeout = 0.5  # [s]
        self.commanding_address = None
        self.is_socket_connected = False

        self.connect_socket(settings)

    def connect_socket(self, settings):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.

        Args:
            - settings: Settings with the connection information (which was loaded from the settings file).
        &#34;&#34;&#34;

        try:

            # Ctrl settings:
            #   - transport protocol
            #   - hostname
            #   - commanding port (to check whether the CS is active)
            #   - monitoring port (to ask for process information)

            transport = settings.PROTOCOL
            hostname = settings.HOSTNAME
            commanding_port = settings.COMMANDING_PORT
            monitoring_port = settings.MONITORING_PORT

            # Create a socket and connect to the monitoring port

            monitoring_address = connect_address(transport, hostname, monitoring_port)
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

            # Address of the commanding port
            # This is needed when checking whether or not the CS is active

            self.commanding_address = connect_address(transport, hostname, commanding_port)

            self.is_socket_connected = True

        except AttributeError:

            self.is_socket_connected = False

    def stop(self):
        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;

        self.is_socket_connected = False
        self.monitoring_socket.close()

        # self.monitoring_socket.disconnect(self.monitoring_address)
        # self.monitoring_socket.close(linger=0)

    def start_process(self):
        &#34;&#34;&#34; Start listening on the monitoring port.

        If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
        to notify the GUI.
        &#34;&#34;&#34;

        self.run()

    # @pyqtSlot()
    def run(self):

        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.fov.fov_ui.HexapodMonitoringWorker" href="#egse.fov.fov_ui.HexapodMonitoringWorker">HexapodMonitoringWorker</a></li>
<li><a title="egse.fov.fov_ui.StagesMonitoringWorker" href="#egse.fov.fov_ui.StagesMonitoringWorker">StagesMonitoringWorker</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fov.fov_ui.MonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self, settings)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p>
<h2 id="args">Args</h2>
<ul>
<li>settings: Settings with the connection information (which was loaded from the settings file).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self, settings):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.

    Args:
        - settings: Settings with the connection information (which was loaded from the settings file).
    &#34;&#34;&#34;

    try:

        # Ctrl settings:
        #   - transport protocol
        #   - hostname
        #   - commanding port (to check whether the CS is active)
        #   - monitoring port (to ask for process information)

        transport = settings.PROTOCOL
        hostname = settings.HOSTNAME
        commanding_port = settings.COMMANDING_PORT
        monitoring_port = settings.MONITORING_PORT

        # Create a socket and connect to the monitoring port

        monitoring_address = connect_address(transport, hostname, monitoring_port)
        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        # Address of the commanding port
        # This is needed when checking whether or not the CS is active

        self.commanding_address = connect_address(transport, hostname, commanding_port)

        self.is_socket_connected = True

    except AttributeError:

        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.MonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.MonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start listening on the monitoring port.</p>
<p>If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
to notify the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34; Start listening on the monitoring port.

    If the Control Server is not active when the thread starts listening on the monitoring port, a signal is emitted
    to notify the GUI.
    &#34;&#34;&#34;

    self.run()</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.MonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the monitoring worker.</p>
<p>The monitoring socket is disconnected from the monitoring port and is then closed immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34; Stop the monitoring worker.

    The monitoring socket is disconnected from the monitoring port and is then closed immediately.
    &#34;&#34;&#34;

    self.is_socket_connected = False
    self.monitoring_socket.close()

    # self.monitoring_socket.disconnect(self.monitoring_address)
    # self.monitoring_socket.close(linger=0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fov.fov_ui.StagesMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">StagesMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the position of the stages.</p>
<p>Initialisation of a monitoring worker for the stages.</p>
<p>This monitoring worker will listen on the monitoring port of the Huber Control Server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StagesMonitoringWorker(MonitoringWorker):
    &#34;&#34;&#34; Worker for monitoring the position of the stages.&#34;&#34;&#34;

    # The worker will send a signal with three floats and one dictionaries:
    # The floats will be:
    #   - Commanded position of the big rotation stage [degrees]
    #   - Commanded position of the small rotation stage [degrees]
    #   - Commanded position of the translation stage [mm]
    # The dictionary will have the following entries:
    #   - &#34;angles&#34;: Tuple with the field angles (theta, phi) [degrees]
    #   - &#34;pixels&#34;: Tuple with the CCD coordinates (row, column) [pixels] and the CCD code
    #   - &#34;mm&#34;: Tuple with the focal-plane coordinates (x, y) [pixels]

    stages_position_signal = pyqtSignal(float, float, float, dict)

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker for the stages.

        This monitoring worker will listen on the monitoring port of the Huber Control Server.
        &#34;&#34;&#34;

        super(StagesMonitoringWorker, self).__init__(STAGES_SETTINGS)

        # When new monitoring information comes in, these variables will contain the previous values for the position
        # of the stages (as currently displayed in the GUI).  Once we have checked whether changes have occurred since
        # the last time monitoring information was received, these values will be overwritten by the new ones.

        self.position_big_rotation_stage = None
        self.position_small_rotation_stage = None
        self.position_translation_stage = None

        # Information from the setup

        setup = load_setup()

        self.focal_length = setup.camera.fov.focal_length_mm
        self.offset_alpha = setup.gse.stages.calibration.offset_alpha
        self.offset_phi = setup.gse.stages.calibration.offset_phi
        self.offset_delta_x = setup.gse.stages.calibration.offset_delta_x
        self.alpha_correction_coefficients = setup.gse.stages.calibration.alpha_correction_coefficients
        self.phi_correction_coefficients = setup.gse.stages.calibration.phi_correction_coefficients

        self.distortion_coefficients = setup.camera.fov.distortion_coefficients
        self.height_collimated_beam = setup.gse.stages.calibration.height_collimated_beam

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on listening on the monitoring port of the stages.

        If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
        Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
        process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
        0.5s).
        &#34;&#34;&#34;

        self.active = True

        while self.is_socket_connected and self.active:

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Update the timeout, to be more in line with the monitoring frequency of the CS (i.e. the delay).
                    # Take 0.5s extra to be on the safe side.

                    self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                    if self.position_has_changed(monitoring_info):

                        self.stages_position_signal.emit(self.position_big_rotation_stage,
                                                         self.position_small_rotation_stage,
                                                         self.position_translation_stage,
                                                         self.get_position())

            except zmq.ZMQError:

                pass

            # Timeout occurred

            else:

                # The CS is not active

                if not is_control_server_active(self.commanding_address):

                    # TODO
                    pass

                # The CS is active, but the timeout was too strict

                else:

                    self.monitoring_timeout += 0.5

    def position_has_changed(self, monitoring_info: dict):
        &#34;&#34;&#34; Check whether the position of at least one of the stages has changed.

        Check whether the position of at least one of the changes has changed since the previous time monitoring
        information was received.

        If the position of the stages has changed, the previous values are updated.

        Args:
            - monitoring_info: Monitoring information for the stages.

        Returns: True if the position of at least one of the stages has changed; False otherwise.
        &#34;&#34;&#34;

        position_has_changed = False

        # Big rotation stage

        position_big_rotation_stage = monitoring_info[&#34;big_rotation_stage_position&#34;]

        if position_big_rotation_stage != self.position_big_rotation_stage:

            self.position_big_rotation_stage = position_big_rotation_stage
            position_has_changed = True

        # Small rotation stage

        position_small_rotation_stage = monitoring_info[&#34;small_rotation_stage_position&#34;]

        if position_small_rotation_stage != self.position_small_rotation_stage:

            self.position_small_rotation_stage = position_small_rotation_stage
            position_has_changed = True

        # Translation stage

        position_translation_stage = monitoring_info[&#34;translation_stage_position&#34;]

        if position_translation_stage != self.position_translation_stage:

            self.position_translation_stage = position_translation_stage
            position_has_changed = True

        return position_has_changed

    def get_position(self):
        &#34;&#34;&#34; Calculates the coordinate of the source.

        Calculates the coordinate of the source, given the position of the associated hexapod and stages, and taking
        the field distortion into account.

        :return: Dictionary with the following entries:
                    - &#34;angles&#34;: gnomonic distance from the optical axis and in-field angle [degrees]
                    - &#34;pixels&#34;: CCD coordinates (row, column) [pixels] and the corresponding CCD code
                    - &#34;mm&#34;: focal-plane coordinates (x, y) [mm]
        &#34;&#34;&#34;

        # TODO Check whether the light beam passes through the entrance pupil

        # Gnomonic distance to optical axis and in-field angle [degrees]

        theta = (self.position_small_rotation_stage + self.offset_alpha - self.alpha_correction_coefficients[0]) \
            / self.alpha_correction_coefficients[1]

        phi_correction = self.phi_correction_coefficients[1] * theta + self.phi_correction_coefficients[0]
        phi = -self.position_big_rotation_stage - self.offset_phi - phi_correction

        # Focal-plane coordinates [mm]

        x, y = coordinates.angles_to_focal_plane_coordinates(theta, phi)

        # CCD coordinates [pixels]

        (row, column, ccd_code) = focal_plane_to_ccd_coordinates(x, y, setup)

        position = {
            &#34;angles&#34;: (theta, phi),
            &#34;pixels&#34;: (row, column, ccd_code),
            &#34;mm&#34;: (x, y)
        }

        return position

    def light_beam_through_entrance_pupil(self):
        &#34;&#34;&#34; Check whether the light beam goes through the entrance pupil.

        Returns: True of the light beam passes through the entrance pupil; False otherwise.
        &#34;&#34;&#34;

        distance_sma = -self.position_translation_stage + self.offset_delta_x

        return distance_sma / self.height_collimated_beam == \
            tan(radians(self.position_small_rotation_stage + self.offset_alpha + 45))

    # def get_focal_plane_position(self):
    #
    #     &#34;&#34;&#34;
    #     Calculates and returns the focal-plane coordinates (x, y) [mm] of the source, given the
    #     position of the associated hexapod and stages, and taking the field distortion into account.
    #
    #     :return: Focal-plane coordinates (x, y) [mm] of the source, given the position of the
    #              associated hexapod and stages, and taking the field distortion into account.
    #     &#34;&#34;&#34;
    #
    #     angle_big_rotation_stage = self.position_big_rotation_stage

        # # Rotation angle of the big rotation stage [degrees]
        # # - counterclockwise rotation
        # # - 0° -&gt; axis of the focal plane aligned with GL_FIX
        #
        # angle_big_rotation_stage = self.position_big_rotation_stage
        #
        # # Rotation angle of the small rotation stage [degrees]
        # # - clockwise rotation
        # # - 0° -&gt; ?
        #
        # angle_small_rotation_stage = self.position_small_rotation_stage
        #
        # # Radial distance without field distortion [mm] and corresponding focal-plane coordinates [mm]
        # # Note that the height of the lower triangle is very close to the focal length
        #
        # theta = 2 * angle_small_rotation_stage  # [degrees]
        #
        # radial_distance_undistorted = self.focal_length * tan(radians(theta))
        #
        # x_undistorted = -radial_distance_undistorted * cos(-radians(angle_big_rotation_stage))
        # y_undistorted = -radial_distance_undistorted * sin(-radians(angle_big_rotation_stage))
        #
        # x_distorted, y_distorted = \
        #     undistorted_to_distorted_focal_plane_coordinates(x_undistorted, y_undistorted,
        #                                                      self.distortion_coefficients, self.focal_length)
        #
        # return x_distorted, y_distorted</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.fov.fov_ui.MonitoringWorker" href="#egse.fov.fov_ui.MonitoringWorker">MonitoringWorker</a></li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fov.fov_ui.StagesMonitoringWorker.get_position"><code class="name flex">
<span>def <span class="ident">get_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the coordinate of the source.</p>
<p>Calculates the coordinate of the source, given the position of the associated hexapod and stages, and taking
the field distortion into account.</p>
<p>:return: Dictionary with the following entries:
- "angles": gnomonic distance from the optical axis and in-field angle [degrees]
- "pixels": CCD coordinates (row, column) [pixels] and the corresponding CCD code
- "mm": focal-plane coordinates (x, y) [mm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_position(self):
    &#34;&#34;&#34; Calculates the coordinate of the source.

    Calculates the coordinate of the source, given the position of the associated hexapod and stages, and taking
    the field distortion into account.

    :return: Dictionary with the following entries:
                - &#34;angles&#34;: gnomonic distance from the optical axis and in-field angle [degrees]
                - &#34;pixels&#34;: CCD coordinates (row, column) [pixels] and the corresponding CCD code
                - &#34;mm&#34;: focal-plane coordinates (x, y) [mm]
    &#34;&#34;&#34;

    # TODO Check whether the light beam passes through the entrance pupil

    # Gnomonic distance to optical axis and in-field angle [degrees]

    theta = (self.position_small_rotation_stage + self.offset_alpha - self.alpha_correction_coefficients[0]) \
        / self.alpha_correction_coefficients[1]

    phi_correction = self.phi_correction_coefficients[1] * theta + self.phi_correction_coefficients[0]
    phi = -self.position_big_rotation_stage - self.offset_phi - phi_correction

    # Focal-plane coordinates [mm]

    x, y = coordinates.angles_to_focal_plane_coordinates(theta, phi)

    # CCD coordinates [pixels]

    (row, column, ccd_code) = focal_plane_to_ccd_coordinates(x, y, setup)

    position = {
        &#34;angles&#34;: (theta, phi),
        &#34;pixels&#34;: (row, column, ccd_code),
        &#34;mm&#34;: (x, y)
    }

    return position</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.StagesMonitoringWorker.light_beam_through_entrance_pupil"><code class="name flex">
<span>def <span class="ident">light_beam_through_entrance_pupil</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the light beam goes through the entrance pupil.</p>
<p>Returns: True of the light beam passes through the entrance pupil; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def light_beam_through_entrance_pupil(self):
    &#34;&#34;&#34; Check whether the light beam goes through the entrance pupil.

    Returns: True of the light beam passes through the entrance pupil; False otherwise.
    &#34;&#34;&#34;

    distance_sma = -self.position_translation_stage + self.offset_delta_x

    return distance_sma / self.height_collimated_beam == \
        tan(radians(self.position_small_rotation_stage + self.offset_alpha + 45))

# def get_focal_plane_position(self):
#
#     &#34;&#34;&#34;
#     Calculates and returns the focal-plane coordinates (x, y) [mm] of the source, given the
#     position of the associated hexapod and stages, and taking the field distortion into account.
#
#     :return: Focal-plane coordinates (x, y) [mm] of the source, given the position of the
#              associated hexapod and stages, and taking the field distortion into account.
#     &#34;&#34;&#34;
#
#     angle_big_rotation_stage = self.position_big_rotation_stage

    # # Rotation angle of the big rotation stage [degrees]
    # # - counterclockwise rotation
    # # - 0° -&gt; axis of the focal plane aligned with GL_FIX
    #
    # angle_big_rotation_stage = self.position_big_rotation_stage
    #
    # # Rotation angle of the small rotation stage [degrees]
    # # - clockwise rotation
    # # - 0° -&gt; ?
    #
    # angle_small_rotation_stage = self.position_small_rotation_stage
    #
    # # Radial distance without field distortion [mm] and corresponding focal-plane coordinates [mm]
    # # Note that the height of the lower triangle is very close to the focal length
    #
    # theta = 2 * angle_small_rotation_stage  # [degrees]
    #
    # radial_distance_undistorted = self.focal_length * tan(radians(theta))
    #
    # x_undistorted = -radial_distance_undistorted * cos(-radians(angle_big_rotation_stage))
    # y_undistorted = -radial_distance_undistorted * sin(-radians(angle_big_rotation_stage))
    #
    # x_distorted, y_distorted = \
    #     undistorted_to_distorted_focal_plane_coordinates(x_undistorted, y_undistorted,
    #                                                      self.distortion_coefficients, self.focal_length)
    #
    # return x_distorted, y_distorted</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.StagesMonitoringWorker.position_has_changed"><code class="name flex">
<span>def <span class="ident">position_has_changed</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the position of at least one of the stages has changed.</p>
<p>Check whether the position of at least one of the changes has changed since the previous time monitoring
information was received.</p>
<p>If the position of the stages has changed, the previous values are updated.</p>
<h2 id="args">Args</h2>
<ul>
<li>monitoring_info: Monitoring information for the stages.
Returns: True if the position of at least one of the stages has changed; False otherwise.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_has_changed(self, monitoring_info: dict):
    &#34;&#34;&#34; Check whether the position of at least one of the stages has changed.

    Check whether the position of at least one of the changes has changed since the previous time monitoring
    information was received.

    If the position of the stages has changed, the previous values are updated.

    Args:
        - monitoring_info: Monitoring information for the stages.

    Returns: True if the position of at least one of the stages has changed; False otherwise.
    &#34;&#34;&#34;

    position_has_changed = False

    # Big rotation stage

    position_big_rotation_stage = monitoring_info[&#34;big_rotation_stage_position&#34;]

    if position_big_rotation_stage != self.position_big_rotation_stage:

        self.position_big_rotation_stage = position_big_rotation_stage
        position_has_changed = True

    # Small rotation stage

    position_small_rotation_stage = monitoring_info[&#34;small_rotation_stage_position&#34;]

    if position_small_rotation_stage != self.position_small_rotation_stage:

        self.position_small_rotation_stage = position_small_rotation_stage
        position_has_changed = True

    # Translation stage

    position_translation_stage = monitoring_info[&#34;translation_stage_position&#34;]

    if position_translation_stage != self.position_translation_stage:

        self.position_translation_stage = position_translation_stage
        position_has_changed = True

    return position_has_changed</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.StagesMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on listening on the monitoring port of the stages.</p>
<p>If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
Otherwise, it is checked whether or not the Control Server is active.
If not, a signal is emitted with the
process name.
Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
0.5s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34; Keep on listening on the monitoring port of the stages.

    If monitoring information is received before the timeout, a signal with the monitoring information is emitted.
    Otherwise, it is checked whether or not the Control Server is active.  If not, a signal is emitted with the
    process name.  Otherwise, the timeout for monitoring was too strict (and it will therefore be increased by
    0.5s).
    &#34;&#34;&#34;

    self.active = True

    while self.is_socket_connected and self.active:

        try:

            socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            # Monitoring information was received (before timeout)

            if self.monitoring_socket in socket_list:

                pickle_string = self.monitoring_socket.recv()
                monitoring_info = pickle.loads(pickle_string)

                # Update the timeout, to be more in line with the monitoring frequency of the CS (i.e. the delay).
                # Take 0.5s extra to be on the safe side.

                self.monitoring_timeout = monitoring_info[&#34;delay&#34;] / 1000.0 + 0.5    # [s]

                if self.position_has_changed(monitoring_info):

                    self.stages_position_signal.emit(self.position_big_rotation_stage,
                                                     self.position_small_rotation_stage,
                                                     self.position_translation_stage,
                                                     self.get_position())

        except zmq.ZMQError:

            pass

        # Timeout occurred

        else:

            # The CS is not active

            if not is_control_server_active(self.commanding_address):

                # TODO
                pass

            # The CS is active, but the timeout was too strict

            else:

                self.monitoring_timeout += 0.5</code></pre>
</details>
</dd>
<dt id="egse.fov.fov_ui.StagesMonitoringWorker.stages_position_signal"><code class="name flex">
<span>def <span class="ident">stages_position_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.fov.fov_ui.MonitoringWorker" href="#egse.fov.fov_ui.MonitoringWorker">MonitoringWorker</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.connect_socket" href="#egse.fov.fov_ui.MonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.start_process" href="#egse.fov.fov_ui.MonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.stop" href="#egse.fov.fov_ui.MonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.fov" href="index.html">egse.fov</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.fov.fov_ui.main" href="#egse.fov.fov_ui.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.fov.fov_ui.FOVUIController" href="#egse.fov.fov_ui.FOVUIController">FOVUIController</a></code></h4>
<ul class="">
<li><code><a title="egse.fov.fov_ui.FOVUIController.do" href="#egse.fov.fov_ui.FOVUIController.do">do</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIController.update" href="#egse.fov.fov_ui.FOVUIController.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fov.fov_ui.FOVUIView" href="#egse.fov.fov_ui.FOVUIView">FOVUIView</a></code></h4>
<ul class="">
<li><code><a title="egse.fov.fov_ui.FOVUIView.closeEvent" href="#egse.fov.fov_ui.FOVUIView.closeEvent">closeEvent</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.create_statusbar" href="#egse.fov.fov_ui.FOVUIView.create_statusbar">create_statusbar</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.create_toolbar" href="#egse.fov.fov_ui.FOVUIView.create_toolbar">create_toolbar</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.init_ui" href="#egse.fov.fov_ui.FOVUIView.init_ui">init_ui</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.on_click" href="#egse.fov.fov_ui.FOVUIView.on_click">on_click</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.on_hexapod_position_change_signal" href="#egse.fov.fov_ui.FOVUIView.on_hexapod_position_change_signal">on_hexapod_position_change_signal</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.on_stages_position_change_signal" href="#egse.fov.fov_ui.FOVUIView.on_stages_position_change_signal">on_stages_position_change_signal</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.update_big_rotation_stage" href="#egse.fov.fov_ui.FOVUIView.update_big_rotation_stage">update_big_rotation_stage</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.update_focus_position" href="#egse.fov.fov_ui.FOVUIView.update_focus_position">update_focus_position</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.update_sma" href="#egse.fov.fov_ui.FOVUIView.update_sma">update_sma</a></code></li>
<li><code><a title="egse.fov.fov_ui.FOVUIView.update_source_position" href="#egse.fov.fov_ui.FOVUIView.update_source_position">update_source_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fov.fov_ui.HexapodMonitoringWorker" href="#egse.fov.fov_ui.HexapodMonitoringWorker">HexapodMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.fov.fov_ui.HexapodMonitoringWorker.get_focus_position" href="#egse.fov.fov_ui.HexapodMonitoringWorker.get_focus_position">get_focus_position</a></code></li>
<li><code><a title="egse.fov.fov_ui.HexapodMonitoringWorker.hexapod_position_signal" href="#egse.fov.fov_ui.HexapodMonitoringWorker.hexapod_position_signal">hexapod_position_signal</a></code></li>
<li><code><a title="egse.fov.fov_ui.HexapodMonitoringWorker.position_has_changed" href="#egse.fov.fov_ui.HexapodMonitoringWorker.position_has_changed">position_has_changed</a></code></li>
<li><code><a title="egse.fov.fov_ui.HexapodMonitoringWorker.run" href="#egse.fov.fov_ui.HexapodMonitoringWorker.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fov.fov_ui.MonitoringWorker" href="#egse.fov.fov_ui.MonitoringWorker">MonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.connect_socket" href="#egse.fov.fov_ui.MonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.run" href="#egse.fov.fov_ui.MonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.start_process" href="#egse.fov.fov_ui.MonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.fov.fov_ui.MonitoringWorker.stop" href="#egse.fov.fov_ui.MonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fov.fov_ui.StagesMonitoringWorker" href="#egse.fov.fov_ui.StagesMonitoringWorker">StagesMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.fov.fov_ui.StagesMonitoringWorker.get_position" href="#egse.fov.fov_ui.StagesMonitoringWorker.get_position">get_position</a></code></li>
<li><code><a title="egse.fov.fov_ui.StagesMonitoringWorker.light_beam_through_entrance_pupil" href="#egse.fov.fov_ui.StagesMonitoringWorker.light_beam_through_entrance_pupil">light_beam_through_entrance_pupil</a></code></li>
<li><code><a title="egse.fov.fov_ui.StagesMonitoringWorker.position_has_changed" href="#egse.fov.fov_ui.StagesMonitoringWorker.position_has_changed">position_has_changed</a></code></li>
<li><code><a title="egse.fov.fov_ui.StagesMonitoringWorker.run" href="#egse.fov.fov_ui.StagesMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.fov.fov_ui.StagesMonitoringWorker.stages_position_signal" href="#egse.fov.fov_ui.StagesMonitoringWorker.stages_position_signal">stages_position_signal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
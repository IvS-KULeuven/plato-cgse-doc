<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.fee.feesim API documentation</title>
<meta name="description" content="The FEE Simulator application. This app provides basic FEE functionality and is used mainly to
test the DPU Processor. The communication between the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.fee.feesim</code></h1>
</header>
<section id="section-intro">
<p>The FEE Simulator application. This app provides basic FEE functionality and is used mainly to
test the DPU Processor. The communication between the FEE Simulator and the DPU Processor is
abstracted by a SpaceWireInterface which currently has two implementations:</p>
<pre><code>1. a SpaceWireOverDSI, i.e. the 4Links Diagnostic SpaceWire Interface (DSI) or the
   EtherSpaceLink (ESL) device running over SpaceWire and TCP/IP, or
2. a SpaceWireOverZeroMQ, i.e. all communication runs over ZeroMQ.
</code></pre>
<p>The FEE Simulator can be started as follows:</p>
<pre><code>$ feesim start --dsi-address &lt;IP address of the DSI&gt; --dsi-port &lt;the SpW port on the DSI&gt;
$ feesim start --zeromq
</code></pre>
<p>The FEE Simulator can also be started to run over an ssh tunnel:</p>
<pre><code>$ feesim start --tunnel -ssh-user &lt;name&gt;
</code></pre>
<p>When connecting over a tunnel, the SSH passphrase is requested.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The FEE Simulator application. This app provides basic FEE functionality and is used mainly to
test the DPU Processor. The communication between the FEE Simulator and the DPU Processor is
abstracted by a SpaceWireInterface which currently has two implementations:

    1. a SpaceWireOverDSI, i.e. the 4Links Diagnostic SpaceWire Interface (DSI) or the
       EtherSpaceLink (ESL) device running over SpaceWire and TCP/IP, or
    2. a SpaceWireOverZeroMQ, i.e. all communication runs over ZeroMQ.

The FEE Simulator can be started as follows:

    $ feesim start --dsi-address &lt;IP address of the DSI&gt; --dsi-port &lt;the SpW port on the DSI&gt;
    $ feesim start --zeromq

The FEE Simulator can also be started to run over an ssh tunnel:

    $ feesim start --tunnel -ssh-user &lt;name&gt;

When connecting over a tunnel, the SSH passphrase is requested.
&#34;&#34;&#34;
import getpass
import logging
import multiprocessing

import click
import numpy as np

from egse.hk import TmDictionaryColumns
from egse.setup import SetupError
from egse.state import GlobalState

multiprocessing.current_process().name = &#34;feesim&#34;

import sys
import time
from typing import NamedTuple, List

import sshtunnel

from egse.dsi.spw import SpaceWireOverDSI
from egse.fee import n_fee_mode
from egse.fee import convert_ccd_order_value
from egse.fee.fee import create_pattern_data
from egse.fee.fee import generate_data_packets
from egse.fee.nfee import HousekeepingData
from egse.reg import RegisterMap
from egse.settings import Settings
from egse.spw import DataPacketHeader
from egse.spw import DataPacketType
from egse.spw import PacketType
from egse.spw import ReadRequest
from egse.spw import SpaceWireInterface
from egse.spw import SpaceWirePacket
from egse.spw import WriteRequest
from egse.spw import create_rmap_read_request_reply_packet
from egse.spw import create_rmap_write_request_reply_packet
from egse.zmq.spw import SpaceWireOverZeroMQ
from egse.fee.n_fee_hk import ORIGIN

logging.basicConfig(level=logging.DEBUG, format=Settings.LOG_FORMAT_FULL)

LOGGER = logging.getLogger(&#34;egse.fee.feesim&#34;)

fee_settings = Settings.load(&#34;FEE&#34;)
dsi_settings = Settings.load(&#34;DSI&#34;)
site_settings = Settings.load(&#34;SITE&#34;)
dpu_settings = Settings.load(&#34;DPU Processor&#34;)


# Define the possible states


class States(NamedTuple):
    ST_OFF: int
    ST_ON: int
    ST_FULL_IMAGE_PATTERN: int
    ST_WINDOWING_PATTERN: int
    ST_STANDBY: int
    ST_FULL_IMAGE: int
    ST_WINDOWING: int
    ST_PERFORMANCE_TEST: int
    ST_PARALLEL_TRAP_PUMPING_1: int
    ST_PARALLEL_TRAP_PUMPING_2: int
    ST_SERIAL_TRAP_PUMPING_1: int
    ST_SERIAL_TRAP_PUMPING_2: int


states = States(
    ST_OFF=-1,
    ST_ON=0,
    ST_FULL_IMAGE_PATTERN=1,
    ST_WINDOWING_PATTERN=2,
    ST_STANDBY=4,
    ST_FULL_IMAGE=5,
    ST_WINDOWING=6,
    ST_PERFORMANCE_TEST=7,
    ST_PARALLEL_TRAP_PUMPING_1=9,
    ST_PARALLEL_TRAP_PUMPING_2=10,
    ST_SERIAL_TRAP_PUMPING_1=11,
    ST_SERIAL_TRAP_PUMPING_2=12,
)

# Set the initial state

current_state: int = states.ST_OFF


# Define the transitions


def goto_on_mode(state):
    # N-FEE in ON-mode
    # * Power of the CCDs is disabled
    # * Power of subsystems is disabled
    # * N-FEE is ready for receiving RMAP command
    return states.ST_ON


def goto_standby_mode(state):
    # N-FEE in STANDBY-mode
    # * CCDs and subsystems are powered
    # * CCD timing signals are disabled
    # * no image data shall be transferred
    return states.ST_STANDBY


def goto_windowing_mode(state):
    # N-FEE in WINDOWING-mode
    # * The full CCDs are readout
    # * Only regions of interest (windows) are transmitted
    # * Configuration:
    #   * This configuration needs to be set via RMAP before changing from STANDBY to WINDOWING mode
    #   * Set first and last row to read-out
    #   * Set serial transfers size (column size)
    #   * Set number of overscan lines.
    #   * Enable or disable charge injection
    #   * Set first and last line for charge injection - Set width and gap for charge injection.
    #   * Enable or disable warm-up (= disable data transfer) - Set data-packet size
    #   * Set CCD read-out order (all CCDs)
    #   * Set CCD side E or F- Upload the window-lists
    #   * Set the window-lists pointers
    #   * Set the window-list lengths
    #   * Set the window size
    #   * Set the copy-order list (including list-length for side E and F) -
    #     Set dump-gate high or low
    return states.ST_WINDOWING


# Define all legal transitions

state_transitions = {
    (states.ST_OFF, &#34;goto_on&#34;): goto_on_mode,
    (states.ST_ON, &#34;goto_standby&#34;): goto_standby_mode,
    (states.ST_WINDOWING, &#34;goto_standby&#34;): goto_standby_mode,
    (states.ST_STANDBY, &#34;goto_windowing&#34;): goto_windowing_mode,
}


class NFEEInternals:
    &#34;&#34;&#34;
    The N-FEE Internals class represents the actual state of the N-FEE. A bit like the FPGA status
    in the N-FEE hardware. The difference with the RegisterMap is that the register map is updated
    on RMAP write requests, while this class is updated on sync pulses (from the content of the
    register map). Therefore, the N-FEE Internals represent the actual state, while the register
    map represents the commanded state.
    &#34;&#34;&#34;
    def __init__(self, reg_map: RegisterMap):
        self.reg_map = reg_map
        self.ccd_mode_config = self.reg_map[&#34;ccd_mode_config&#34;]
        self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
        self.ccd_read_en = self.reg_map[&#34;ccd_read_en&#34;]
        self.v_start = self.reg_map[&#34;v_start&#34;]
        self.v_end = self.reg_map[&#34;v_end&#34;]
        self.digitise_en = self.reg_map[&#34;digitise_en&#34;]
        self.sync_sel = self.reg_map[&#34;sync_sel&#34;]
        self.int_sync_period = self.reg_map[&#34;int_sync_period&#34;]
        self.ccd_readout_order = self.reg_map[&#34;ccd_readout_order&#34;]
        LOGGER.info(f&#34;Initialised {self.v_start=}, {self.v_end=}&#34;)

    def update(self, pulse_type: int):
        &#34;&#34;&#34;
        Update the internal state from the register. Depending on the pulse_type, specific state
        variables are updated from the current register map values.

        Args:
            pulse_type (int): a 200 or 400 ms pulse
        &#34;&#34;&#34;
        if pulse_type == 200:
            self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
            self.ccd_read_en = self.reg_map[&#39;ccd_read_en&#39;]
        if pulse_type == 400:
            self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
            self.ccd_read_en = self.reg_map[&#39;ccd_read_en&#39;]
            self.ccd_mode_config = self.reg_map[&#34;ccd_mode_config&#34;]
            self.v_start = self.reg_map[&#34;v_start&#34;]
            self.v_end = self.reg_map[&#34;v_end&#34;]
            self.digitise_en = self.reg_map[&#34;digitise_en&#34;]
            self.sync_sel = self.reg_map[&#34;sync_sel&#34;]
            self.int_sync_period = self.reg_map[&#34;int_sync_period&#34;]
            self.ccd_readout_order = self.reg_map[&#34;ccd_readout_order&#34;]
            LOGGER.info(f&#34;Updated {self.v_start=}, {self.v_end=}, {self.ccd_mode_config=}&#34;)

    def get_sync_period(self) -&gt; float:
        &#34;&#34;&#34;
        Calculate and return the period between two successive sync pulses.

        Note:
            Please note that this value is calculated from what is known in the register map. The
            external sync period is however dependent from the sync signal received from the AEU,
            and the AEU might have been configured for extended sync periods.

        Returns:
            The sync period (time between two sync pulses) in seconds.
        &#34;&#34;&#34;
        sync_sel = self.reg_map.get_value(&#34;reg_5_config&#34;, &#34;sync_sel&#34;)
        if sync_sel:
            sync_period = self.reg_map.get_value(&#34;reg_4_config&#34;, &#34;int_sync_period&#34;)
        else:
            sync_period = 6250
        return sync_period / 1000

    def get_readout_order(self) -&gt; List:
        &#34;&#34;&#34;Returns the ccd readout order as a list of CCD numbers, e.g. [1, 2, 3, 4].&#34;&#34;&#34;
        return convert_ccd_order_value(self.ccd_readout_order)


class FEESimulator:
    &#34;&#34;&#34;
    A software simulator for the front-end electronics of the PLATO cameras.
    &#34;&#34;&#34;

    def __init__(self, transport: SpaceWireInterface):
        &#34;&#34;&#34;
        Args:
            transport: the SpaceWire transport method, e.g. DSI or ZeroMQ.
        &#34;&#34;&#34;
        self._transport: SpaceWireInterface = transport
        self.register_map = RegisterMap(&#34;N-FEE&#34;)
        self._hk_data = HousekeepingData()
        self._hk_header = DataPacketHeader()

        self._IN = NFEEInternals(self.register_map)

        self.initialise_hk_data()
        self.initialise_hk_header()

    def initialise_hk_data(self):
        &#34;&#34;&#34;Initialises the housekeeping data to fake or simulated values.&#34;&#34;&#34;

        try:
            hk_info_table = GlobalState.setup.telemetry.dictionary
        except AttributeError:
            raise SetupError(&#34;Version of the telemetry dictionary not specified in the current setup&#34;)

        storage_mnemonic_col = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
        original_name_col = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values
        selection = np.where(storage_mnemonic_col == ORIGIN)
        original_names = original_name_col[selection]

        self._hk_data[&#34;TOU_SENSE_1&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_2&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_3&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_4&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_5&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_6&#34;] = 0x8000

        self._hk_data[&#34;CCD1_TS&#34;] = 0x7FFF
        self._hk_data[&#34;CCD2_TS&#34;] = 0x7FFF
        self._hk_data[&#34;CCD3_TS&#34;] = 0x7FFF
        self._hk_data[&#34;CCD4_TS&#34;] = 0x7FFF

        self._hk_data[&#34;PRT1&#34;] = 0x7FFF
        self._hk_data[&#34;PRT2&#34;] = 0x7FFF
        self._hk_data[&#34;PRT3&#34;] = 0x7FFF
        self._hk_data[&#34;PRT4&#34;] = 0x7FFF
        self._hk_data[&#34;PRT5&#34;] = 0x7FFF

        self._hk_data[&#34;ZERO_DIFF_AMP&#34;] = 0x8015

        if &#34;CCD1_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD1_VOD_MON&#34;] = 0x8055
        else:
            if &#34;CCD1_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD1_VOD_MON_E&#34;] = 0x8055
            if &#34;CCD1_VOD_MON_F&#34; in original_names:
                self._hk_data[&#34;CCD1_VOD_MON_F&#34;] = 0x8055
        self._hk_data[&#34;CCD1_VOG_MON&#34;] = 0x8056
        self._hk_data[&#34;CCD1_VRD_MON_E&#34;] = 0x8056

        if &#34;CCD2_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD2_VOD_MON&#34;] = 0x8057
        else:
            if &#34;CCD2_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD2_VOD_MON_E&#34;] = 0x8057
            if &#34;CCD2_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD2_VOD_MON_E&#34;] = 0x8057
        self._hk_data[&#34;CCD2_VOG_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD2_VRD_MON_E&#34;] = 0x8057

        if &#34;CCD3_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD3_VOD_MON&#34;] = 0x8058
        else:
            if &#34;CCD3_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD3_VOD_MON_E&#34;] = 0x8058
            if &#34;CCD3_VOD_MON_F&#34; in original_names:
                self._hk_data[&#34;CCD3_VOD_MON_F&#34;] = 0x8058
        self._hk_data[&#34;CCD3_VOG_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD3_VRD_MON_E&#34;] = 0x8058

        if &#34;CCD4_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD4_VOD_MON&#34;] = 0x8057
        else:
            if &#34;CCD4_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD4_VOD_MON_E&#34;] = 0x8057
            if &#34;CCD4_VOD_MON_F&#34; in original_names:
                self._hk_data[&#34;CCD4_VOD_MON_F&#34;] = 0x8057
        self._hk_data[&#34;CCD4_VOG_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD4_VRD_MON_E&#34;] = 0x8058

        self._hk_data[&#34;VCCD&#34;] = 0x39BF
        self._hk_data[&#34;VRCLK_MON&#34;] = 0xFC8A
        self._hk_data[&#34;VICLK&#34;] = 0xFAE9
        if &#34;VRCLK_LOW&#34; in original_names:
            self._hk_data[&#34;VRCLK_LOW&#34;] = 0x821A

        if &#34;5VB_POS_MON&#34; in original_names:
            self._hk_data[&#34;5VB_POS_MON&#34;] = 0x1E6A
        self._hk_data[&#34;5VB_NEG_MON&#34;] = 0x1A9F
        self._hk_data[&#34;3V3B_MON&#34;] = 0xE75D
        self._hk_data[&#34;2V5A_MON&#34;] = 0x1979
        self._hk_data[&#34;3V3D_MON&#34;] = 0xE76E
        self._hk_data[&#34;2V5D_MON&#34;] = 0x1A8C
        self._hk_data[&#34;1V5D_MON&#34;] = 0xDF35
        self._hk_data[&#34;5VREF_MON&#34;] = 0x1A80

        self._hk_data[&#34;VCCD_POS_RAW&#34;] = 0x53BF
        self._hk_data[&#34;VCLK_POS_RAW&#34;] = 0x40BA
        self._hk_data[&#34;VAN1_POS_RAW&#34;] = 0x0744
        self._hk_data[&#34;VAN3_NEG_MON&#34;] = 0xFB7C
        self._hk_data[&#34;VAN2_POS_RAW&#34;] = 0x3AEC
        self._hk_data[&#34;VDIG_RAW&#34;] = 0x0AB5
        if &#34;5VB_POS_MON&#34; in original_names:
            self._hk_data[&#34;VDIG_RAW_2&#34;] = 0x0A32
        if &#34;VICLK_LOW&#34; in original_names:
            self._hk_data[&#34;VICLK_LOW&#34;] = 0x8277

        self._hk_data[&#34;CCD1_VRD_MON_F&#34;] = 0x8059
        self._hk_data[&#34;CCD1_VDD_MON&#34;] = 0x94CA
        self._hk_data[&#34;CCD1_VGD_MON&#34;] = 0x8056
        self._hk_data[&#34;CCD2_VRD_MON_F&#34;] = 0x8058
        self._hk_data[&#34;CCD2_VDD_MON&#34;] = 0x94C1
        self._hk_data[&#34;CCD2_VGD_MON&#34;] = 0x8055
        self._hk_data[&#34;CCD3_VRD_MON_F&#34;] = 0x8059
        self._hk_data[&#34;CCD3_VDD_MON&#34;] = 0x94C1
        self._hk_data[&#34;CCD3_VGD_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD4_VRD_MON_F&#34;] = 0x8058
        self._hk_data[&#34;CCD4_VDD_MON&#34;] = 0x94BA
        self._hk_data[&#34;CCD4_VGD_MON&#34;] = 0x8056

        self._hk_data[&#34;IG_HI_MON&#34;] = 0x8057
        if &#34;IG_LO_MON&#34; in original_names:
            self._hk_data[&#34;IG_LO_MON&#34;] = 0x8059
        self._hk_data[&#34;TSENSE_A&#34;] = 0x8059
        self._hk_data[&#34;TSENSE_B&#34;] = 0x805A

        self._hk_data[&#34;spw_timecode&#34;] = 0x0000
        self._hk_data[&#34;rmap_target_status&#34;] = 0x0000
        self._hk_data[&#34;rmap_target_indicate&#34;] = 0x0000
        self._hk_data[&#34;spw_link_escape_error&#34;] = 0x0000
        self._hk_data[&#34;spw_credit_error&#34;] = 0x0000
        self._hk_data[&#34;spw_parity_error&#34;] = 0x0000
        self._hk_data[&#34;spw_link_disconnect&#34;] = 0x0000
        self._hk_data[&#34;spw_link_running&#34;] = 0x0001

        self._hk_data[&#34;frame_counter&#34;] = 0x0000
        self._hk_data[&#34;op_mode&#34;] = 0x0000
        self._hk_data[&#34;frame_number&#34;] = 0x0000

        self._hk_data[&#34;error_flags&#34;] = 0x0000

        self._hk_data[&#34;FPGA minor version&#34;] = 0x0018
        self._hk_data[&#34;FPGA major version&#34;] = 0x0000
        self._hk_data[&#34;Board ID&#34;] = 0x0000

    def initialise_hk_header(self):
        &#34;&#34;&#34;
        Initialise the header for the HK data packet. Call this method only after the HK data itself
        has been initialised.
        &#34;&#34;&#34;
        self._hk_header.length = self._hk_data.data_length()
        data_packet_type = DataPacketType()
        data_packet_type.packet_type = PacketType.HOUSEKEEPING_DATA
        data_packet_type.last_packet = True
        self._hk_header.type = data_packet_type.value

    def update_hk_header(self, pulse_type: int):
        &#34;&#34;&#34;
        Update the header of the HK data packet.
        &#34;&#34;&#34;
        data_packet_type = DataPacketType(self._hk_header.type)
        data_packet_type.frame_number = self._hk_data.frame_number
        data_packet_type.mode = self._IN.ccd_mode_config
        self._hk_header.type = data_packet_type.value
        self._hk_header.frame_counter = self._hk_data.frame_counter
        if pulse_type == 400:
            self._hk_header.sequence_counter = 0

    def update_hk_data(self):
        pass

    def get_mode(self):
        mode = self._IN.ccd_mode_config
        return n_fee_mode(mode)

    def get_sync_period(self) -&gt; float:
        return self._IN.get_sync_period()

    def get_current_ccd_number(self):
        &#34;&#34;&#34;Return the current CCD number [range=1-4].&#34;&#34;&#34;
        readout_order = self._IN.ccd_readout_order
        # The convert_ccd_order_value function returns CCD number [1-4]
        readout_order = convert_ccd_order_value(readout_order)
        # CCD number in the N-FEE is [0-3]
        return readout_order[self._hk_data.frame_number]

    @property
    def sensor_sel(self) -&gt; int:
        return self._IN.sensor_sel

    @property
    def v_start(self) -&gt; int:
        return self._IN.v_start

    @property
    def v_end(self) -&gt; int:
        return self._IN.v_end

    @property
    def internal_sync(self) -&gt; bool:
        return bool(self._IN.sync_sel)

    def decode_current_state(self) -&gt; str:
        return self.get_mode().name

    def run(self):

        LOGGER.info(f&#34;FEE Simulator Current State: {self.decode_current_state()}&#34;)
        n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum
        sensor_sel_enum = GlobalState.setup.camera.fee.sensor_sel.enum

        with self._transport:

            LOGGER.info(&#34;SpaceWire Transport has been connected.&#34;)

            self._transport.configure()

            LOGGER.info(&#34;SpaceWire Transport has been configured.&#34;)

            LOGGER.info(&#34;Listening for SpaceWire communication...&#34;)

            start_time = time.perf_counter()  # time in fractional seconds

            while True:

                sync_period = self.get_sync_period()

                if time.perf_counter() &lt;= start_time + sync_period:
                    continue

                start_time = time.perf_counter()

                # Send a timecode packet -----------------------------------------------------------

                timecode = self._hk_data.timecode
                LOGGER.info(f&#34;Sending timecode=0x{timecode:02X}&#34;)
                self._transport.send_timecode(timecode)

                # Send a housekeeping packet -------------------------------------------------------

                LOGGER.info(f&#34;Sending HK packet: frame_counter={self._hk_data.frame_counter}, &#34;
                            f&#34;sequence_counter={self._hk_header.sequence_counter}, &#34;
                            f&#34;type={self._hk_header.type_as_object}&#34;)
                LOGGER.info(f&#34;error_flags={self._hk_data[&#39;error_flags&#39;]}&#34;)

                data = self._hk_header.data_as_bytes() + self._hk_data.data_as_bytes()
                packet = SpaceWirePacket.create_packet(data)
                self._transport.write_packet(packet.packet_as_bytes)

                self._transport.flush()

                # Send the Data packets ------------------------------------------------------------

                LOGGER.info(f&#34;mode={self.decode_current_state()}, &#34;
                            f&#34;Sensor={self.sensor_sel}, &#34;
                            f&#34;Digitising={bool(self._IN.digitise_en)}, &#34;
                            f&#34;Internal Sync={self.internal_sync}&#34;)

                # FIXME: N-FEE sends E- and F-side interlaced, in the code code below we always
                #        send E-side first, then F-side.

                if (self._IN.digitise_en and
                    self._IN.ccd_mode_config in (n_fee_mode.FULL_IMAGE_PATTERN_MODE,
                                                 n_fee_mode.FULL_IMAGE_MODE,)):

                    try:
                        ccd_id_to_bin = GlobalState.setup.camera.fee.ccd_numbering.CCD_ID_TO_BIN
                    except AttributeError:
                        raise SetupError(&#34;No entry in the setup for camera.fee.ccd_numbering.CCD_ID_TO_BIN&#34;)

                    ccd_number = ccd_id_to_bin[self.get_current_ccd_number()]  # N-FEE CCD number [0-3]
                    if self.sensor_sel &amp; sensor_sel_enum.E_SIDE:
                        self.send_data_packets(timecode, ccd_id=ccd_number, ccd_side=n_fee_side.E_SIDE)
                    if self.sensor_sel &amp; sensor_sel_enum.F_SIDE:
                        self.send_data_packets(timecode, ccd_id=ccd_number, ccd_side=n_fee_side.F_SIDE)

                # Process any RMAP commands that were sent -----------------------------------------

                LOGGER.info(
                    f&#34;Calling process_rmap_commands() method for &#34;
                    f&#34;{self._transport.__class__.__name__}.&#34;
                )

                while time.perf_counter() &lt; start_time + sync_period - 0.2:
                    process_rmap_command(self._transport, self.register_map)

                self._hk_data.increment_timecode()

                if not self.internal_sync:
                    self._hk_data.increment_frame_number()

                if self._hk_data.frame_number == 0:
                    self._hk_data.increment_frame_counter()
                    self._IN.update(400)
                    self.update_hk_header(400)
                else:
                    self._IN.update(200)
                    self.update_hk_header(200)

                self.update_error_flags()

    def update_error_flags(self):
        &#34;&#34;&#34;Set error_flags to 0b0000_1000_1000 (136) whenever the frame counter is a multiple of 5.&#34;&#34;&#34;
        self._hk_data[&#34;error_flags&#34;] = 0b0000_0000_0000 if self._hk_data.frame_counter % 5 else 0b0000_1000_1000

    def send_data_packets(self, timecode: int, ccd_id: int, ccd_side: int):

            data = create_pattern_data(timecode, ccd_id, ccd_side)

            header = DataPacketHeader()
            packet_type = header.type_as_object
            packet_type.ccd_side = ccd_side
            packet_type.ccd_number = ccd_id
            packet_type.last_packet = False
            packet_type.frame_number = self._hk_data.frame_number
            packet_type.mode = self._IN.ccd_mode_config
            header.type = packet_type

            LOGGER.info(f&#34;**** {packet_type=!s}&#34;)
            LOGGER.info(f&#34;Sending data packets...{self.v_start=} {self.v_end=}&#34;)

            for packet in generate_data_packets(data, header, self.v_start, self.v_end):
                self._transport.write_packet(packet.packet_as_bytes)
                self._transport.flush()


def process_rmap_command(transport: SpaceWireInterface, register: RegisterMap):

    _, buffer = transport.read_packet(timeout=200)
    if not buffer:
        return

    # The following check is to cope with loss of connection when either the
    # DPU Processor crashed or the connection dropped for some other reason.
    # We will receive one packet with 0 or 1 bytes.

    if len(buffer) in (0, 1):
        return

    packet = SpaceWirePacket.create_packet(buffer)

    LOGGER.info(f&#34;SpW packet received: {packet}&#34;)

    status = 0  # indicating OK

    if isinstance(packet, ReadRequest):
        data = register.get_data(packet.address, packet.data_length)

        data = create_rmap_read_request_reply_packet(
            packet.instruction, packet.transaction_id, status, data, packet.data_length)

        LOGGER.info(f&#34;Sending a ReadRequestReply: {data[:10]=}&#34;)

        transport.write_packet(data)
        transport.flush()

    elif isinstance(packet, WriteRequest):
        if packet.is_verified():
            LOGGER.info(f&#34;Write data to register map: 0x{packet.address:x} {packet.data}&#34;)
            register.set_data(packet.address, packet.data)
            data = create_rmap_write_request_reply_packet(
                packet.instruction, packet.transaction_id, status
            )

            transport.write_packet(data)
            transport.flush()

        else:
            LOGGER.warning(f&#34;Unverified Write Request not yet implemented!&#34;)


def start_fee_simulator(transport: SpaceWireInterface):

    try:
        fee_sim = FEESimulator(transport)
        fee_sim.run()
    except KeyboardInterrupt:
        print(&#34;Shutdown requested...exiting&#34;)
    except SystemExit as exit_code:
        print(&#34;System Exit with code {}.&#34;.format(exit_code))
        return exit_code
    except Exception:
        import traceback

        traceback.print_exc(file=sys.stdout)


@click.group()
def cli():
    pass


@cli.command()
@click.option(&#34;--tunnel&#34;, is_flag=True,
              help=&#34;use an SSH tunnel to connect to the DSI&#34;)
@click.option(&#34;--zeromq&#34;, is_flag=True,
              help=&#34;use ZeroMQ to connect to the DPU Processor&#34;)
@click.option(&#34;--ssh-user&#34;, &#34;-u&#34;,
              help=&#34;the username at the SSH server&#34;)
@click.option(&#34;--dsi-address&#34;, &#34;-a&#34;,
              help=&#34;the hostname or IP address of the DSI to which this client &#34;
                   &#34;will connect (+ tcp socket port)&#34;)
@click.option(&#34;--dsi-port&#34;, &#34;-p&#34;, type=int, default=1,
              help=&#34;the DSI port number to which this client needs to connect &#34;
                   &#34;(not the port on the socket) [type=int]&#34;)
def start(tunnel, zeromq, ssh_user, dsi_address, dsi_port):
    &#34;&#34;&#34;
    Start the FEE Simulator.

    When --tunnel is specified, DSI_ADDRESS will default to 127.0.0.1
    unless explicitly provided.
    &#34;&#34;&#34;
    print(f&#34;{tunnel=}, {zeromq=}, {ssh_user=}, {dsi_address=}, {dsi_port=}&#34;)

    if tunnel:
        user = getpass.getuser()
        password = getpass.getpass(&#34;Enter SSH passphrase: &#34;)

        # This is the IP address of the SSH server.

        server_host = site_settings.SSH_SERVER
        server_port = site_settings.SSH_PORT

        # The IP address of the DSI, i.e. the EtherSpaceLink device from 4Links and
        # the default port as defined in the Settings configuration file.

        remote_host = dsi_settings.DSI_FEE_IP_ADDRESS
        remote_port = dsi_settings.DSI_FEE_PORT

        # The host from which the connection will be established. Usually, this
        # is the &#39;localhost&#39;, but can be specified on the commandline if needed.

        if not dsi_address:
            local_host = &#34;127.0.0.1&#34;
            local_port = 4948  # this number is just an arbitrary choice
            dsi_address = f&#34;{local_host}:{local_port}&#34;
        else:
            local_host, local_port = dsi_address.split(&#34;:&#34;)
            local_port = int(local_port)

        LOGGER.debug(
            f&#34;SSH server: {server_host}:{server_port}, &#34;
            f&#34;DSI: {remote_host}:{remote_port}, &#34;
            f&#34;{local_host=}:{local_port=}, &#34;
            f&#34;{dsi_address=}, {dsi_port=}&#34;
        )

        with sshtunnel.open_tunnel(
            (server_host, server_port),
            ssh_username=user,
            # FIXME: hardcoded info should go into specific user settings or the file should
            #   be searched for in the user&#39;s home directory.
            ssh_private_key=&#34;/Users/rik/.ssh/id_rsa&#34;,
            ssh_private_key_password=password,
            remote_bind_address=(remote_host, remote_port),
            local_bind_address=(local_host, local_port),
        ):
            transport = SpaceWireOverDSI(dsi_address, dsi_port)
            return start_fee_simulator(transport)
    else:
        if zeromq:
            transport = SpaceWireOverZeroMQ(
                f&#34;tcp://{dpu_settings.HOSTNAME}:5555&#34;, &#34;DPU--FEE&#34;)
        else:
            if not dsi_address:
                dsi_address = f&#34;{dsi_settings.DSI_FEE_IP_ADDRESS}:{dsi_settings.DSI_FEE_PORT}&#34;

            transport = SpaceWireOverDSI(dsi_address, dsi_port)

        return start_fee_simulator(transport)


if __name__ == &#34;__main__&#34;:
    sys.exit(cli())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.fee.feesim.goto_on_mode"><code class="name flex">
<span>def <span class="ident">goto_on_mode</span></span>(<span>state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_on_mode(state):
    # N-FEE in ON-mode
    # * Power of the CCDs is disabled
    # * Power of subsystems is disabled
    # * N-FEE is ready for receiving RMAP command
    return states.ST_ON</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.goto_standby_mode"><code class="name flex">
<span>def <span class="ident">goto_standby_mode</span></span>(<span>state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_standby_mode(state):
    # N-FEE in STANDBY-mode
    # * CCDs and subsystems are powered
    # * CCD timing signals are disabled
    # * no image data shall be transferred
    return states.ST_STANDBY</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.goto_windowing_mode"><code class="name flex">
<span>def <span class="ident">goto_windowing_mode</span></span>(<span>state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_windowing_mode(state):
    # N-FEE in WINDOWING-mode
    # * The full CCDs are readout
    # * Only regions of interest (windows) are transmitted
    # * Configuration:
    #   * This configuration needs to be set via RMAP before changing from STANDBY to WINDOWING mode
    #   * Set first and last row to read-out
    #   * Set serial transfers size (column size)
    #   * Set number of overscan lines.
    #   * Enable or disable charge injection
    #   * Set first and last line for charge injection - Set width and gap for charge injection.
    #   * Enable or disable warm-up (= disable data transfer) - Set data-packet size
    #   * Set CCD read-out order (all CCDs)
    #   * Set CCD side E or F- Upload the window-lists
    #   * Set the window-lists pointers
    #   * Set the window-list lengths
    #   * Set the window size
    #   * Set the copy-order list (including list-length for side E and F) -
    #     Set dump-gate high or low
    return states.ST_WINDOWING</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.process_rmap_command"><code class="name flex">
<span>def <span class="ident">process_rmap_command</span></span>(<span>transport:Â <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register:Â <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_rmap_command(transport: SpaceWireInterface, register: RegisterMap):

    _, buffer = transport.read_packet(timeout=200)
    if not buffer:
        return

    # The following check is to cope with loss of connection when either the
    # DPU Processor crashed or the connection dropped for some other reason.
    # We will receive one packet with 0 or 1 bytes.

    if len(buffer) in (0, 1):
        return

    packet = SpaceWirePacket.create_packet(buffer)

    LOGGER.info(f&#34;SpW packet received: {packet}&#34;)

    status = 0  # indicating OK

    if isinstance(packet, ReadRequest):
        data = register.get_data(packet.address, packet.data_length)

        data = create_rmap_read_request_reply_packet(
            packet.instruction, packet.transaction_id, status, data, packet.data_length)

        LOGGER.info(f&#34;Sending a ReadRequestReply: {data[:10]=}&#34;)

        transport.write_packet(data)
        transport.flush()

    elif isinstance(packet, WriteRequest):
        if packet.is_verified():
            LOGGER.info(f&#34;Write data to register map: 0x{packet.address:x} {packet.data}&#34;)
            register.set_data(packet.address, packet.data)
            data = create_rmap_write_request_reply_packet(
                packet.instruction, packet.transaction_id, status
            )

            transport.write_packet(data)
            transport.flush()

        else:
            LOGGER.warning(f&#34;Unverified Write Request not yet implemented!&#34;)</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.start_fee_simulator"><code class="name flex">
<span>def <span class="ident">start_fee_simulator</span></span>(<span>transport:Â <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_fee_simulator(transport: SpaceWireInterface):

    try:
        fee_sim = FEESimulator(transport)
        fee_sim.run()
    except KeyboardInterrupt:
        print(&#34;Shutdown requested...exiting&#34;)
    except SystemExit as exit_code:
        print(&#34;System Exit with code {}.&#34;.format(exit_code))
        return exit_code
    except Exception:
        import traceback

        traceback.print_exc(file=sys.stdout)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.fee.feesim.FEESimulator"><code class="flex name class">
<span>class <span class="ident">FEESimulator</span></span>
<span>(</span><span>transport:Â <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A software simulator for the front-end electronics of the PLATO cameras.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>the SpaceWire transport method, e.g. DSI or ZeroMQ.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FEESimulator:
    &#34;&#34;&#34;
    A software simulator for the front-end electronics of the PLATO cameras.
    &#34;&#34;&#34;

    def __init__(self, transport: SpaceWireInterface):
        &#34;&#34;&#34;
        Args:
            transport: the SpaceWire transport method, e.g. DSI or ZeroMQ.
        &#34;&#34;&#34;
        self._transport: SpaceWireInterface = transport
        self.register_map = RegisterMap(&#34;N-FEE&#34;)
        self._hk_data = HousekeepingData()
        self._hk_header = DataPacketHeader()

        self._IN = NFEEInternals(self.register_map)

        self.initialise_hk_data()
        self.initialise_hk_header()

    def initialise_hk_data(self):
        &#34;&#34;&#34;Initialises the housekeeping data to fake or simulated values.&#34;&#34;&#34;

        try:
            hk_info_table = GlobalState.setup.telemetry.dictionary
        except AttributeError:
            raise SetupError(&#34;Version of the telemetry dictionary not specified in the current setup&#34;)

        storage_mnemonic_col = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
        original_name_col = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values
        selection = np.where(storage_mnemonic_col == ORIGIN)
        original_names = original_name_col[selection]

        self._hk_data[&#34;TOU_SENSE_1&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_2&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_3&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_4&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_5&#34;] = 0x8000
        self._hk_data[&#34;TOU_SENSE_6&#34;] = 0x8000

        self._hk_data[&#34;CCD1_TS&#34;] = 0x7FFF
        self._hk_data[&#34;CCD2_TS&#34;] = 0x7FFF
        self._hk_data[&#34;CCD3_TS&#34;] = 0x7FFF
        self._hk_data[&#34;CCD4_TS&#34;] = 0x7FFF

        self._hk_data[&#34;PRT1&#34;] = 0x7FFF
        self._hk_data[&#34;PRT2&#34;] = 0x7FFF
        self._hk_data[&#34;PRT3&#34;] = 0x7FFF
        self._hk_data[&#34;PRT4&#34;] = 0x7FFF
        self._hk_data[&#34;PRT5&#34;] = 0x7FFF

        self._hk_data[&#34;ZERO_DIFF_AMP&#34;] = 0x8015

        if &#34;CCD1_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD1_VOD_MON&#34;] = 0x8055
        else:
            if &#34;CCD1_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD1_VOD_MON_E&#34;] = 0x8055
            if &#34;CCD1_VOD_MON_F&#34; in original_names:
                self._hk_data[&#34;CCD1_VOD_MON_F&#34;] = 0x8055
        self._hk_data[&#34;CCD1_VOG_MON&#34;] = 0x8056
        self._hk_data[&#34;CCD1_VRD_MON_E&#34;] = 0x8056

        if &#34;CCD2_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD2_VOD_MON&#34;] = 0x8057
        else:
            if &#34;CCD2_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD2_VOD_MON_E&#34;] = 0x8057
            if &#34;CCD2_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD2_VOD_MON_E&#34;] = 0x8057
        self._hk_data[&#34;CCD2_VOG_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD2_VRD_MON_E&#34;] = 0x8057

        if &#34;CCD3_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD3_VOD_MON&#34;] = 0x8058
        else:
            if &#34;CCD3_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD3_VOD_MON_E&#34;] = 0x8058
            if &#34;CCD3_VOD_MON_F&#34; in original_names:
                self._hk_data[&#34;CCD3_VOD_MON_F&#34;] = 0x8058
        self._hk_data[&#34;CCD3_VOG_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD3_VRD_MON_E&#34;] = 0x8058

        if &#34;CCD4_VOD_MON&#34; in original_names:
            self._hk_data[&#34;CCD4_VOD_MON&#34;] = 0x8057
        else:
            if &#34;CCD4_VOD_MON_E&#34; in original_names:
                self._hk_data[&#34;CCD4_VOD_MON_E&#34;] = 0x8057
            if &#34;CCD4_VOD_MON_F&#34; in original_names:
                self._hk_data[&#34;CCD4_VOD_MON_F&#34;] = 0x8057
        self._hk_data[&#34;CCD4_VOG_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD4_VRD_MON_E&#34;] = 0x8058

        self._hk_data[&#34;VCCD&#34;] = 0x39BF
        self._hk_data[&#34;VRCLK_MON&#34;] = 0xFC8A
        self._hk_data[&#34;VICLK&#34;] = 0xFAE9
        if &#34;VRCLK_LOW&#34; in original_names:
            self._hk_data[&#34;VRCLK_LOW&#34;] = 0x821A

        if &#34;5VB_POS_MON&#34; in original_names:
            self._hk_data[&#34;5VB_POS_MON&#34;] = 0x1E6A
        self._hk_data[&#34;5VB_NEG_MON&#34;] = 0x1A9F
        self._hk_data[&#34;3V3B_MON&#34;] = 0xE75D
        self._hk_data[&#34;2V5A_MON&#34;] = 0x1979
        self._hk_data[&#34;3V3D_MON&#34;] = 0xE76E
        self._hk_data[&#34;2V5D_MON&#34;] = 0x1A8C
        self._hk_data[&#34;1V5D_MON&#34;] = 0xDF35
        self._hk_data[&#34;5VREF_MON&#34;] = 0x1A80

        self._hk_data[&#34;VCCD_POS_RAW&#34;] = 0x53BF
        self._hk_data[&#34;VCLK_POS_RAW&#34;] = 0x40BA
        self._hk_data[&#34;VAN1_POS_RAW&#34;] = 0x0744
        self._hk_data[&#34;VAN3_NEG_MON&#34;] = 0xFB7C
        self._hk_data[&#34;VAN2_POS_RAW&#34;] = 0x3AEC
        self._hk_data[&#34;VDIG_RAW&#34;] = 0x0AB5
        if &#34;5VB_POS_MON&#34; in original_names:
            self._hk_data[&#34;VDIG_RAW_2&#34;] = 0x0A32
        if &#34;VICLK_LOW&#34; in original_names:
            self._hk_data[&#34;VICLK_LOW&#34;] = 0x8277

        self._hk_data[&#34;CCD1_VRD_MON_F&#34;] = 0x8059
        self._hk_data[&#34;CCD1_VDD_MON&#34;] = 0x94CA
        self._hk_data[&#34;CCD1_VGD_MON&#34;] = 0x8056
        self._hk_data[&#34;CCD2_VRD_MON_F&#34;] = 0x8058
        self._hk_data[&#34;CCD2_VDD_MON&#34;] = 0x94C1
        self._hk_data[&#34;CCD2_VGD_MON&#34;] = 0x8055
        self._hk_data[&#34;CCD3_VRD_MON_F&#34;] = 0x8059
        self._hk_data[&#34;CCD3_VDD_MON&#34;] = 0x94C1
        self._hk_data[&#34;CCD3_VGD_MON&#34;] = 0x8058
        self._hk_data[&#34;CCD4_VRD_MON_F&#34;] = 0x8058
        self._hk_data[&#34;CCD4_VDD_MON&#34;] = 0x94BA
        self._hk_data[&#34;CCD4_VGD_MON&#34;] = 0x8056

        self._hk_data[&#34;IG_HI_MON&#34;] = 0x8057
        if &#34;IG_LO_MON&#34; in original_names:
            self._hk_data[&#34;IG_LO_MON&#34;] = 0x8059
        self._hk_data[&#34;TSENSE_A&#34;] = 0x8059
        self._hk_data[&#34;TSENSE_B&#34;] = 0x805A

        self._hk_data[&#34;spw_timecode&#34;] = 0x0000
        self._hk_data[&#34;rmap_target_status&#34;] = 0x0000
        self._hk_data[&#34;rmap_target_indicate&#34;] = 0x0000
        self._hk_data[&#34;spw_link_escape_error&#34;] = 0x0000
        self._hk_data[&#34;spw_credit_error&#34;] = 0x0000
        self._hk_data[&#34;spw_parity_error&#34;] = 0x0000
        self._hk_data[&#34;spw_link_disconnect&#34;] = 0x0000
        self._hk_data[&#34;spw_link_running&#34;] = 0x0001

        self._hk_data[&#34;frame_counter&#34;] = 0x0000
        self._hk_data[&#34;op_mode&#34;] = 0x0000
        self._hk_data[&#34;frame_number&#34;] = 0x0000

        self._hk_data[&#34;error_flags&#34;] = 0x0000

        self._hk_data[&#34;FPGA minor version&#34;] = 0x0018
        self._hk_data[&#34;FPGA major version&#34;] = 0x0000
        self._hk_data[&#34;Board ID&#34;] = 0x0000

    def initialise_hk_header(self):
        &#34;&#34;&#34;
        Initialise the header for the HK data packet. Call this method only after the HK data itself
        has been initialised.
        &#34;&#34;&#34;
        self._hk_header.length = self._hk_data.data_length()
        data_packet_type = DataPacketType()
        data_packet_type.packet_type = PacketType.HOUSEKEEPING_DATA
        data_packet_type.last_packet = True
        self._hk_header.type = data_packet_type.value

    def update_hk_header(self, pulse_type: int):
        &#34;&#34;&#34;
        Update the header of the HK data packet.
        &#34;&#34;&#34;
        data_packet_type = DataPacketType(self._hk_header.type)
        data_packet_type.frame_number = self._hk_data.frame_number
        data_packet_type.mode = self._IN.ccd_mode_config
        self._hk_header.type = data_packet_type.value
        self._hk_header.frame_counter = self._hk_data.frame_counter
        if pulse_type == 400:
            self._hk_header.sequence_counter = 0

    def update_hk_data(self):
        pass

    def get_mode(self):
        mode = self._IN.ccd_mode_config
        return n_fee_mode(mode)

    def get_sync_period(self) -&gt; float:
        return self._IN.get_sync_period()

    def get_current_ccd_number(self):
        &#34;&#34;&#34;Return the current CCD number [range=1-4].&#34;&#34;&#34;
        readout_order = self._IN.ccd_readout_order
        # The convert_ccd_order_value function returns CCD number [1-4]
        readout_order = convert_ccd_order_value(readout_order)
        # CCD number in the N-FEE is [0-3]
        return readout_order[self._hk_data.frame_number]

    @property
    def sensor_sel(self) -&gt; int:
        return self._IN.sensor_sel

    @property
    def v_start(self) -&gt; int:
        return self._IN.v_start

    @property
    def v_end(self) -&gt; int:
        return self._IN.v_end

    @property
    def internal_sync(self) -&gt; bool:
        return bool(self._IN.sync_sel)

    def decode_current_state(self) -&gt; str:
        return self.get_mode().name

    def run(self):

        LOGGER.info(f&#34;FEE Simulator Current State: {self.decode_current_state()}&#34;)
        n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum
        sensor_sel_enum = GlobalState.setup.camera.fee.sensor_sel.enum

        with self._transport:

            LOGGER.info(&#34;SpaceWire Transport has been connected.&#34;)

            self._transport.configure()

            LOGGER.info(&#34;SpaceWire Transport has been configured.&#34;)

            LOGGER.info(&#34;Listening for SpaceWire communication...&#34;)

            start_time = time.perf_counter()  # time in fractional seconds

            while True:

                sync_period = self.get_sync_period()

                if time.perf_counter() &lt;= start_time + sync_period:
                    continue

                start_time = time.perf_counter()

                # Send a timecode packet -----------------------------------------------------------

                timecode = self._hk_data.timecode
                LOGGER.info(f&#34;Sending timecode=0x{timecode:02X}&#34;)
                self._transport.send_timecode(timecode)

                # Send a housekeeping packet -------------------------------------------------------

                LOGGER.info(f&#34;Sending HK packet: frame_counter={self._hk_data.frame_counter}, &#34;
                            f&#34;sequence_counter={self._hk_header.sequence_counter}, &#34;
                            f&#34;type={self._hk_header.type_as_object}&#34;)
                LOGGER.info(f&#34;error_flags={self._hk_data[&#39;error_flags&#39;]}&#34;)

                data = self._hk_header.data_as_bytes() + self._hk_data.data_as_bytes()
                packet = SpaceWirePacket.create_packet(data)
                self._transport.write_packet(packet.packet_as_bytes)

                self._transport.flush()

                # Send the Data packets ------------------------------------------------------------

                LOGGER.info(f&#34;mode={self.decode_current_state()}, &#34;
                            f&#34;Sensor={self.sensor_sel}, &#34;
                            f&#34;Digitising={bool(self._IN.digitise_en)}, &#34;
                            f&#34;Internal Sync={self.internal_sync}&#34;)

                # FIXME: N-FEE sends E- and F-side interlaced, in the code code below we always
                #        send E-side first, then F-side.

                if (self._IN.digitise_en and
                    self._IN.ccd_mode_config in (n_fee_mode.FULL_IMAGE_PATTERN_MODE,
                                                 n_fee_mode.FULL_IMAGE_MODE,)):

                    try:
                        ccd_id_to_bin = GlobalState.setup.camera.fee.ccd_numbering.CCD_ID_TO_BIN
                    except AttributeError:
                        raise SetupError(&#34;No entry in the setup for camera.fee.ccd_numbering.CCD_ID_TO_BIN&#34;)

                    ccd_number = ccd_id_to_bin[self.get_current_ccd_number()]  # N-FEE CCD number [0-3]
                    if self.sensor_sel &amp; sensor_sel_enum.E_SIDE:
                        self.send_data_packets(timecode, ccd_id=ccd_number, ccd_side=n_fee_side.E_SIDE)
                    if self.sensor_sel &amp; sensor_sel_enum.F_SIDE:
                        self.send_data_packets(timecode, ccd_id=ccd_number, ccd_side=n_fee_side.F_SIDE)

                # Process any RMAP commands that were sent -----------------------------------------

                LOGGER.info(
                    f&#34;Calling process_rmap_commands() method for &#34;
                    f&#34;{self._transport.__class__.__name__}.&#34;
                )

                while time.perf_counter() &lt; start_time + sync_period - 0.2:
                    process_rmap_command(self._transport, self.register_map)

                self._hk_data.increment_timecode()

                if not self.internal_sync:
                    self._hk_data.increment_frame_number()

                if self._hk_data.frame_number == 0:
                    self._hk_data.increment_frame_counter()
                    self._IN.update(400)
                    self.update_hk_header(400)
                else:
                    self._IN.update(200)
                    self.update_hk_header(200)

                self.update_error_flags()

    def update_error_flags(self):
        &#34;&#34;&#34;Set error_flags to 0b0000_1000_1000 (136) whenever the frame counter is a multiple of 5.&#34;&#34;&#34;
        self._hk_data[&#34;error_flags&#34;] = 0b0000_0000_0000 if self._hk_data.frame_counter % 5 else 0b0000_1000_1000

    def send_data_packets(self, timecode: int, ccd_id: int, ccd_side: int):

            data = create_pattern_data(timecode, ccd_id, ccd_side)

            header = DataPacketHeader()
            packet_type = header.type_as_object
            packet_type.ccd_side = ccd_side
            packet_type.ccd_number = ccd_id
            packet_type.last_packet = False
            packet_type.frame_number = self._hk_data.frame_number
            packet_type.mode = self._IN.ccd_mode_config
            header.type = packet_type

            LOGGER.info(f&#34;**** {packet_type=!s}&#34;)
            LOGGER.info(f&#34;Sending data packets...{self.v_start=} {self.v_end=}&#34;)

            for packet in generate_data_packets(data, header, self.v_start, self.v_end):
                self._transport.write_packet(packet.packet_as_bytes)
                self._transport.flush()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.fee.feesim.FEESimulator.internal_sync"><code class="name">var <span class="ident">internal_sync</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_sync(self) -&gt; bool:
    return bool(self._IN.sync_sel)</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.sensor_sel"><code class="name">var <span class="ident">sensor_sel</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_sel(self) -&gt; int:
    return self._IN.sensor_sel</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.v_end"><code class="name">var <span class="ident">v_end</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_end(self) -&gt; int:
    return self._IN.v_end</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.v_start"><code class="name">var <span class="ident">v_start</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_start(self) -&gt; int:
    return self._IN.v_start</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.feesim.FEESimulator.decode_current_state"><code class="name flex">
<span>def <span class="ident">decode_current_state</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_current_state(self) -&gt; str:
    return self.get_mode().name</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.get_current_ccd_number"><code class="name flex">
<span>def <span class="ident">get_current_ccd_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current CCD number [range=1-4].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_ccd_number(self):
    &#34;&#34;&#34;Return the current CCD number [range=1-4].&#34;&#34;&#34;
    readout_order = self._IN.ccd_readout_order
    # The convert_ccd_order_value function returns CCD number [1-4]
    readout_order = convert_ccd_order_value(readout_order)
    # CCD number in the N-FEE is [0-3]
    return readout_order[self._hk_data.frame_number]</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.get_mode"><code class="name flex">
<span>def <span class="ident">get_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mode(self):
    mode = self._IN.ccd_mode_config
    return n_fee_mode(mode)</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.get_sync_period"><code class="name flex">
<span>def <span class="ident">get_sync_period</span></span>(<span>self) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sync_period(self) -&gt; float:
    return self._IN.get_sync_period()</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.initialise_hk_data"><code class="name flex">
<span>def <span class="ident">initialise_hk_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialises the housekeeping data to fake or simulated values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialise_hk_data(self):
    &#34;&#34;&#34;Initialises the housekeeping data to fake or simulated values.&#34;&#34;&#34;

    try:
        hk_info_table = GlobalState.setup.telemetry.dictionary
    except AttributeError:
        raise SetupError(&#34;Version of the telemetry dictionary not specified in the current setup&#34;)

    storage_mnemonic_col = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    original_name_col = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values
    selection = np.where(storage_mnemonic_col == ORIGIN)
    original_names = original_name_col[selection]

    self._hk_data[&#34;TOU_SENSE_1&#34;] = 0x8000
    self._hk_data[&#34;TOU_SENSE_2&#34;] = 0x8000
    self._hk_data[&#34;TOU_SENSE_3&#34;] = 0x8000
    self._hk_data[&#34;TOU_SENSE_4&#34;] = 0x8000
    self._hk_data[&#34;TOU_SENSE_5&#34;] = 0x8000
    self._hk_data[&#34;TOU_SENSE_6&#34;] = 0x8000

    self._hk_data[&#34;CCD1_TS&#34;] = 0x7FFF
    self._hk_data[&#34;CCD2_TS&#34;] = 0x7FFF
    self._hk_data[&#34;CCD3_TS&#34;] = 0x7FFF
    self._hk_data[&#34;CCD4_TS&#34;] = 0x7FFF

    self._hk_data[&#34;PRT1&#34;] = 0x7FFF
    self._hk_data[&#34;PRT2&#34;] = 0x7FFF
    self._hk_data[&#34;PRT3&#34;] = 0x7FFF
    self._hk_data[&#34;PRT4&#34;] = 0x7FFF
    self._hk_data[&#34;PRT5&#34;] = 0x7FFF

    self._hk_data[&#34;ZERO_DIFF_AMP&#34;] = 0x8015

    if &#34;CCD1_VOD_MON&#34; in original_names:
        self._hk_data[&#34;CCD1_VOD_MON&#34;] = 0x8055
    else:
        if &#34;CCD1_VOD_MON_E&#34; in original_names:
            self._hk_data[&#34;CCD1_VOD_MON_E&#34;] = 0x8055
        if &#34;CCD1_VOD_MON_F&#34; in original_names:
            self._hk_data[&#34;CCD1_VOD_MON_F&#34;] = 0x8055
    self._hk_data[&#34;CCD1_VOG_MON&#34;] = 0x8056
    self._hk_data[&#34;CCD1_VRD_MON_E&#34;] = 0x8056

    if &#34;CCD2_VOD_MON&#34; in original_names:
        self._hk_data[&#34;CCD2_VOD_MON&#34;] = 0x8057
    else:
        if &#34;CCD2_VOD_MON_E&#34; in original_names:
            self._hk_data[&#34;CCD2_VOD_MON_E&#34;] = 0x8057
        if &#34;CCD2_VOD_MON_E&#34; in original_names:
            self._hk_data[&#34;CCD2_VOD_MON_E&#34;] = 0x8057
    self._hk_data[&#34;CCD2_VOG_MON&#34;] = 0x8058
    self._hk_data[&#34;CCD2_VRD_MON_E&#34;] = 0x8057

    if &#34;CCD3_VOD_MON&#34; in original_names:
        self._hk_data[&#34;CCD3_VOD_MON&#34;] = 0x8058
    else:
        if &#34;CCD3_VOD_MON_E&#34; in original_names:
            self._hk_data[&#34;CCD3_VOD_MON_E&#34;] = 0x8058
        if &#34;CCD3_VOD_MON_F&#34; in original_names:
            self._hk_data[&#34;CCD3_VOD_MON_F&#34;] = 0x8058
    self._hk_data[&#34;CCD3_VOG_MON&#34;] = 0x8058
    self._hk_data[&#34;CCD3_VRD_MON_E&#34;] = 0x8058

    if &#34;CCD4_VOD_MON&#34; in original_names:
        self._hk_data[&#34;CCD4_VOD_MON&#34;] = 0x8057
    else:
        if &#34;CCD4_VOD_MON_E&#34; in original_names:
            self._hk_data[&#34;CCD4_VOD_MON_E&#34;] = 0x8057
        if &#34;CCD4_VOD_MON_F&#34; in original_names:
            self._hk_data[&#34;CCD4_VOD_MON_F&#34;] = 0x8057
    self._hk_data[&#34;CCD4_VOG_MON&#34;] = 0x8058
    self._hk_data[&#34;CCD4_VRD_MON_E&#34;] = 0x8058

    self._hk_data[&#34;VCCD&#34;] = 0x39BF
    self._hk_data[&#34;VRCLK_MON&#34;] = 0xFC8A
    self._hk_data[&#34;VICLK&#34;] = 0xFAE9
    if &#34;VRCLK_LOW&#34; in original_names:
        self._hk_data[&#34;VRCLK_LOW&#34;] = 0x821A

    if &#34;5VB_POS_MON&#34; in original_names:
        self._hk_data[&#34;5VB_POS_MON&#34;] = 0x1E6A
    self._hk_data[&#34;5VB_NEG_MON&#34;] = 0x1A9F
    self._hk_data[&#34;3V3B_MON&#34;] = 0xE75D
    self._hk_data[&#34;2V5A_MON&#34;] = 0x1979
    self._hk_data[&#34;3V3D_MON&#34;] = 0xE76E
    self._hk_data[&#34;2V5D_MON&#34;] = 0x1A8C
    self._hk_data[&#34;1V5D_MON&#34;] = 0xDF35
    self._hk_data[&#34;5VREF_MON&#34;] = 0x1A80

    self._hk_data[&#34;VCCD_POS_RAW&#34;] = 0x53BF
    self._hk_data[&#34;VCLK_POS_RAW&#34;] = 0x40BA
    self._hk_data[&#34;VAN1_POS_RAW&#34;] = 0x0744
    self._hk_data[&#34;VAN3_NEG_MON&#34;] = 0xFB7C
    self._hk_data[&#34;VAN2_POS_RAW&#34;] = 0x3AEC
    self._hk_data[&#34;VDIG_RAW&#34;] = 0x0AB5
    if &#34;5VB_POS_MON&#34; in original_names:
        self._hk_data[&#34;VDIG_RAW_2&#34;] = 0x0A32
    if &#34;VICLK_LOW&#34; in original_names:
        self._hk_data[&#34;VICLK_LOW&#34;] = 0x8277

    self._hk_data[&#34;CCD1_VRD_MON_F&#34;] = 0x8059
    self._hk_data[&#34;CCD1_VDD_MON&#34;] = 0x94CA
    self._hk_data[&#34;CCD1_VGD_MON&#34;] = 0x8056
    self._hk_data[&#34;CCD2_VRD_MON_F&#34;] = 0x8058
    self._hk_data[&#34;CCD2_VDD_MON&#34;] = 0x94C1
    self._hk_data[&#34;CCD2_VGD_MON&#34;] = 0x8055
    self._hk_data[&#34;CCD3_VRD_MON_F&#34;] = 0x8059
    self._hk_data[&#34;CCD3_VDD_MON&#34;] = 0x94C1
    self._hk_data[&#34;CCD3_VGD_MON&#34;] = 0x8058
    self._hk_data[&#34;CCD4_VRD_MON_F&#34;] = 0x8058
    self._hk_data[&#34;CCD4_VDD_MON&#34;] = 0x94BA
    self._hk_data[&#34;CCD4_VGD_MON&#34;] = 0x8056

    self._hk_data[&#34;IG_HI_MON&#34;] = 0x8057
    if &#34;IG_LO_MON&#34; in original_names:
        self._hk_data[&#34;IG_LO_MON&#34;] = 0x8059
    self._hk_data[&#34;TSENSE_A&#34;] = 0x8059
    self._hk_data[&#34;TSENSE_B&#34;] = 0x805A

    self._hk_data[&#34;spw_timecode&#34;] = 0x0000
    self._hk_data[&#34;rmap_target_status&#34;] = 0x0000
    self._hk_data[&#34;rmap_target_indicate&#34;] = 0x0000
    self._hk_data[&#34;spw_link_escape_error&#34;] = 0x0000
    self._hk_data[&#34;spw_credit_error&#34;] = 0x0000
    self._hk_data[&#34;spw_parity_error&#34;] = 0x0000
    self._hk_data[&#34;spw_link_disconnect&#34;] = 0x0000
    self._hk_data[&#34;spw_link_running&#34;] = 0x0001

    self._hk_data[&#34;frame_counter&#34;] = 0x0000
    self._hk_data[&#34;op_mode&#34;] = 0x0000
    self._hk_data[&#34;frame_number&#34;] = 0x0000

    self._hk_data[&#34;error_flags&#34;] = 0x0000

    self._hk_data[&#34;FPGA minor version&#34;] = 0x0018
    self._hk_data[&#34;FPGA major version&#34;] = 0x0000
    self._hk_data[&#34;Board ID&#34;] = 0x0000</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.initialise_hk_header"><code class="name flex">
<span>def <span class="ident">initialise_hk_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the header for the HK data packet. Call this method only after the HK data itself
has been initialised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialise_hk_header(self):
    &#34;&#34;&#34;
    Initialise the header for the HK data packet. Call this method only after the HK data itself
    has been initialised.
    &#34;&#34;&#34;
    self._hk_header.length = self._hk_data.data_length()
    data_packet_type = DataPacketType()
    data_packet_type.packet_type = PacketType.HOUSEKEEPING_DATA
    data_packet_type.last_packet = True
    self._hk_header.type = data_packet_type.value</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):

    LOGGER.info(f&#34;FEE Simulator Current State: {self.decode_current_state()}&#34;)
    n_fee_side = GlobalState.setup.camera.fee.ccd_sides.enum
    sensor_sel_enum = GlobalState.setup.camera.fee.sensor_sel.enum

    with self._transport:

        LOGGER.info(&#34;SpaceWire Transport has been connected.&#34;)

        self._transport.configure()

        LOGGER.info(&#34;SpaceWire Transport has been configured.&#34;)

        LOGGER.info(&#34;Listening for SpaceWire communication...&#34;)

        start_time = time.perf_counter()  # time in fractional seconds

        while True:

            sync_period = self.get_sync_period()

            if time.perf_counter() &lt;= start_time + sync_period:
                continue

            start_time = time.perf_counter()

            # Send a timecode packet -----------------------------------------------------------

            timecode = self._hk_data.timecode
            LOGGER.info(f&#34;Sending timecode=0x{timecode:02X}&#34;)
            self._transport.send_timecode(timecode)

            # Send a housekeeping packet -------------------------------------------------------

            LOGGER.info(f&#34;Sending HK packet: frame_counter={self._hk_data.frame_counter}, &#34;
                        f&#34;sequence_counter={self._hk_header.sequence_counter}, &#34;
                        f&#34;type={self._hk_header.type_as_object}&#34;)
            LOGGER.info(f&#34;error_flags={self._hk_data[&#39;error_flags&#39;]}&#34;)

            data = self._hk_header.data_as_bytes() + self._hk_data.data_as_bytes()
            packet = SpaceWirePacket.create_packet(data)
            self._transport.write_packet(packet.packet_as_bytes)

            self._transport.flush()

            # Send the Data packets ------------------------------------------------------------

            LOGGER.info(f&#34;mode={self.decode_current_state()}, &#34;
                        f&#34;Sensor={self.sensor_sel}, &#34;
                        f&#34;Digitising={bool(self._IN.digitise_en)}, &#34;
                        f&#34;Internal Sync={self.internal_sync}&#34;)

            # FIXME: N-FEE sends E- and F-side interlaced, in the code code below we always
            #        send E-side first, then F-side.

            if (self._IN.digitise_en and
                self._IN.ccd_mode_config in (n_fee_mode.FULL_IMAGE_PATTERN_MODE,
                                             n_fee_mode.FULL_IMAGE_MODE,)):

                try:
                    ccd_id_to_bin = GlobalState.setup.camera.fee.ccd_numbering.CCD_ID_TO_BIN
                except AttributeError:
                    raise SetupError(&#34;No entry in the setup for camera.fee.ccd_numbering.CCD_ID_TO_BIN&#34;)

                ccd_number = ccd_id_to_bin[self.get_current_ccd_number()]  # N-FEE CCD number [0-3]
                if self.sensor_sel &amp; sensor_sel_enum.E_SIDE:
                    self.send_data_packets(timecode, ccd_id=ccd_number, ccd_side=n_fee_side.E_SIDE)
                if self.sensor_sel &amp; sensor_sel_enum.F_SIDE:
                    self.send_data_packets(timecode, ccd_id=ccd_number, ccd_side=n_fee_side.F_SIDE)

            # Process any RMAP commands that were sent -----------------------------------------

            LOGGER.info(
                f&#34;Calling process_rmap_commands() method for &#34;
                f&#34;{self._transport.__class__.__name__}.&#34;
            )

            while time.perf_counter() &lt; start_time + sync_period - 0.2:
                process_rmap_command(self._transport, self.register_map)

            self._hk_data.increment_timecode()

            if not self.internal_sync:
                self._hk_data.increment_frame_number()

            if self._hk_data.frame_number == 0:
                self._hk_data.increment_frame_counter()
                self._IN.update(400)
                self.update_hk_header(400)
            else:
                self._IN.update(200)
                self.update_hk_header(200)

            self.update_error_flags()</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.send_data_packets"><code class="name flex">
<span>def <span class="ident">send_data_packets</span></span>(<span>self, timecode:Â int, ccd_id:Â int, ccd_side:Â int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_data_packets(self, timecode: int, ccd_id: int, ccd_side: int):

        data = create_pattern_data(timecode, ccd_id, ccd_side)

        header = DataPacketHeader()
        packet_type = header.type_as_object
        packet_type.ccd_side = ccd_side
        packet_type.ccd_number = ccd_id
        packet_type.last_packet = False
        packet_type.frame_number = self._hk_data.frame_number
        packet_type.mode = self._IN.ccd_mode_config
        header.type = packet_type

        LOGGER.info(f&#34;**** {packet_type=!s}&#34;)
        LOGGER.info(f&#34;Sending data packets...{self.v_start=} {self.v_end=}&#34;)

        for packet in generate_data_packets(data, header, self.v_start, self.v_end):
            self._transport.write_packet(packet.packet_as_bytes)
            self._transport.flush()</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.update_error_flags"><code class="name flex">
<span>def <span class="ident">update_error_flags</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set error_flags to 0b0000_1000_1000 (136) whenever the frame counter is a multiple of 5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_error_flags(self):
    &#34;&#34;&#34;Set error_flags to 0b0000_1000_1000 (136) whenever the frame counter is a multiple of 5.&#34;&#34;&#34;
    self._hk_data[&#34;error_flags&#34;] = 0b0000_0000_0000 if self._hk_data.frame_counter % 5 else 0b0000_1000_1000</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.update_hk_data"><code class="name flex">
<span>def <span class="ident">update_hk_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hk_data(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.FEESimulator.update_hk_header"><code class="name flex">
<span>def <span class="ident">update_hk_header</span></span>(<span>self, pulse_type:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the header of the HK data packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hk_header(self, pulse_type: int):
    &#34;&#34;&#34;
    Update the header of the HK data packet.
    &#34;&#34;&#34;
    data_packet_type = DataPacketType(self._hk_header.type)
    data_packet_type.frame_number = self._hk_data.frame_number
    data_packet_type.mode = self._IN.ccd_mode_config
    self._hk_header.type = data_packet_type.value
    self._hk_header.frame_counter = self._hk_data.frame_counter
    if pulse_type == 400:
        self._hk_header.sequence_counter = 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.feesim.NFEEInternals"><code class="flex name class">
<span>class <span class="ident">NFEEInternals</span></span>
<span>(</span><span>reg_map:Â <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The N-FEE Internals class represents the actual state of the N-FEE. A bit like the FPGA status
in the N-FEE hardware. The difference with the RegisterMap is that the register map is updated
on RMAP write requests, while this class is updated on sync pulses (from the content of the
register map). Therefore, the N-FEE Internals represent the actual state, while the register
map represents the commanded state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NFEEInternals:
    &#34;&#34;&#34;
    The N-FEE Internals class represents the actual state of the N-FEE. A bit like the FPGA status
    in the N-FEE hardware. The difference with the RegisterMap is that the register map is updated
    on RMAP write requests, while this class is updated on sync pulses (from the content of the
    register map). Therefore, the N-FEE Internals represent the actual state, while the register
    map represents the commanded state.
    &#34;&#34;&#34;
    def __init__(self, reg_map: RegisterMap):
        self.reg_map = reg_map
        self.ccd_mode_config = self.reg_map[&#34;ccd_mode_config&#34;]
        self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
        self.ccd_read_en = self.reg_map[&#34;ccd_read_en&#34;]
        self.v_start = self.reg_map[&#34;v_start&#34;]
        self.v_end = self.reg_map[&#34;v_end&#34;]
        self.digitise_en = self.reg_map[&#34;digitise_en&#34;]
        self.sync_sel = self.reg_map[&#34;sync_sel&#34;]
        self.int_sync_period = self.reg_map[&#34;int_sync_period&#34;]
        self.ccd_readout_order = self.reg_map[&#34;ccd_readout_order&#34;]
        LOGGER.info(f&#34;Initialised {self.v_start=}, {self.v_end=}&#34;)

    def update(self, pulse_type: int):
        &#34;&#34;&#34;
        Update the internal state from the register. Depending on the pulse_type, specific state
        variables are updated from the current register map values.

        Args:
            pulse_type (int): a 200 or 400 ms pulse
        &#34;&#34;&#34;
        if pulse_type == 200:
            self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
            self.ccd_read_en = self.reg_map[&#39;ccd_read_en&#39;]
        if pulse_type == 400:
            self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
            self.ccd_read_en = self.reg_map[&#39;ccd_read_en&#39;]
            self.ccd_mode_config = self.reg_map[&#34;ccd_mode_config&#34;]
            self.v_start = self.reg_map[&#34;v_start&#34;]
            self.v_end = self.reg_map[&#34;v_end&#34;]
            self.digitise_en = self.reg_map[&#34;digitise_en&#34;]
            self.sync_sel = self.reg_map[&#34;sync_sel&#34;]
            self.int_sync_period = self.reg_map[&#34;int_sync_period&#34;]
            self.ccd_readout_order = self.reg_map[&#34;ccd_readout_order&#34;]
            LOGGER.info(f&#34;Updated {self.v_start=}, {self.v_end=}, {self.ccd_mode_config=}&#34;)

    def get_sync_period(self) -&gt; float:
        &#34;&#34;&#34;
        Calculate and return the period between two successive sync pulses.

        Note:
            Please note that this value is calculated from what is known in the register map. The
            external sync period is however dependent from the sync signal received from the AEU,
            and the AEU might have been configured for extended sync periods.

        Returns:
            The sync period (time between two sync pulses) in seconds.
        &#34;&#34;&#34;
        sync_sel = self.reg_map.get_value(&#34;reg_5_config&#34;, &#34;sync_sel&#34;)
        if sync_sel:
            sync_period = self.reg_map.get_value(&#34;reg_4_config&#34;, &#34;int_sync_period&#34;)
        else:
            sync_period = 6250
        return sync_period / 1000

    def get_readout_order(self) -&gt; List:
        &#34;&#34;&#34;Returns the ccd readout order as a list of CCD numbers, e.g. [1, 2, 3, 4].&#34;&#34;&#34;
        return convert_ccd_order_value(self.ccd_readout_order)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.feesim.NFEEInternals.get_readout_order"><code class="name flex">
<span>def <span class="ident">get_readout_order</span></span>(<span>self) â€‘>Â List[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ccd readout order as a list of CCD numbers, e.g. [1, 2, 3, 4].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_readout_order(self) -&gt; List:
    &#34;&#34;&#34;Returns the ccd readout order as a list of CCD numbers, e.g. [1, 2, 3, 4].&#34;&#34;&#34;
    return convert_ccd_order_value(self.ccd_readout_order)</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.NFEEInternals.get_sync_period"><code class="name flex">
<span>def <span class="ident">get_sync_period</span></span>(<span>self) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate and return the period between two successive sync pulses.</p>
<h2 id="note">Note</h2>
<p>Please note that this value is calculated from what is known in the register map. The
external sync period is however dependent from the sync signal received from the AEU,
and the AEU might have been configured for extended sync periods.</p>
<h2 id="returns">Returns</h2>
<p>The sync period (time between two sync pulses) in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sync_period(self) -&gt; float:
    &#34;&#34;&#34;
    Calculate and return the period between two successive sync pulses.

    Note:
        Please note that this value is calculated from what is known in the register map. The
        external sync period is however dependent from the sync signal received from the AEU,
        and the AEU might have been configured for extended sync periods.

    Returns:
        The sync period (time between two sync pulses) in seconds.
    &#34;&#34;&#34;
    sync_sel = self.reg_map.get_value(&#34;reg_5_config&#34;, &#34;sync_sel&#34;)
    if sync_sel:
        sync_period = self.reg_map.get_value(&#34;reg_4_config&#34;, &#34;int_sync_period&#34;)
    else:
        sync_period = 6250
    return sync_period / 1000</code></pre>
</details>
</dd>
<dt id="egse.fee.feesim.NFEEInternals.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, pulse_type:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the internal state from the register. Depending on the pulse_type, specific state
variables are updated from the current register map values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pulse_type</code></strong> :&ensp;<code>int</code></dt>
<dd>a 200 or 400 ms pulse</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, pulse_type: int):
    &#34;&#34;&#34;
    Update the internal state from the register. Depending on the pulse_type, specific state
    variables are updated from the current register map values.

    Args:
        pulse_type (int): a 200 or 400 ms pulse
    &#34;&#34;&#34;
    if pulse_type == 200:
        self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
        self.ccd_read_en = self.reg_map[&#39;ccd_read_en&#39;]
    if pulse_type == 400:
        self.sensor_sel = self.reg_map[&#34;sensor_sel&#34;]
        self.ccd_read_en = self.reg_map[&#39;ccd_read_en&#39;]
        self.ccd_mode_config = self.reg_map[&#34;ccd_mode_config&#34;]
        self.v_start = self.reg_map[&#34;v_start&#34;]
        self.v_end = self.reg_map[&#34;v_end&#34;]
        self.digitise_en = self.reg_map[&#34;digitise_en&#34;]
        self.sync_sel = self.reg_map[&#34;sync_sel&#34;]
        self.int_sync_period = self.reg_map[&#34;int_sync_period&#34;]
        self.ccd_readout_order = self.reg_map[&#34;ccd_readout_order&#34;]
        LOGGER.info(f&#34;Updated {self.v_start=}, {self.v_end=}, {self.ccd_mode_config=}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.feesim.States"><code class="flex name class">
<span>class <span class="ident">States</span></span>
<span>(</span><span>ST_OFF:Â int, ST_ON:Â int, ST_FULL_IMAGE_PATTERN:Â int, ST_WINDOWING_PATTERN:Â int, ST_STANDBY:Â int, ST_FULL_IMAGE:Â int, ST_WINDOWING:Â int, ST_PERFORMANCE_TEST:Â int, ST_PARALLEL_TRAP_PUMPING_1:Â int, ST_PARALLEL_TRAP_PUMPING_2:Â int, ST_SERIAL_TRAP_PUMPING_1:Â int, ST_SERIAL_TRAP_PUMPING_2:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>States(ST_OFF, ST_ON, ST_FULL_IMAGE_PATTERN, ST_WINDOWING_PATTERN, ST_STANDBY, ST_FULL_IMAGE, ST_WINDOWING, ST_PERFORMANCE_TEST, ST_PARALLEL_TRAP_PUMPING_1, ST_PARALLEL_TRAP_PUMPING_2, ST_SERIAL_TRAP_PUMPING_1, ST_SERIAL_TRAP_PUMPING_2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class States(NamedTuple):
    ST_OFF: int
    ST_ON: int
    ST_FULL_IMAGE_PATTERN: int
    ST_WINDOWING_PATTERN: int
    ST_STANDBY: int
    ST_FULL_IMAGE: int
    ST_WINDOWING: int
    ST_PERFORMANCE_TEST: int
    ST_PARALLEL_TRAP_PUMPING_1: int
    ST_PARALLEL_TRAP_PUMPING_2: int
    ST_SERIAL_TRAP_PUMPING_1: int
    ST_SERIAL_TRAP_PUMPING_2: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="egse.fee.feesim.States.ST_FULL_IMAGE"><code class="name">var <span class="ident">ST_FULL_IMAGE</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_FULL_IMAGE_PATTERN"><code class="name">var <span class="ident">ST_FULL_IMAGE_PATTERN</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_OFF"><code class="name">var <span class="ident">ST_OFF</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_ON"><code class="name">var <span class="ident">ST_ON</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_PARALLEL_TRAP_PUMPING_1"><code class="name">var <span class="ident">ST_PARALLEL_TRAP_PUMPING_1</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 8</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_PARALLEL_TRAP_PUMPING_2"><code class="name">var <span class="ident">ST_PARALLEL_TRAP_PUMPING_2</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 9</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_PERFORMANCE_TEST"><code class="name">var <span class="ident">ST_PERFORMANCE_TEST</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 7</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_SERIAL_TRAP_PUMPING_1"><code class="name">var <span class="ident">ST_SERIAL_TRAP_PUMPING_1</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 10</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_SERIAL_TRAP_PUMPING_2"><code class="name">var <span class="ident">ST_SERIAL_TRAP_PUMPING_2</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 11</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_STANDBY"><code class="name">var <span class="ident">ST_STANDBY</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_WINDOWING"><code class="name">var <span class="ident">ST_WINDOWING</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 6</p></div>
</dd>
<dt id="egse.fee.feesim.States.ST_WINDOWING_PATTERN"><code class="name">var <span class="ident">ST_WINDOWING_PATTERN</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.fee" href="index.html">egse.fee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.fee.feesim.goto_on_mode" href="#egse.fee.feesim.goto_on_mode">goto_on_mode</a></code></li>
<li><code><a title="egse.fee.feesim.goto_standby_mode" href="#egse.fee.feesim.goto_standby_mode">goto_standby_mode</a></code></li>
<li><code><a title="egse.fee.feesim.goto_windowing_mode" href="#egse.fee.feesim.goto_windowing_mode">goto_windowing_mode</a></code></li>
<li><code><a title="egse.fee.feesim.process_rmap_command" href="#egse.fee.feesim.process_rmap_command">process_rmap_command</a></code></li>
<li><code><a title="egse.fee.feesim.start_fee_simulator" href="#egse.fee.feesim.start_fee_simulator">start_fee_simulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.fee.feesim.FEESimulator" href="#egse.fee.feesim.FEESimulator">FEESimulator</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.feesim.FEESimulator.decode_current_state" href="#egse.fee.feesim.FEESimulator.decode_current_state">decode_current_state</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.get_current_ccd_number" href="#egse.fee.feesim.FEESimulator.get_current_ccd_number">get_current_ccd_number</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.get_mode" href="#egse.fee.feesim.FEESimulator.get_mode">get_mode</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.get_sync_period" href="#egse.fee.feesim.FEESimulator.get_sync_period">get_sync_period</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.initialise_hk_data" href="#egse.fee.feesim.FEESimulator.initialise_hk_data">initialise_hk_data</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.initialise_hk_header" href="#egse.fee.feesim.FEESimulator.initialise_hk_header">initialise_hk_header</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.internal_sync" href="#egse.fee.feesim.FEESimulator.internal_sync">internal_sync</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.run" href="#egse.fee.feesim.FEESimulator.run">run</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.send_data_packets" href="#egse.fee.feesim.FEESimulator.send_data_packets">send_data_packets</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.sensor_sel" href="#egse.fee.feesim.FEESimulator.sensor_sel">sensor_sel</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.update_error_flags" href="#egse.fee.feesim.FEESimulator.update_error_flags">update_error_flags</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.update_hk_data" href="#egse.fee.feesim.FEESimulator.update_hk_data">update_hk_data</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.update_hk_header" href="#egse.fee.feesim.FEESimulator.update_hk_header">update_hk_header</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.v_end" href="#egse.fee.feesim.FEESimulator.v_end">v_end</a></code></li>
<li><code><a title="egse.fee.feesim.FEESimulator.v_start" href="#egse.fee.feesim.FEESimulator.v_start">v_start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.feesim.NFEEInternals" href="#egse.fee.feesim.NFEEInternals">NFEEInternals</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.feesim.NFEEInternals.get_readout_order" href="#egse.fee.feesim.NFEEInternals.get_readout_order">get_readout_order</a></code></li>
<li><code><a title="egse.fee.feesim.NFEEInternals.get_sync_period" href="#egse.fee.feesim.NFEEInternals.get_sync_period">get_sync_period</a></code></li>
<li><code><a title="egse.fee.feesim.NFEEInternals.update" href="#egse.fee.feesim.NFEEInternals.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.feesim.States" href="#egse.fee.feesim.States">States</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.feesim.States.ST_FULL_IMAGE" href="#egse.fee.feesim.States.ST_FULL_IMAGE">ST_FULL_IMAGE</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_FULL_IMAGE_PATTERN" href="#egse.fee.feesim.States.ST_FULL_IMAGE_PATTERN">ST_FULL_IMAGE_PATTERN</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_OFF" href="#egse.fee.feesim.States.ST_OFF">ST_OFF</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_ON" href="#egse.fee.feesim.States.ST_ON">ST_ON</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_PARALLEL_TRAP_PUMPING_1" href="#egse.fee.feesim.States.ST_PARALLEL_TRAP_PUMPING_1">ST_PARALLEL_TRAP_PUMPING_1</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_PARALLEL_TRAP_PUMPING_2" href="#egse.fee.feesim.States.ST_PARALLEL_TRAP_PUMPING_2">ST_PARALLEL_TRAP_PUMPING_2</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_PERFORMANCE_TEST" href="#egse.fee.feesim.States.ST_PERFORMANCE_TEST">ST_PERFORMANCE_TEST</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_SERIAL_TRAP_PUMPING_1" href="#egse.fee.feesim.States.ST_SERIAL_TRAP_PUMPING_1">ST_SERIAL_TRAP_PUMPING_1</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_SERIAL_TRAP_PUMPING_2" href="#egse.fee.feesim.States.ST_SERIAL_TRAP_PUMPING_2">ST_SERIAL_TRAP_PUMPING_2</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_STANDBY" href="#egse.fee.feesim.States.ST_STANDBY">ST_STANDBY</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_WINDOWING" href="#egse.fee.feesim.States.ST_WINDOWING">ST_WINDOWING</a></code></li>
<li><code><a title="egse.fee.feesim.States.ST_WINDOWING_PATTERN" href="#egse.fee.feesim.States.ST_WINDOWING_PATTERN">ST_WINDOWING_PATTERN</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
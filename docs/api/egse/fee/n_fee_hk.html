<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.fee.n_fee_hk API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.fee.n_fee_hk</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import multiprocessing
import os
import pickle
import signal
from typing import List

import click
import invoke
import numpy as np
import pandas
import rich
import sys
import time
import zmq
from PyQt5 import QtCore
from PyQt5.QtCore import QObject
from PyQt5.QtCore import QRunnable
from PyQt5.QtCore import QThreadPool
from PyQt5.QtCore import QTimer
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtGui import QCloseEvent
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QMessageBox
from prometheus_client import start_http_server

import egse.logger
from egse.fee.nfee import HousekeepingData
from egse.hk import TmDictionaryColumns
from egse.hk import convert_hk_names
from egse.hk import read_conversion_dict
from egse.metrics import define_metrics
from egse.resource import get_resource
from egse.settings import Settings
from egse.setup import NavigableDict, SetupError
from egse.state import GlobalState
from egse.storage import StorageProxy
from egse.storage import register_to_storage_manager
from egse.storage import unregister_from_storage_manager
from egse.storage.persistence import CSV
from egse.synoptics import SynopticsManagerProxy
from egse.system import get_host_ip
from egse.zmq import MessageIdentifier
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

LOGGER = logging.getLogger(__name__)

DPU_SETTINGS = Settings.load(&#34;DPU Processor&#34;)
CTRL_SETTINGS = Settings.load(&#34;N-FEE HK Control Server&#34;)

APP_NAME = &#34;n_fee_hk&#34;
ORIGIN = &#34;N-FEE-HK&#34;
TIMEOUT = 1  # timeout for polling the data distribution from the DPU CS

HK_TIMESTAMP_NAME = &#34;timestamp&#34;

# These are the names (with the correct prefix) of the calibrated N-FEE HK.  The name of the
# corresponding raw/uncalibrated N-FEE HK is obtained by appending &#34;_RAW&#34; to these names. Each
# array represents N-FEE sensors that need to be calibrated the same way.

TOU_SENSOR_NAMES = [
    &#34;NFEE_TOU_TRP5&#34;, &#34;NFEE_TOU_TRP6&#34;, &#34;NFEE_TOU_TRP8&#34;, &#34;NFEE_TOU_TRP21&#34;, &#34;NFEE_TOU_TRP31&#34;,
    &#34;NFEE_TOU_TRP41&#34;]
CCD_SENSOR_NAMES = [
    &#34;NFEE_T_CCD1&#34;, &#34;NFEE_T_CCD2&#34;, &#34;NFEE_T_CCD3&#34;, &#34;NFEE_T_CCD4&#34;]
BOARD_SENSOR_NAMES_PT1000 = [
    &#34;NFEE_T_PCB1&#34;, &#34;NFEE_T_PCB2&#34;, &#34;NFEE_T_ADC&#34;, &#34;NFEE_T_CDS&#34;,&#34;NFEE_T_ANALOG&#34;]
BOARD_SENSOR_NAMES_ISL71590 = [
    &#34;NFEE_T_PCB3&#34;, &#34;NFEE_T_PCB4&#34;]


class GeneratorSignals(QObject):
    finished = pyqtSignal()


class WorkerSignals(QObject):
    &#34;&#34;&#34;
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        &#39;str&#39; Exception string

    data
        &#39;object&#39; data returned from processing

    &#34;&#34;&#34;

    finished = pyqtSignal()
    error = pyqtSignal(str)
    data = pyqtSignal(int, object)


class DataPuller(QRunnable):
    def __init__(self, hostname: str, port: int, timeout: int = TIMEOUT):
        super().__init__()
        self.signals = WorkerSignals()
        self.hostname = hostname
        self.port = port
        self.quit_request = False
        self.timeout = timeout

        context = zmq.Context.instance()

        self.receiver = context.socket(zmq.SUB)
        self.receiver.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        self.commander = context.socket(zmq.REP)

    @pyqtSlot()
    def run(self):
        ip_address = get_host_ip()
        receiver_endpoint = f&#34;tcp://{self.hostname}:{self.port}&#34;
        commander_endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
        self.receiver.connect(receiver_endpoint)
        self.commander.bind(commander_endpoint)

        poller = zmq.Poller()
        poller.register(self.receiver, zmq.POLLIN)
        poller.register(self.commander, zmq.POLLIN)

        while True:

            socket_list = dict(poller.poll(timeout=self.timeout))

            if self.quit_request:
                LOGGER.info(&#39;DataPuller quit requested.&#39;)
                break

            if self.receiver in socket_list:
                try:
                    sync_id, pickle_string = self.receiver.recv_multipart()
                    sync_id = int.from_bytes(sync_id, byteorder=&#39;big&#39;)
                    data = pickle.loads(pickle_string)
                    self.signals.data.emit(sync_id, data)
                except Exception as exc:
                    LOGGER.error(&#34;Exception caught!&#34;, exc_info=True)
                    self.signals.error.emit(str(exc))

            if self.commander in socket_list:
                pickle_string = self.commander.recv()
                command = pickle.loads(pickle_string)
                if command.lower() == &#34;quit&#34;:
                    self.commander.send(pickle.dumps(&#34;ACK&#34;))
                    LOGGER.info(&#39;DataPuller quit requested...&#39;)
                    break
                if command.lower() == &#34;status&#34;:
                    LOGGER.info(&#39;DataPuller status requested...&#39;)
                    response = dict(
                        status=&#34;ACK&#34;,
                        host=ip_address,
                        listening_port=self.port,
                        command_port=CTRL_SETTINGS.COMMANDING_PORT,
                    )
                    self.commander.send(pickle.dumps(response))

        LOGGER.info(&#34;Cleaning up ZeroMQ sockets...&#34;)

        poller.unregister(self.commander)
        poller.unregister(self.receiver)

        self.receiver.disconnect(f&#34;tcp://{self.hostname}:{self.port}&#34;)
        self.receiver.close(linger=0)
        self.commander.close(linger=0)

        self.signals.finished.emit()

    def quit(self):
        self.quit_request = True


class DataCollector:
    def __init__(self, keys: List):
        self._keys = keys

        # initialise the data dictionary

        self._data = {k: None for k in self._keys}

    def __getitem__(self, item):
        return self._data[item]

    def get(self, item):
        try:
            return self._data[item]
        except KeyError:
            return None

    def keys(self):
        return self._keys

    def values(self):
        return [self._data[name] for name in self._keys]

    def update(self, data: dict):
        if x := set(data) - set(self._data):
            LOGGER.warning(
                f&#34;New housekeeping found which was not previously in the N-FEE HK packet: {x}&#34;
            )
        self._data.update(data)

    def clear(self):
        self._data = {k: None for k in self._keys}


class MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.hk_generator = HousekeepingGenerator()

        column_names = self.hk_generator.current_data.keys()
        register_to_storage_manager(ORIGIN, CSV, prep=dict(mode=&#39;a&#39;, column_names=column_names))

        self.hk_generator.signals.finished.connect(self.close)
        self.hk_generator.run()

        LOGGER.info(&#34;Initialised MainWindow&#34;)

    def closeEvent(self, event: QCloseEvent) -&gt; None:
        LOGGER.info(f&#34;closeEvent called...{event=}&#34;)

        if self.hk_generator.data_puller:
            self.hk_generator.data_puller.quit()
        else:
            LOGGER.info(&#34;Data Puller was already terminated.&#34;)

        time.sleep(TIMEOUT)
        unregister_from_storage_manager(ORIGIN)
        LOGGER.info(&#34;AFTER UNREGISTER STORAGE&#34;)


def read_hk_info() -&gt; (dict, dict):
    &#34;&#34;&#34; Read the table with the HK information, i.e. the TM dictionary.

    Returns:
        - Dictionary relating the original HK names with the ones starting with the correct prefix (NFEE_)
        - Dictionary relating the HK names (with the correct prefix) with the slope a and offset b for the
          calibration of the supply voltages
    &#34;&#34;&#34;

    filename = get_resource(f&#34;:/data/tm-dictionary.csv&#34;)
    hk_info_table = pandas.read_csv(filename, sep=&#34;;&#34;)

    storage_mnemonic = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    hk_names = hk_info_table[TmDictionaryColumns.CORRECT_HK_NAMES].values
    original_names = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values
    nfee_cal_offset_b = hk_info_table[TmDictionaryColumns.CAL_OFFSET_B].values
    nfee_cal_slope_a = hk_info_table[TmDictionaryColumns.CAL_SLOPE_A].values

    # Name conversion

    nfee_selection = np.where(storage_mnemonic == &#34;N-FEE-HK&#34;)
    original_names = original_names[nfee_selection]
    new_names = hk_names[nfee_selection]

    # Supply voltage calibration

    nfee_selection = np.where(np.logical_and(storage_mnemonic == &#34;N-FEE-HK&#34;, np.isfinite(nfee_cal_offset_b)))

    nfee_supply_voltage_names = hk_names[nfee_selection]
    nfee_cal_offset_b = nfee_cal_offset_b[nfee_selection]
    nfee_cal_slope_a = nfee_cal_slope_a[nfee_selection]

    name_conversion = dict(zip(original_names, new_names))
    nfee_supply_voltage_cal = dict(zip(nfee_supply_voltage_names, list(zip(nfee_cal_slope_a, nfee_cal_offset_b))))

    return name_conversion, nfee_supply_voltage_cal


class HousekeepingGenerator:

    def __init__(self):

        self.signals = GeneratorSignals()

        # Convert with info from HK info table
        # Append the new names

        self.data_puller = None
        self.threadpool = QThreadPool()

        # Read from the HK info file:
        #   - name of the HK parameters with the raw values for the N-FEE supply voltages
        #   - value of the offset (b) for the calibration
        #   - values of the slope (a) for the calibration

        self.name_conversion, self.nfee_supply_voltage_cal = read_hk_info()
        hk_header = self.name_conversion.values()

        # Read from the setup: sensor calibration data (as a NavigableDict)

        self.sensor_calibration = self.read_temp_calibration()

        self.current_data = DataCollector(
            [HK_TIMESTAMP_NAME, *hk_header]
        )

        # The hk_names_mapping is a dictionary that maps the original device telemetry parameter
        # names to the correct device names as defined in the CGSE. The keys in the mapping are
        # the original device name, the values are the CGSE corrected names.

        self.hk_names_mapping = read_conversion_dict(ORIGIN, use_site=False)
        self.hk_metrics = define_metrics(ORIGIN, dashboard=&#39;*&#39;)

    def read_temp_calibration(self) -&gt; NavigableDict:
        &#34;&#34;&#34; Read the temperature calibration from the designated file.

        Returns: N-FEE temperature calibration as a NavigableDict.
        &#34;&#34;&#34;

        return GlobalState.setup.camera.fee.calibration

    def run(self):
        self.start_pulling_data()

    def start_pulling_data(self):
        self.data_puller = worker = DataPuller(
            DPU_SETTINGS.HOSTNAME, DPU_SETTINGS.DATA_DISTRIBUTION_PORT
        )
        worker.signals.data.connect(self.worker_output)
        worker.signals.finished.connect(self.worker_complete)
        worker.signals.error.connect(self.worker_error)
        self.threadpool.start(worker)

    def update_metrics(self):

        for metric_name in self.hk_names_mapping.values():
            # LOGGER.info(f&#34;{metric_name=}&#34;)
            value = self.current_data.get(metric_name)
            if value is not None:
                self.hk_metrics[metric_name].set(value)
            else:
                self.hk_metrics[metric_name].set(float(&#39;nan&#39;))
                LOGGER.log(logging.DEBUG, f&#34;No current data available for {metric_name}.&#34;)

    def send_hk_data_to_storage(self):

        if not any(self.current_data.values()):
            return

        # Translate the HK names (i.e. start using the correct prefix)
        # and append them to the rest of the HK

        self.current_data = convert_hk_names(dict(zip(self.current_data.keys(), self.current_data.values())),
                                             self.name_conversion)
        # Calibration (supply voltages + temperatures)

        calibrated_supply_voltages = get_calibrated_nfee_supply_voltages(self.current_data, self.nfee_supply_voltage_cal)
        self.current_data.update(calibrated_supply_voltages)
        calibrated_temperatures = get_calibrated_temperatures(self.current_data, self.sensor_calibration)
        self.current_data.update(calibrated_temperatures)

        with StorageProxy() as storage:

            rc = storage.save(
                {
                    &#34;origin&#34;: ORIGIN,
                    &#34;data&#34;: self.current_data
                }
            )
        if rc and not rc.successful:
            LOGGER.warning(f&#34;Couldn&#39;t save HK data to the Storage manager: {rc}&#34;)

        # Store the calibrated temperatures as synoptics
        # (only when there&#39;s actually something there in the N-FEE HK)

        if len(calibrated_temperatures) &gt; 0:

            calibrated_temperatures[&#34;timestamp&#34;] = self.current_data[HK_TIMESTAMP_NAME]

            with SynopticsManagerProxy() as synoptics:
                synoptics.store_common_synoptics(calibrated_temperatures)

    def worker_output(self, sync_id, data):

        if sync_id == MessageIdentifier.SYNC_TIMECODE:
            self.send_hk_data_to_storage()
            self.update_metrics()
            self.current_data.clear()
            timecode, timestamp = data
            LOGGER.info(f&#34;Timecode: {timecode}&#34;)

            self.current_data.update({&#34;timecode&#34;: timecode, &#34;timecode_ts&#34;: timestamp})

        if sync_id == MessageIdentifier.SYNC_HK_PACKET:
            hk_packet, timestamp = data
            LOGGER.info(f&#34;HK Packet: {hk_packet.type=!s}&#34;)

            self.current_data.update({HK_TIMESTAMP_NAME: timestamp})

            hk_data = HousekeepingData(hk_packet.data)

            for par_name in hk_data:
                self.current_data.update({par_name: hk_data[par_name]})

        if sync_id == MessageIdentifier.NUM_CYCLES:
            LOGGER.info(f&#34;num_cycles: {max(0, data)}&#34;)
            self.current_data.update({&#39;num_cycles&#39;: max(0, data)})

    def worker_complete(self):
        LOGGER.info(&#34;THREAD COMPLETE!&#34;)
        LOGGER.info(f&#34;Number of threads running: {self.threadpool.activeThreadCount()}&#34;)
        self.data_puller = None
        self.signals.finished.emit()

    def worker_error(self, t):
        LOGGER.warning(&#34;ERROR: %s&#34; % t)


def get_calibrated_nfee_supply_voltages(current_data, nfee_supply_voltage_cal):
    &#34;&#34;&#34; Calibrate the N-FEE supply voltages.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consist of applying a linear function to the raw values.

    Returns: Dictionary with calibrated supply voltages [V].
    &#34;&#34;&#34;

    supply_voltages = {}

    for hk_name, (nfee_cal_slope_a, nfee_cal_offset_b) in nfee_supply_voltage_cal.items():

        if current_data[hk_name] is not None:

            supply_voltage = nfee_cal_slope_a * current_data[hk_name] + nfee_cal_offset_b

            supply_voltages[hk_name[:-4]] = supply_voltage

    return supply_voltages


def get_calibrated_temperatures(current_data, sensor_calibration):
    &#34;&#34;&#34; Calibrate the N-FEE temperatures.

    The calibrated temperatures come from:

        - TOU TRP PT1000 sensors
        - CCD PT100 sensors
        - PT1000 board sensors
        - ISL71590 board sensors

    The difference in naming between calibrated and uncalibrated temperatures is the suffix &#34;_RAW&#34;.

    Returns: Dictionary with calibrated temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # TOU TRP PT1000 sensors

    tou_temperatures = get_calibrated_tou_temperatures(current_data, sensor_calibration)
    temperatures.update(tou_temperatures)

    # CCD PT100 sensors

    ccd_temperatures = get_calibrated_ccd_temperatures(current_data, sensor_calibration)
    temperatures.update(ccd_temperatures)

    # Board sensors

    board_temperatures = get_calibrated_board_temperatures(current_data, sensor_calibration)
    temperatures.update(board_temperatures)

    return temperatures


def get_calibrated_tou_temperatures(current_data, sensor_calibration) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE TOU temperatures.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consists of the following steps:

        - apply factor to convert counts to voltage
        - apply factor to convert voltage to resistance
        - apply Von Dusen equation to convert resistance to temperature

    Returns: Dictionary with calibrated TOU temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # TOU TRP PT1000 sensors

    cal = sensor_calibration[&#34;TOU TRP PT1000&#34;]

    for cal_name in TOU_SENSOR_NAMES:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                resistance = current_data[hk_name] * float(cal.counts_to_voltage) * cal.voltage_to_resistance
                temperature = np.polyval(cal.von_dusen_coefficients, resistance)
            except AttributeError as exc:
                raise SetupError(&#34;Not all TOU TRP PT1000 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures


def get_calibrated_ccd_temperatures(current_data, sensor_calibration) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE CCD temperatures.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consists of the following steps:

        - apply factor to convert counts to voltage
        - apply factor to convert voltage to resistance
        - apply Von Dusen equation to convert resistance to temperature

    Returns: Dictionary with calibrated CCD temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # CCD PT100 sensors

    cal = sensor_calibration[&#34;CCD PT100&#34;]

    for cal_name in CCD_SENSOR_NAMES:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                resistance = current_data[hk_name] * cal.counts_to_voltage * cal.voltage_to_resistance \
                             - cal.series_resistance[int(cal_name[-1])]
                temperature = np.polyval(cal.von_dusen_coefficients, resistance)
            except AttributeError as exc:
                raise SetupError(&#34;Not all CCD PT100 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures

    try:
        cal.series_res
    except AttributeError as exc:
        print(exc)


def get_calibrated_board_temperatures(current_data, sensor_calibration) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE board sensor temperatures.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    For the PT1000 board sensors, the calibration consists of the following steps:

        - apply factor to convert counts to voltage
        - apply factor to convert voltage to resistance
        - apply Von Dusen equation to convert resistance to temperature

    For the ISL71590 board sensors, the calibration consist of applying a linear function to the raw values.

    Returns: Dictionary with calibrated board sensor temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # PT1000 board sensors

    cal = sensor_calibration[&#34;BOARD PT1000&#34;]

    for cal_name in BOARD_SENSOR_NAMES_PT1000:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                resistance = current_data[hk_name] * cal.counts_to_voltage * cal.voltage_to_resistance
                temperature = np.polyval(cal.von_dusen_coefficients, resistance)
            except AttributeError as exc:
                raise SetupError(&#34;Not all BOARD PT1000 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    # ISL71590 board sensors

    cal = sensor_calibration[&#34;BOARD ISL71590&#34;]

    for cal_name in BOARD_SENSOR_NAMES_ISL71590:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                temperature = cal.slope * current_data[hk_name] + cal.offset
            except AttributeError as exc:
                raise SetupError(&#34;Not all BOARD ISL71590 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures


@click.group()
def cli():
    pass


@cli.command()
@click.option(&#34;--gui/--no-gui&#34;, default=False,
              help=&#34;start the N-FEE HK Process with graphics support [default=--no-gui].&#34;)
def start_bg(gui):
    &#34;&#34;&#34;Start the N-FEE HK Processor in the background.&#34;&#34;&#34;

    options = &#34;--gui&#34; if gui else &#34;--no-gui&#34;
    invoke.run(f&#34;n_fee_hk start {options}&#34;, disown=True)


@cli.command()
@click.option(&#34;--gui/--no-gui&#34;, default=False,
              help=&#34;start the N-FEE HK Process with graphics support [default=--no-gui].&#34;)
def start(gui):
    &#34;&#34;&#34;Start the N-FEE HK Processor.&#34;&#34;&#34;

    multiprocessing.current_process().name = &#34;n_fee_hk&#34;

    start_http_server(CTRL_SETTINGS.METRICS_PORT)

    args = sys.argv
    if not gui:
        args.extend([&#34;-platform&#34;, &#34;offscreen&#34;])

    LOGGER.info(f&#34;{args=}&#34;)

    app = QApplication(args)

    os.environ[&#34;QT_ENABLE_HIGHDPI_SCALING&#34;] = &#34;1&#34;
    QApplication.setHighDpiScaleFactorRoundingPolicy(
        QtCore.Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )
    window = MainWindow()
    window.show()

    def sigint_handler(*args):
        &#34;&#34;&#34;Handler for the SIGINT signal.&#34;&#34;&#34;
        LOGGER.info(f&#39;Handling signal SIGINT...&#39;)
        if QApplication.platformName() == &#34;offscreen&#34;:
            window.close()
            QApplication.quit()
        elif QMessageBox.question(
                None, &#39;&#39;, &#34;Are you sure you want to quit?&#34;,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
        ) == QMessageBox.Yes:
            window.close()
            QApplication.quit()

    signal.signal(signal.SIGINT, sigint_handler)

    # The following code is solely here to have the app react faster to CTRL-C in the terminal

    timer = QTimer()
    timer.start(500)  # interval in msec
    timer.timeout.connect(lambda: None)  # Let the interpreter run each 500 ms.

    try:
        rc = app.exec_()
    except KeyboardInterrupt:
        LOGGER.info(f&#34;Keyboard interrupt accepted, terminating application {APP_NAME}&#34;)

    LOGGER.info(&#34;Destroying ZeroMQ context...&#34;)

    egse.logger.close_all_zmq_handlers()

    context = zmq.Context.instance()
    context.destroy(linger=0)


@cli.command()
def stop():
    &#34;&#34;&#34;Stop the N-FEE HK Control Server.&#34;&#34;&#34;

    response = send_request(&#34;quit&#34;)
    if response == &#34;ACK&#34;:
        rich.print(&#34;Logger successfully terminated.&#34;)
    else:
        rich.print(f&#34;[red] ERROR: {response}&#34;)


@cli.command()
def status():
    &#34;&#34;&#34;Roll over the log file of the Logger Control Server.&#34;&#34;&#34;

    rich.print(&#34;N-FEE HK Generator:&#34;)

    response = send_request(&#34;status&#34;)
    if response.get(&#34;status&#34;) == &#34;ACK&#34;:
        rich.print(&#34;  Status: [green]active&#34;)
        rich.print(f&#34;  Hostname: {response.get(&#39;host&#39;)}&#34;)
        rich.print(f&#34;  Listening port: {response.get(&#39;listening_port&#39;)}&#34;)
        rich.print(f&#34;  Commanding port: {response.get(&#39;command_port&#39;)}&#34;)
    else:
        rich.print(&#34;  Status: [red]not active&#34;)


TIMEOUT_RECV = 1.0  # seconds


def send_request(command_request: str):
    &#34;&#34;&#34;Sends a request to the Logger Control Server and waits for a response.&#34;&#34;&#34;
    ctx = zmq.Context.instance()
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket = ctx.socket(zmq.REQ)
    socket.connect(endpoint)

    socket.send(pickle.dumps(command_request))
    rlist, _, _ = zmq.select([socket], [], [], timeout=TIMEOUT_RECV)
    if socket in rlist:
        response = socket.recv()
        response = pickle.loads(response)
    else:
        response = {&#34;error&#34;: &#34;Received from ZeroMQ socket timed out for N-FEE HK Control Server.&#34;}
    socket.close(linger=0)

    return response


if __name__ == &#39;__main__&#39;:
    sys.exit(cli())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.fee.n_fee_hk.get_calibrated_board_temperatures"><code class="name flex">
<span>def <span class="ident">get_calibrated_board_temperatures</span></span>(<span>current_data, sensor_calibration) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE board sensor temperatures.</p>
<p>The difference in naming between calibrated and uncalibrated housekeeping is the suffix "_RAW".</p>
<p>For the PT1000 board sensors, the calibration consists of the following steps:</p>
<pre><code>- apply factor to convert counts to voltage
- apply factor to convert voltage to resistance
- apply Von Dusen equation to convert resistance to temperature
</code></pre>
<p>For the ISL71590 board sensors, the calibration consist of applying a linear function to the raw values.</p>
<p>Returns: Dictionary with calibrated board sensor temperatures [°C].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_board_temperatures(current_data, sensor_calibration) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE board sensor temperatures.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    For the PT1000 board sensors, the calibration consists of the following steps:

        - apply factor to convert counts to voltage
        - apply factor to convert voltage to resistance
        - apply Von Dusen equation to convert resistance to temperature

    For the ISL71590 board sensors, the calibration consist of applying a linear function to the raw values.

    Returns: Dictionary with calibrated board sensor temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # PT1000 board sensors

    cal = sensor_calibration[&#34;BOARD PT1000&#34;]

    for cal_name in BOARD_SENSOR_NAMES_PT1000:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                resistance = current_data[hk_name] * cal.counts_to_voltage * cal.voltage_to_resistance
                temperature = np.polyval(cal.von_dusen_coefficients, resistance)
            except AttributeError as exc:
                raise SetupError(&#34;Not all BOARD PT1000 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    # ISL71590 board sensors

    cal = sensor_calibration[&#34;BOARD ISL71590&#34;]

    for cal_name in BOARD_SENSOR_NAMES_ISL71590:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                temperature = cal.slope * current_data[hk_name] + cal.offset
            except AttributeError as exc:
                raise SetupError(&#34;Not all BOARD ISL71590 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_ccd_temperatures"><code class="name flex">
<span>def <span class="ident">get_calibrated_ccd_temperatures</span></span>(<span>current_data, sensor_calibration) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE CCD temperatures.</p>
<p>The difference in naming between calibrated and uncalibrated housekeeping is the suffix "_RAW".</p>
<p>The calibration consists of the following steps:</p>
<pre><code>- apply factor to convert counts to voltage
- apply factor to convert voltage to resistance
- apply Von Dusen equation to convert resistance to temperature
</code></pre>
<p>Returns: Dictionary with calibrated CCD temperatures [°C].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_ccd_temperatures(current_data, sensor_calibration) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE CCD temperatures.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consists of the following steps:

        - apply factor to convert counts to voltage
        - apply factor to convert voltage to resistance
        - apply Von Dusen equation to convert resistance to temperature

    Returns: Dictionary with calibrated CCD temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # CCD PT100 sensors

    cal = sensor_calibration[&#34;CCD PT100&#34;]

    for cal_name in CCD_SENSOR_NAMES:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                resistance = current_data[hk_name] * cal.counts_to_voltage * cal.voltage_to_resistance \
                             - cal.series_resistance[int(cal_name[-1])]
                temperature = np.polyval(cal.von_dusen_coefficients, resistance)
            except AttributeError as exc:
                raise SetupError(&#34;Not all CCD PT100 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures

    try:
        cal.series_res
    except AttributeError as exc:
        print(exc)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_nfee_supply_voltages"><code class="name flex">
<span>def <span class="ident">get_calibrated_nfee_supply_voltages</span></span>(<span>current_data, nfee_supply_voltage_cal)</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE supply voltages.</p>
<p>The difference in naming between calibrated and uncalibrated housekeeping is the suffix "_RAW".</p>
<p>The calibration consist of applying a linear function to the raw values.</p>
<p>Returns: Dictionary with calibrated supply voltages [V].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_nfee_supply_voltages(current_data, nfee_supply_voltage_cal):
    &#34;&#34;&#34; Calibrate the N-FEE supply voltages.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consist of applying a linear function to the raw values.

    Returns: Dictionary with calibrated supply voltages [V].
    &#34;&#34;&#34;

    supply_voltages = {}

    for hk_name, (nfee_cal_slope_a, nfee_cal_offset_b) in nfee_supply_voltage_cal.items():

        if current_data[hk_name] is not None:

            supply_voltage = nfee_cal_slope_a * current_data[hk_name] + nfee_cal_offset_b

            supply_voltages[hk_name[:-4]] = supply_voltage

    return supply_voltages</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_temperatures"><code class="name flex">
<span>def <span class="ident">get_calibrated_temperatures</span></span>(<span>current_data, sensor_calibration)</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE temperatures.</p>
<p>The calibrated temperatures come from:</p>
<pre><code>- TOU TRP PT1000 sensors
- CCD PT100 sensors
- PT1000 board sensors
- ISL71590 board sensors
</code></pre>
<p>The difference in naming between calibrated and uncalibrated temperatures is the suffix "_RAW".</p>
<p>Returns: Dictionary with calibrated temperatures [°C].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_temperatures(current_data, sensor_calibration):
    &#34;&#34;&#34; Calibrate the N-FEE temperatures.

    The calibrated temperatures come from:

        - TOU TRP PT1000 sensors
        - CCD PT100 sensors
        - PT1000 board sensors
        - ISL71590 board sensors

    The difference in naming between calibrated and uncalibrated temperatures is the suffix &#34;_RAW&#34;.

    Returns: Dictionary with calibrated temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # TOU TRP PT1000 sensors

    tou_temperatures = get_calibrated_tou_temperatures(current_data, sensor_calibration)
    temperatures.update(tou_temperatures)

    # CCD PT100 sensors

    ccd_temperatures = get_calibrated_ccd_temperatures(current_data, sensor_calibration)
    temperatures.update(ccd_temperatures)

    # Board sensors

    board_temperatures = get_calibrated_board_temperatures(current_data, sensor_calibration)
    temperatures.update(board_temperatures)

    return temperatures</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_tou_temperatures"><code class="name flex">
<span>def <span class="ident">get_calibrated_tou_temperatures</span></span>(<span>current_data, sensor_calibration) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE TOU temperatures.</p>
<p>The difference in naming between calibrated and uncalibrated housekeeping is the suffix "_RAW".</p>
<p>The calibration consists of the following steps:</p>
<pre><code>- apply factor to convert counts to voltage
- apply factor to convert voltage to resistance
- apply Von Dusen equation to convert resistance to temperature
</code></pre>
<p>Returns: Dictionary with calibrated TOU temperatures [°C].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_tou_temperatures(current_data, sensor_calibration) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE TOU temperatures.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consists of the following steps:

        - apply factor to convert counts to voltage
        - apply factor to convert voltage to resistance
        - apply Von Dusen equation to convert resistance to temperature

    Returns: Dictionary with calibrated TOU temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    # TOU TRP PT1000 sensors

    cal = sensor_calibration[&#34;TOU TRP PT1000&#34;]

    for cal_name in TOU_SENSOR_NAMES:

        hk_name = cal_name + &#34;_RAW&#34;

        if current_data[hk_name] is not None:
            try:
                resistance = current_data[hk_name] * float(cal.counts_to_voltage) * cal.voltage_to_resistance
                temperature = np.polyval(cal.von_dusen_coefficients, resistance)
            except AttributeError as exc:
                raise SetupError(&#34;Not all TOU TRP PT1000 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.read_hk_info"><code class="name flex">
<span>def <span class="ident">read_hk_info</span></span>(<span>) ‑> (<class 'dict'>, <class 'dict'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the table with the HK information, i.e. the TM dictionary.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Dictionary relating the original HK names with the ones starting with the correct prefix (NFEE_)</li>
<li>Dictionary relating the HK names (with the correct prefix) with the slope a and offset b for the
calibration of the supply voltages</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_hk_info() -&gt; (dict, dict):
    &#34;&#34;&#34; Read the table with the HK information, i.e. the TM dictionary.

    Returns:
        - Dictionary relating the original HK names with the ones starting with the correct prefix (NFEE_)
        - Dictionary relating the HK names (with the correct prefix) with the slope a and offset b for the
          calibration of the supply voltages
    &#34;&#34;&#34;

    filename = get_resource(f&#34;:/data/tm-dictionary.csv&#34;)
    hk_info_table = pandas.read_csv(filename, sep=&#34;;&#34;)

    storage_mnemonic = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    hk_names = hk_info_table[TmDictionaryColumns.CORRECT_HK_NAMES].values
    original_names = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values
    nfee_cal_offset_b = hk_info_table[TmDictionaryColumns.CAL_OFFSET_B].values
    nfee_cal_slope_a = hk_info_table[TmDictionaryColumns.CAL_SLOPE_A].values

    # Name conversion

    nfee_selection = np.where(storage_mnemonic == &#34;N-FEE-HK&#34;)
    original_names = original_names[nfee_selection]
    new_names = hk_names[nfee_selection]

    # Supply voltage calibration

    nfee_selection = np.where(np.logical_and(storage_mnemonic == &#34;N-FEE-HK&#34;, np.isfinite(nfee_cal_offset_b)))

    nfee_supply_voltage_names = hk_names[nfee_selection]
    nfee_cal_offset_b = nfee_cal_offset_b[nfee_selection]
    nfee_cal_slope_a = nfee_cal_slope_a[nfee_selection]

    name_conversion = dict(zip(original_names, new_names))
    nfee_supply_voltage_cal = dict(zip(nfee_supply_voltage_names, list(zip(nfee_cal_slope_a, nfee_cal_offset_b))))

    return name_conversion, nfee_supply_voltage_cal</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.send_request"><code class="name flex">
<span>def <span class="ident">send_request</span></span>(<span>command_request: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a request to the Logger Control Server and waits for a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request(command_request: str):
    &#34;&#34;&#34;Sends a request to the Logger Control Server and waits for a response.&#34;&#34;&#34;
    ctx = zmq.Context.instance()
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket = ctx.socket(zmq.REQ)
    socket.connect(endpoint)

    socket.send(pickle.dumps(command_request))
    rlist, _, _ = zmq.select([socket], [], [], timeout=TIMEOUT_RECV)
    if socket in rlist:
        response = socket.recv()
        response = pickle.loads(response)
    else:
        response = {&#34;error&#34;: &#34;Received from ZeroMQ socket timed out for N-FEE HK Control Server.&#34;}
    socket.close(linger=0)

    return response</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.fee.n_fee_hk.DataCollector"><code class="flex name class">
<span>class <span class="ident">DataCollector</span></span>
<span>(</span><span>keys: List[~T])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataCollector:
    def __init__(self, keys: List):
        self._keys = keys

        # initialise the data dictionary

        self._data = {k: None for k in self._keys}

    def __getitem__(self, item):
        return self._data[item]

    def get(self, item):
        try:
            return self._data[item]
        except KeyError:
            return None

    def keys(self):
        return self._keys

    def values(self):
        return [self._data[name] for name in self._keys]

    def update(self, data: dict):
        if x := set(data) - set(self._data):
            LOGGER.warning(
                f&#34;New housekeeping found which was not previously in the N-FEE HK packet: {x}&#34;
            )
        self._data.update(data)

    def clear(self):
        self._data = {k: None for k in self._keys}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.DataCollector.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self._data = {k: None for k in self._keys}</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, item):
    try:
        return self._data[item]
    except KeyError:
        return None</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self._keys</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, data: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, data: dict):
    if x := set(data) - set(self._data):
        LOGGER.warning(
            f&#34;New housekeeping found which was not previously in the N-FEE HK packet: {x}&#34;
        )
    self._data.update(data)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    return [self._data[name] for name in self._keys]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.DataPuller"><code class="flex name class">
<span>class <span class="ident">DataPuller</span></span>
<span>(</span><span>hostname: str, port: int, timeout: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>QRunnable()
QRunnable(QRunnable)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataPuller(QRunnable):
    def __init__(self, hostname: str, port: int, timeout: int = TIMEOUT):
        super().__init__()
        self.signals = WorkerSignals()
        self.hostname = hostname
        self.port = port
        self.quit_request = False
        self.timeout = timeout

        context = zmq.Context.instance()

        self.receiver = context.socket(zmq.SUB)
        self.receiver.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        self.commander = context.socket(zmq.REP)

    @pyqtSlot()
    def run(self):
        ip_address = get_host_ip()
        receiver_endpoint = f&#34;tcp://{self.hostname}:{self.port}&#34;
        commander_endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
        self.receiver.connect(receiver_endpoint)
        self.commander.bind(commander_endpoint)

        poller = zmq.Poller()
        poller.register(self.receiver, zmq.POLLIN)
        poller.register(self.commander, zmq.POLLIN)

        while True:

            socket_list = dict(poller.poll(timeout=self.timeout))

            if self.quit_request:
                LOGGER.info(&#39;DataPuller quit requested.&#39;)
                break

            if self.receiver in socket_list:
                try:
                    sync_id, pickle_string = self.receiver.recv_multipart()
                    sync_id = int.from_bytes(sync_id, byteorder=&#39;big&#39;)
                    data = pickle.loads(pickle_string)
                    self.signals.data.emit(sync_id, data)
                except Exception as exc:
                    LOGGER.error(&#34;Exception caught!&#34;, exc_info=True)
                    self.signals.error.emit(str(exc))

            if self.commander in socket_list:
                pickle_string = self.commander.recv()
                command = pickle.loads(pickle_string)
                if command.lower() == &#34;quit&#34;:
                    self.commander.send(pickle.dumps(&#34;ACK&#34;))
                    LOGGER.info(&#39;DataPuller quit requested...&#39;)
                    break
                if command.lower() == &#34;status&#34;:
                    LOGGER.info(&#39;DataPuller status requested...&#39;)
                    response = dict(
                        status=&#34;ACK&#34;,
                        host=ip_address,
                        listening_port=self.port,
                        command_port=CTRL_SETTINGS.COMMANDING_PORT,
                    )
                    self.commander.send(pickle.dumps(response))

        LOGGER.info(&#34;Cleaning up ZeroMQ sockets...&#34;)

        poller.unregister(self.commander)
        poller.unregister(self.receiver)

        self.receiver.disconnect(f&#34;tcp://{self.hostname}:{self.port}&#34;)
        self.receiver.close(linger=0)
        self.commander.close(linger=0)

        self.signals.finished.emit()

    def quit(self):
        self.quit_request = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QRunnable</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.DataPuller.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    self.quit_request = True</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataPuller.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>run(self)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    ip_address = get_host_ip()
    receiver_endpoint = f&#34;tcp://{self.hostname}:{self.port}&#34;
    commander_endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
    self.receiver.connect(receiver_endpoint)
    self.commander.bind(commander_endpoint)

    poller = zmq.Poller()
    poller.register(self.receiver, zmq.POLLIN)
    poller.register(self.commander, zmq.POLLIN)

    while True:

        socket_list = dict(poller.poll(timeout=self.timeout))

        if self.quit_request:
            LOGGER.info(&#39;DataPuller quit requested.&#39;)
            break

        if self.receiver in socket_list:
            try:
                sync_id, pickle_string = self.receiver.recv_multipart()
                sync_id = int.from_bytes(sync_id, byteorder=&#39;big&#39;)
                data = pickle.loads(pickle_string)
                self.signals.data.emit(sync_id, data)
            except Exception as exc:
                LOGGER.error(&#34;Exception caught!&#34;, exc_info=True)
                self.signals.error.emit(str(exc))

        if self.commander in socket_list:
            pickle_string = self.commander.recv()
            command = pickle.loads(pickle_string)
            if command.lower() == &#34;quit&#34;:
                self.commander.send(pickle.dumps(&#34;ACK&#34;))
                LOGGER.info(&#39;DataPuller quit requested...&#39;)
                break
            if command.lower() == &#34;status&#34;:
                LOGGER.info(&#39;DataPuller status requested...&#39;)
                response = dict(
                    status=&#34;ACK&#34;,
                    host=ip_address,
                    listening_port=self.port,
                    command_port=CTRL_SETTINGS.COMMANDING_PORT,
                )
                self.commander.send(pickle.dumps(response))

    LOGGER.info(&#34;Cleaning up ZeroMQ sockets...&#34;)

    poller.unregister(self.commander)
    poller.unregister(self.receiver)

    self.receiver.disconnect(f&#34;tcp://{self.hostname}:{self.port}&#34;)
    self.receiver.close(linger=0)
    self.commander.close(linger=0)

    self.signals.finished.emit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.GeneratorSignals"><code class="flex name class">
<span>class <span class="ident">GeneratorSignals</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneratorSignals(QObject):
    finished = pyqtSignal()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.GeneratorSignals.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator"><code class="flex name class">
<span>class <span class="ident">HousekeepingGenerator</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HousekeepingGenerator:

    def __init__(self):

        self.signals = GeneratorSignals()

        # Convert with info from HK info table
        # Append the new names

        self.data_puller = None
        self.threadpool = QThreadPool()

        # Read from the HK info file:
        #   - name of the HK parameters with the raw values for the N-FEE supply voltages
        #   - value of the offset (b) for the calibration
        #   - values of the slope (a) for the calibration

        self.name_conversion, self.nfee_supply_voltage_cal = read_hk_info()
        hk_header = self.name_conversion.values()

        # Read from the setup: sensor calibration data (as a NavigableDict)

        self.sensor_calibration = self.read_temp_calibration()

        self.current_data = DataCollector(
            [HK_TIMESTAMP_NAME, *hk_header]
        )

        # The hk_names_mapping is a dictionary that maps the original device telemetry parameter
        # names to the correct device names as defined in the CGSE. The keys in the mapping are
        # the original device name, the values are the CGSE corrected names.

        self.hk_names_mapping = read_conversion_dict(ORIGIN, use_site=False)
        self.hk_metrics = define_metrics(ORIGIN, dashboard=&#39;*&#39;)

    def read_temp_calibration(self) -&gt; NavigableDict:
        &#34;&#34;&#34; Read the temperature calibration from the designated file.

        Returns: N-FEE temperature calibration as a NavigableDict.
        &#34;&#34;&#34;

        return GlobalState.setup.camera.fee.calibration

    def run(self):
        self.start_pulling_data()

    def start_pulling_data(self):
        self.data_puller = worker = DataPuller(
            DPU_SETTINGS.HOSTNAME, DPU_SETTINGS.DATA_DISTRIBUTION_PORT
        )
        worker.signals.data.connect(self.worker_output)
        worker.signals.finished.connect(self.worker_complete)
        worker.signals.error.connect(self.worker_error)
        self.threadpool.start(worker)

    def update_metrics(self):

        for metric_name in self.hk_names_mapping.values():
            # LOGGER.info(f&#34;{metric_name=}&#34;)
            value = self.current_data.get(metric_name)
            if value is not None:
                self.hk_metrics[metric_name].set(value)
            else:
                self.hk_metrics[metric_name].set(float(&#39;nan&#39;))
                LOGGER.log(logging.DEBUG, f&#34;No current data available for {metric_name}.&#34;)

    def send_hk_data_to_storage(self):

        if not any(self.current_data.values()):
            return

        # Translate the HK names (i.e. start using the correct prefix)
        # and append them to the rest of the HK

        self.current_data = convert_hk_names(dict(zip(self.current_data.keys(), self.current_data.values())),
                                             self.name_conversion)
        # Calibration (supply voltages + temperatures)

        calibrated_supply_voltages = get_calibrated_nfee_supply_voltages(self.current_data, self.nfee_supply_voltage_cal)
        self.current_data.update(calibrated_supply_voltages)
        calibrated_temperatures = get_calibrated_temperatures(self.current_data, self.sensor_calibration)
        self.current_data.update(calibrated_temperatures)

        with StorageProxy() as storage:

            rc = storage.save(
                {
                    &#34;origin&#34;: ORIGIN,
                    &#34;data&#34;: self.current_data
                }
            )
        if rc and not rc.successful:
            LOGGER.warning(f&#34;Couldn&#39;t save HK data to the Storage manager: {rc}&#34;)

        # Store the calibrated temperatures as synoptics
        # (only when there&#39;s actually something there in the N-FEE HK)

        if len(calibrated_temperatures) &gt; 0:

            calibrated_temperatures[&#34;timestamp&#34;] = self.current_data[HK_TIMESTAMP_NAME]

            with SynopticsManagerProxy() as synoptics:
                synoptics.store_common_synoptics(calibrated_temperatures)

    def worker_output(self, sync_id, data):

        if sync_id == MessageIdentifier.SYNC_TIMECODE:
            self.send_hk_data_to_storage()
            self.update_metrics()
            self.current_data.clear()
            timecode, timestamp = data
            LOGGER.info(f&#34;Timecode: {timecode}&#34;)

            self.current_data.update({&#34;timecode&#34;: timecode, &#34;timecode_ts&#34;: timestamp})

        if sync_id == MessageIdentifier.SYNC_HK_PACKET:
            hk_packet, timestamp = data
            LOGGER.info(f&#34;HK Packet: {hk_packet.type=!s}&#34;)

            self.current_data.update({HK_TIMESTAMP_NAME: timestamp})

            hk_data = HousekeepingData(hk_packet.data)

            for par_name in hk_data:
                self.current_data.update({par_name: hk_data[par_name]})

        if sync_id == MessageIdentifier.NUM_CYCLES:
            LOGGER.info(f&#34;num_cycles: {max(0, data)}&#34;)
            self.current_data.update({&#39;num_cycles&#39;: max(0, data)})

    def worker_complete(self):
        LOGGER.info(&#34;THREAD COMPLETE!&#34;)
        LOGGER.info(f&#34;Number of threads running: {self.threadpool.activeThreadCount()}&#34;)
        self.data_puller = None
        self.signals.finished.emit()

    def worker_error(self, t):
        LOGGER.warning(&#34;ERROR: %s&#34; % t)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.read_temp_calibration"><code class="name flex">
<span>def <span class="ident">read_temp_calibration</span></span>(<span>self) ‑> egse.setup.NavigableDict</span>
</code></dt>
<dd>
<div class="desc"><p>Read the temperature calibration from the designated file.</p>
<p>Returns: N-FEE temperature calibration as a NavigableDict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_temp_calibration(self) -&gt; NavigableDict:
    &#34;&#34;&#34; Read the temperature calibration from the designated file.

    Returns: N-FEE temperature calibration as a NavigableDict.
    &#34;&#34;&#34;

    return GlobalState.setup.camera.fee.calibration</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.start_pulling_data()</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.send_hk_data_to_storage"><code class="name flex">
<span>def <span class="ident">send_hk_data_to_storage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_hk_data_to_storage(self):

    if not any(self.current_data.values()):
        return

    # Translate the HK names (i.e. start using the correct prefix)
    # and append them to the rest of the HK

    self.current_data = convert_hk_names(dict(zip(self.current_data.keys(), self.current_data.values())),
                                         self.name_conversion)
    # Calibration (supply voltages + temperatures)

    calibrated_supply_voltages = get_calibrated_nfee_supply_voltages(self.current_data, self.nfee_supply_voltage_cal)
    self.current_data.update(calibrated_supply_voltages)
    calibrated_temperatures = get_calibrated_temperatures(self.current_data, self.sensor_calibration)
    self.current_data.update(calibrated_temperatures)

    with StorageProxy() as storage:

        rc = storage.save(
            {
                &#34;origin&#34;: ORIGIN,
                &#34;data&#34;: self.current_data
            }
        )
    if rc and not rc.successful:
        LOGGER.warning(f&#34;Couldn&#39;t save HK data to the Storage manager: {rc}&#34;)

    # Store the calibrated temperatures as synoptics
    # (only when there&#39;s actually something there in the N-FEE HK)

    if len(calibrated_temperatures) &gt; 0:

        calibrated_temperatures[&#34;timestamp&#34;] = self.current_data[HK_TIMESTAMP_NAME]

        with SynopticsManagerProxy() as synoptics:
            synoptics.store_common_synoptics(calibrated_temperatures)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.start_pulling_data"><code class="name flex">
<span>def <span class="ident">start_pulling_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_pulling_data(self):
    self.data_puller = worker = DataPuller(
        DPU_SETTINGS.HOSTNAME, DPU_SETTINGS.DATA_DISTRIBUTION_PORT
    )
    worker.signals.data.connect(self.worker_output)
    worker.signals.finished.connect(self.worker_complete)
    worker.signals.error.connect(self.worker_error)
    self.threadpool.start(worker)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.update_metrics"><code class="name flex">
<span>def <span class="ident">update_metrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_metrics(self):

    for metric_name in self.hk_names_mapping.values():
        # LOGGER.info(f&#34;{metric_name=}&#34;)
        value = self.current_data.get(metric_name)
        if value is not None:
            self.hk_metrics[metric_name].set(value)
        else:
            self.hk_metrics[metric_name].set(float(&#39;nan&#39;))
            LOGGER.log(logging.DEBUG, f&#34;No current data available for {metric_name}.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.worker_complete"><code class="name flex">
<span>def <span class="ident">worker_complete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker_complete(self):
    LOGGER.info(&#34;THREAD COMPLETE!&#34;)
    LOGGER.info(f&#34;Number of threads running: {self.threadpool.activeThreadCount()}&#34;)
    self.data_puller = None
    self.signals.finished.emit()</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.worker_error"><code class="name flex">
<span>def <span class="ident">worker_error</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker_error(self, t):
    LOGGER.warning(&#34;ERROR: %s&#34; % t)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.worker_output"><code class="name flex">
<span>def <span class="ident">worker_output</span></span>(<span>self, sync_id, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker_output(self, sync_id, data):

    if sync_id == MessageIdentifier.SYNC_TIMECODE:
        self.send_hk_data_to_storage()
        self.update_metrics()
        self.current_data.clear()
        timecode, timestamp = data
        LOGGER.info(f&#34;Timecode: {timecode}&#34;)

        self.current_data.update({&#34;timecode&#34;: timecode, &#34;timecode_ts&#34;: timestamp})

    if sync_id == MessageIdentifier.SYNC_HK_PACKET:
        hk_packet, timestamp = data
        LOGGER.info(f&#34;HK Packet: {hk_packet.type=!s}&#34;)

        self.current_data.update({HK_TIMESTAMP_NAME: timestamp})

        hk_data = HousekeepingData(hk_packet.data)

        for par_name in hk_data:
            self.current_data.update({par_name: hk_data[par_name]})

    if sync_id == MessageIdentifier.NUM_CYCLES:
        LOGGER.info(f&#34;num_cycles: {max(0, data)}&#34;)
        self.current_data.update({&#39;num_cycles&#39;: max(0, data)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.hk_generator = HousekeepingGenerator()

        column_names = self.hk_generator.current_data.keys()
        register_to_storage_manager(ORIGIN, CSV, prep=dict(mode=&#39;a&#39;, column_names=column_names))

        self.hk_generator.signals.finished.connect(self.close)
        self.hk_generator.run()

        LOGGER.info(&#34;Initialised MainWindow&#34;)

    def closeEvent(self, event: QCloseEvent) -&gt; None:
        LOGGER.info(f&#34;closeEvent called...{event=}&#34;)

        if self.hk_generator.data_puller:
            self.hk_generator.data_puller.quit()
        else:
            LOGGER.info(&#34;Data Puller was already terminated.&#34;)

        time.sleep(TIMEOUT)
        unregister_from_storage_manager(ORIGIN)
        LOGGER.info(&#34;AFTER UNREGISTER STORAGE&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.MainWindow.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>closeEvent(self, QCloseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, event: QCloseEvent) -&gt; None:
    LOGGER.info(f&#34;closeEvent called...{event=}&#34;)

    if self.hk_generator.data_puller:
        self.hk_generator.data_puller.quit()
    else:
        LOGGER.info(&#34;Data Puller was already terminated.&#34;)

    time.sleep(TIMEOUT)
    unregister_from_storage_manager(ORIGIN)
    LOGGER.info(&#34;AFTER UNREGISTER STORAGE&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.WorkerSignals"><code class="flex name class">
<span>class <span class="ident">WorkerSignals</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the signals available from a running worker thread.</p>
<p>Supported signals are:</p>
<p>finished
No data</p>
<p>error
'str' Exception string</p>
<p>data
'object' data returned from processing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkerSignals(QObject):
    &#34;&#34;&#34;
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        &#39;str&#39; Exception string

    data
        &#39;object&#39; data returned from processing

    &#34;&#34;&#34;

    finished = pyqtSignal()
    error = pyqtSignal(str)
    data = pyqtSignal(int, object)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.WorkerSignals.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.fee.n_fee_hk.WorkerSignals.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.fee.n_fee_hk.WorkerSignals.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.fee" href="index.html">egse.fee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_board_temperatures" href="#egse.fee.n_fee_hk.get_calibrated_board_temperatures">get_calibrated_board_temperatures</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_ccd_temperatures" href="#egse.fee.n_fee_hk.get_calibrated_ccd_temperatures">get_calibrated_ccd_temperatures</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_nfee_supply_voltages" href="#egse.fee.n_fee_hk.get_calibrated_nfee_supply_voltages">get_calibrated_nfee_supply_voltages</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_temperatures" href="#egse.fee.n_fee_hk.get_calibrated_temperatures">get_calibrated_temperatures</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_tou_temperatures" href="#egse.fee.n_fee_hk.get_calibrated_tou_temperatures">get_calibrated_tou_temperatures</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.read_hk_info" href="#egse.fee.n_fee_hk.read_hk_info">read_hk_info</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.send_request" href="#egse.fee.n_fee_hk.send_request">send_request</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.fee.n_fee_hk.DataCollector" href="#egse.fee.n_fee_hk.DataCollector">DataCollector</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.DataCollector.clear" href="#egse.fee.n_fee_hk.DataCollector.clear">clear</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.get" href="#egse.fee.n_fee_hk.DataCollector.get">get</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.keys" href="#egse.fee.n_fee_hk.DataCollector.keys">keys</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.update" href="#egse.fee.n_fee_hk.DataCollector.update">update</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.values" href="#egse.fee.n_fee_hk.DataCollector.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.DataPuller" href="#egse.fee.n_fee_hk.DataPuller">DataPuller</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.DataPuller.quit" href="#egse.fee.n_fee_hk.DataPuller.quit">quit</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataPuller.run" href="#egse.fee.n_fee_hk.DataPuller.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.GeneratorSignals" href="#egse.fee.n_fee_hk.GeneratorSignals">GeneratorSignals</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.GeneratorSignals.finished" href="#egse.fee.n_fee_hk.GeneratorSignals.finished">finished</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator" href="#egse.fee.n_fee_hk.HousekeepingGenerator">HousekeepingGenerator</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.read_temp_calibration" href="#egse.fee.n_fee_hk.HousekeepingGenerator.read_temp_calibration">read_temp_calibration</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.run" href="#egse.fee.n_fee_hk.HousekeepingGenerator.run">run</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.send_hk_data_to_storage" href="#egse.fee.n_fee_hk.HousekeepingGenerator.send_hk_data_to_storage">send_hk_data_to_storage</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.start_pulling_data" href="#egse.fee.n_fee_hk.HousekeepingGenerator.start_pulling_data">start_pulling_data</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.update_metrics" href="#egse.fee.n_fee_hk.HousekeepingGenerator.update_metrics">update_metrics</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.worker_complete" href="#egse.fee.n_fee_hk.HousekeepingGenerator.worker_complete">worker_complete</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.worker_error" href="#egse.fee.n_fee_hk.HousekeepingGenerator.worker_error">worker_error</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.worker_output" href="#egse.fee.n_fee_hk.HousekeepingGenerator.worker_output">worker_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.MainWindow" href="#egse.fee.n_fee_hk.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.MainWindow.closeEvent" href="#egse.fee.n_fee_hk.MainWindow.closeEvent">closeEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.WorkerSignals" href="#egse.fee.n_fee_hk.WorkerSignals">WorkerSignals</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.WorkerSignals.data" href="#egse.fee.n_fee_hk.WorkerSignals.data">data</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.WorkerSignals.error" href="#egse.fee.n_fee_hk.WorkerSignals.error">error</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.WorkerSignals.finished" href="#egse.fee.n_fee_hk.WorkerSignals.finished">finished</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
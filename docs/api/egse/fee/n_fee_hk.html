<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.fee.n_fee_hk API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.fee.n_fee_hk</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import multiprocessing
import os
import pickle
import signal
from typing import List

import click
import invoke
import numpy as np
import rich
import sys
import time
import zmq
from PyQt5 import QtCore
from PyQt5.QtCore import QObject
from PyQt5.QtCore import QRunnable
from PyQt5.QtCore import QThreadPool
from PyQt5.QtCore import QTimer
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtGui import QCloseEvent
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QMessageBox
from prometheus_client import start_http_server

import egse.logger
from egse.fee.nfee import HousekeepingData
from egse.hk import convert_hk_names
from egse.hk import read_conversion_dict
from egse.metrics import define_metrics
from egse.settings import Settings
from egse.setup import NavigableDict, SetupError
from egse.state import GlobalState
from egse.storage import StorageProxy
from egse.storage import register_to_storage_manager
from egse.storage import unregister_from_storage_manager
from egse.storage.persistence import CSV
from egse.synoptics import SynopticsManagerProxy
from egse.system import get_host_ip
from egse.zmq import MessageIdentifier
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

LOGGER = logging.getLogger(__name__)

DPU_SETTINGS = Settings.load(&#34;DPU Processor&#34;)
CTRL_SETTINGS = Settings.load(&#34;N-FEE HK Control Server&#34;)

APP_NAME = &#34;n_fee_hk&#34;
ORIGIN = &#34;N-FEE-HK&#34;
TIMEOUT = 1  # timeout for polling the data distribution from the DPU CS

HK_TIMESTAMP_NAME = &#34;timestamp&#34;

class GeneratorSignals(QObject):
    finished = pyqtSignal()


class WorkerSignals(QObject):
    &#34;&#34;&#34;
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        &#39;str&#39; Exception string

    data
        &#39;object&#39; data returned from processing

    &#34;&#34;&#34;

    finished = pyqtSignal()
    error = pyqtSignal(str)
    data = pyqtSignal(int, object)


class DataPuller(QRunnable):
    def __init__(self, hostname: str, port: int, timeout: int = TIMEOUT):
        super().__init__()
        self.signals = WorkerSignals()
        self.hostname = hostname
        self.port = port
        self.quit_request = False
        self.timeout = timeout

        context = zmq.Context.instance()

        self.receiver = context.socket(zmq.SUB)
        self.receiver.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        self.commander = context.socket(zmq.REP)

    @pyqtSlot()
    def run(self):
        ip_address = get_host_ip()
        receiver_endpoint = f&#34;tcp://{self.hostname}:{self.port}&#34;
        commander_endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
        self.receiver.connect(receiver_endpoint)
        self.commander.bind(commander_endpoint)

        poller = zmq.Poller()
        poller.register(self.receiver, zmq.POLLIN)
        poller.register(self.commander, zmq.POLLIN)

        while True:

            socket_list = dict(poller.poll(timeout=self.timeout))

            if self.quit_request:
                LOGGER.info(&#39;DataPuller quit requested.&#39;)
                break

            if self.receiver in socket_list:
                try:
                    sync_id, pickle_string = self.receiver.recv_multipart()
                    sync_id = int.from_bytes(sync_id, byteorder=&#39;big&#39;)
                    data = pickle.loads(pickle_string)
                    self.signals.data.emit(sync_id, data)
                except Exception as exc:
                    LOGGER.error(&#34;Exception caught!&#34;, exc_info=True)
                    self.signals.error.emit(str(exc))

            if self.commander in socket_list:
                pickle_string = self.commander.recv()
                command = pickle.loads(pickle_string)
                if command.lower() == &#34;quit&#34;:
                    self.commander.send(pickle.dumps(&#34;ACK&#34;))
                    LOGGER.info(&#39;DataPuller quit requested...&#39;)
                    break
                if command.lower() == &#34;status&#34;:
                    LOGGER.info(&#39;DataPuller status requested...&#39;)
                    response = dict(
                        status=&#34;ACK&#34;,
                        host=ip_address,
                        listening_port=self.port,
                        command_port=CTRL_SETTINGS.COMMANDING_PORT,
                    )
                    self.commander.send(pickle.dumps(response))

        LOGGER.info(&#34;Cleaning up ZeroMQ sockets...&#34;)

        poller.unregister(self.commander)
        poller.unregister(self.receiver)

        self.receiver.disconnect(f&#34;tcp://{self.hostname}:{self.port}&#34;)
        self.receiver.close(linger=0)
        self.commander.close(linger=0)

        self.signals.finished.emit()

    def quit(self):
        self.quit_request = True


class DataCollector:
    def __init__(self, keys: List):
        self._keys = keys

        # initialise the data dictionary

        self._data = {k: None for k in self._keys}

    def __getitem__(self, item):
        return self._data[item]

    def get(self, item):
        try:
            return self._data[item]
        except KeyError:
            return None

    def keys(self):
        return self._keys

    def values(self):
        return [self._data[name] for name in self._keys]

    def update(self, data: dict):
        if x := set(data) - set(self._data):
            LOGGER.warning(
                f&#34;New housekeeping found which was not previously in the N-FEE HK packet: {x}&#34;
            )
        self._data.update(data)

    def clear(self):
        self._data = {k: None for k in self._keys}


class MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.hk_generator = HousekeepingGenerator()

        column_names = self.hk_generator.current_data.keys()
        register_to_storage_manager(ORIGIN, CSV, prep=dict(mode=&#39;a&#39;, column_names=column_names))

        self.hk_generator.signals.finished.connect(self.close)
        self.hk_generator.run()

        LOGGER.info(&#34;Initialised MainWindow&#34;)

    def closeEvent(self, event: QCloseEvent) -&gt; None:
        LOGGER.info(f&#34;closeEvent called...{event=}&#34;)

        if self.hk_generator.data_puller:
            self.hk_generator.data_puller.quit()
        else:
            LOGGER.info(&#34;Data Puller was already terminated.&#34;)

        time.sleep(TIMEOUT)
        unregister_from_storage_manager(ORIGIN)
        LOGGER.info(&#34;AFTER UNREGISTER STORAGE&#34;)


class HousekeepingGenerator:

    def __init__(self):

        self.signals = GeneratorSignals()

        # Convert with info from HK info table
        # Append the new names

        self.data_puller = None
        self.threadpool = QThreadPool()

        # The hk_names_mapping is a dictionary that maps the original device telemetry parameter
        # names to the correct device names as defined in the CGSE. The keys in the mapping are
        # the original device name, the values are the CGSE corrected names

        self.hk_names_mapping = read_conversion_dict(ORIGIN, use_site=False)
        hk_header = self.hk_names_mapping.values()

        # Read from the setup: sensor calibration data (as a NavigableDict)

        self.supply_voltage_calibration = GlobalState.setup.camera.fee.calibration.supply_voltages
        self.temperature_calibration = GlobalState.setup.camera.fee.calibration.temperatures

        self.current_data = DataCollector(
            [HK_TIMESTAMP_NAME, *hk_header]
        )

        self.hk_metrics = define_metrics(ORIGIN, dashboard=&#39;*&#39;)

    def run(self):
        self.start_pulling_data()

    def start_pulling_data(self):
        self.data_puller = worker = DataPuller(
            DPU_SETTINGS.HOSTNAME, DPU_SETTINGS.DATA_DISTRIBUTION_PORT
        )
        worker.signals.data.connect(self.worker_output)
        worker.signals.finished.connect(self.worker_complete)
        worker.signals.error.connect(self.worker_error)
        self.threadpool.start(worker)

    def update_metrics(self):

        for metric_name in self.hk_names_mapping.values():
            # LOGGER.info(f&#34;{metric_name=}&#34;)
            value = self.current_data.get(metric_name)
            if value is not None:
                self.hk_metrics[metric_name].set(value)
            else:
                self.hk_metrics[metric_name].set(float(&#39;nan&#39;))
                LOGGER.log(logging.DEBUG, f&#34;No current data available for {metric_name}.&#34;)

    def send_hk_data_to_storage(self):

        if not any(self.current_data.values()):
            return

        # Translate the HK names (i.e. start using the correct prefix)
        # and append them to the rest of the HK

        self.current_data = convert_hk_names(dict(zip(self.current_data.keys(), self.current_data.values())),
                                             self.hk_names_mapping)
        # Calibration (supply voltages + temperatures)

        calibrated_supply_voltages = get_calibrated_supply_voltages(self.current_data,
                                                                    self.supply_voltage_calibration)
        self.current_data.update(calibrated_supply_voltages)
        calibrated_temperatures = get_calibrated_temperatures(self.current_data, self.temperature_calibration)
        self.current_data.update(calibrated_temperatures)

        with StorageProxy() as storage:

            rc = storage.save(
                {
                    &#34;origin&#34;: ORIGIN,
                    &#34;data&#34;: self.current_data
                }
            )
        if rc and not rc.successful:
            LOGGER.warning(f&#34;Couldn&#39;t save HK data to the Storage manager: {rc}&#34;)

        # Store the calibrated temperatures as synoptics
        # (only when there&#39;s actually something there in the N-FEE HK)

        if len(calibrated_temperatures) &gt; 0:

            calibrated_temperatures[&#34;timestamp&#34;] = self.current_data[HK_TIMESTAMP_NAME]

            with SynopticsManagerProxy() as synoptics:
                synoptics.store_common_synoptics(calibrated_temperatures)

    def worker_output(self, sync_id, data):

        if sync_id == MessageIdentifier.SYNC_TIMECODE:
            self.send_hk_data_to_storage()
            self.update_metrics()
            self.current_data.clear()
            timecode, timestamp = data
            LOGGER.info(f&#34;Timecode: {timecode}&#34;)

            self.current_data.update({&#34;timecode&#34;: timecode, &#34;timecode_ts&#34;: timestamp})

        if sync_id == MessageIdentifier.SYNC_HK_PACKET:
            hk_packet, timestamp = data
            LOGGER.info(f&#34;HK Packet: {hk_packet.type=!s}&#34;)

            self.current_data.update({HK_TIMESTAMP_NAME: timestamp})

            hk_data = HousekeepingData(hk_packet.data)

            for par_name in hk_data:
                self.current_data.update({par_name: hk_data[par_name]})

        if sync_id == MessageIdentifier.NUM_CYCLES:
            LOGGER.info(f&#34;num_cycles: {max(0, data)}&#34;)
            self.current_data.update({&#39;num_cycles&#39;: max(0, data)})

    def worker_complete(self):
        LOGGER.info(&#34;THREAD COMPLETE!&#34;)
        LOGGER.info(f&#34;Number of threads running: {self.threadpool.activeThreadCount()}&#34;)
        self.data_puller = None
        self.signals.finished.emit()

    def worker_error(self, t):
        LOGGER.warning(&#34;ERROR: %s&#34; % t)


def get_calibrated_supply_voltages(counts, supply_voltage_calibration):
    &#34;&#34;&#34; Calibrate the N-FEE supply voltages.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consist of applying a linear function to the raw values.

    Args:
        - counts: Uncalibrated, raw data for all HK.
        - supply_voltage_calibration: Supply voltage calibration s read from the YAML file that was specified in the
                                      setup

    Returns: Dictionary with calibrated supply voltages [V].
    &#34;&#34;&#34;

    supply_voltages = {}

    for cal_name in supply_voltage_calibration:

        raw_name = cal_name + &#34;_RAW&#34;
        cal = supply_voltage_calibration[cal_name]

        if counts[raw_name] is not None:

            supply_voltage = cal.gain * counts[raw_name] + cal.offset

            supply_voltages[cal_name] = supply_voltage

    return supply_voltages


def get_calibrated_temperatures(counts, sensor_calibration):
    &#34;&#34;&#34; Calibrate the N-FEE temperatures.

    The calibrated temperatures come from:

        - TOU TRP PT1000 sensors
        - CCD PT100/PT1000 sensors
        - PT1000 board sensors
        - ISL71590 board sensors

    The difference in naming between calibrated and uncalibrated temperatures is the suffix &#34;_RAW&#34;.

    Args:
        - counts: Uncalibrated, raw data for all HK.
        - sensor_calibration: N-FEE temperature calibration as read from the YAML file that was specified in the setup

    Returns: Dictionary with calibrated temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    for sensor_type in sensor_calibration:
        temperatures.update(get_calibrated_temperatures_for_type(counts, sensor_calibration, sensor_type))

    return temperatures


def get_calibrated_temperatures_for_type(counts, sensor_calibration, sensor_type) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE temperatures for the given sensor type.

    Args:
        - counts: Uncalibrated, raw data [ADU]
        - sensor_calibration: Calibration information for the given sensor type
        - sensor_calibration: N-FEE sensor calibration as read from the YAML file that was specified in the setup

    Returns: Dictionary with calibrated temperatures [°C] for the given sensor type.
    &#34;&#34;&#34;

    cal = sensor_calibration[sensor_type]

    temperatures = {}

    for cal_name in cal.sensor_names:

        raw_name = cal_name + &#34;_RAW&#34;

        if counts[raw_name] is not None:

            sensor_info = cal[cal_name] if cal_name in cal else cal

            try:
                temperature = counts_to_temperature(cal_name, counts[raw_name], sensor_info)

            except AttributeError as exc:
                raise SetupError(&#34;Not all TOU TRP PT1000 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures


def counts_to_temperature(sensor_name: str, counts: float, sensor_info: NavigableDict):
    &#34;&#34;&#34; Convert the given counts for the given sensor to temperature.

    Args:
        - sensor_name: Sensor name
        - counts: Uncalibrated, raw data [ADU]
        - sensor_info: Calibration information for the given sensor (type)

    Returns: Calibrated temperature [°C] for the given sensor
    &#34;&#34;&#34;

    # Conversion: temperature = counts * gain + offset

    if &#34;counts_to_temperature_gain&#34; in sensor_info and &#34;counts_to_temperature_offset&#34; in sensor_info:
        return counts * sensor_info.counts_to_temperature_gain + sensor_info.counts_to_temperature_offset

    # Conversion: counts -&gt; resistance -&gt; temperature

    else:
        resistance = counts_to_resistance(sensor_name, counts, sensor_info)
        return resistance_to_temperature(sensor_name, resistance, sensor_info)


def counts_to_resistance(sensor_name: str, counts: float, sensor_info: NavigableDict):
    &#34;&#34;&#34; Convert the given counts for the given sensor to resistance.

    Args:
        - sensor_name: Sensor name
        - counts: Uncalibrated, raw data [ADU]
        - sensor_info: Calibration information for the given sensor (type)

    Returns: Resistance [Ohm] for the given sensor.
    &#34;&#34;&#34;

    # Offset (if any)

    counts_to_resistance_offset = sensor_info.counts_to_resistance_offset \
        if &#34;counts_to_resistance_offset&#34; in sensor_info \
        else 0

    # Conversion: counts -&gt; voltage -&gt; resistance

    if &#34;counts_to_voltage_gain&#34; in sensor_info and &#34;voltage_to_resistance_gain&#34; in sensor_info:
        return counts * sensor_info.counts_to_voltage_gain * sensor_info.voltage_to_resistance_gain \
               + counts_to_resistance_offset

    # Conversion: counts -&gt; resistance

    elif &#34;counts_to_resistance_gain&#34; in sensor_info:
        return counts * sensor_info.counts_to_resistance_gain \
               + counts_to_resistance_offset

    raise SetupError(f&#34;Setup does not contain info for conversion from counts to resistance for {sensor_name}&#34;)


def resistance_to_temperature(sensor_name: str, resistance: float, sensor_info: NavigableDict):
    &#34;&#34;&#34; Convert the given resistance for the given sensor to counts.

    Args:
        - sensor_name: Sensor name
        - resistance: Resistance [Ohm]
        - sensor_info: Calibration information for the given sensor (type)

    Returns: Temperature [°C] for the given sensor.
    &#34;&#34;&#34;

    resistance_to_temperature_info = sensor_info.resistance_to_temperature

    # Series resistance (if any)

    if &#34;series_resistance&#34; in resistance_to_temperature_info:

        series_resistance = resistance_to_temperature_info.series_resistance
        if sensor_name in resistance_to_temperature_info:
            series_resistance = series_resistance[sensor_name]
        resistance -= series_resistance

    method: str = resistance_to_temperature_info.method

    # Polynomial

    if method == &#34;polynomial&#34;:

        # Coefficients given for conversion temperature -&gt; resistance

        if &#34;temperature_to_resistance_coefficients&#34; in resistance_to_temperature_info:
            return solve_temperature(resistance_to_temperature_info.temperature_to_resistance_coefficients, resistance)

        # Coefficients given for conversion resistance -&gt; temperature

        if &#34;resistance_to_temperature_coefficients&#34; in resistance_to_temperature_info:
            return np.polyval(resistance_to_temperature_info.resistance_to_temperature_coefficients, resistance)

    # Callendar - van Dusen equation

    if method == &#34;callendar_van_dusen&#34;:
        standard = resistance_to_temperature_info.standard
        ref_resistance = resistance_to_temperature_info.ref_resistance
        return callendar_van_dusen(resistance, ref_resistance, standard)

    else:
        raise SetupError(f&#34;Setup does not contain info for conversion from resistance to temperature for {sensor_name}&#34;)


def solve_temperature(temperature_to_resistance_coefficients, resistance):
    &#34;&#34;&#34; Solve the temperature from the temperature -&gt; resistance polynomial.

    For the given temperature -&gt; resistance polynomial and the given resistance, we determine what the corresponding
    temperature is by:
        - Finding the roots of
            polynomial(temperature) = resistance
        - Discarding the roots with an imaginary component
        - Selecting the remaining root in the relevant temperature regime (here: [-200°C, 200°C])
    &#34;&#34;&#34;

    temperature_to_resistance_poly = np.poly1d(temperature_to_resistance_coefficients)
    temperatures = (temperature_to_resistance_poly - resistance).roots

    for temperature in temperatures:
        if temperature.imag == 0 and -200 &lt;= temperature &lt;= 200:
            return temperature.real


def callendar_van_dusen(resistance, ref_resistance, standard):
    &#34;&#34;&#34; Solve the Callendar - van Dusen equation for temperature.

    Args:
        - resistance: Resistance [Ohm] for which to calculate the temperature
        - ref_resistance: Resistance [Ohm] for a temperature of 0°C

    Return: Temperature [°C] corresponding to the given resistance.
    &#34;&#34;&#34;

    # Resistances higher than the reference resistance correspond to

    coefficients = GlobalState.setup.sensor_calibration.callendar_van_dusen[standard]

    # Positive temperatures

    if resistance &gt;= ref_resistance:
        resistance_to_temperature_coefficients = [ref_resistance * coefficients.C,
                                                  -ref_resistance * 100 * coefficients.C,
                                                  ref_resistance * coefficients.B,
                                                  ref_resistance * coefficients.A, ref_resistance * 1]

    # Negative temperatures

    else:
        resistance_to_temperature_coefficients = [ref_resistance * coefficients.B,
                                                  ref_resistance * coefficients.A,
                                                  ref_resistance * 1]

    return solve_temperature(resistance_to_temperature_coefficients, resistance)



@click.group()
def cli():
    pass


@cli.command()
@click.option(&#34;--gui/--no-gui&#34;, default=False,
              help=&#34;start the N-FEE HK Process with graphics support [default=--no-gui].&#34;)
def start_bg(gui):
    &#34;&#34;&#34;Start the N-FEE HK Processor in the background.&#34;&#34;&#34;

    options = &#34;--gui&#34; if gui else &#34;--no-gui&#34;
    invoke.run(f&#34;n_fee_hk start {options}&#34;, disown=True)


@cli.command()
@click.option(&#34;--gui/--no-gui&#34;, default=False,
              help=&#34;start the N-FEE HK Process with graphics support [default=--no-gui].&#34;)
def start(gui):
    &#34;&#34;&#34;Start the N-FEE HK Processor.&#34;&#34;&#34;

    multiprocessing.current_process().name = &#34;n_fee_hk&#34;

    start_http_server(CTRL_SETTINGS.METRICS_PORT)

    args = sys.argv
    if not gui:
        args.extend([&#34;-platform&#34;, &#34;offscreen&#34;])

    LOGGER.info(f&#34;{args=}&#34;)

    app = QApplication(args)

    os.environ[&#34;QT_ENABLE_HIGHDPI_SCALING&#34;] = &#34;1&#34;
    QApplication.setHighDpiScaleFactorRoundingPolicy(
        QtCore.Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )
    window = MainWindow()
    window.show()

    def sigint_handler(*args):
        &#34;&#34;&#34;Handler for the SIGINT signal.&#34;&#34;&#34;
        LOGGER.info(f&#39;Handling signal SIGINT...&#39;)
        if QApplication.platformName() == &#34;offscreen&#34;:
            window.close()
            QApplication.quit()
        elif QMessageBox.question(
                None, &#39;&#39;, &#34;Are you sure you want to quit?&#34;,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
        ) == QMessageBox.Yes:
            window.close()
            QApplication.quit()

    signal.signal(signal.SIGINT, sigint_handler)

    # The following code is solely here to have the app react faster to CTRL-C in the terminal

    timer = QTimer()
    timer.start(500)  # interval in msec
    timer.timeout.connect(lambda: None)  # Let the interpreter run each 500 ms.

    try:
        rc = app.exec_()
    except KeyboardInterrupt:
        LOGGER.info(f&#34;Keyboard interrupt accepted, terminating application {APP_NAME}&#34;)

    LOGGER.info(&#34;Destroying ZeroMQ context...&#34;)

    egse.logger.close_all_zmq_handlers()

    context = zmq.Context.instance()
    context.destroy(linger=0)


@cli.command()
def stop():
    &#34;&#34;&#34;Stop the N-FEE HK Control Server.&#34;&#34;&#34;

    response = send_request(&#34;quit&#34;)
    if response == &#34;ACK&#34;:
        rich.print(&#34;Logger successfully terminated.&#34;)
    else:
        rich.print(f&#34;[red] ERROR: {response}&#34;)


@cli.command()
def status():
    &#34;&#34;&#34;Roll over the log file of the Logger Control Server.&#34;&#34;&#34;

    rich.print(&#34;N-FEE HK Generator:&#34;)

    response = send_request(&#34;status&#34;)
    if response.get(&#34;status&#34;) == &#34;ACK&#34;:
        rich.print(&#34;  Status: [green]active&#34;)
        rich.print(f&#34;  Hostname: {response.get(&#39;host&#39;)}&#34;)
        rich.print(f&#34;  Listening port: {response.get(&#39;listening_port&#39;)}&#34;)
        rich.print(f&#34;  Commanding port: {response.get(&#39;command_port&#39;)}&#34;)
    else:
        rich.print(&#34;  Status: [red]not active&#34;)


TIMEOUT_RECV = 1.0  # seconds


def send_request(command_request: str):
    &#34;&#34;&#34;Sends a request to the Logger Control Server and waits for a response.&#34;&#34;&#34;
    ctx = zmq.Context.instance()
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket = ctx.socket(zmq.REQ)
    socket.connect(endpoint)

    socket.send(pickle.dumps(command_request))
    rlist, _, _ = zmq.select([socket], [], [], timeout=TIMEOUT_RECV)
    if socket in rlist:
        response = socket.recv()
        response = pickle.loads(response)
    else:
        response = {&#34;error&#34;: &#34;Received from ZeroMQ socket timed out for N-FEE HK Control Server.&#34;}
    socket.close(linger=0)

    return response


if __name__ == &#39;__main__&#39;:
    sys.exit(cli())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.fee.n_fee_hk.callendar_van_dusen"><code class="name flex">
<span>def <span class="ident">callendar_van_dusen</span></span>(<span>resistance, ref_resistance, standard)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve the Callendar - van Dusen equation for temperature.</p>
<h2 id="args">Args</h2>
<ul>
<li>resistance: Resistance [Ohm] for which to calculate the temperature</li>
<li>ref_resistance: Resistance [Ohm] for a temperature of 0°C
Return: Temperature [°C] corresponding to the given resistance.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callendar_van_dusen(resistance, ref_resistance, standard):
    &#34;&#34;&#34; Solve the Callendar - van Dusen equation for temperature.

    Args:
        - resistance: Resistance [Ohm] for which to calculate the temperature
        - ref_resistance: Resistance [Ohm] for a temperature of 0°C

    Return: Temperature [°C] corresponding to the given resistance.
    &#34;&#34;&#34;

    # Resistances higher than the reference resistance correspond to

    coefficients = GlobalState.setup.sensor_calibration.callendar_van_dusen[standard]

    # Positive temperatures

    if resistance &gt;= ref_resistance:
        resistance_to_temperature_coefficients = [ref_resistance * coefficients.C,
                                                  -ref_resistance * 100 * coefficients.C,
                                                  ref_resistance * coefficients.B,
                                                  ref_resistance * coefficients.A, ref_resistance * 1]

    # Negative temperatures

    else:
        resistance_to_temperature_coefficients = [ref_resistance * coefficients.B,
                                                  ref_resistance * coefficients.A,
                                                  ref_resistance * 1]

    return solve_temperature(resistance_to_temperature_coefficients, resistance)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.counts_to_resistance"><code class="name flex">
<span>def <span class="ident">counts_to_resistance</span></span>(<span>sensor_name: str, counts: float, sensor_info: egse.setup.NavigableDict)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the given counts for the given sensor to resistance.</p>
<h2 id="args">Args</h2>
<ul>
<li>sensor_name: Sensor name</li>
<li>counts: Uncalibrated, raw data [ADU]</li>
<li>sensor_info: Calibration information for the given sensor (type)
Returns: Resistance [Ohm] for the given sensor.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counts_to_resistance(sensor_name: str, counts: float, sensor_info: NavigableDict):
    &#34;&#34;&#34; Convert the given counts for the given sensor to resistance.

    Args:
        - sensor_name: Sensor name
        - counts: Uncalibrated, raw data [ADU]
        - sensor_info: Calibration information for the given sensor (type)

    Returns: Resistance [Ohm] for the given sensor.
    &#34;&#34;&#34;

    # Offset (if any)

    counts_to_resistance_offset = sensor_info.counts_to_resistance_offset \
        if &#34;counts_to_resistance_offset&#34; in sensor_info \
        else 0

    # Conversion: counts -&gt; voltage -&gt; resistance

    if &#34;counts_to_voltage_gain&#34; in sensor_info and &#34;voltage_to_resistance_gain&#34; in sensor_info:
        return counts * sensor_info.counts_to_voltage_gain * sensor_info.voltage_to_resistance_gain \
               + counts_to_resistance_offset

    # Conversion: counts -&gt; resistance

    elif &#34;counts_to_resistance_gain&#34; in sensor_info:
        return counts * sensor_info.counts_to_resistance_gain \
               + counts_to_resistance_offset

    raise SetupError(f&#34;Setup does not contain info for conversion from counts to resistance for {sensor_name}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.counts_to_temperature"><code class="name flex">
<span>def <span class="ident">counts_to_temperature</span></span>(<span>sensor_name: str, counts: float, sensor_info: egse.setup.NavigableDict)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the given counts for the given sensor to temperature.</p>
<h2 id="args">Args</h2>
<ul>
<li>sensor_name: Sensor name</li>
<li>counts: Uncalibrated, raw data [ADU]</li>
<li>sensor_info: Calibration information for the given sensor (type)
Returns: Calibrated temperature [°C] for the given sensor</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counts_to_temperature(sensor_name: str, counts: float, sensor_info: NavigableDict):
    &#34;&#34;&#34; Convert the given counts for the given sensor to temperature.

    Args:
        - sensor_name: Sensor name
        - counts: Uncalibrated, raw data [ADU]
        - sensor_info: Calibration information for the given sensor (type)

    Returns: Calibrated temperature [°C] for the given sensor
    &#34;&#34;&#34;

    # Conversion: temperature = counts * gain + offset

    if &#34;counts_to_temperature_gain&#34; in sensor_info and &#34;counts_to_temperature_offset&#34; in sensor_info:
        return counts * sensor_info.counts_to_temperature_gain + sensor_info.counts_to_temperature_offset

    # Conversion: counts -&gt; resistance -&gt; temperature

    else:
        resistance = counts_to_resistance(sensor_name, counts, sensor_info)
        return resistance_to_temperature(sensor_name, resistance, sensor_info)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_supply_voltages"><code class="name flex">
<span>def <span class="ident">get_calibrated_supply_voltages</span></span>(<span>counts, supply_voltage_calibration)</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE supply voltages.</p>
<p>The difference in naming between calibrated and uncalibrated housekeeping is the suffix "_RAW".</p>
<p>The calibration consist of applying a linear function to the raw values.</p>
<h2 id="args">Args</h2>
<ul>
<li>counts: Uncalibrated, raw data for all HK.</li>
<li>supply_voltage_calibration: Supply voltage calibration s read from the YAML file that was specified in the
setup
Returns: Dictionary with calibrated supply voltages [V].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_supply_voltages(counts, supply_voltage_calibration):
    &#34;&#34;&#34; Calibrate the N-FEE supply voltages.

    The difference in naming between calibrated and uncalibrated housekeeping is the suffix &#34;_RAW&#34;.

    The calibration consist of applying a linear function to the raw values.

    Args:
        - counts: Uncalibrated, raw data for all HK.
        - supply_voltage_calibration: Supply voltage calibration s read from the YAML file that was specified in the
                                      setup

    Returns: Dictionary with calibrated supply voltages [V].
    &#34;&#34;&#34;

    supply_voltages = {}

    for cal_name in supply_voltage_calibration:

        raw_name = cal_name + &#34;_RAW&#34;
        cal = supply_voltage_calibration[cal_name]

        if counts[raw_name] is not None:

            supply_voltage = cal.gain * counts[raw_name] + cal.offset

            supply_voltages[cal_name] = supply_voltage

    return supply_voltages</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_temperatures"><code class="name flex">
<span>def <span class="ident">get_calibrated_temperatures</span></span>(<span>counts, sensor_calibration)</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE temperatures.</p>
<p>The calibrated temperatures come from:</p>
<pre><code>- TOU TRP PT1000 sensors
- CCD PT100/PT1000 sensors
- PT1000 board sensors
- ISL71590 board sensors
</code></pre>
<p>The difference in naming between calibrated and uncalibrated temperatures is the suffix "_RAW".</p>
<h2 id="args">Args</h2>
<ul>
<li>counts: Uncalibrated, raw data for all HK.</li>
<li>sensor_calibration: N-FEE temperature calibration as read from the YAML file that was specified in the setup
Returns: Dictionary with calibrated temperatures [°C].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_temperatures(counts, sensor_calibration):
    &#34;&#34;&#34; Calibrate the N-FEE temperatures.

    The calibrated temperatures come from:

        - TOU TRP PT1000 sensors
        - CCD PT100/PT1000 sensors
        - PT1000 board sensors
        - ISL71590 board sensors

    The difference in naming between calibrated and uncalibrated temperatures is the suffix &#34;_RAW&#34;.

    Args:
        - counts: Uncalibrated, raw data for all HK.
        - sensor_calibration: N-FEE temperature calibration as read from the YAML file that was specified in the setup

    Returns: Dictionary with calibrated temperatures [°C].
    &#34;&#34;&#34;

    temperatures = {}

    for sensor_type in sensor_calibration:
        temperatures.update(get_calibrated_temperatures_for_type(counts, sensor_calibration, sensor_type))

    return temperatures</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.get_calibrated_temperatures_for_type"><code class="name flex">
<span>def <span class="ident">get_calibrated_temperatures_for_type</span></span>(<span>counts, sensor_calibration, sensor_type) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calibrate the N-FEE temperatures for the given sensor type.</p>
<h2 id="args">Args</h2>
<ul>
<li>counts: Uncalibrated, raw data [ADU]</li>
<li>sensor_calibration: Calibration information for the given sensor type</li>
<li>sensor_calibration: N-FEE sensor calibration as read from the YAML file that was specified in the setup
Returns: Dictionary with calibrated temperatures [°C] for the given sensor type.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_temperatures_for_type(counts, sensor_calibration, sensor_type) -&gt; dict:
    &#34;&#34;&#34; Calibrate the N-FEE temperatures for the given sensor type.

    Args:
        - counts: Uncalibrated, raw data [ADU]
        - sensor_calibration: Calibration information for the given sensor type
        - sensor_calibration: N-FEE sensor calibration as read from the YAML file that was specified in the setup

    Returns: Dictionary with calibrated temperatures [°C] for the given sensor type.
    &#34;&#34;&#34;

    cal = sensor_calibration[sensor_type]

    temperatures = {}

    for cal_name in cal.sensor_names:

        raw_name = cal_name + &#34;_RAW&#34;

        if counts[raw_name] is not None:

            sensor_info = cal[cal_name] if cal_name in cal else cal

            try:
                temperature = counts_to_temperature(cal_name, counts[raw_name], sensor_info)

            except AttributeError as exc:
                raise SetupError(&#34;Not all TOU TRP PT1000 calibration information is available in the setup under &#34;
                                 &#34;setup.camera.fee.calibration.&#34;, {exc})

            temperatures[cal_name] = temperature

    return temperatures</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.resistance_to_temperature"><code class="name flex">
<span>def <span class="ident">resistance_to_temperature</span></span>(<span>sensor_name: str, resistance: float, sensor_info: egse.setup.NavigableDict)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the given resistance for the given sensor to counts.</p>
<h2 id="args">Args</h2>
<ul>
<li>sensor_name: Sensor name</li>
<li>resistance: Resistance [Ohm]</li>
<li>sensor_info: Calibration information for the given sensor (type)
Returns: Temperature [°C] for the given sensor.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resistance_to_temperature(sensor_name: str, resistance: float, sensor_info: NavigableDict):
    &#34;&#34;&#34; Convert the given resistance for the given sensor to counts.

    Args:
        - sensor_name: Sensor name
        - resistance: Resistance [Ohm]
        - sensor_info: Calibration information for the given sensor (type)

    Returns: Temperature [°C] for the given sensor.
    &#34;&#34;&#34;

    resistance_to_temperature_info = sensor_info.resistance_to_temperature

    # Series resistance (if any)

    if &#34;series_resistance&#34; in resistance_to_temperature_info:

        series_resistance = resistance_to_temperature_info.series_resistance
        if sensor_name in resistance_to_temperature_info:
            series_resistance = series_resistance[sensor_name]
        resistance -= series_resistance

    method: str = resistance_to_temperature_info.method

    # Polynomial

    if method == &#34;polynomial&#34;:

        # Coefficients given for conversion temperature -&gt; resistance

        if &#34;temperature_to_resistance_coefficients&#34; in resistance_to_temperature_info:
            return solve_temperature(resistance_to_temperature_info.temperature_to_resistance_coefficients, resistance)

        # Coefficients given for conversion resistance -&gt; temperature

        if &#34;resistance_to_temperature_coefficients&#34; in resistance_to_temperature_info:
            return np.polyval(resistance_to_temperature_info.resistance_to_temperature_coefficients, resistance)

    # Callendar - van Dusen equation

    if method == &#34;callendar_van_dusen&#34;:
        standard = resistance_to_temperature_info.standard
        ref_resistance = resistance_to_temperature_info.ref_resistance
        return callendar_van_dusen(resistance, ref_resistance, standard)

    else:
        raise SetupError(f&#34;Setup does not contain info for conversion from resistance to temperature for {sensor_name}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.send_request"><code class="name flex">
<span>def <span class="ident">send_request</span></span>(<span>command_request: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a request to the Logger Control Server and waits for a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request(command_request: str):
    &#34;&#34;&#34;Sends a request to the Logger Control Server and waits for a response.&#34;&#34;&#34;
    ctx = zmq.Context.instance()
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket = ctx.socket(zmq.REQ)
    socket.connect(endpoint)

    socket.send(pickle.dumps(command_request))
    rlist, _, _ = zmq.select([socket], [], [], timeout=TIMEOUT_RECV)
    if socket in rlist:
        response = socket.recv()
        response = pickle.loads(response)
    else:
        response = {&#34;error&#34;: &#34;Received from ZeroMQ socket timed out for N-FEE HK Control Server.&#34;}
    socket.close(linger=0)

    return response</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.solve_temperature"><code class="name flex">
<span>def <span class="ident">solve_temperature</span></span>(<span>temperature_to_resistance_coefficients, resistance)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve the temperature from the temperature -&gt; resistance polynomial.</p>
<p>For the given temperature -&gt; resistance polynomial and the given resistance, we determine what the corresponding
temperature is by:
- Finding the roots of
polynomial(temperature) = resistance
- Discarding the roots with an imaginary component
- Selecting the remaining root in the relevant temperature regime (here: [-200°C, 200°C])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_temperature(temperature_to_resistance_coefficients, resistance):
    &#34;&#34;&#34; Solve the temperature from the temperature -&gt; resistance polynomial.

    For the given temperature -&gt; resistance polynomial and the given resistance, we determine what the corresponding
    temperature is by:
        - Finding the roots of
            polynomial(temperature) = resistance
        - Discarding the roots with an imaginary component
        - Selecting the remaining root in the relevant temperature regime (here: [-200°C, 200°C])
    &#34;&#34;&#34;

    temperature_to_resistance_poly = np.poly1d(temperature_to_resistance_coefficients)
    temperatures = (temperature_to_resistance_poly - resistance).roots

    for temperature in temperatures:
        if temperature.imag == 0 and -200 &lt;= temperature &lt;= 200:
            return temperature.real</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.fee.n_fee_hk.DataCollector"><code class="flex name class">
<span>class <span class="ident">DataCollector</span></span>
<span>(</span><span>keys: List[~T])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataCollector:
    def __init__(self, keys: List):
        self._keys = keys

        # initialise the data dictionary

        self._data = {k: None for k in self._keys}

    def __getitem__(self, item):
        return self._data[item]

    def get(self, item):
        try:
            return self._data[item]
        except KeyError:
            return None

    def keys(self):
        return self._keys

    def values(self):
        return [self._data[name] for name in self._keys]

    def update(self, data: dict):
        if x := set(data) - set(self._data):
            LOGGER.warning(
                f&#34;New housekeeping found which was not previously in the N-FEE HK packet: {x}&#34;
            )
        self._data.update(data)

    def clear(self):
        self._data = {k: None for k in self._keys}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.DataCollector.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self._data = {k: None for k in self._keys}</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, item):
    try:
        return self._data[item]
    except KeyError:
        return None</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self._keys</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, data: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, data: dict):
    if x := set(data) - set(self._data):
        LOGGER.warning(
            f&#34;New housekeeping found which was not previously in the N-FEE HK packet: {x}&#34;
        )
    self._data.update(data)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataCollector.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    return [self._data[name] for name in self._keys]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.DataPuller"><code class="flex name class">
<span>class <span class="ident">DataPuller</span></span>
<span>(</span><span>hostname: str, port: int, timeout: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>QRunnable()
QRunnable(QRunnable)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataPuller(QRunnable):
    def __init__(self, hostname: str, port: int, timeout: int = TIMEOUT):
        super().__init__()
        self.signals = WorkerSignals()
        self.hostname = hostname
        self.port = port
        self.quit_request = False
        self.timeout = timeout

        context = zmq.Context.instance()

        self.receiver = context.socket(zmq.SUB)
        self.receiver.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        self.commander = context.socket(zmq.REP)

    @pyqtSlot()
    def run(self):
        ip_address = get_host_ip()
        receiver_endpoint = f&#34;tcp://{self.hostname}:{self.port}&#34;
        commander_endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
        self.receiver.connect(receiver_endpoint)
        self.commander.bind(commander_endpoint)

        poller = zmq.Poller()
        poller.register(self.receiver, zmq.POLLIN)
        poller.register(self.commander, zmq.POLLIN)

        while True:

            socket_list = dict(poller.poll(timeout=self.timeout))

            if self.quit_request:
                LOGGER.info(&#39;DataPuller quit requested.&#39;)
                break

            if self.receiver in socket_list:
                try:
                    sync_id, pickle_string = self.receiver.recv_multipart()
                    sync_id = int.from_bytes(sync_id, byteorder=&#39;big&#39;)
                    data = pickle.loads(pickle_string)
                    self.signals.data.emit(sync_id, data)
                except Exception as exc:
                    LOGGER.error(&#34;Exception caught!&#34;, exc_info=True)
                    self.signals.error.emit(str(exc))

            if self.commander in socket_list:
                pickle_string = self.commander.recv()
                command = pickle.loads(pickle_string)
                if command.lower() == &#34;quit&#34;:
                    self.commander.send(pickle.dumps(&#34;ACK&#34;))
                    LOGGER.info(&#39;DataPuller quit requested...&#39;)
                    break
                if command.lower() == &#34;status&#34;:
                    LOGGER.info(&#39;DataPuller status requested...&#39;)
                    response = dict(
                        status=&#34;ACK&#34;,
                        host=ip_address,
                        listening_port=self.port,
                        command_port=CTRL_SETTINGS.COMMANDING_PORT,
                    )
                    self.commander.send(pickle.dumps(response))

        LOGGER.info(&#34;Cleaning up ZeroMQ sockets...&#34;)

        poller.unregister(self.commander)
        poller.unregister(self.receiver)

        self.receiver.disconnect(f&#34;tcp://{self.hostname}:{self.port}&#34;)
        self.receiver.close(linger=0)
        self.commander.close(linger=0)

        self.signals.finished.emit()

    def quit(self):
        self.quit_request = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QRunnable</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.DataPuller.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    self.quit_request = True</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.DataPuller.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>run(self)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    ip_address = get_host_ip()
    receiver_endpoint = f&#34;tcp://{self.hostname}:{self.port}&#34;
    commander_endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
    self.receiver.connect(receiver_endpoint)
    self.commander.bind(commander_endpoint)

    poller = zmq.Poller()
    poller.register(self.receiver, zmq.POLLIN)
    poller.register(self.commander, zmq.POLLIN)

    while True:

        socket_list = dict(poller.poll(timeout=self.timeout))

        if self.quit_request:
            LOGGER.info(&#39;DataPuller quit requested.&#39;)
            break

        if self.receiver in socket_list:
            try:
                sync_id, pickle_string = self.receiver.recv_multipart()
                sync_id = int.from_bytes(sync_id, byteorder=&#39;big&#39;)
                data = pickle.loads(pickle_string)
                self.signals.data.emit(sync_id, data)
            except Exception as exc:
                LOGGER.error(&#34;Exception caught!&#34;, exc_info=True)
                self.signals.error.emit(str(exc))

        if self.commander in socket_list:
            pickle_string = self.commander.recv()
            command = pickle.loads(pickle_string)
            if command.lower() == &#34;quit&#34;:
                self.commander.send(pickle.dumps(&#34;ACK&#34;))
                LOGGER.info(&#39;DataPuller quit requested...&#39;)
                break
            if command.lower() == &#34;status&#34;:
                LOGGER.info(&#39;DataPuller status requested...&#39;)
                response = dict(
                    status=&#34;ACK&#34;,
                    host=ip_address,
                    listening_port=self.port,
                    command_port=CTRL_SETTINGS.COMMANDING_PORT,
                )
                self.commander.send(pickle.dumps(response))

    LOGGER.info(&#34;Cleaning up ZeroMQ sockets...&#34;)

    poller.unregister(self.commander)
    poller.unregister(self.receiver)

    self.receiver.disconnect(f&#34;tcp://{self.hostname}:{self.port}&#34;)
    self.receiver.close(linger=0)
    self.commander.close(linger=0)

    self.signals.finished.emit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.GeneratorSignals"><code class="flex name class">
<span>class <span class="ident">GeneratorSignals</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneratorSignals(QObject):
    finished = pyqtSignal()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.GeneratorSignals.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator"><code class="flex name class">
<span>class <span class="ident">HousekeepingGenerator</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HousekeepingGenerator:

    def __init__(self):

        self.signals = GeneratorSignals()

        # Convert with info from HK info table
        # Append the new names

        self.data_puller = None
        self.threadpool = QThreadPool()

        # The hk_names_mapping is a dictionary that maps the original device telemetry parameter
        # names to the correct device names as defined in the CGSE. The keys in the mapping are
        # the original device name, the values are the CGSE corrected names

        self.hk_names_mapping = read_conversion_dict(ORIGIN, use_site=False)
        hk_header = self.hk_names_mapping.values()

        # Read from the setup: sensor calibration data (as a NavigableDict)

        self.supply_voltage_calibration = GlobalState.setup.camera.fee.calibration.supply_voltages
        self.temperature_calibration = GlobalState.setup.camera.fee.calibration.temperatures

        self.current_data = DataCollector(
            [HK_TIMESTAMP_NAME, *hk_header]
        )

        self.hk_metrics = define_metrics(ORIGIN, dashboard=&#39;*&#39;)

    def run(self):
        self.start_pulling_data()

    def start_pulling_data(self):
        self.data_puller = worker = DataPuller(
            DPU_SETTINGS.HOSTNAME, DPU_SETTINGS.DATA_DISTRIBUTION_PORT
        )
        worker.signals.data.connect(self.worker_output)
        worker.signals.finished.connect(self.worker_complete)
        worker.signals.error.connect(self.worker_error)
        self.threadpool.start(worker)

    def update_metrics(self):

        for metric_name in self.hk_names_mapping.values():
            # LOGGER.info(f&#34;{metric_name=}&#34;)
            value = self.current_data.get(metric_name)
            if value is not None:
                self.hk_metrics[metric_name].set(value)
            else:
                self.hk_metrics[metric_name].set(float(&#39;nan&#39;))
                LOGGER.log(logging.DEBUG, f&#34;No current data available for {metric_name}.&#34;)

    def send_hk_data_to_storage(self):

        if not any(self.current_data.values()):
            return

        # Translate the HK names (i.e. start using the correct prefix)
        # and append them to the rest of the HK

        self.current_data = convert_hk_names(dict(zip(self.current_data.keys(), self.current_data.values())),
                                             self.hk_names_mapping)
        # Calibration (supply voltages + temperatures)

        calibrated_supply_voltages = get_calibrated_supply_voltages(self.current_data,
                                                                    self.supply_voltage_calibration)
        self.current_data.update(calibrated_supply_voltages)
        calibrated_temperatures = get_calibrated_temperatures(self.current_data, self.temperature_calibration)
        self.current_data.update(calibrated_temperatures)

        with StorageProxy() as storage:

            rc = storage.save(
                {
                    &#34;origin&#34;: ORIGIN,
                    &#34;data&#34;: self.current_data
                }
            )
        if rc and not rc.successful:
            LOGGER.warning(f&#34;Couldn&#39;t save HK data to the Storage manager: {rc}&#34;)

        # Store the calibrated temperatures as synoptics
        # (only when there&#39;s actually something there in the N-FEE HK)

        if len(calibrated_temperatures) &gt; 0:

            calibrated_temperatures[&#34;timestamp&#34;] = self.current_data[HK_TIMESTAMP_NAME]

            with SynopticsManagerProxy() as synoptics:
                synoptics.store_common_synoptics(calibrated_temperatures)

    def worker_output(self, sync_id, data):

        if sync_id == MessageIdentifier.SYNC_TIMECODE:
            self.send_hk_data_to_storage()
            self.update_metrics()
            self.current_data.clear()
            timecode, timestamp = data
            LOGGER.info(f&#34;Timecode: {timecode}&#34;)

            self.current_data.update({&#34;timecode&#34;: timecode, &#34;timecode_ts&#34;: timestamp})

        if sync_id == MessageIdentifier.SYNC_HK_PACKET:
            hk_packet, timestamp = data
            LOGGER.info(f&#34;HK Packet: {hk_packet.type=!s}&#34;)

            self.current_data.update({HK_TIMESTAMP_NAME: timestamp})

            hk_data = HousekeepingData(hk_packet.data)

            for par_name in hk_data:
                self.current_data.update({par_name: hk_data[par_name]})

        if sync_id == MessageIdentifier.NUM_CYCLES:
            LOGGER.info(f&#34;num_cycles: {max(0, data)}&#34;)
            self.current_data.update({&#39;num_cycles&#39;: max(0, data)})

    def worker_complete(self):
        LOGGER.info(&#34;THREAD COMPLETE!&#34;)
        LOGGER.info(f&#34;Number of threads running: {self.threadpool.activeThreadCount()}&#34;)
        self.data_puller = None
        self.signals.finished.emit()

    def worker_error(self, t):
        LOGGER.warning(&#34;ERROR: %s&#34; % t)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.start_pulling_data()</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.send_hk_data_to_storage"><code class="name flex">
<span>def <span class="ident">send_hk_data_to_storage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_hk_data_to_storage(self):

    if not any(self.current_data.values()):
        return

    # Translate the HK names (i.e. start using the correct prefix)
    # and append them to the rest of the HK

    self.current_data = convert_hk_names(dict(zip(self.current_data.keys(), self.current_data.values())),
                                         self.hk_names_mapping)
    # Calibration (supply voltages + temperatures)

    calibrated_supply_voltages = get_calibrated_supply_voltages(self.current_data,
                                                                self.supply_voltage_calibration)
    self.current_data.update(calibrated_supply_voltages)
    calibrated_temperatures = get_calibrated_temperatures(self.current_data, self.temperature_calibration)
    self.current_data.update(calibrated_temperatures)

    with StorageProxy() as storage:

        rc = storage.save(
            {
                &#34;origin&#34;: ORIGIN,
                &#34;data&#34;: self.current_data
            }
        )
    if rc and not rc.successful:
        LOGGER.warning(f&#34;Couldn&#39;t save HK data to the Storage manager: {rc}&#34;)

    # Store the calibrated temperatures as synoptics
    # (only when there&#39;s actually something there in the N-FEE HK)

    if len(calibrated_temperatures) &gt; 0:

        calibrated_temperatures[&#34;timestamp&#34;] = self.current_data[HK_TIMESTAMP_NAME]

        with SynopticsManagerProxy() as synoptics:
            synoptics.store_common_synoptics(calibrated_temperatures)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.start_pulling_data"><code class="name flex">
<span>def <span class="ident">start_pulling_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_pulling_data(self):
    self.data_puller = worker = DataPuller(
        DPU_SETTINGS.HOSTNAME, DPU_SETTINGS.DATA_DISTRIBUTION_PORT
    )
    worker.signals.data.connect(self.worker_output)
    worker.signals.finished.connect(self.worker_complete)
    worker.signals.error.connect(self.worker_error)
    self.threadpool.start(worker)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.update_metrics"><code class="name flex">
<span>def <span class="ident">update_metrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_metrics(self):

    for metric_name in self.hk_names_mapping.values():
        # LOGGER.info(f&#34;{metric_name=}&#34;)
        value = self.current_data.get(metric_name)
        if value is not None:
            self.hk_metrics[metric_name].set(value)
        else:
            self.hk_metrics[metric_name].set(float(&#39;nan&#39;))
            LOGGER.log(logging.DEBUG, f&#34;No current data available for {metric_name}.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.worker_complete"><code class="name flex">
<span>def <span class="ident">worker_complete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker_complete(self):
    LOGGER.info(&#34;THREAD COMPLETE!&#34;)
    LOGGER.info(f&#34;Number of threads running: {self.threadpool.activeThreadCount()}&#34;)
    self.data_puller = None
    self.signals.finished.emit()</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.worker_error"><code class="name flex">
<span>def <span class="ident">worker_error</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker_error(self, t):
    LOGGER.warning(&#34;ERROR: %s&#34; % t)</code></pre>
</details>
</dd>
<dt id="egse.fee.n_fee_hk.HousekeepingGenerator.worker_output"><code class="name flex">
<span>def <span class="ident">worker_output</span></span>(<span>self, sync_id, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def worker_output(self, sync_id, data):

    if sync_id == MessageIdentifier.SYNC_TIMECODE:
        self.send_hk_data_to_storage()
        self.update_metrics()
        self.current_data.clear()
        timecode, timestamp = data
        LOGGER.info(f&#34;Timecode: {timecode}&#34;)

        self.current_data.update({&#34;timecode&#34;: timecode, &#34;timecode_ts&#34;: timestamp})

    if sync_id == MessageIdentifier.SYNC_HK_PACKET:
        hk_packet, timestamp = data
        LOGGER.info(f&#34;HK Packet: {hk_packet.type=!s}&#34;)

        self.current_data.update({HK_TIMESTAMP_NAME: timestamp})

        hk_data = HousekeepingData(hk_packet.data)

        for par_name in hk_data:
            self.current_data.update({par_name: hk_data[par_name]})

    if sync_id == MessageIdentifier.NUM_CYCLES:
        LOGGER.info(f&#34;num_cycles: {max(0, data)}&#34;)
        self.current_data.update({&#39;num_cycles&#39;: max(0, data)})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.hk_generator = HousekeepingGenerator()

        column_names = self.hk_generator.current_data.keys()
        register_to_storage_manager(ORIGIN, CSV, prep=dict(mode=&#39;a&#39;, column_names=column_names))

        self.hk_generator.signals.finished.connect(self.close)
        self.hk_generator.run()

        LOGGER.info(&#34;Initialised MainWindow&#34;)

    def closeEvent(self, event: QCloseEvent) -&gt; None:
        LOGGER.info(f&#34;closeEvent called...{event=}&#34;)

        if self.hk_generator.data_puller:
            self.hk_generator.data_puller.quit()
        else:
            LOGGER.info(&#34;Data Puller was already terminated.&#34;)

        time.sleep(TIMEOUT)
        unregister_from_storage_manager(ORIGIN)
        LOGGER.info(&#34;AFTER UNREGISTER STORAGE&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.MainWindow.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>closeEvent(self, QCloseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, event: QCloseEvent) -&gt; None:
    LOGGER.info(f&#34;closeEvent called...{event=}&#34;)

    if self.hk_generator.data_puller:
        self.hk_generator.data_puller.quit()
    else:
        LOGGER.info(&#34;Data Puller was already terminated.&#34;)

    time.sleep(TIMEOUT)
    unregister_from_storage_manager(ORIGIN)
    LOGGER.info(&#34;AFTER UNREGISTER STORAGE&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.fee.n_fee_hk.WorkerSignals"><code class="flex name class">
<span>class <span class="ident">WorkerSignals</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the signals available from a running worker thread.</p>
<p>Supported signals are:</p>
<p>finished
No data</p>
<p>error
'str' Exception string</p>
<p>data
'object' data returned from processing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkerSignals(QObject):
    &#34;&#34;&#34;
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        &#39;str&#39; Exception string

    data
        &#39;object&#39; data returned from processing

    &#34;&#34;&#34;

    finished = pyqtSignal()
    error = pyqtSignal(str)
    data = pyqtSignal(int, object)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.fee.n_fee_hk.WorkerSignals.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.fee.n_fee_hk.WorkerSignals.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.fee.n_fee_hk.WorkerSignals.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.fee" href="index.html">egse.fee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.callendar_van_dusen" href="#egse.fee.n_fee_hk.callendar_van_dusen">callendar_van_dusen</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.counts_to_resistance" href="#egse.fee.n_fee_hk.counts_to_resistance">counts_to_resistance</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.counts_to_temperature" href="#egse.fee.n_fee_hk.counts_to_temperature">counts_to_temperature</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_supply_voltages" href="#egse.fee.n_fee_hk.get_calibrated_supply_voltages">get_calibrated_supply_voltages</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_temperatures" href="#egse.fee.n_fee_hk.get_calibrated_temperatures">get_calibrated_temperatures</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.get_calibrated_temperatures_for_type" href="#egse.fee.n_fee_hk.get_calibrated_temperatures_for_type">get_calibrated_temperatures_for_type</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.resistance_to_temperature" href="#egse.fee.n_fee_hk.resistance_to_temperature">resistance_to_temperature</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.send_request" href="#egse.fee.n_fee_hk.send_request">send_request</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.solve_temperature" href="#egse.fee.n_fee_hk.solve_temperature">solve_temperature</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.fee.n_fee_hk.DataCollector" href="#egse.fee.n_fee_hk.DataCollector">DataCollector</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.DataCollector.clear" href="#egse.fee.n_fee_hk.DataCollector.clear">clear</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.get" href="#egse.fee.n_fee_hk.DataCollector.get">get</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.keys" href="#egse.fee.n_fee_hk.DataCollector.keys">keys</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.update" href="#egse.fee.n_fee_hk.DataCollector.update">update</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataCollector.values" href="#egse.fee.n_fee_hk.DataCollector.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.DataPuller" href="#egse.fee.n_fee_hk.DataPuller">DataPuller</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.DataPuller.quit" href="#egse.fee.n_fee_hk.DataPuller.quit">quit</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.DataPuller.run" href="#egse.fee.n_fee_hk.DataPuller.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.GeneratorSignals" href="#egse.fee.n_fee_hk.GeneratorSignals">GeneratorSignals</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.GeneratorSignals.finished" href="#egse.fee.n_fee_hk.GeneratorSignals.finished">finished</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator" href="#egse.fee.n_fee_hk.HousekeepingGenerator">HousekeepingGenerator</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.run" href="#egse.fee.n_fee_hk.HousekeepingGenerator.run">run</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.send_hk_data_to_storage" href="#egse.fee.n_fee_hk.HousekeepingGenerator.send_hk_data_to_storage">send_hk_data_to_storage</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.start_pulling_data" href="#egse.fee.n_fee_hk.HousekeepingGenerator.start_pulling_data">start_pulling_data</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.update_metrics" href="#egse.fee.n_fee_hk.HousekeepingGenerator.update_metrics">update_metrics</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.worker_complete" href="#egse.fee.n_fee_hk.HousekeepingGenerator.worker_complete">worker_complete</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.worker_error" href="#egse.fee.n_fee_hk.HousekeepingGenerator.worker_error">worker_error</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.HousekeepingGenerator.worker_output" href="#egse.fee.n_fee_hk.HousekeepingGenerator.worker_output">worker_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.MainWindow" href="#egse.fee.n_fee_hk.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.MainWindow.closeEvent" href="#egse.fee.n_fee_hk.MainWindow.closeEvent">closeEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.fee.n_fee_hk.WorkerSignals" href="#egse.fee.n_fee_hk.WorkerSignals">WorkerSignals</a></code></h4>
<ul class="">
<li><code><a title="egse.fee.n_fee_hk.WorkerSignals.data" href="#egse.fee.n_fee_hk.WorkerSignals.data">data</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.WorkerSignals.error" href="#egse.fee.n_fee_hk.WorkerSignals.error">error</a></code></li>
<li><code><a title="egse.fee.n_fee_hk.WorkerSignals.finished" href="#egse.fee.n_fee_hk.WorkerSignals.finished">finished</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
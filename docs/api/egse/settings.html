<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.settings API documentation</title>
<meta name="description" content="The Settings class handles user and configuration settings that are provided in
a [`YAML`](http://yaml.org) file …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.settings</code></h1>
</header>
<section id="section-intro">
<p>The Settings class handles user and configuration settings that are provided in
a <a href="http://yaml.org"><code>YAML</code></a> file.</p>
<p>The idea is that settings are grouped by components or any arbitrary grouping that makes sense for
the application or for the user. The Settings class can read from different YAML files. By default,
settings are loaded from a file called <code>settings.yaml</code>. The default yaml configuration file is
located in the same directory as this module.</p>
<p>The YAML file is read and the configuration parameters for the given group are
made available as instance variables of the returned class.</p>
<p>The intended use is as follows:</p>
<pre><code>from egse.settings import Settings

dsi_settings = Settings.load("DSI")

if (dsi_settings.RMAP_BASE_ADDRESS
    &lt;= addr
    &lt; dsi_settings.RMAP_BASE_ADDRESS + dsi_settings.RMAP_MEMORY_SIZE):
    # do something here
else:
    raise RMAPError("Attempt to access outside the RMAP memory map.")
</code></pre>
<p>The above code reads the settings from the default YAML file for a group called <code>DSI</code>.
The settings will then be available as variables of the returned class, in this case
<code>dsi_settings</code>. The returned class is and behaves also like a dictionary, so you can check
if a configuration parameter is defined like this:</p>
<pre><code>if "DSI_FEE_IP_ADDRESS" not in dsi_settings:
    # define the IP address of the DSI
</code></pre>
<p>The YAML section for the above code looks like this:</p>
<pre><code>DSI:

    # DSI Specific Settings

    DSI_FEE_IP_ADDRESS  10.33.178.144   # IP address of the DSI EtherSpaceLink interface
    LINK_SPEED:                   100   # SpW link speed used for both up- and downlink

    # RMAP Specific Settings

    RMAP_BASE_ADDRESS:     0x00000000   # The start of the RMAP memory map managed by the FEE
    RMAP_MEMORY_SIZE:            4096   # The size of the RMAP memory map managed by the FEE
</code></pre>
<p>When you want to read settings from another YAML file, specify the <code>filename=</code> keyword.
If that file is located at a specific location, also use the <code>location=</code> keyword.</p>
<pre><code>my_settings = Settings.load(filename="user.yaml", location="/Users/JohnDoe")
</code></pre>
<p>The above code will read the complete YAML file, i.e. all the groups into a dictionary.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Settings class handles user and configuration settings that are provided in
a [`YAML`](http://yaml.org) file.

The idea is that settings are grouped by components or any arbitrary grouping that makes sense for
the application or for the user. The Settings class can read from different YAML files. By default,
settings are loaded from a file called ``settings.yaml``. The default yaml configuration file is
located in the same directory as this module.

The YAML file is read and the configuration parameters for the given group are
made available as instance variables of the returned class.

The intended use is as follows:

    from egse.settings import Settings

    dsi_settings = Settings.load(&#34;DSI&#34;)

    if (dsi_settings.RMAP_BASE_ADDRESS
        &lt;= addr
        &lt; dsi_settings.RMAP_BASE_ADDRESS + dsi_settings.RMAP_MEMORY_SIZE):
        # do something here
    else:
        raise RMAPError(&#34;Attempt to access outside the RMAP memory map.&#34;)


The above code reads the settings from the default YAML file for a group called ``DSI``.
The settings will then be available as variables of the returned class, in this case
``dsi_settings``. The returned class is and behaves also like a dictionary, so you can check
if a configuration parameter is defined like this:

    if &#34;DSI_FEE_IP_ADDRESS&#34; not in dsi_settings:
        # define the IP address of the DSI

The YAML section for the above code looks like this:

    DSI:

        # DSI Specific Settings

        DSI_FEE_IP_ADDRESS  10.33.178.144   # IP address of the DSI EtherSpaceLink interface
        LINK_SPEED:                   100   # SpW link speed used for both up- and downlink

        # RMAP Specific Settings

        RMAP_BASE_ADDRESS:     0x00000000   # The start of the RMAP memory map managed by the FEE
        RMAP_MEMORY_SIZE:            4096   # The size of the RMAP memory map managed by the FEE

When you want to read settings from another YAML file, specify the ``filename=`` keyword.
If that file is located at a specific location, also use the ``location=`` keyword.

    my_settings = Settings.load(filename=&#34;user.yaml&#34;, location=&#34;/Users/JohnDoe&#34;)

The above code will read the complete YAML file, i.e. all the groups into a dictionary.

&#34;&#34;&#34;

import logging
import os
import pathlib
import re

import yaml  # This module is provided by the pip package PyYaml - pip install pyyaml

from egse.env import ENV_PLATO_LOCAL_SETTINGS
from egse.exceptions import FileIsEmptyError
from egse.system import AttributeDict
from egse.system import get_caller_info
from egse.system import recursive_dict_update

logger = logging.getLogger(__name__)


class SettingsError(Exception):
    pass


def is_defined(cls, name):
    return hasattr(cls, name)


def get_attr_value(cls, name, default=None):
    try:
        return getattr(cls, name)
    except AttributeError:
        return default


def set_attr_value(cls, name, value):
    if hasattr(cls, name):
        raise KeyError(f&#34;Overwriting setting {name} with {value}, was {hasattr(cls, name)}&#34;)


# Fix the problem: YAML loads 5e-6 as string and not a number
# https://stackoverflow.com/questions/30458977/yaml-loads-5e-6-as-string-and-not-a-number

SAFE_LOADER = yaml.SafeLoader
SAFE_LOADER.add_implicit_resolver(
    u&#39;tag:yaml.org,2002:float&#39;,
    re.compile(u&#34;&#34;&#34;^(?:
     [-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+]?[0-9]+)?
    |[-+]?(?:[0-9][0-9_]*)(?:[eE][-+]?[0-9]+)
    |\\.[0-9_]+(?:[eE][-+][0-9]+)?
    |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*
    |[-+]?\\.(?:inf|Inf|INF)
    |\\.(?:nan|NaN|NAN))$&#34;&#34;&#34;, re.X),
    list(u&#39;-+0123456789.&#39;))


class Settings:
    &#34;&#34;&#34;
    The Settings class provides a load() method that loads configuration settings for a group
    into a dynamically created class as instance variables.
    &#34;&#34;&#34;

    __memoized_yaml = {}  # Memoized settings yaml files

    __profile = False  # Used for profiling methods and functions
    __simulation = False  # Use simulation mode where applicable and possible

    LOG_FORMAT_DEFAULT = &#34;%(levelname)s:%(module)s:%(lineno)d:%(message)s&#34;
    LOG_FORMAT_FULL = &#34;%(asctime)23s:%(levelname)8s:%(lineno)5d:%(name)-20s: %(message)s&#34;
    LOG_FORMAT_THREAD = (
        &#34;%(asctime)23s:%(levelname)7s:%(lineno)5d:%(name)-20s(%(threadName)-15s): %(message)s&#34;
    )
    LOG_FORMAT_PROCESS = (
        &#34;%(asctime)23s:%(levelname)7s:%(lineno)5d:%(name)20s.%(funcName)-31s(%(processName)-20s): &#34;
        &#34;%(message)s&#34;
    )
    LOG_FORMAT_DATE = &#34;%d/%m/%Y %H:%M:%S&#34;

    @classmethod
    def read_configuration_file(cls, filename: str, *, force=False):
        &#34;&#34;&#34;
        Read the YAML input configuration file. The configuration file is only read
        once and memoized as load optimization.

        Args:
            filename (str): the fully qualified filename of the YAML file
            force (bool): force reloading the file

        Returns:
            a dictionary containing all the configuration settings from the YAML file.
        &#34;&#34;&#34;
        if force or filename not in cls.__memoized_yaml:

            logger.debug(f&#34;Parsing YAML configuration file {filename}.&#34;)

            with open(filename, &#34;r&#34;) as stream:
                try:
                    yaml_document = yaml.load(stream, Loader=SAFE_LOADER)
                except yaml.YAMLError as exc:
                    logger.error(exc)
                    raise SettingsError(f&#34;Error loading YAML document {filename}&#34;) from exc

            cls.__memoized_yaml[filename] = yaml_document

        return cls.__memoized_yaml[filename]

    @classmethod
    def get_memoized_locations(cls):
        return cls.__memoized_yaml.keys()

    @classmethod
    def load(cls, group_name=None, filename=&#34;settings.yaml&#34;, location=None, *, force=False,
             add_local_settings=True):
        &#34;&#34;&#34;
        Load the settings for the given group from YAML configuration file.
        When no group is provided, the complete configuration is returned.

        The default YAML file is &#39;settings.yaml&#39; and is located in the same directory
        as the settings module.

        About the ``location`` keyword several options are available.

        * when no location is given, i.e. ``location=None``, the YAML settings file is searched for
          at the same location as the settings module.

        * when a relative location is given, the YAML settings file is searched for relative to the
          current working directory.

        * when an absolute location is given, that location is used &#39;as is&#39;.

        Args:
            group_name (str): the name of one of the main groups from the YAML file
            filename (str): the name of the YAML file to read
            location (str): the path to the location of the YAML file
            force (bool): force reloading the file
            add_local_settings (bool): update the Settings with site specific local settings

        Returns:
            a dynamically created class with the configuration parameters as instance variables.

        Raises:
            a SettingsError when the group is not defined in the YAML file.
        &#34;&#34;&#34;

        _THIS_FILE_LOCATION = pathlib.Path(__file__).resolve().parent

        if location is None:

            # Check if the yaml file is located at the location of the caller,
            # if not, use the file that is located where the Settings module is located.

            caller_dir = get_caller_info(level=2).filename
            caller_dir = pathlib.Path(caller_dir).resolve().parent

            if (caller_dir / filename).is_file():
                yaml_location = caller_dir
            else:
                yaml_location = _THIS_FILE_LOCATION
        else:

            # The location was given as an argument

            yaml_location = pathlib.Path(location).resolve()

        logger.log(5, f&#34;yaml_location in Settings.load(location={location}) is {yaml_location}&#34;)

        # Load the YAML global document

        try:
            yaml_document_global = cls.read_configuration_file(
                yaml_location / filename, force=force
            )
        except FileNotFoundError as exc:
            raise SettingsError(
                f&#34;Filename {filename} not found at location {yaml_location}.&#34;
            ) from exc

        # Check if there were any groups defined in the YAML document

        if not yaml_document_global:
            raise SettingsError(f&#34;Empty YAML document {filename} at {yaml_location}.&#34;)

        # Load the LOCAL settings YAML file

        if add_local_settings:
            try:
                local_settings_location = os.environ[ENV_PLATO_LOCAL_SETTINGS]
                logger.log(5, f&#34;Using {ENV_PLATO_LOCAL_SETTINGS} to update global settings.&#34;)
                try:
                    yaml_document_local = cls.read_configuration_file(
                        local_settings_location, force=force
                    )
                    if yaml_document_local is None:
                        raise FileIsEmptyError()
                    local_settings = AttributeDict(
                        {name: value for name, value in yaml_document_local.items()}
                    )
                except FileNotFoundError as exc:
                    raise SettingsError(
                        f&#34;Local settings YAML file &#39;{local_settings_location}&#39; not found. &#34;
                        f&#34;Check your environment variable {ENV_PLATO_LOCAL_SETTINGS}.&#34;
                    ) from exc
                except FileIsEmptyError as exc:
                    logger.warning(f&#34;Local settings YAML file &#39;{local_settings_location}&#39; is empty. &#34;
                                   f&#34;No local settings were loaded.&#34;)
                    local_settings = {}
            except KeyError:
                logger.debug(f&#34;The environment variable {ENV_PLATO_LOCAL_SETTINGS} is not defined.&#34;)
                local_settings = {}

        if group_name in (None, &#34;&#34;):
            global_settings = AttributeDict(
                {name: value for name, value in yaml_document_global.items()}
            )
            if add_local_settings:
                recursive_dict_update(global_settings, local_settings)
            return global_settings

        # Check if the requested group is defined in the YAML document

        if group_name not in yaml_document_global:
            raise SettingsError(
                f&#34;Group name &#39;{group_name}&#39; is not defined in the YAML &#34;
                f&#34;document &#39;{filename}&#39; at &#39;{yaml_location}.&#34;
            )

        # Check if the group has any settings

        if not yaml_document_global[group_name]:
            raise SettingsError(f&#34;Empty group in YAML document {filename} at {yaml_location}.&#34;)

        group_settings = AttributeDict(
            {name: value for name, value in yaml_document_global[group_name].items()}
        )

        if add_local_settings and group_name in local_settings:
            recursive_dict_update(group_settings, local_settings[group_name])

        return group_settings

    @classmethod
    def to_string(cls):
        &#34;&#34;&#34;
        Returns a simple string representation of the cached configuration of this Settings class.
        &#34;&#34;&#34;
        memoized = cls.__memoized_yaml

        msg = &#34;&#34;
        for key in memoized.keys():
            msg += f&#34;YAML file: {key}\n&#34;
            for field in memoized[key].keys():
                length = 60
                line = str(memoized[key][field])
                trunc = line[:length]
                if len(line) &gt; length:
                    trunc += &#34; ...&#34;
                msg += f&#34;   {field}: {trunc}\n&#34;

        return msg

    @classmethod
    def set_profiling(cls, flag):
        cls.__profile = flag

    @classmethod
    def profiling(cls):
        return cls.__profile

    @classmethod
    def set_simulation_mode(cls, flag: bool) -&gt; bool:
        cls.__simulation = flag

    @classmethod
    def simulation_mode(cls) -&gt; bool:
        return cls.__simulation


if __name__ == &#34;__main__&#34;:

    # We provide convenience to inspect the settings by calling this module directly from Python.
    #
    # python -m egse.settings
    #
    # Use the &#39;--help&#39; option to see the what your choices are.

    logging.basicConfig(level=20)

    import argparse

    parser = argparse.ArgumentParser(
        description=(
            f&#34;Print out the default Settings, updated with local settings if the &#34;
            f&#34;{ENV_PLATO_LOCAL_SETTINGS} environment variable is set.&#34;
        ),
    )
    parser.add_argument(&#34;--local&#34;, action=&#34;store_true&#34;, help=&#34;print only the local settings.&#34;)
    args = parser.parse_args()

    # The following import will activate the pretty printing of the AttributeDict
    # through the __rich__ method.

    from rich import print

    if args.local:
        location = os.environ.get(ENV_PLATO_LOCAL_SETTINGS)
        if location:
            settings = Settings.load(filename=location)
            print(settings)
            print(f&#34;Loaded from [purple]{location}.&#34;)
        else:
            print(&#34;[red]No local settings defined.&#34;)
    else:
        settings = Settings.load()
        print(settings)
        print(&#34;[blue]Memoized locations:&#34;)
        locations = Settings.get_memoized_locations()
        print([str(loc) for loc in locations])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.settings.get_attr_value"><code class="name flex">
<span>def <span class="ident">get_attr_value</span></span>(<span>cls, name, default=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attr_value(cls, name, default=None):
    try:
        return getattr(cls, name)
    except AttributeError:
        return default</code></pre>
</details>
</dd>
<dt id="egse.settings.is_defined"><code class="name flex">
<span>def <span class="ident">is_defined</span></span>(<span>cls, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_defined(cls, name):
    return hasattr(cls, name)</code></pre>
</details>
</dd>
<dt id="egse.settings.set_attr_value"><code class="name flex">
<span>def <span class="ident">set_attr_value</span></span>(<span>cls, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attr_value(cls, name, value):
    if hasattr(cls, name):
        raise KeyError(f&#34;Overwriting setting {name} with {value}, was {hasattr(cls, name)}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.settings.Settings"><code class="flex name class">
<span>class <span class="ident">Settings</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Settings class provides a load() method that loads configuration settings for a group
into a dynamically created class as instance variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Settings:
    &#34;&#34;&#34;
    The Settings class provides a load() method that loads configuration settings for a group
    into a dynamically created class as instance variables.
    &#34;&#34;&#34;

    __memoized_yaml = {}  # Memoized settings yaml files

    __profile = False  # Used for profiling methods and functions
    __simulation = False  # Use simulation mode where applicable and possible

    LOG_FORMAT_DEFAULT = &#34;%(levelname)s:%(module)s:%(lineno)d:%(message)s&#34;
    LOG_FORMAT_FULL = &#34;%(asctime)23s:%(levelname)8s:%(lineno)5d:%(name)-20s: %(message)s&#34;
    LOG_FORMAT_THREAD = (
        &#34;%(asctime)23s:%(levelname)7s:%(lineno)5d:%(name)-20s(%(threadName)-15s): %(message)s&#34;
    )
    LOG_FORMAT_PROCESS = (
        &#34;%(asctime)23s:%(levelname)7s:%(lineno)5d:%(name)20s.%(funcName)-31s(%(processName)-20s): &#34;
        &#34;%(message)s&#34;
    )
    LOG_FORMAT_DATE = &#34;%d/%m/%Y %H:%M:%S&#34;

    @classmethod
    def read_configuration_file(cls, filename: str, *, force=False):
        &#34;&#34;&#34;
        Read the YAML input configuration file. The configuration file is only read
        once and memoized as load optimization.

        Args:
            filename (str): the fully qualified filename of the YAML file
            force (bool): force reloading the file

        Returns:
            a dictionary containing all the configuration settings from the YAML file.
        &#34;&#34;&#34;
        if force or filename not in cls.__memoized_yaml:

            logger.debug(f&#34;Parsing YAML configuration file {filename}.&#34;)

            with open(filename, &#34;r&#34;) as stream:
                try:
                    yaml_document = yaml.load(stream, Loader=SAFE_LOADER)
                except yaml.YAMLError as exc:
                    logger.error(exc)
                    raise SettingsError(f&#34;Error loading YAML document {filename}&#34;) from exc

            cls.__memoized_yaml[filename] = yaml_document

        return cls.__memoized_yaml[filename]

    @classmethod
    def get_memoized_locations(cls):
        return cls.__memoized_yaml.keys()

    @classmethod
    def load(cls, group_name=None, filename=&#34;settings.yaml&#34;, location=None, *, force=False,
             add_local_settings=True):
        &#34;&#34;&#34;
        Load the settings for the given group from YAML configuration file.
        When no group is provided, the complete configuration is returned.

        The default YAML file is &#39;settings.yaml&#39; and is located in the same directory
        as the settings module.

        About the ``location`` keyword several options are available.

        * when no location is given, i.e. ``location=None``, the YAML settings file is searched for
          at the same location as the settings module.

        * when a relative location is given, the YAML settings file is searched for relative to the
          current working directory.

        * when an absolute location is given, that location is used &#39;as is&#39;.

        Args:
            group_name (str): the name of one of the main groups from the YAML file
            filename (str): the name of the YAML file to read
            location (str): the path to the location of the YAML file
            force (bool): force reloading the file
            add_local_settings (bool): update the Settings with site specific local settings

        Returns:
            a dynamically created class with the configuration parameters as instance variables.

        Raises:
            a SettingsError when the group is not defined in the YAML file.
        &#34;&#34;&#34;

        _THIS_FILE_LOCATION = pathlib.Path(__file__).resolve().parent

        if location is None:

            # Check if the yaml file is located at the location of the caller,
            # if not, use the file that is located where the Settings module is located.

            caller_dir = get_caller_info(level=2).filename
            caller_dir = pathlib.Path(caller_dir).resolve().parent

            if (caller_dir / filename).is_file():
                yaml_location = caller_dir
            else:
                yaml_location = _THIS_FILE_LOCATION
        else:

            # The location was given as an argument

            yaml_location = pathlib.Path(location).resolve()

        logger.log(5, f&#34;yaml_location in Settings.load(location={location}) is {yaml_location}&#34;)

        # Load the YAML global document

        try:
            yaml_document_global = cls.read_configuration_file(
                yaml_location / filename, force=force
            )
        except FileNotFoundError as exc:
            raise SettingsError(
                f&#34;Filename {filename} not found at location {yaml_location}.&#34;
            ) from exc

        # Check if there were any groups defined in the YAML document

        if not yaml_document_global:
            raise SettingsError(f&#34;Empty YAML document {filename} at {yaml_location}.&#34;)

        # Load the LOCAL settings YAML file

        if add_local_settings:
            try:
                local_settings_location = os.environ[ENV_PLATO_LOCAL_SETTINGS]
                logger.log(5, f&#34;Using {ENV_PLATO_LOCAL_SETTINGS} to update global settings.&#34;)
                try:
                    yaml_document_local = cls.read_configuration_file(
                        local_settings_location, force=force
                    )
                    if yaml_document_local is None:
                        raise FileIsEmptyError()
                    local_settings = AttributeDict(
                        {name: value for name, value in yaml_document_local.items()}
                    )
                except FileNotFoundError as exc:
                    raise SettingsError(
                        f&#34;Local settings YAML file &#39;{local_settings_location}&#39; not found. &#34;
                        f&#34;Check your environment variable {ENV_PLATO_LOCAL_SETTINGS}.&#34;
                    ) from exc
                except FileIsEmptyError as exc:
                    logger.warning(f&#34;Local settings YAML file &#39;{local_settings_location}&#39; is empty. &#34;
                                   f&#34;No local settings were loaded.&#34;)
                    local_settings = {}
            except KeyError:
                logger.debug(f&#34;The environment variable {ENV_PLATO_LOCAL_SETTINGS} is not defined.&#34;)
                local_settings = {}

        if group_name in (None, &#34;&#34;):
            global_settings = AttributeDict(
                {name: value for name, value in yaml_document_global.items()}
            )
            if add_local_settings:
                recursive_dict_update(global_settings, local_settings)
            return global_settings

        # Check if the requested group is defined in the YAML document

        if group_name not in yaml_document_global:
            raise SettingsError(
                f&#34;Group name &#39;{group_name}&#39; is not defined in the YAML &#34;
                f&#34;document &#39;{filename}&#39; at &#39;{yaml_location}.&#34;
            )

        # Check if the group has any settings

        if not yaml_document_global[group_name]:
            raise SettingsError(f&#34;Empty group in YAML document {filename} at {yaml_location}.&#34;)

        group_settings = AttributeDict(
            {name: value for name, value in yaml_document_global[group_name].items()}
        )

        if add_local_settings and group_name in local_settings:
            recursive_dict_update(group_settings, local_settings[group_name])

        return group_settings

    @classmethod
    def to_string(cls):
        &#34;&#34;&#34;
        Returns a simple string representation of the cached configuration of this Settings class.
        &#34;&#34;&#34;
        memoized = cls.__memoized_yaml

        msg = &#34;&#34;
        for key in memoized.keys():
            msg += f&#34;YAML file: {key}\n&#34;
            for field in memoized[key].keys():
                length = 60
                line = str(memoized[key][field])
                trunc = line[:length]
                if len(line) &gt; length:
                    trunc += &#34; ...&#34;
                msg += f&#34;   {field}: {trunc}\n&#34;

        return msg

    @classmethod
    def set_profiling(cls, flag):
        cls.__profile = flag

    @classmethod
    def profiling(cls):
        return cls.__profile

    @classmethod
    def set_simulation_mode(cls, flag: bool) -&gt; bool:
        cls.__simulation = flag

    @classmethod
    def simulation_mode(cls) -&gt; bool:
        return cls.__simulation</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="egse.settings.Settings.LOG_FORMAT_DATE"><code class="name">var <span class="ident">LOG_FORMAT_DATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.settings.Settings.LOG_FORMAT_DEFAULT"><code class="name">var <span class="ident">LOG_FORMAT_DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.settings.Settings.LOG_FORMAT_FULL"><code class="name">var <span class="ident">LOG_FORMAT_FULL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.settings.Settings.LOG_FORMAT_PROCESS"><code class="name">var <span class="ident">LOG_FORMAT_PROCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.settings.Settings.LOG_FORMAT_THREAD"><code class="name">var <span class="ident">LOG_FORMAT_THREAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="egse.settings.Settings.get_memoized_locations"><code class="name flex">
<span>def <span class="ident">get_memoized_locations</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_memoized_locations(cls):
    return cls.__memoized_yaml.keys()</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>group_name=None, filename='settings.yaml', location=None, *, force=False, add_local_settings=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the settings for the given group from YAML configuration file.
When no group is provided, the complete configuration is returned.</p>
<p>The default YAML file is 'settings.yaml' and is located in the same directory
as the settings module.</p>
<p>About the <code>location</code> keyword several options are available.</p>
<ul>
<li>
<p>when no location is given, i.e. <code>location=None</code>, the YAML settings file is searched for
at the same location as the settings module.</p>
</li>
<li>
<p>when a relative location is given, the YAML settings file is searched for relative to the
current working directory.</p>
</li>
<li>
<p>when an absolute location is given, that location is used 'as is'.</p>
</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of one of the main groups from the YAML file</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the YAML file to read</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to the location of the YAML file</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code></dt>
<dd>force reloading the file</dd>
<dt><strong><code>add_local_settings</code></strong> :&ensp;<code>bool</code></dt>
<dd>update the Settings with site specific local settings</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a dynamically created class with the configuration parameters as instance variables.</p>
<h2 id="raises">Raises</h2>
<p>a SettingsError when the group is not defined in the YAML file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, group_name=None, filename=&#34;settings.yaml&#34;, location=None, *, force=False,
         add_local_settings=True):
    &#34;&#34;&#34;
    Load the settings for the given group from YAML configuration file.
    When no group is provided, the complete configuration is returned.

    The default YAML file is &#39;settings.yaml&#39; and is located in the same directory
    as the settings module.

    About the ``location`` keyword several options are available.

    * when no location is given, i.e. ``location=None``, the YAML settings file is searched for
      at the same location as the settings module.

    * when a relative location is given, the YAML settings file is searched for relative to the
      current working directory.

    * when an absolute location is given, that location is used &#39;as is&#39;.

    Args:
        group_name (str): the name of one of the main groups from the YAML file
        filename (str): the name of the YAML file to read
        location (str): the path to the location of the YAML file
        force (bool): force reloading the file
        add_local_settings (bool): update the Settings with site specific local settings

    Returns:
        a dynamically created class with the configuration parameters as instance variables.

    Raises:
        a SettingsError when the group is not defined in the YAML file.
    &#34;&#34;&#34;

    _THIS_FILE_LOCATION = pathlib.Path(__file__).resolve().parent

    if location is None:

        # Check if the yaml file is located at the location of the caller,
        # if not, use the file that is located where the Settings module is located.

        caller_dir = get_caller_info(level=2).filename
        caller_dir = pathlib.Path(caller_dir).resolve().parent

        if (caller_dir / filename).is_file():
            yaml_location = caller_dir
        else:
            yaml_location = _THIS_FILE_LOCATION
    else:

        # The location was given as an argument

        yaml_location = pathlib.Path(location).resolve()

    logger.log(5, f&#34;yaml_location in Settings.load(location={location}) is {yaml_location}&#34;)

    # Load the YAML global document

    try:
        yaml_document_global = cls.read_configuration_file(
            yaml_location / filename, force=force
        )
    except FileNotFoundError as exc:
        raise SettingsError(
            f&#34;Filename {filename} not found at location {yaml_location}.&#34;
        ) from exc

    # Check if there were any groups defined in the YAML document

    if not yaml_document_global:
        raise SettingsError(f&#34;Empty YAML document {filename} at {yaml_location}.&#34;)

    # Load the LOCAL settings YAML file

    if add_local_settings:
        try:
            local_settings_location = os.environ[ENV_PLATO_LOCAL_SETTINGS]
            logger.log(5, f&#34;Using {ENV_PLATO_LOCAL_SETTINGS} to update global settings.&#34;)
            try:
                yaml_document_local = cls.read_configuration_file(
                    local_settings_location, force=force
                )
                if yaml_document_local is None:
                    raise FileIsEmptyError()
                local_settings = AttributeDict(
                    {name: value for name, value in yaml_document_local.items()}
                )
            except FileNotFoundError as exc:
                raise SettingsError(
                    f&#34;Local settings YAML file &#39;{local_settings_location}&#39; not found. &#34;
                    f&#34;Check your environment variable {ENV_PLATO_LOCAL_SETTINGS}.&#34;
                ) from exc
            except FileIsEmptyError as exc:
                logger.warning(f&#34;Local settings YAML file &#39;{local_settings_location}&#39; is empty. &#34;
                               f&#34;No local settings were loaded.&#34;)
                local_settings = {}
        except KeyError:
            logger.debug(f&#34;The environment variable {ENV_PLATO_LOCAL_SETTINGS} is not defined.&#34;)
            local_settings = {}

    if group_name in (None, &#34;&#34;):
        global_settings = AttributeDict(
            {name: value for name, value in yaml_document_global.items()}
        )
        if add_local_settings:
            recursive_dict_update(global_settings, local_settings)
        return global_settings

    # Check if the requested group is defined in the YAML document

    if group_name not in yaml_document_global:
        raise SettingsError(
            f&#34;Group name &#39;{group_name}&#39; is not defined in the YAML &#34;
            f&#34;document &#39;{filename}&#39; at &#39;{yaml_location}.&#34;
        )

    # Check if the group has any settings

    if not yaml_document_global[group_name]:
        raise SettingsError(f&#34;Empty group in YAML document {filename} at {yaml_location}.&#34;)

    group_settings = AttributeDict(
        {name: value for name, value in yaml_document_global[group_name].items()}
    )

    if add_local_settings and group_name in local_settings:
        recursive_dict_update(group_settings, local_settings[group_name])

    return group_settings</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.profiling"><code class="name flex">
<span>def <span class="ident">profiling</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def profiling(cls):
    return cls.__profile</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.read_configuration_file"><code class="name flex">
<span>def <span class="ident">read_configuration_file</span></span>(<span>filename: str, *, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the YAML input configuration file. The configuration file is only read
once and memoized as load optimization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>the fully qualified filename of the YAML file</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code></dt>
<dd>force reloading the file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a dictionary containing all the configuration settings from the YAML file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def read_configuration_file(cls, filename: str, *, force=False):
    &#34;&#34;&#34;
    Read the YAML input configuration file. The configuration file is only read
    once and memoized as load optimization.

    Args:
        filename (str): the fully qualified filename of the YAML file
        force (bool): force reloading the file

    Returns:
        a dictionary containing all the configuration settings from the YAML file.
    &#34;&#34;&#34;
    if force or filename not in cls.__memoized_yaml:

        logger.debug(f&#34;Parsing YAML configuration file {filename}.&#34;)

        with open(filename, &#34;r&#34;) as stream:
            try:
                yaml_document = yaml.load(stream, Loader=SAFE_LOADER)
            except yaml.YAMLError as exc:
                logger.error(exc)
                raise SettingsError(f&#34;Error loading YAML document {filename}&#34;) from exc

        cls.__memoized_yaml[filename] = yaml_document

    return cls.__memoized_yaml[filename]</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.set_profiling"><code class="name flex">
<span>def <span class="ident">set_profiling</span></span>(<span>flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_profiling(cls, flag):
    cls.__profile = flag</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.set_simulation_mode"><code class="name flex">
<span>def <span class="ident">set_simulation_mode</span></span>(<span>flag: bool) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_simulation_mode(cls, flag: bool) -&gt; bool:
    cls.__simulation = flag</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.simulation_mode"><code class="name flex">
<span>def <span class="ident">simulation_mode</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def simulation_mode(cls) -&gt; bool:
    return cls.__simulation</code></pre>
</details>
</dd>
<dt id="egse.settings.Settings.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a simple string representation of the cached configuration of this Settings class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def to_string(cls):
    &#34;&#34;&#34;
    Returns a simple string representation of the cached configuration of this Settings class.
    &#34;&#34;&#34;
    memoized = cls.__memoized_yaml

    msg = &#34;&#34;
    for key in memoized.keys():
        msg += f&#34;YAML file: {key}\n&#34;
        for field in memoized[key].keys():
            length = 60
            line = str(memoized[key][field])
            trunc = line[:length]
            if len(line) &gt; length:
                trunc += &#34; ...&#34;
            msg += f&#34;   {field}: {trunc}\n&#34;

    return msg</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.settings.SettingsError"><code class="flex name class">
<span>class <span class="ident">SettingsError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SettingsError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.settings.get_attr_value" href="#egse.settings.get_attr_value">get_attr_value</a></code></li>
<li><code><a title="egse.settings.is_defined" href="#egse.settings.is_defined">is_defined</a></code></li>
<li><code><a title="egse.settings.set_attr_value" href="#egse.settings.set_attr_value">set_attr_value</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.settings.Settings" href="#egse.settings.Settings">Settings</a></code></h4>
<ul class="">
<li><code><a title="egse.settings.Settings.LOG_FORMAT_DATE" href="#egse.settings.Settings.LOG_FORMAT_DATE">LOG_FORMAT_DATE</a></code></li>
<li><code><a title="egse.settings.Settings.LOG_FORMAT_DEFAULT" href="#egse.settings.Settings.LOG_FORMAT_DEFAULT">LOG_FORMAT_DEFAULT</a></code></li>
<li><code><a title="egse.settings.Settings.LOG_FORMAT_FULL" href="#egse.settings.Settings.LOG_FORMAT_FULL">LOG_FORMAT_FULL</a></code></li>
<li><code><a title="egse.settings.Settings.LOG_FORMAT_PROCESS" href="#egse.settings.Settings.LOG_FORMAT_PROCESS">LOG_FORMAT_PROCESS</a></code></li>
<li><code><a title="egse.settings.Settings.LOG_FORMAT_THREAD" href="#egse.settings.Settings.LOG_FORMAT_THREAD">LOG_FORMAT_THREAD</a></code></li>
<li><code><a title="egse.settings.Settings.get_memoized_locations" href="#egse.settings.Settings.get_memoized_locations">get_memoized_locations</a></code></li>
<li><code><a title="egse.settings.Settings.load" href="#egse.settings.Settings.load">load</a></code></li>
<li><code><a title="egse.settings.Settings.profiling" href="#egse.settings.Settings.profiling">profiling</a></code></li>
<li><code><a title="egse.settings.Settings.read_configuration_file" href="#egse.settings.Settings.read_configuration_file">read_configuration_file</a></code></li>
<li><code><a title="egse.settings.Settings.set_profiling" href="#egse.settings.Settings.set_profiling">set_profiling</a></code></li>
<li><code><a title="egse.settings.Settings.set_simulation_mode" href="#egse.settings.Settings.set_simulation_mode">set_simulation_mode</a></code></li>
<li><code><a title="egse.settings.Settings.simulation_mode" href="#egse.settings.Settings.simulation_mode">simulation_mode</a></code></li>
<li><code><a title="egse.settings.Settings.to_string" href="#egse.settings.Settings.to_string">to_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.settings.SettingsError" href="#egse.settings.SettingsError">SettingsError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tempcontrol.keithley.daq6510 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tempcontrol.keithley.daq6510</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import re
import sys
from typing import Dict
from typing import List
from typing import Tuple

from egse.decorators import dynamic_interface
from egse.device import DeviceConnectionState
from egse.device import DeviceInterface
from egse.mixin import DynamicCommandMixin
from egse.mixin import add_lf
from egse.mixin import dynamic_command
from egse.proxy import Proxy
from egse.settings import Settings
from egse.tempcontrol.keithley.daq6510_devif import DAQ6510EthernetInterface
from egse.zmq_ser import connect_address

logger = logging.getLogger(__name__)

CTRL_SETTINGS = Settings.load(&#34;Keithley Control Server&#34;)
FW_SETTINGS = Settings.load(&#34;Keithley DAQ6510&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;daq6510.yaml&#34;)

DEFAULT_BUFFER_1 = &#34;defbuffer1&#34;
DEFAULT_BUFFER_2 = &#34;defbuffer2&#34;


class DAQ6510Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Keithley DAQ6510 Controller,Proxy and Simulator.
    &#34;&#34;&#34;

    @dynamic_interface
    def send_command(self, command: str, response: bool):
        &#34;&#34;&#34;
        Send a SCPI command to the device. The valid commands are described in the DAQ6510
        Reference Manual [DAQ6510-901-01 Rev. B / September 2019]

        Args:
            command (str): a SCPI command as specified in the DAQ6510 Reference Manual
            response (bool): set to True if you expect a response from the device

        Returns:
            The response from the DAQ6510 is returned when a response was expected. When
            `response` is False, None will be returned.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;,
        cmd_string=&#34;*IDN?&#34;,
        process_cmd_string=add_lf,
    )
    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Returns basic information about the device, its name, firmwre version etc.

        The string returned is subject to change without notice and can not be used for parsing
        information.

        Returns:
            An identification string of the instrument.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;,
        cmd_string=&#34;*RST&#34;,
        process_cmd_string=add_lf,
    )
    def reset(self):
        &#34;&#34;&#34;
        Resets the DAQ6510. This returns the instrument to default settings, and cancels all
        pending commands.

        .. Note::
            The `reset()` method also deletes all the user-defined buffers. The two default
            buffers are cleared.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int):
        &#34;&#34;&#34;Set the absolute date and time for the device.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_time(self):
        &#34;&#34;&#34;
        Get the date and time from the device in UTC. The returned string is of the format:

            &lt;weekday&gt; &lt;month&gt; &lt;day&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;year&gt;

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def read_buffer(self, start: int, end: int, buffer_name: str, elements: List[str]):
        raise NotImplementedError

    @dynamic_interface
    def get_buffer_count(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def get_buffer_capacity(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def delete_buffer(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def clear_buffer(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def create_buffer(self, buffer_name: str, size: int):
        raise NotImplementedError

    @dynamic_interface
    def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
        raise NotImplementedError

    @dynamic_interface
    def setup_measurements(self, *, buffer_name: str, channel_list: str):
        raise NotImplementedError

    @dynamic_interface
    def perform_measurement(
        self, *, buffer_name: str, channel_list: str, count: int, interval: int
    ):
        raise NotImplementedError


class DAQ6510Controller(DAQ6510Interface, DynamicCommandMixin):
    &#34;&#34;&#34;
    The DAQ6510 Controller allows to remotely control the Keithley Data Acquisition System
    through an Ethernet interface.
    &#34;&#34;&#34;

    def __init__(self, hostname=FW_SETTINGS.HOSTNAME, port=FW_SETTINGS.PORT):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the Keithley DAQ6510 Hardware.

        Args:
            hostname (str): the IP address or fully qualified hostname of the Hexapod hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the ``settings.yaml``
                configuration file.

        Raises:
            Error: when the connection could not be established for some reason.
        &#34;&#34;&#34;

        super().__init__()

        logger.debug(f&#34;Initializing the DAQ6510 Controller with hostname={hostname} on port={port}&#34;)

        self.daq = self.transport = DAQ6510EthernetInterface(hostname, port)

        # We set the default buffer here, this can be changed with the `create_buffer()` method.

        self.buffer_name = DEFAULT_BUFFER_1

    def is_simulator(self):
        return False

    def connect(self):
        self.daq.connect()
        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        self.daq.disconnect()
        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_connected(self):
        return self.daq.is_connected()

    def send_command(self, command: str, response: bool):
        return self.daq.trans(command) if response else self.daq.write(command)

    def set_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int):
        command = f&#34;:SYST:TIME {year}, {month}, {day}, {hour}, {minute}, {second}&#34;
        self.daq.write(command)

    def get_time(self) -&gt; str:
        return self.daq.trans(&#34;:SYST:TIME? 1&#34;)

    def read_buffer(
        self, start: int, end: int, buffer_name: str = DEFAULT_BUFFER_1, elements: List[str] = None
    ):
        &#34;&#34;&#34;
        Reads specific data elements (measurements) from the given buffer.

        Elements that can be specified to read out:

        * CHANNEL: the channel for which the data was acquired
        * DATE: the date when the data point was measured
        * READING: the actual reading of the measurement
        * TSTAMP: the time stamp when the data point was measured
        * UNIT: the unit of measure for the measurement
        * STATUS: the status information associated with the measurement

        Args:
            start: first index of the buffer, must be greater or equal to 1
            end: last index of the buffer to return
            buffer_name: the name of the buffer to read out
            elements: the list of elements from the buffer to include in the response

        Returns:
            A list of all the readings.
        &#34;&#34;&#34;
        if elements is None:
            elements = [&#34;READING&#34;]
        else:
            elements = &#34;, &#34;.join(elements)

        return self.daq.trans(f&#39;TRACE:DATA? {start}, {end}, &#34;{buffer_name}&#34;, {elements}&#39;)

    def get_buffer_count(self, buffer_name: str = DEFAULT_BUFFER_1):

        return self.daq.trans(f&#39;TRACE:ACTUAL? &#34;{buffer_name}&#34;&#39;)

    def get_buffer_capacity(self, buffer_name: str = DEFAULT_BUFFER_1):

        return self.daq.trans(f&#39;TRACE:POINTS? &#34;{buffer_name}&#34;&#39;)

    def delete_buffer(self, buffer_name: str):
        &#34;&#34;&#34;
        Deletes the specified buffer.

        Args:
            buffer_name (str): the name of the buffer
        &#34;&#34;&#34;
        self.daq.write(f&#39;TRACE:DELETE &#34;{buffer_name}&#34;&#39;)

    def clear_buffer(self, buffer_name: str = DEFAULT_BUFFER_1):
        &#34;&#34;&#34;
        Clears all readings and statistics from the specified buffer.

        Args:
            buffer_name (str): the name of the buffer [default: DEFAULT_BUFFER_1]
        &#34;&#34;&#34;

        response = self.daq.trans(f&#39;TRACE:ACTUAL? &#34;{buffer_name}&#34;&#39;)

        logger.info(f&#34;Clearing buffer &#39;{buffer_name}&#39; containing {response} readings.&#34;)

        self.daq.write(f&#39;TRACE:CLEAR &#34;{buffer_name}&#34;&#39;)

    def create_buffer(self, buffer_name: str, size: int = 1000):
        &#34;&#34;&#34;
        Creates a Reading Buffer with the given name.

        A buffer with this name should not already exist in the device.
        When the buffer does exist, the DAQ6510 will show a dialog on the front panel
        with error 1115 saying the command cannot take an existing buffer name.

        Buffer names must start with an alphabetic character. The names cannot
        contain any periods nor the underscore (_) character. The name can be
        up to 31 characters long.

        If the given size is 0, the instrument creates the largest reading buffer
        possible based on the available memory when the buffer is created.

        Args:
            buffer_name (str): the name of the buffer
            size (int): the maximum number of readings (size &gt;= 10) [default: 1000]

        &#34;&#34;&#34;

        self.daq.write(f&#39;TRACE:MAKE &#34;{buffer_name}&#34;, {size}&#39;)

        self.buffer_name = buffer_name

    def reset(self):
        self.daq.write(&#34;SYSTem:BEEPer 500, 0.1; :*RST; :SYSTem:BEEPer 1000, 0.1\n&#34;)


    def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
        &#34;&#34;&#34;
        This command allows to configure the different sensors in the `channel_list`. Each sensor
        in the list will be configured according to the settings given in the `sense` dictionary.

        The following code will configure channels 101 and 102 as 4-wire transducers of type PT100.

        ```
        channel_list = create_channel_list(101, 102)

        sense = {
            &#34;TEMPERATURE&#34;: [
                (&#34;TRANSDUCER&#34;, &#34;FRTD&#34;),
                (&#34;RTD:FOUR&#34;, &#34;PT100&#34;),
            ]
        }

        daq.configure_sensors(channel_list, sense=sense)

        ```

        The `sense` argument is a dictionary where the keys are function names like &#34;TEMPERATURE&#34;
        or &#34;VOLTAGE:DC&#34;, and the values are a list of settings for that function. The list of
        settings is a list of tuples with the command and the value, e.g. &#34;TRANSDUCER&#34; is the
        settings command and &#34;FRTD&#34; is its value. The list of settings will be send to the device
        in the order that they take in the list.

        Args:
            channel_list (str): the channels to configure
            sense: a dictionary with all the information on the configuration

        Returns:
            None.
        &#34;&#34;&#34;

        if &#34;TEMPERATURE&#34; in sense:

            # Allowed settings for TEMPERATURE:
            #
            # - TEMPERATURE:APERTURE                  (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:COUNT             (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:STATE             (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:TCONTROL          (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:WINDOW            (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:AZERO:STATE
            # - TEMPERATURE:DELAY:AUTO
            # - TEMPERATURE:DELAY:USER&lt;N&gt;
            # - TEMPERATURE:LINE:SYNC
            # - TEMPERATURE:NPLCYCLES
            # - TEMPERATURE:OCOMPENSATED
            # - TEMPERATURE:ODETECTOR
            # - TEMPERATURE:RELATIVE
            # - TEMPERATURE:RELATIVE:ACQUIRE
            # - TEMPERATURE:RELATIVE:STATE
            # - TEMPERATURE:RTD:ALPHA, BETA, DELTA      (@&lt;channelList&gt;)
            # - TEMPERATURE:RTD:ZERO, TWO, THREE, FOUR  (@&lt;channelList&gt;)
            # - TEMPERATURE:TCOUPLE:RJUNCTION:SIMULATED
            # - TEMPERATURE:TCOUPLE:RJUNCTION:RSELECT
            # - TEMPERATURE:TCOUPLE:TYPE
            # - TEMPERATURE:THERMISTOR      (@&lt;channelList&gt;)
            # - TEMPERATURE:TRANSDUCER      (@&lt;channelList&gt;)
            # - TEMPERATURE:UNIT            (@&lt;channelList&gt;)
            #

            # set the function to temperature

            self.daq.write(f&#39;SENSE:FUNCTION &#34;TEMPERATURE&#34;, {channel_list}&#39;)

            for cmd, value in sense[&#34;TEMPERATURE&#34;]:
                self.daq.write(f&#34;SENSE:TEMPERATURE:{cmd} {value}, {channel_list}&#34;)

    def setup_measurements(self, *, buffer_name: str = DEFAULT_BUFFER_1, channel_list: str):
        &#34;&#34;&#34;
        Setup the measurements for the given channel list.

        Args:
            buffer_name: The name of the buffer to use [default: defbuffer1]
            channel_list: The channels to read out

        Returns:
            None
        &#34;&#34;&#34;
        self.daq.write(f&#39;ROUTE:SCAN:BUFFER &#34;{buffer_name}&#34;&#39;)
        self.daq.write(f&#34;ROUTE:SCAN:CREATE {channel_list}&#34;)
        self.daq.write(f&#34;ROUTE:CHANNEL:OPEN {channel_list}&#34;)
        _ = self.daq.trans(f&#34;ROUTE:CHANNEL:STATE? {channel_list}&#34;)
        self.daq.write(&#34;ROUTE:SCAN:START:STIMULUS NONE&#34;)

    def perform_measurement(
        self,
        *,  # all following parameters shall be given as keyword arguments
        buffer_name: str = DEFAULT_BUFFER_1,
        channel_list: str,
        count: int = 1,
        interval: int = 2,
    ):
        &#34;&#34;&#34;
        Perform the actual measurements. This function will wait until all measurements have
        completed, so be careful with the arguments `count` and `interval` as they will multiply
        into the number of seconds that you will have to wait for the response.

        Args:
            buffer_name: The name of the buffer to use [default: defbuffer1]
            channel_list: The channels to read out
            count: number of measurements to perform [default: 1]
            interval: The interval in which to read out [default: 2s]

        Returns:
            List of readings.
        &#34;&#34;&#34;

        # Set the number of times a scan is repeated

        self.daq.write(f&#34;ROUTE:SCAN:COUNT:SCAN {count}&#34;)
        self.daq.write(f&#34;ROUTE:SCAN:INTERVAL {interval}&#34;)  # [seconds]

        #
        self.daq.write(&#34;INITIATE:IMMEDIATE&#34;)
        self.daq.write(&#34;*WAI&#34;)

        # Read out the buffer

        logger.debug(&#34;Buffer count = &#34;, self.get_buffer_count())

        num_sensors = count_number_of_channels(channel_list)

        readings = []

        for idx in range(1, count * num_sensors + 1):
            response = self.read_buffer(
                idx, idx, buffer_name=buffer_name, elements=[&#34;CHANNEL&#34;, &#34;TSTAMP&#34;, &#34;READING&#34;, &#34;UNIT&#34;]
            )
            if response != &#34;&#34; and response != str(count * num_sensors):
                if &#34;\n&#34; in response:
                    response = response.split(&#34;\n&#34;)
                    for i in range(len(response)):
                        readings.append(response[i].split(&#34;,&#34;))
                else:
                    readings.append(response.split(&#34;,&#34;))
                if len(readings[0]) &lt; 4:
                    del readings[0]

        return readings


class DAQ6510Simulator(DAQ6510Interface):
    def read_buffer(self, start: int, end: int, buffer_name: str, elements: List[str]):
        pass

    def get_buffer_count(self, buffer_name: str):
        pass

    def get_buffer_capacity(self, buffer_name: str):
        pass

    def delete_buffer(self, buffer_name: str):
        pass

    def clear_buffer(self, buffer_name: str):
        pass

    def create_buffer(self, buffer_name: str, size: int):
        pass

    def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
        pass

    def setup_measurements(self, *, buffer_name: str, channel_list: str):
        pass

    def perform_measurement(
        self, *, buffer_name: str, channel_list: str, count: int, interval: int
    ):
        pass

    def send_command(self, command: str, response: bool):
        pass

    def info(self) -&gt; str:
        pass

    def reset(self):
        pass

    def is_simulator(self):
        pass

    def connect(self):
        pass

    def disconnect(self):
        pass

    def reconnect(self):
        pass

    def is_connected(self):
        pass


class DAQ6510Proxy(Proxy, DAQ6510Interface):
    &#34;&#34;&#34;
    The LakeShoreProxy class is used to connect to the LakeShore control server and send commands
    to the LakeShore Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
        timeout = CTRL_SETTINGS.TIMEOUT * 1000 # timeout in ms. timeout must be &gt; scan count * interval + (one scan duration)
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)


def create_channel_list(*args) -&gt; str:
    &#34;&#34;&#34;
    Create a channel list that is understood by the SCPI commands of the DAQ6510.

    Channel names contain both the slot number and the channel number. The slot number is the
    number of the slot where the card is installed at the back of the device.

    When addressing multiple individual channels, add each of them as a separate argument,
    e.g. to include channels 1, 3, and 7 from slot 1, use the following command:

        &gt;&gt;&gt; create_channel_list(101, 103, 107)
        &#39;(@101, 103, 107)&#39;

    To designate a range of channels, only one argument should be given, i.e. a tuple containing
    two channel representing the range. The following tuple `(101, 110)` will create the
    following response: `&#34;(@101:110)&#34;`. The range is inclusive, so this will define a range of
    10 channels in slot 1.

        &gt;&gt;&gt; create_channel_list((201, 205))
        &#39;(@201:205)&#39;

    See reference manual for the Keithley DAQ6510 [DAQ6510-901-01 Rev. B / September 2019],
    chapter 11: Introduction to SCPI commands, SCPI command formatting, channel naming.

    Args:
        *args: a tuple or a list of channels

    Returns:
        A string containing the channel list as understood by the device.

    &#34;&#34;&#34;
    if not args:
        return &#34;&#34;

    # If only one argument is given, I expect either a tuple defining a range
    # or just one channel. When several arguments are given, I expect them all
    # to be individual channels.

    if len(args) == 1:

        arg = args[0]
        if isinstance(arg, tuple):
            ch_list = f&#34;(@{arg[0]}:{arg[1]})&#34;
        else:
            ch_list = f&#34;(@{arg})&#34;

    else:
        ch_list = &#34;(@&#34; + &#34;, &#34;.join([str(arg) for arg in args]) + &#34;)&#34;

    return ch_list


def count_number_of_channels(channel_list: str) -&gt; int:
    &#34;&#34;&#34;
    Given a proper channel list, this function counts the number of channels.
    For ranges, it returns the actual number of channels that are included in the range.

        &gt;&gt;&gt; count_number_of_channels(&#34;(@1,2,3,4,5)&#34;)
        5
        &gt;&gt;&gt; count_number_of_channels(&#34;(@1, 3, 5)&#34;)
        3
        &gt;&gt;&gt; count_number_of_channels(&#34;(@2:7)&#34;)
        6

    Args:
        channel_list: a channel list as understood by the SCPI commands of DAQ6510.

    Returns:
        The number of channels in the list.
    &#34;&#34;&#34;

    match = re.match(r&#34;\(@(.*)\)&#34;, channel_list)
    group = match.groups()[0]

    parts = group.replace(&#34; &#34;, &#34;&#34;).split(&#34;,&#34;)
    count = 0
    for part in parts:
        if &#34;:&#34; in part:
            channels = part.split(&#34;:&#34;)
            count += int(channels[1]) - int(channels[0]) + 1
        else:
            count += 1

    return count


def get_channel_names(channel_list: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Generate a list of channel names from a given channel list.

    Args:
        channel_list: a channel list as understood by the SCPI commands of DAQ6510.

    Returns:
        A list of channel names.
    &#34;&#34;&#34;

    match = re.match(r&#34;\(@(.*)\)&#34;, channel_list)
    group = match.groups()[0]

    parts = group.replace(&#34; &#34;, &#34;&#34;).split(&#34;,&#34;)
    names = []
    for part in parts:
        if &#34;:&#34; in part:
            channels = part.split(&#34;:&#34;)
            names.extend(str(ch) for ch in range(int(channels[0]), int(channels[1]) + 1))
        else:
            names.append(part)

    return names


if __name__ == &#34;__main__&#34;:

    logging.basicConfig(level=20)

    print(f&#39;{get_channel_names(&#34;(@101:105)&#34;)=}&#39;)
    print(f&#39;{get_channel_names(&#34;(@101, 102, 103, 105)&#34;)=}&#39;)
    sys.exit(0)

    daq = DAQ6510Controller()
    daq.connect()
    daq.reset()

    print(daq.info())

    size = daq.get_buffer_capacity()
    print(f&#34;buffer {DEFAULT_BUFFER_1} can still hold {size} readings&#34;)

    count = daq.get_buffer_count()
    print(f&#34;buffer {DEFAULT_BUFFER_1} holds {count} readings&#34;)

    channel_list = create_channel_list((101, 102))

    print(channel_list)

    sense = {&#34;TEMPERATURE&#34;: [(&#34;TRANSDUCER&#34;, &#34;FRTD&#34;), (&#34;RTD:FOUR&#34;, &#34;PT100&#34;), (&#34;UNIT&#34;, &#34;KELVIN&#34;)]}

    daq.configure_sensors(channel_list, sense=sense)

    daq.setup_measurements(channel_list=channel_list)

    response = daq.perform_measurement(channel_list=channel_list, count=5, interval=1)

    print(response)

    count = daq.get_buffer_count()
    print(f&#34;buffer {DEFAULT_BUFFER_1} holds {count} readings&#34;)

    daq.disconnect()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510.count_number_of_channels"><code class="name flex">
<span>def <span class="ident">count_number_of_channels</span></span>(<span>channel_list: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Given a proper channel list, this function counts the number of channels.
For ranges, it returns the actual number of channels that are included in the range.</p>
<pre><code>&gt;&gt;&gt; count_number_of_channels("(@1,2,3,4,5)")
5
&gt;&gt;&gt; count_number_of_channels("(@1, 3, 5)")
3
&gt;&gt;&gt; count_number_of_channels("(@2:7)")
6
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_list</code></strong></dt>
<dd>a channel list as understood by the SCPI commands of DAQ6510.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of channels in the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_number_of_channels(channel_list: str) -&gt; int:
    &#34;&#34;&#34;
    Given a proper channel list, this function counts the number of channels.
    For ranges, it returns the actual number of channels that are included in the range.

        &gt;&gt;&gt; count_number_of_channels(&#34;(@1,2,3,4,5)&#34;)
        5
        &gt;&gt;&gt; count_number_of_channels(&#34;(@1, 3, 5)&#34;)
        3
        &gt;&gt;&gt; count_number_of_channels(&#34;(@2:7)&#34;)
        6

    Args:
        channel_list: a channel list as understood by the SCPI commands of DAQ6510.

    Returns:
        The number of channels in the list.
    &#34;&#34;&#34;

    match = re.match(r&#34;\(@(.*)\)&#34;, channel_list)
    group = match.groups()[0]

    parts = group.replace(&#34; &#34;, &#34;&#34;).split(&#34;,&#34;)
    count = 0
    for part in parts:
        if &#34;:&#34; in part:
            channels = part.split(&#34;:&#34;)
            count += int(channels[1]) - int(channels[0]) + 1
        else:
            count += 1

    return count</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.create_channel_list"><code class="name flex">
<span>def <span class="ident">create_channel_list</span></span>(<span>*args) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a channel list that is understood by the SCPI commands of the DAQ6510.</p>
<p>Channel names contain both the slot number and the channel number. The slot number is the
number of the slot where the card is installed at the back of the device.</p>
<p>When addressing multiple individual channels, add each of them as a separate argument,
e.g. to include channels 1, 3, and 7 from slot 1, use the following command:</p>
<pre><code>&gt;&gt;&gt; create_channel_list(101, 103, 107)
'(@101, 103, 107)'
</code></pre>
<p>To designate a range of channels, only one argument should be given, i.e. a tuple containing
two channel representing the range. The following tuple <code>(101, 110)</code> will create the
following response: <code>"(@101:110)"</code>. The range is inclusive, so this will define a range of
10 channels in slot 1.</p>
<pre><code>&gt;&gt;&gt; create_channel_list((201, 205))
'(@201:205)'
</code></pre>
<p>See reference manual for the Keithley DAQ6510 [DAQ6510-901-01 Rev. B / September 2019],
chapter 11: Introduction to SCPI commands, SCPI command formatting, channel naming.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>a tuple or a list of channels</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing the channel list as understood by the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_channel_list(*args) -&gt; str:
    &#34;&#34;&#34;
    Create a channel list that is understood by the SCPI commands of the DAQ6510.

    Channel names contain both the slot number and the channel number. The slot number is the
    number of the slot where the card is installed at the back of the device.

    When addressing multiple individual channels, add each of them as a separate argument,
    e.g. to include channels 1, 3, and 7 from slot 1, use the following command:

        &gt;&gt;&gt; create_channel_list(101, 103, 107)
        &#39;(@101, 103, 107)&#39;

    To designate a range of channels, only one argument should be given, i.e. a tuple containing
    two channel representing the range. The following tuple `(101, 110)` will create the
    following response: `&#34;(@101:110)&#34;`. The range is inclusive, so this will define a range of
    10 channels in slot 1.

        &gt;&gt;&gt; create_channel_list((201, 205))
        &#39;(@201:205)&#39;

    See reference manual for the Keithley DAQ6510 [DAQ6510-901-01 Rev. B / September 2019],
    chapter 11: Introduction to SCPI commands, SCPI command formatting, channel naming.

    Args:
        *args: a tuple or a list of channels

    Returns:
        A string containing the channel list as understood by the device.

    &#34;&#34;&#34;
    if not args:
        return &#34;&#34;

    # If only one argument is given, I expect either a tuple defining a range
    # or just one channel. When several arguments are given, I expect them all
    # to be individual channels.

    if len(args) == 1:

        arg = args[0]
        if isinstance(arg, tuple):
            ch_list = f&#34;(@{arg[0]}:{arg[1]})&#34;
        else:
            ch_list = f&#34;(@{arg})&#34;

    else:
        ch_list = &#34;(@&#34; + &#34;, &#34;.join([str(arg) for arg in args]) + &#34;)&#34;

    return ch_list</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.get_channel_names"><code class="name flex">
<span>def <span class="ident">get_channel_names</span></span>(<span>channel_list: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a list of channel names from a given channel list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_list</code></strong></dt>
<dd>a channel list as understood by the SCPI commands of DAQ6510.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of channel names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_names(channel_list: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Generate a list of channel names from a given channel list.

    Args:
        channel_list: a channel list as understood by the SCPI commands of DAQ6510.

    Returns:
        A list of channel names.
    &#34;&#34;&#34;

    match = re.match(r&#34;\(@(.*)\)&#34;, channel_list)
    group = match.groups()[0]

    parts = group.replace(&#34; &#34;, &#34;&#34;).split(&#34;,&#34;)
    names = []
    for part in parts:
        if &#34;:&#34; in part:
            channels = part.split(&#34;:&#34;)
            names.extend(str(ch) for ch in range(int(channels[0]), int(channels[1]) + 1))
        else:
            names.append(part)

    return names</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller"><code class="flex name class">
<span>class <span class="ident">DAQ6510Controller</span></span>
<span>(</span><span>hostname='localhost', port=5025)</span>
</code></dt>
<dd>
<div class="desc"><p>The DAQ6510 Controller allows to remotely control the Keithley Data Acquisition System
through an Ethernet interface.</p>
<p>Opens a TCP/IP socket connection with the Keithley DAQ6510 Hardware.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the Hexapod hardware
controller. The default is defined in the <code>settings.yaml</code> configuration file.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to, by default set in the <code>settings.yaml</code>
configuration file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Error</code></dt>
<dd>when the connection could not be established for some reason.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAQ6510Controller(DAQ6510Interface, DynamicCommandMixin):
    &#34;&#34;&#34;
    The DAQ6510 Controller allows to remotely control the Keithley Data Acquisition System
    through an Ethernet interface.
    &#34;&#34;&#34;

    def __init__(self, hostname=FW_SETTINGS.HOSTNAME, port=FW_SETTINGS.PORT):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the Keithley DAQ6510 Hardware.

        Args:
            hostname (str): the IP address or fully qualified hostname of the Hexapod hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the ``settings.yaml``
                configuration file.

        Raises:
            Error: when the connection could not be established for some reason.
        &#34;&#34;&#34;

        super().__init__()

        logger.debug(f&#34;Initializing the DAQ6510 Controller with hostname={hostname} on port={port}&#34;)

        self.daq = self.transport = DAQ6510EthernetInterface(hostname, port)

        # We set the default buffer here, this can be changed with the `create_buffer()` method.

        self.buffer_name = DEFAULT_BUFFER_1

    def is_simulator(self):
        return False

    def connect(self):
        self.daq.connect()
        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        self.daq.disconnect()
        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_connected(self):
        return self.daq.is_connected()

    def send_command(self, command: str, response: bool):
        return self.daq.trans(command) if response else self.daq.write(command)

    def set_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int):
        command = f&#34;:SYST:TIME {year}, {month}, {day}, {hour}, {minute}, {second}&#34;
        self.daq.write(command)

    def get_time(self) -&gt; str:
        return self.daq.trans(&#34;:SYST:TIME? 1&#34;)

    def read_buffer(
        self, start: int, end: int, buffer_name: str = DEFAULT_BUFFER_1, elements: List[str] = None
    ):
        &#34;&#34;&#34;
        Reads specific data elements (measurements) from the given buffer.

        Elements that can be specified to read out:

        * CHANNEL: the channel for which the data was acquired
        * DATE: the date when the data point was measured
        * READING: the actual reading of the measurement
        * TSTAMP: the time stamp when the data point was measured
        * UNIT: the unit of measure for the measurement
        * STATUS: the status information associated with the measurement

        Args:
            start: first index of the buffer, must be greater or equal to 1
            end: last index of the buffer to return
            buffer_name: the name of the buffer to read out
            elements: the list of elements from the buffer to include in the response

        Returns:
            A list of all the readings.
        &#34;&#34;&#34;
        if elements is None:
            elements = [&#34;READING&#34;]
        else:
            elements = &#34;, &#34;.join(elements)

        return self.daq.trans(f&#39;TRACE:DATA? {start}, {end}, &#34;{buffer_name}&#34;, {elements}&#39;)

    def get_buffer_count(self, buffer_name: str = DEFAULT_BUFFER_1):

        return self.daq.trans(f&#39;TRACE:ACTUAL? &#34;{buffer_name}&#34;&#39;)

    def get_buffer_capacity(self, buffer_name: str = DEFAULT_BUFFER_1):

        return self.daq.trans(f&#39;TRACE:POINTS? &#34;{buffer_name}&#34;&#39;)

    def delete_buffer(self, buffer_name: str):
        &#34;&#34;&#34;
        Deletes the specified buffer.

        Args:
            buffer_name (str): the name of the buffer
        &#34;&#34;&#34;
        self.daq.write(f&#39;TRACE:DELETE &#34;{buffer_name}&#34;&#39;)

    def clear_buffer(self, buffer_name: str = DEFAULT_BUFFER_1):
        &#34;&#34;&#34;
        Clears all readings and statistics from the specified buffer.

        Args:
            buffer_name (str): the name of the buffer [default: DEFAULT_BUFFER_1]
        &#34;&#34;&#34;

        response = self.daq.trans(f&#39;TRACE:ACTUAL? &#34;{buffer_name}&#34;&#39;)

        logger.info(f&#34;Clearing buffer &#39;{buffer_name}&#39; containing {response} readings.&#34;)

        self.daq.write(f&#39;TRACE:CLEAR &#34;{buffer_name}&#34;&#39;)

    def create_buffer(self, buffer_name: str, size: int = 1000):
        &#34;&#34;&#34;
        Creates a Reading Buffer with the given name.

        A buffer with this name should not already exist in the device.
        When the buffer does exist, the DAQ6510 will show a dialog on the front panel
        with error 1115 saying the command cannot take an existing buffer name.

        Buffer names must start with an alphabetic character. The names cannot
        contain any periods nor the underscore (_) character. The name can be
        up to 31 characters long.

        If the given size is 0, the instrument creates the largest reading buffer
        possible based on the available memory when the buffer is created.

        Args:
            buffer_name (str): the name of the buffer
            size (int): the maximum number of readings (size &gt;= 10) [default: 1000]

        &#34;&#34;&#34;

        self.daq.write(f&#39;TRACE:MAKE &#34;{buffer_name}&#34;, {size}&#39;)

        self.buffer_name = buffer_name

    def reset(self):
        self.daq.write(&#34;SYSTem:BEEPer 500, 0.1; :*RST; :SYSTem:BEEPer 1000, 0.1\n&#34;)


    def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
        &#34;&#34;&#34;
        This command allows to configure the different sensors in the `channel_list`. Each sensor
        in the list will be configured according to the settings given in the `sense` dictionary.

        The following code will configure channels 101 and 102 as 4-wire transducers of type PT100.

        ```
        channel_list = create_channel_list(101, 102)

        sense = {
            &#34;TEMPERATURE&#34;: [
                (&#34;TRANSDUCER&#34;, &#34;FRTD&#34;),
                (&#34;RTD:FOUR&#34;, &#34;PT100&#34;),
            ]
        }

        daq.configure_sensors(channel_list, sense=sense)

        ```

        The `sense` argument is a dictionary where the keys are function names like &#34;TEMPERATURE&#34;
        or &#34;VOLTAGE:DC&#34;, and the values are a list of settings for that function. The list of
        settings is a list of tuples with the command and the value, e.g. &#34;TRANSDUCER&#34; is the
        settings command and &#34;FRTD&#34; is its value. The list of settings will be send to the device
        in the order that they take in the list.

        Args:
            channel_list (str): the channels to configure
            sense: a dictionary with all the information on the configuration

        Returns:
            None.
        &#34;&#34;&#34;

        if &#34;TEMPERATURE&#34; in sense:

            # Allowed settings for TEMPERATURE:
            #
            # - TEMPERATURE:APERTURE                  (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:COUNT             (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:STATE             (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:TCONTROL          (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:WINDOW            (@&lt;channelList&gt;)
            # - TEMPERATURE:AVERAGE:AZERO:STATE
            # - TEMPERATURE:DELAY:AUTO
            # - TEMPERATURE:DELAY:USER&lt;N&gt;
            # - TEMPERATURE:LINE:SYNC
            # - TEMPERATURE:NPLCYCLES
            # - TEMPERATURE:OCOMPENSATED
            # - TEMPERATURE:ODETECTOR
            # - TEMPERATURE:RELATIVE
            # - TEMPERATURE:RELATIVE:ACQUIRE
            # - TEMPERATURE:RELATIVE:STATE
            # - TEMPERATURE:RTD:ALPHA, BETA, DELTA      (@&lt;channelList&gt;)
            # - TEMPERATURE:RTD:ZERO, TWO, THREE, FOUR  (@&lt;channelList&gt;)
            # - TEMPERATURE:TCOUPLE:RJUNCTION:SIMULATED
            # - TEMPERATURE:TCOUPLE:RJUNCTION:RSELECT
            # - TEMPERATURE:TCOUPLE:TYPE
            # - TEMPERATURE:THERMISTOR      (@&lt;channelList&gt;)
            # - TEMPERATURE:TRANSDUCER      (@&lt;channelList&gt;)
            # - TEMPERATURE:UNIT            (@&lt;channelList&gt;)
            #

            # set the function to temperature

            self.daq.write(f&#39;SENSE:FUNCTION &#34;TEMPERATURE&#34;, {channel_list}&#39;)

            for cmd, value in sense[&#34;TEMPERATURE&#34;]:
                self.daq.write(f&#34;SENSE:TEMPERATURE:{cmd} {value}, {channel_list}&#34;)

    def setup_measurements(self, *, buffer_name: str = DEFAULT_BUFFER_1, channel_list: str):
        &#34;&#34;&#34;
        Setup the measurements for the given channel list.

        Args:
            buffer_name: The name of the buffer to use [default: defbuffer1]
            channel_list: The channels to read out

        Returns:
            None
        &#34;&#34;&#34;
        self.daq.write(f&#39;ROUTE:SCAN:BUFFER &#34;{buffer_name}&#34;&#39;)
        self.daq.write(f&#34;ROUTE:SCAN:CREATE {channel_list}&#34;)
        self.daq.write(f&#34;ROUTE:CHANNEL:OPEN {channel_list}&#34;)
        _ = self.daq.trans(f&#34;ROUTE:CHANNEL:STATE? {channel_list}&#34;)
        self.daq.write(&#34;ROUTE:SCAN:START:STIMULUS NONE&#34;)

    def perform_measurement(
        self,
        *,  # all following parameters shall be given as keyword arguments
        buffer_name: str = DEFAULT_BUFFER_1,
        channel_list: str,
        count: int = 1,
        interval: int = 2,
    ):
        &#34;&#34;&#34;
        Perform the actual measurements. This function will wait until all measurements have
        completed, so be careful with the arguments `count` and `interval` as they will multiply
        into the number of seconds that you will have to wait for the response.

        Args:
            buffer_name: The name of the buffer to use [default: defbuffer1]
            channel_list: The channels to read out
            count: number of measurements to perform [default: 1]
            interval: The interval in which to read out [default: 2s]

        Returns:
            List of readings.
        &#34;&#34;&#34;

        # Set the number of times a scan is repeated

        self.daq.write(f&#34;ROUTE:SCAN:COUNT:SCAN {count}&#34;)
        self.daq.write(f&#34;ROUTE:SCAN:INTERVAL {interval}&#34;)  # [seconds]

        #
        self.daq.write(&#34;INITIATE:IMMEDIATE&#34;)
        self.daq.write(&#34;*WAI&#34;)

        # Read out the buffer

        logger.debug(&#34;Buffer count = &#34;, self.get_buffer_count())

        num_sensors = count_number_of_channels(channel_list)

        readings = []

        for idx in range(1, count * num_sensors + 1):
            response = self.read_buffer(
                idx, idx, buffer_name=buffer_name, elements=[&#34;CHANNEL&#34;, &#34;TSTAMP&#34;, &#34;READING&#34;, &#34;UNIT&#34;]
            )
            if response != &#34;&#34; and response != str(count * num_sensors):
                if &#34;\n&#34; in response:
                    response = response.split(&#34;\n&#34;)
                    for i in range(len(response)):
                        readings.append(response[i].split(&#34;,&#34;))
                else:
                    readings.append(response.split(&#34;,&#34;))
                if len(readings[0]) &lt; 4:
                    del readings[0]

        return readings</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
<li><a title="egse.mixin.DynamicCommandMixin" href="../../mixin.html#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.clear_buffer"><code class="name flex">
<span>def <span class="ident">clear_buffer</span></span>(<span>self, buffer_name: str = 'defbuffer1')</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all readings and statistics from the specified buffer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the buffer [default: DEFAULT_BUFFER_1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_buffer(self, buffer_name: str = DEFAULT_BUFFER_1):
    &#34;&#34;&#34;
    Clears all readings and statistics from the specified buffer.

    Args:
        buffer_name (str): the name of the buffer [default: DEFAULT_BUFFER_1]
    &#34;&#34;&#34;

    response = self.daq.trans(f&#39;TRACE:ACTUAL? &#34;{buffer_name}&#34;&#39;)

    logger.info(f&#34;Clearing buffer &#39;{buffer_name}&#39; containing {response} readings.&#34;)

    self.daq.write(f&#39;TRACE:CLEAR &#34;{buffer_name}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.configure_sensors"><code class="name flex">
<span>def <span class="ident">configure_sensors</span></span>(<span>self, channel_list: str, *, sense: Dict[str, List[Tuple[]]])</span>
</code></dt>
<dd>
<div class="desc"><p>This command allows to configure the different sensors in the <code>channel_list</code>. Each sensor
in the list will be configured according to the settings given in the <code>sense</code> dictionary.</p>
<p>The following code will configure channels 101 and 102 as 4-wire transducers of type PT100.</p>
<pre><code>channel_list = create_channel_list(101, 102)

sense = {
    &quot;TEMPERATURE&quot;: [
        (&quot;TRANSDUCER&quot;, &quot;FRTD&quot;),
        (&quot;RTD:FOUR&quot;, &quot;PT100&quot;),
    ]
}

daq.configure_sensors(channel_list, sense=sense)

</code></pre>
<p>The <code>sense</code> argument is a dictionary where the keys are function names like "TEMPERATURE"
or "VOLTAGE:DC", and the values are a list of settings for that function. The list of
settings is a list of tuples with the command and the value, e.g. "TRANSDUCER" is the
settings command and "FRTD" is its value. The list of settings will be send to the device
in the order that they take in the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_list</code></strong> :&ensp;<code>str</code></dt>
<dd>the channels to configure</dd>
<dt><strong><code>sense</code></strong></dt>
<dd>a dictionary with all the information on the configuration</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
    &#34;&#34;&#34;
    This command allows to configure the different sensors in the `channel_list`. Each sensor
    in the list will be configured according to the settings given in the `sense` dictionary.

    The following code will configure channels 101 and 102 as 4-wire transducers of type PT100.

    ```
    channel_list = create_channel_list(101, 102)

    sense = {
        &#34;TEMPERATURE&#34;: [
            (&#34;TRANSDUCER&#34;, &#34;FRTD&#34;),
            (&#34;RTD:FOUR&#34;, &#34;PT100&#34;),
        ]
    }

    daq.configure_sensors(channel_list, sense=sense)

    ```

    The `sense` argument is a dictionary where the keys are function names like &#34;TEMPERATURE&#34;
    or &#34;VOLTAGE:DC&#34;, and the values are a list of settings for that function. The list of
    settings is a list of tuples with the command and the value, e.g. &#34;TRANSDUCER&#34; is the
    settings command and &#34;FRTD&#34; is its value. The list of settings will be send to the device
    in the order that they take in the list.

    Args:
        channel_list (str): the channels to configure
        sense: a dictionary with all the information on the configuration

    Returns:
        None.
    &#34;&#34;&#34;

    if &#34;TEMPERATURE&#34; in sense:

        # Allowed settings for TEMPERATURE:
        #
        # - TEMPERATURE:APERTURE                  (@&lt;channelList&gt;)
        # - TEMPERATURE:AVERAGE:COUNT             (@&lt;channelList&gt;)
        # - TEMPERATURE:AVERAGE:STATE             (@&lt;channelList&gt;)
        # - TEMPERATURE:AVERAGE:TCONTROL          (@&lt;channelList&gt;)
        # - TEMPERATURE:AVERAGE:WINDOW            (@&lt;channelList&gt;)
        # - TEMPERATURE:AVERAGE:AZERO:STATE
        # - TEMPERATURE:DELAY:AUTO
        # - TEMPERATURE:DELAY:USER&lt;N&gt;
        # - TEMPERATURE:LINE:SYNC
        # - TEMPERATURE:NPLCYCLES
        # - TEMPERATURE:OCOMPENSATED
        # - TEMPERATURE:ODETECTOR
        # - TEMPERATURE:RELATIVE
        # - TEMPERATURE:RELATIVE:ACQUIRE
        # - TEMPERATURE:RELATIVE:STATE
        # - TEMPERATURE:RTD:ALPHA, BETA, DELTA      (@&lt;channelList&gt;)
        # - TEMPERATURE:RTD:ZERO, TWO, THREE, FOUR  (@&lt;channelList&gt;)
        # - TEMPERATURE:TCOUPLE:RJUNCTION:SIMULATED
        # - TEMPERATURE:TCOUPLE:RJUNCTION:RSELECT
        # - TEMPERATURE:TCOUPLE:TYPE
        # - TEMPERATURE:THERMISTOR      (@&lt;channelList&gt;)
        # - TEMPERATURE:TRANSDUCER      (@&lt;channelList&gt;)
        # - TEMPERATURE:UNIT            (@&lt;channelList&gt;)
        #

        # set the function to temperature

        self.daq.write(f&#39;SENSE:FUNCTION &#34;TEMPERATURE&#34;, {channel_list}&#39;)

        for cmd, value in sense[&#34;TEMPERATURE&#34;]:
            self.daq.write(f&#34;SENSE:TEMPERATURE:{cmd} {value}, {channel_list}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.create_buffer"><code class="name flex">
<span>def <span class="ident">create_buffer</span></span>(<span>self, buffer_name: str, size: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Reading Buffer with the given name.</p>
<p>A buffer with this name should not already exist in the device.
When the buffer does exist, the DAQ6510 will show a dialog on the front panel
with error 1115 saying the command cannot take an existing buffer name.</p>
<p>Buffer names must start with an alphabetic character. The names cannot
contain any periods nor the underscore (_) character. The name can be
up to 31 characters long.</p>
<p>If the given size is 0, the instrument creates the largest reading buffer
possible based on the available memory when the buffer is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the buffer</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>the maximum number of readings (size &gt;= 10) [default: 1000]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_buffer(self, buffer_name: str, size: int = 1000):
    &#34;&#34;&#34;
    Creates a Reading Buffer with the given name.

    A buffer with this name should not already exist in the device.
    When the buffer does exist, the DAQ6510 will show a dialog on the front panel
    with error 1115 saying the command cannot take an existing buffer name.

    Buffer names must start with an alphabetic character. The names cannot
    contain any periods nor the underscore (_) character. The name can be
    up to 31 characters long.

    If the given size is 0, the instrument creates the largest reading buffer
    possible based on the available memory when the buffer is created.

    Args:
        buffer_name (str): the name of the buffer
        size (int): the maximum number of readings (size &gt;= 10) [default: 1000]

    &#34;&#34;&#34;

    self.daq.write(f&#39;TRACE:MAKE &#34;{buffer_name}&#34;, {size}&#39;)

    self.buffer_name = buffer_name</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.delete_buffer"><code class="name flex">
<span>def <span class="ident">delete_buffer</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the specified buffer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the buffer</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_buffer(self, buffer_name: str):
    &#34;&#34;&#34;
    Deletes the specified buffer.

    Args:
        buffer_name (str): the name of the buffer
    &#34;&#34;&#34;
    self.daq.write(f&#39;TRACE:DELETE &#34;{buffer_name}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.get_buffer_capacity"><code class="name flex">
<span>def <span class="ident">get_buffer_capacity</span></span>(<span>self, buffer_name: str = 'defbuffer1')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer_capacity(self, buffer_name: str = DEFAULT_BUFFER_1):

    return self.daq.trans(f&#39;TRACE:POINTS? &#34;{buffer_name}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.get_buffer_count"><code class="name flex">
<span>def <span class="ident">get_buffer_count</span></span>(<span>self, buffer_name: str = 'defbuffer1')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer_count(self, buffer_name: str = DEFAULT_BUFFER_1):

    return self.daq.trans(f&#39;TRACE:ACTUAL? &#34;{buffer_name}&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.perform_measurement"><code class="name flex">
<span>def <span class="ident">perform_measurement</span></span>(<span>self, *, buffer_name: str = 'defbuffer1', channel_list: str, count: int = 1, interval: int = 2)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the actual measurements. This function will wait until all measurements have
completed, so be careful with the arguments <code>count</code> and <code>interval</code> as they will multiply
into the number of seconds that you will have to wait for the response.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer_name</code></strong></dt>
<dd>The name of the buffer to use [default: defbuffer1]</dd>
<dt><strong><code>channel_list</code></strong></dt>
<dd>The channels to read out</dd>
<dt><strong><code>count</code></strong></dt>
<dd>number of measurements to perform [default: 1]</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>The interval in which to read out [default: 2s]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of readings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_measurement(
    self,
    *,  # all following parameters shall be given as keyword arguments
    buffer_name: str = DEFAULT_BUFFER_1,
    channel_list: str,
    count: int = 1,
    interval: int = 2,
):
    &#34;&#34;&#34;
    Perform the actual measurements. This function will wait until all measurements have
    completed, so be careful with the arguments `count` and `interval` as they will multiply
    into the number of seconds that you will have to wait for the response.

    Args:
        buffer_name: The name of the buffer to use [default: defbuffer1]
        channel_list: The channels to read out
        count: number of measurements to perform [default: 1]
        interval: The interval in which to read out [default: 2s]

    Returns:
        List of readings.
    &#34;&#34;&#34;

    # Set the number of times a scan is repeated

    self.daq.write(f&#34;ROUTE:SCAN:COUNT:SCAN {count}&#34;)
    self.daq.write(f&#34;ROUTE:SCAN:INTERVAL {interval}&#34;)  # [seconds]

    #
    self.daq.write(&#34;INITIATE:IMMEDIATE&#34;)
    self.daq.write(&#34;*WAI&#34;)

    # Read out the buffer

    logger.debug(&#34;Buffer count = &#34;, self.get_buffer_count())

    num_sensors = count_number_of_channels(channel_list)

    readings = []

    for idx in range(1, count * num_sensors + 1):
        response = self.read_buffer(
            idx, idx, buffer_name=buffer_name, elements=[&#34;CHANNEL&#34;, &#34;TSTAMP&#34;, &#34;READING&#34;, &#34;UNIT&#34;]
        )
        if response != &#34;&#34; and response != str(count * num_sensors):
            if &#34;\n&#34; in response:
                response = response.split(&#34;\n&#34;)
                for i in range(len(response)):
                    readings.append(response[i].split(&#34;,&#34;))
            else:
                readings.append(response.split(&#34;,&#34;))
            if len(readings[0]) &lt; 4:
                del readings[0]

    return readings</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.read_buffer"><code class="name flex">
<span>def <span class="ident">read_buffer</span></span>(<span>self, start: int, end: int, buffer_name: str = 'defbuffer1', elements: List[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads specific data elements (measurements) from the given buffer.</p>
<p>Elements that can be specified to read out:</p>
<ul>
<li>CHANNEL: the channel for which the data was acquired</li>
<li>DATE: the date when the data point was measured</li>
<li>READING: the actual reading of the measurement</li>
<li>TSTAMP: the time stamp when the data point was measured</li>
<li>UNIT: the unit of measure for the measurement</li>
<li>STATUS: the status information associated with the measurement</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>first index of the buffer, must be greater or equal to 1</dd>
<dt><strong><code>end</code></strong></dt>
<dd>last index of the buffer to return</dd>
<dt><strong><code>buffer_name</code></strong></dt>
<dd>the name of the buffer to read out</dd>
<dt><strong><code>elements</code></strong></dt>
<dd>the list of elements from the buffer to include in the response</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of all the readings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_buffer(
    self, start: int, end: int, buffer_name: str = DEFAULT_BUFFER_1, elements: List[str] = None
):
    &#34;&#34;&#34;
    Reads specific data elements (measurements) from the given buffer.

    Elements that can be specified to read out:

    * CHANNEL: the channel for which the data was acquired
    * DATE: the date when the data point was measured
    * READING: the actual reading of the measurement
    * TSTAMP: the time stamp when the data point was measured
    * UNIT: the unit of measure for the measurement
    * STATUS: the status information associated with the measurement

    Args:
        start: first index of the buffer, must be greater or equal to 1
        end: last index of the buffer to return
        buffer_name: the name of the buffer to read out
        elements: the list of elements from the buffer to include in the response

    Returns:
        A list of all the readings.
    &#34;&#34;&#34;
    if elements is None:
        elements = [&#34;READING&#34;]
    else:
        elements = &#34;, &#34;.join(elements)

    return self.daq.trans(f&#39;TRACE:DATA? {start}, {end}, &#34;{buffer_name}&#34;, {elements}&#39;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.setup_measurements"><code class="name flex">
<span>def <span class="ident">setup_measurements</span></span>(<span>self, *, buffer_name: str = 'defbuffer1', channel_list: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Setup the measurements for the given channel list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>buffer_name</code></strong></dt>
<dd>The name of the buffer to use [default: defbuffer1]</dd>
<dt><strong><code>channel_list</code></strong></dt>
<dd>The channels to read out</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_measurements(self, *, buffer_name: str = DEFAULT_BUFFER_1, channel_list: str):
    &#34;&#34;&#34;
    Setup the measurements for the given channel list.

    Args:
        buffer_name: The name of the buffer to use [default: defbuffer1]
        channel_list: The channels to read out

    Returns:
        None
    &#34;&#34;&#34;
    self.daq.write(f&#39;ROUTE:SCAN:BUFFER &#34;{buffer_name}&#34;&#39;)
    self.daq.write(f&#34;ROUTE:SCAN:CREATE {channel_list}&#34;)
    self.daq.write(f&#34;ROUTE:CHANNEL:OPEN {channel_list}&#34;)
    _ = self.daq.trans(f&#34;ROUTE:CHANNEL:STATE? {channel_list}&#34;)
    self.daq.write(&#34;ROUTE:SCAN:START:STIMULUS NONE&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time">get_time</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command">send_command</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time">set_time</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.mixin.DynamicCommandMixin" href="../../mixin.html#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.mixin.DynamicCommandMixin.create_command_string" href="../../mixin.html#egse.mixin.DynamicCommandMixin.create_command_string">create_command_string</a></code></li>
<li><code><a title="egse.mixin.DynamicCommandMixin.handle_dynamic_command" href="../../mixin.html#egse.mixin.DynamicCommandMixin.handle_dynamic_command">handle_dynamic_command</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface"><code class="flex name class">
<span>class <span class="ident">DAQ6510Interface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Keithley DAQ6510 Controller,Proxy and Simulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAQ6510Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Keithley DAQ6510 Controller,Proxy and Simulator.
    &#34;&#34;&#34;

    @dynamic_interface
    def send_command(self, command: str, response: bool):
        &#34;&#34;&#34;
        Send a SCPI command to the device. The valid commands are described in the DAQ6510
        Reference Manual [DAQ6510-901-01 Rev. B / September 2019]

        Args:
            command (str): a SCPI command as specified in the DAQ6510 Reference Manual
            response (bool): set to True if you expect a response from the device

        Returns:
            The response from the DAQ6510 is returned when a response was expected. When
            `response` is False, None will be returned.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;transaction&#34;,
        cmd_string=&#34;*IDN?&#34;,
        process_cmd_string=add_lf,
    )
    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Returns basic information about the device, its name, firmwre version etc.

        The string returned is subject to change without notice and can not be used for parsing
        information.

        Returns:
            An identification string of the instrument.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;,
        cmd_string=&#34;*RST&#34;,
        process_cmd_string=add_lf,
    )
    def reset(self):
        &#34;&#34;&#34;
        Resets the DAQ6510. This returns the instrument to default settings, and cancels all
        pending commands.

        .. Note::
            The `reset()` method also deletes all the user-defined buffers. The two default
            buffers are cleared.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int):
        &#34;&#34;&#34;Set the absolute date and time for the device.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_time(self):
        &#34;&#34;&#34;
        Get the date and time from the device in UTC. The returned string is of the format:

            &lt;weekday&gt; &lt;month&gt; &lt;day&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;year&gt;

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def read_buffer(self, start: int, end: int, buffer_name: str, elements: List[str]):
        raise NotImplementedError

    @dynamic_interface
    def get_buffer_count(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def get_buffer_capacity(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def delete_buffer(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def clear_buffer(self, buffer_name: str):
        raise NotImplementedError

    @dynamic_interface
    def create_buffer(self, buffer_name: str, size: int):
        raise NotImplementedError

    @dynamic_interface
    def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
        raise NotImplementedError

    @dynamic_interface
    def setup_measurements(self, *, buffer_name: str, channel_list: str):
        raise NotImplementedError

    @dynamic_interface
    def perform_measurement(
        self, *, buffer_name: str, channel_list: str, count: int, interval: int
    ):
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller">DAQ6510Controller</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Proxy" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Proxy">DAQ6510Proxy</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator">DAQ6510Simulator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.clear_buffer"><code class="name flex">
<span>def <span class="ident">clear_buffer</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def clear_buffer(self, buffer_name: str):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.configure_sensors"><code class="name flex">
<span>def <span class="ident">configure_sensors</span></span>(<span>self, channel_list: str, *, sense: Dict[str, List[Tuple[]]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.create_buffer"><code class="name flex">
<span>def <span class="ident">create_buffer</span></span>(<span>self, buffer_name: str, size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def create_buffer(self, buffer_name: str, size: int):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.delete_buffer"><code class="name flex">
<span>def <span class="ident">delete_buffer</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def delete_buffer(self, buffer_name: str):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_buffer_capacity"><code class="name flex">
<span>def <span class="ident">get_buffer_capacity</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_buffer_capacity(self, buffer_name: str):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_buffer_count"><code class="name flex">
<span>def <span class="ident">get_buffer_count</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_buffer_count(self, buffer_name: str):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the date and time from the device in UTC. The returned string is of the format:</p>
<pre><code>&lt;weekday&gt; &lt;month&gt; &lt;day&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;year&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_time(self):
    &#34;&#34;&#34;
    Get the date and time from the device in UTC. The returned string is of the format:

        &lt;weekday&gt; &lt;month&gt; &lt;day&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; &lt;year&gt;

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns basic information about the device, its name, firmwre version etc.</p>
<p>The string returned is subject to change without notice and can not be used for parsing
information.</p>
<h2 id="returns">Returns</h2>
<p>An identification string of the instrument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;transaction&#34;,
    cmd_string=&#34;*IDN?&#34;,
    process_cmd_string=add_lf,
)
def info(self) -&gt; str:
    &#34;&#34;&#34;
    Returns basic information about the device, its name, firmwre version etc.

    The string returned is subject to change without notice and can not be used for parsing
    information.

    Returns:
        An identification string of the instrument.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.perform_measurement"><code class="name flex">
<span>def <span class="ident">perform_measurement</span></span>(<span>self, *, buffer_name: str, channel_list: str, count: int, interval: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def perform_measurement(
    self, *, buffer_name: str, channel_list: str, count: int, interval: int
):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.read_buffer"><code class="name flex">
<span>def <span class="ident">read_buffer</span></span>(<span>self, start: int, end: int, buffer_name: str, elements: List[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def read_buffer(self, start: int, end: int, buffer_name: str, elements: List[str]):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the DAQ6510. This returns the instrument to default settings, and cancels all
pending commands.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code>reset()</code> method also deletes all the user-defined buffers. The two default
buffers are cleared.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;,
    cmd_string=&#34;*RST&#34;,
    process_cmd_string=add_lf,
)
def reset(self):
    &#34;&#34;&#34;
    Resets the DAQ6510. This returns the instrument to default settings, and cancels all
    pending commands.

    .. Note::
        The `reset()` method also deletes all the user-defined buffers. The two default
        buffers are cleared.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command: str, response: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a SCPI command to the device. The valid commands are described in the DAQ6510
Reference Manual [DAQ6510-901-01 Rev. B / September 2019]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>str</code></dt>
<dd>a SCPI command as specified in the DAQ6510 Reference Manual</dd>
<dt><strong><code>response</code></strong> :&ensp;<code>bool</code></dt>
<dd>set to True if you expect a response from the device</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The response from the DAQ6510 is returned when a response was expected. When
<code>response</code> is False, None will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def send_command(self, command: str, response: bool):
    &#34;&#34;&#34;
    Send a SCPI command to the device. The valid commands are described in the DAQ6510
    Reference Manual [DAQ6510-901-01 Rev. B / September 2019]

    Args:
        command (str): a SCPI command as specified in the DAQ6510 Reference Manual
        response (bool): set to True if you expect a response from the device

    Returns:
        The response from the DAQ6510 is returned when a response was expected. When
        `response` is False, None will be returned.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time"><code class="name flex">
<span>def <span class="ident">set_time</span></span>(<span>self, year: int, month: int, day: int, hour: int, minute: int, second: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the absolute date and time for the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_time(self, year: int, month: int, day: int, hour: int, minute: int, second: int):
    &#34;&#34;&#34;Set the absolute date and time for the device.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.setup_measurements"><code class="name flex">
<span>def <span class="ident">setup_measurements</span></span>(<span>self, *, buffer_name: str, channel_list: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def setup_measurements(self, *, buffer_name: str, channel_list: str):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Proxy"><code class="flex name class">
<span>class <span class="ident">DAQ6510Proxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6920, timeout=90000)</span>
</code></dt>
<dd>
<div class="desc"><p>The LakeShoreProxy class is used to connect to the LakeShore control server and send commands
to the LakeShore Hardware Controller remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol [default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address)
[default is taken from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAQ6510Proxy(Proxy, DAQ6510Interface):
    &#34;&#34;&#34;
    The LakeShoreProxy class is used to connect to the LakeShore control server and send commands
    to the LakeShore Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
        timeout = CTRL_SETTINGS.TIMEOUT * 1000 # timeout in ms. timeout must be &gt; scan count * interval + (one scan duration)
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time">get_time</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command">send_command</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time">set_time</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator"><code class="flex name class">
<span>class <span class="ident">DAQ6510Simulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Keithley DAQ6510 Controller,Proxy and Simulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAQ6510Simulator(DAQ6510Interface):
    def read_buffer(self, start: int, end: int, buffer_name: str, elements: List[str]):
        pass

    def get_buffer_count(self, buffer_name: str):
        pass

    def get_buffer_capacity(self, buffer_name: str):
        pass

    def delete_buffer(self, buffer_name: str):
        pass

    def clear_buffer(self, buffer_name: str):
        pass

    def create_buffer(self, buffer_name: str, size: int):
        pass

    def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
        pass

    def setup_measurements(self, *, buffer_name: str, channel_list: str):
        pass

    def perform_measurement(
        self, *, buffer_name: str, channel_list: str, count: int, interval: int
    ):
        pass

    def send_command(self, command: str, response: bool):
        pass

    def info(self) -&gt; str:
        pass

    def reset(self):
        pass

    def is_simulator(self):
        pass

    def connect(self):
        pass

    def disconnect(self):
        pass

    def reconnect(self):
        pass

    def is_connected(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.clear_buffer"><code class="name flex">
<span>def <span class="ident">clear_buffer</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_buffer(self, buffer_name: str):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.configure_sensors"><code class="name flex">
<span>def <span class="ident">configure_sensors</span></span>(<span>self, channel_list: str, *, sense: Dict[str, List[Tuple[]]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_sensors(self, channel_list: str, *, sense: Dict[str, List[Tuple]]):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.create_buffer"><code class="name flex">
<span>def <span class="ident">create_buffer</span></span>(<span>self, buffer_name: str, size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_buffer(self, buffer_name: str, size: int):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.delete_buffer"><code class="name flex">
<span>def <span class="ident">delete_buffer</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_buffer(self, buffer_name: str):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.get_buffer_capacity"><code class="name flex">
<span>def <span class="ident">get_buffer_capacity</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer_capacity(self, buffer_name: str):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.get_buffer_count"><code class="name flex">
<span>def <span class="ident">get_buffer_count</span></span>(<span>self, buffer_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_buffer_count(self, buffer_name: str):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.perform_measurement"><code class="name flex">
<span>def <span class="ident">perform_measurement</span></span>(<span>self, *, buffer_name: str, channel_list: str, count: int, interval: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_measurement(
    self, *, buffer_name: str, channel_list: str, count: int, interval: int
):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.read_buffer"><code class="name flex">
<span>def <span class="ident">read_buffer</span></span>(<span>self, start: int, end: int, buffer_name: str, elements: List[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_buffer(self, start: int, end: int, buffer_name: str, elements: List[str]):
    pass</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.setup_measurements"><code class="name flex">
<span>def <span class="ident">setup_measurements</span></span>(<span>self, *, buffer_name: str, channel_list: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_measurements(self, *, buffer_name: str, channel_list: str):
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time">get_time</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command">send_command</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time">set_time</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tempcontrol.keithley" href="index.html">egse.tempcontrol.keithley</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.tempcontrol.keithley.daq6510.count_number_of_channels" href="#egse.tempcontrol.keithley.daq6510.count_number_of_channels">count_number_of_channels</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.create_channel_list" href="#egse.tempcontrol.keithley.daq6510.create_channel_list">create_channel_list</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.get_channel_names" href="#egse.tempcontrol.keithley.daq6510.get_channel_names">get_channel_names</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller">DAQ6510Controller</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.clear_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.configure_sensors" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.configure_sensors">configure_sensors</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.create_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.create_buffer">create_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.delete_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.delete_buffer">delete_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.get_buffer_capacity" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.get_buffer_capacity">get_buffer_capacity</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.get_buffer_count" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.get_buffer_count">get_buffer_count</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.perform_measurement" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.perform_measurement">perform_measurement</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.read_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.read_buffer">read_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Controller.setup_measurements" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Controller.setup_measurements">setup_measurements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface">DAQ6510Interface</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.clear_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.configure_sensors" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.configure_sensors">configure_sensors</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.create_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.create_buffer">create_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.delete_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.delete_buffer">delete_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_buffer_capacity" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_buffer_capacity">get_buffer_capacity</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_buffer_count" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_buffer_count">get_buffer_count</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.get_time">get_time</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.perform_measurement" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.perform_measurement">perform_measurement</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.read_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.read_buffer">read_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.send_command">send_command</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.set_time">set_time</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Interface.setup_measurements" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Interface.setup_measurements">setup_measurements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Proxy" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Proxy">DAQ6510Proxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator">DAQ6510Simulator</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.clear_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.configure_sensors" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.configure_sensors">configure_sensors</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.create_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.create_buffer">create_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.delete_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.delete_buffer">delete_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.get_buffer_capacity" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.get_buffer_capacity">get_buffer_capacity</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.get_buffer_count" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.get_buffer_count">get_buffer_count</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.perform_measurement" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.perform_measurement">perform_measurement</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.read_buffer" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.read_buffer">read_buffer</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.setup_measurements" href="#egse.tempcontrol.keithley.daq6510.DAQ6510Simulator.setup_measurements">setup_measurements</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
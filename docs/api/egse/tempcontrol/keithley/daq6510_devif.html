<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tempcontrol.keithley.daq6510_devif API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tempcontrol.keithley.daq6510_devif</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import socket
import time

from egse.command import ClientServerCommand
from egse.device import DeviceConnectionError
from egse.device import DeviceConnectionInterface
from egse.device import DeviceError
from egse.device import DeviceTimeoutError
from egse.device import DeviceTransport
from egse.settings import Settings
from egse.system import Timer

logger = logging.getLogger(__name__)

IDENTIFICATION_QUERY = &#34;*IDN?&#34;

DEVICE_SETTINGS = Settings.load(&#34;Keithley DAQ6510&#34;)
DEVICE_NAME = &#34;DAQ6510&#34;
READ_TIMEOUT = DEVICE_SETTINGS.TIMEOUT # READ_TIMEOUT in second. READ_TIMEOUT can be smaller than timeout (for DAQ6510Proxy) (e.g. 1 second)

class DAQ6510Command(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\n&#34;


class DAQ6510EthernetInterface(DeviceConnectionInterface, DeviceTransport):
    &#34;&#34;&#34;Defines the low-level interface to the Keithley DAQ6510 Controller.&#34;&#34;&#34;

    def __init__(self, hostname=None, port=None):
        self.hostname = DEVICE_SETTINGS.HOSTNAME if hostname is None else hostname
        self.port = DEVICE_SETTINGS.PORT if port is None else port
        self.sock = None

        self.is_connection_open = False

    def connect(self):
        &#34;&#34;&#34;Connect the device.

        Raises:
            DeviceConnectionError: When the connection could not be established. Check the logging
            messages for more detail.

            DeviceTimeoutError: When the connection timed out.

            ValueError: When hostname or port number are not provided.
        &#34;&#34;&#34;

        # Sanity checks

        if self.is_connection_open:
            logger.warning(f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
            return

        if self.hostname in (None, &#34;&#34;):
            raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

        if self.port in (None, 0):
            raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

        # Create a new socket instance

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # The following lines are to experiment with blocking and timeout, but there is no need.
            # self.sock.setblocking(1)
            # self.sock.settimeout(3)
        except socket.error as e_socket:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket

        # Attempt to establish a connection to the remote host

        # FIXME: Socket shall be closed on exception?

        # We set a timeout of 3 sec before connecting and reset to None
        # (=blocking) after the connect. The reason for this is because when no
        # device is available, e.g during testing, the timeout will take about
        # two minutes which is way too long. It needs to be evaluated if this
        # approach is acceptable and not causing problems during production.

        try:
            logger.debug(f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
            self.sock.settimeout(3)
            self.sock.connect((self.hostname, self.port))
            self.sock.settimeout(None)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
            ) from exc
        except TimeoutError as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
            ) from exc
        except socket.gaierror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
            ) from exc
        except socket.herror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
            ) from exc
        except socket.timeout as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
            ) from exc
        except OSError as exc:
            raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

        self.is_connection_open = True

        # Check that we are connected to the controller by issuing the &#34;VERSION&#34; or
        # &#34;*ISDN?&#34; query. If we don&#39;t get the right response, then disconnect automatically.

        if not self.is_connected():
            raise DeviceConnectionError(
                DEVICE_NAME, &#34;Device is not connected, check logging messages for the cause.&#34;
            )

    def disconnect(self):
        &#34;&#34;&#34;Disconnect from the Ethernet connection.

        Raises:
            DeviceConnectionError when the socket could not be closed.
        &#34;&#34;&#34;

        try:
            if self.is_connection_open:
                logger.debug(f&#34;Disconnecting from {self.hostname}&#34;)
                self.sock.close()
                self.is_connection_open = False
        except Exception as e_exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc

    def reconnect(self):
        if self.is_connection_open:
            self.disconnect()
        self.connect()

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the device is connected. This will send a query for the device identification
        and validate the answer.

        Returns:
             True is the device is connected and answered with the proper ID, False otherwise.
        &#34;&#34;&#34;

        if not self.is_connection_open:
            return False

        try:
            response = self.query(IDENTIFICATION_QUERY)
        except DeviceError as exc:
            logger.exception(exc)
            logger.error(&#34;Most probably the client connection was closed. Disconnecting...&#34;)
            self.disconnect()
            return False

        version = response

        if &#34;DAQ6510&#34; not in version:
            logger.error(
                f&#39;Device did not respond correctly to a &#34;VERSION&#34; command, response={response}. &#39;
                f&#34;Disconnecting...&#34;
            )
            self.disconnect()
            return False

        return True

    def write(self, command: str):
        &#34;&#34;&#34;
        Send a single command to the device controller without waiting for a response.

        Args:
            command: an order command for the controller.

        Raises:
            DeviceConnectionError when the command could not be sent due to a
            communication problem.

            DeviceTimeoutError when the command could not be sent due to a timeout.
        &#34;&#34;&#34;

        try:

            command += &#34;\n&#34; if not command.endswith(&#34;\n&#34;) else &#34;&#34;

            self.sock.sendall(command.encode())

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as a connection error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
        except AttributeError:
            if not self.is_connection_open:
                msg = &#34;The DAQ6510 is not connected, use the connect() method.&#34;
                raise DeviceConnectionError(DEVICE_NAME, msg)
            raise

    def trans(self, command: str) -&gt; str:
        &#34;&#34;&#34;
        Send a single command to the device controller and block until a response from the
        controller. This is seen as a transaction.

        Args:
            command: is the command to be sent
        Returns:
            Either a string returned by the controller (on success), or an error message (on
            failure).
        Raises:
            DeviceConnectionError when there was an I/O problem during communication with the
            controller.

            DeviceTimeoutError when there was a timeout in either sending the command or
            receiving the response.
        &#34;&#34;&#34;

        try:

            # Attempt to send the complete command

            command += &#34;\n&#34; if not command.endswith(&#34;\n&#34;) else &#34;&#34;

            self.sock.sendall(command.encode())

            # wait for, read and return the response from HUBER (will be at most TBD chars)

            return_string = self.read()

            response = return_string.decode().rstrip()

            return response

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as an I/O error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
        except ConnectionError as exc:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Connection error.&#34;) from exc
        except AttributeError:
            if not self.is_connection_open:
                raise DeviceConnectionError(
                    DEVICE_NAME, &#34;Device not connected, use the connect() method.&#34;
                )
            raise

    def read(self) -&gt; bytes:
        n_total = 0
        buf_size = 2048

        # Set a timeout of READ_TIMEOUT to the socket.recv

        saved_timeout = self.sock.gettimeout()
        self.sock.settimeout(READ_TIMEOUT)

        try:
            for idx in range(100):
                time.sleep(0.001)  # Give the device time to fill the buffer
                data = self.sock.recv(buf_size)
                n = len(data)
                n_total += n
                if n &lt; buf_size:
                    break
        except socket.timeout as e_timeout:
            logger.warning(f&#34;Socket timeout error for {self.hostname}:{self.port}&#34;)
            return b&#34;\r\n&#34;
        except TimeoutError as exc:
            logger.warning(f&#34;Socket timeout error: {exc}&#34;)
            return b&#34;\r\n&#34;
        finally:
            self.sock.settimeout(saved_timeout)

        # logger.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)

        return data


if __name__ == &#34;__main__&#34;:

    daq = DAQ6510EthernetInterface()

    with Timer():
        daq.connect()

    # print(daq.info())

    # Initialize

    daq.write(&#39;TRAC:DEL &#34;test1&#34;\n&#39;)

    for cmd, response in [
        (&#39;TRAC:MAKE &#34;test1&#34;, 1000&#39;, False),  # create a new buffer
        # settings for channel 1 and 2 of slot 1
        (&#39;SENS:FUNC &#34;TEMP&#34;, (@101:102)&#39;, False),  # set the function to temperature
        (&#34;SENS:TEMP:TRAN FRTD, (@101:102)&#34;, False),  # set the transducer to 4-wire RTD
        (&#34;SENS:TEMP:RTD:FOUR PT100, (@101:102)&#34;, False),  # set the type of the 4-wire RTD
        (&#39;ROUT:SCAN:BUFF &#34;test1&#34;&#39;, False),
        (&#34;ROUT:SCAN:CRE (@101:102)&#34;, False),
        (&#34;ROUT:CHAN:OPEN (@101:102)&#34;, False),
        (&#34;ROUT:STAT? (@101:102)&#34;, True),
        (&#34;ROUT:SCAN:STAR:STIM NONE&#34;, False),
        # (&#34;ROUT:SCAN:ADD:SING (@101, 102)&#34;, False),  # not sure what this does, not really needed
        (&#34;ROUT:SCAN:COUN:SCAN 1&#34;, False),  # not sure if this is needed in this setting
        # (&#34;ROUT:SCAN:INT 1&#34;, False),
    ]:
        print(f&#34;Sending {cmd}...&#34;)
        if response:
            print(daq.trans(cmd), end=&#34;&#34;)
        else:
            daq.write(cmd)

    # Read out the channels

    # daq.write(&#39;TRAC:CLE &#34;test1&#34;\n&#39;)

    for _ in range(10):
        daq.write(&#34;INIT:IMM&#34;)
        daq.write(&#34;*WAI&#34;)

        # Reading the data

        # When a trigger mode is running, these READ? commands can not be used.

        # print(daq.trans(&#39;READ? &#34;test1&#34;, CHAN, TST, READ\n&#39;, wait=False), end=&#34;&#34;)
        # print(daq.trans(&#39;READ? &#34;test1&#34;, CHAN, TST, READ\n&#39;, wait=False), end=&#34;&#34;)
        # time.sleep(1)
        # print(daq.trans(&#39;READ? &#34;test1&#34;, CHAN, TST, READ\n&#39;, wait=False), end=&#34;&#34;)
        # print(daq.trans(&#39;READ? &#34;test1&#34;, CHAN, TST, READ\n&#39;, wait=False), end=&#34;&#34;)

        # Read out the buffer

        response = daq.trans(&#39;TRAC:DATA? 1, 2, &#34;test1&#34;, CHAN, TST, READ&#39;)
        ch1, tst1, val1, ch2, tst2, val2 = response[:-1].split(&#34;,&#34;)
        print(f&#34;Channel: {ch1} Time: {tst1} Value: {float(val1):.4f}\t&#34;, end=&#34;&#34;)
        print(f&#34;Channel: {ch2} Time: {tst2} Value: {float(val2):.4f}&#34;)
        time.sleep(2)

    daq.disconnect()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command"><code class="flex name class">
<span>class <span class="ident">DAQ6510Command</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAQ6510Command(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    out = super().get_cmd_string(*args, **kwargs)
    return out + &#34;\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface"><code class="flex name class">
<span>class <span class="ident">DAQ6510EthernetInterface</span></span>
<span>(</span><span>hostname=None, port=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the low-level interface to the Keithley DAQ6510 Controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DAQ6510EthernetInterface(DeviceConnectionInterface, DeviceTransport):
    &#34;&#34;&#34;Defines the low-level interface to the Keithley DAQ6510 Controller.&#34;&#34;&#34;

    def __init__(self, hostname=None, port=None):
        self.hostname = DEVICE_SETTINGS.HOSTNAME if hostname is None else hostname
        self.port = DEVICE_SETTINGS.PORT if port is None else port
        self.sock = None

        self.is_connection_open = False

    def connect(self):
        &#34;&#34;&#34;Connect the device.

        Raises:
            DeviceConnectionError: When the connection could not be established. Check the logging
            messages for more detail.

            DeviceTimeoutError: When the connection timed out.

            ValueError: When hostname or port number are not provided.
        &#34;&#34;&#34;

        # Sanity checks

        if self.is_connection_open:
            logger.warning(f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
            return

        if self.hostname in (None, &#34;&#34;):
            raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

        if self.port in (None, 0):
            raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

        # Create a new socket instance

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # The following lines are to experiment with blocking and timeout, but there is no need.
            # self.sock.setblocking(1)
            # self.sock.settimeout(3)
        except socket.error as e_socket:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket

        # Attempt to establish a connection to the remote host

        # FIXME: Socket shall be closed on exception?

        # We set a timeout of 3 sec before connecting and reset to None
        # (=blocking) after the connect. The reason for this is because when no
        # device is available, e.g during testing, the timeout will take about
        # two minutes which is way too long. It needs to be evaluated if this
        # approach is acceptable and not causing problems during production.

        try:
            logger.debug(f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
            self.sock.settimeout(3)
            self.sock.connect((self.hostname, self.port))
            self.sock.settimeout(None)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
            ) from exc
        except TimeoutError as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
            ) from exc
        except socket.gaierror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
            ) from exc
        except socket.herror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
            ) from exc
        except socket.timeout as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
            ) from exc
        except OSError as exc:
            raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

        self.is_connection_open = True

        # Check that we are connected to the controller by issuing the &#34;VERSION&#34; or
        # &#34;*ISDN?&#34; query. If we don&#39;t get the right response, then disconnect automatically.

        if not self.is_connected():
            raise DeviceConnectionError(
                DEVICE_NAME, &#34;Device is not connected, check logging messages for the cause.&#34;
            )

    def disconnect(self):
        &#34;&#34;&#34;Disconnect from the Ethernet connection.

        Raises:
            DeviceConnectionError when the socket could not be closed.
        &#34;&#34;&#34;

        try:
            if self.is_connection_open:
                logger.debug(f&#34;Disconnecting from {self.hostname}&#34;)
                self.sock.close()
                self.is_connection_open = False
        except Exception as e_exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc

    def reconnect(self):
        if self.is_connection_open:
            self.disconnect()
        self.connect()

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the device is connected. This will send a query for the device identification
        and validate the answer.

        Returns:
             True is the device is connected and answered with the proper ID, False otherwise.
        &#34;&#34;&#34;

        if not self.is_connection_open:
            return False

        try:
            response = self.query(IDENTIFICATION_QUERY)
        except DeviceError as exc:
            logger.exception(exc)
            logger.error(&#34;Most probably the client connection was closed. Disconnecting...&#34;)
            self.disconnect()
            return False

        version = response

        if &#34;DAQ6510&#34; not in version:
            logger.error(
                f&#39;Device did not respond correctly to a &#34;VERSION&#34; command, response={response}. &#39;
                f&#34;Disconnecting...&#34;
            )
            self.disconnect()
            return False

        return True

    def write(self, command: str):
        &#34;&#34;&#34;
        Send a single command to the device controller without waiting for a response.

        Args:
            command: an order command for the controller.

        Raises:
            DeviceConnectionError when the command could not be sent due to a
            communication problem.

            DeviceTimeoutError when the command could not be sent due to a timeout.
        &#34;&#34;&#34;

        try:

            command += &#34;\n&#34; if not command.endswith(&#34;\n&#34;) else &#34;&#34;

            self.sock.sendall(command.encode())

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as a connection error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
        except AttributeError:
            if not self.is_connection_open:
                msg = &#34;The DAQ6510 is not connected, use the connect() method.&#34;
                raise DeviceConnectionError(DEVICE_NAME, msg)
            raise

    def trans(self, command: str) -&gt; str:
        &#34;&#34;&#34;
        Send a single command to the device controller and block until a response from the
        controller. This is seen as a transaction.

        Args:
            command: is the command to be sent
        Returns:
            Either a string returned by the controller (on success), or an error message (on
            failure).
        Raises:
            DeviceConnectionError when there was an I/O problem during communication with the
            controller.

            DeviceTimeoutError when there was a timeout in either sending the command or
            receiving the response.
        &#34;&#34;&#34;

        try:

            # Attempt to send the complete command

            command += &#34;\n&#34; if not command.endswith(&#34;\n&#34;) else &#34;&#34;

            self.sock.sendall(command.encode())

            # wait for, read and return the response from HUBER (will be at most TBD chars)

            return_string = self.read()

            response = return_string.decode().rstrip()

            return response

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as an I/O error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
        except ConnectionError as exc:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Connection error.&#34;) from exc
        except AttributeError:
            if not self.is_connection_open:
                raise DeviceConnectionError(
                    DEVICE_NAME, &#34;Device not connected, use the connect() method.&#34;
                )
            raise

    def read(self) -&gt; bytes:
        n_total = 0
        buf_size = 2048

        # Set a timeout of READ_TIMEOUT to the socket.recv

        saved_timeout = self.sock.gettimeout()
        self.sock.settimeout(READ_TIMEOUT)

        try:
            for idx in range(100):
                time.sleep(0.001)  # Give the device time to fill the buffer
                data = self.sock.recv(buf_size)
                n = len(data)
                n_total += n
                if n &lt; buf_size:
                    break
        except socket.timeout as e_timeout:
            logger.warning(f&#34;Socket timeout error for {self.hostname}:{self.port}&#34;)
            return b&#34;\r\n&#34;
        except TimeoutError as exc:
            logger.warning(f&#34;Socket timeout error: {exc}&#34;)
            return b&#34;\r\n&#34;
        finally:
            self.sock.settimeout(saved_timeout)

        # logger.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)

        return data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
<li><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect the device.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>DeviceConnectionError</code></dt>
<dd>When the connection could not be established. Check the logging</dd>
</dl>
<p>messages for more detail.</p>
<dl>
<dt><code>DeviceTimeoutError</code></dt>
<dd>When the connection timed out.</dd>
<dt><code>ValueError</code></dt>
<dd>When hostname or port number are not provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Connect the device.

    Raises:
        DeviceConnectionError: When the connection could not be established. Check the logging
        messages for more detail.

        DeviceTimeoutError: When the connection timed out.

        ValueError: When hostname or port number are not provided.
    &#34;&#34;&#34;

    # Sanity checks

    if self.is_connection_open:
        logger.warning(f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
        return

    if self.hostname in (None, &#34;&#34;):
        raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

    if self.port in (None, 0):
        raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

    # Create a new socket instance

    try:
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # The following lines are to experiment with blocking and timeout, but there is no need.
        # self.sock.setblocking(1)
        # self.sock.settimeout(3)
    except socket.error as e_socket:
        raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket

    # Attempt to establish a connection to the remote host

    # FIXME: Socket shall be closed on exception?

    # We set a timeout of 3 sec before connecting and reset to None
    # (=blocking) after the connect. The reason for this is because when no
    # device is available, e.g during testing, the timeout will take about
    # two minutes which is way too long. It needs to be evaluated if this
    # approach is acceptable and not causing problems during production.

    try:
        logger.debug(f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
        self.sock.settimeout(3)
        self.sock.connect((self.hostname, self.port))
        self.sock.settimeout(None)
    except ConnectionRefusedError as exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
        ) from exc
    except TimeoutError as exc:
        raise DeviceTimeoutError(
            DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
        ) from exc
    except socket.gaierror as exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
        ) from exc
    except socket.herror as exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
        ) from exc
    except socket.timeout as exc:
        raise DeviceTimeoutError(
            DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
        ) from exc
    except OSError as exc:
        raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

    self.is_connection_open = True

    # Check that we are connected to the controller by issuing the &#34;VERSION&#34; or
    # &#34;*ISDN?&#34; query. If we don&#39;t get the right response, then disconnect automatically.

    if not self.is_connected():
        raise DeviceConnectionError(
            DEVICE_NAME, &#34;Device is not connected, check logging messages for the cause.&#34;
        )</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from the Ethernet connection.</p>
<h2 id="raises">Raises</h2>
<p>DeviceConnectionError when the socket could not be closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnect from the Ethernet connection.

    Raises:
        DeviceConnectionError when the socket could not be closed.
    &#34;&#34;&#34;

    try:
        if self.is_connection_open:
            logger.debug(f&#34;Disconnecting from {self.hostname}&#34;)
            self.sock.close()
            self.is_connection_open = False
    except Exception as e_exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the device is connected. This will send a query for the device identification
and validate the answer.</p>
<h2 id="returns">Returns</h2>
<p>True is the device is connected and answered with the proper ID, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if the device is connected. This will send a query for the device identification
    and validate the answer.

    Returns:
         True is the device is connected and answered with the proper ID, False otherwise.
    &#34;&#34;&#34;

    if not self.is_connection_open:
        return False

    try:
        response = self.query(IDENTIFICATION_QUERY)
    except DeviceError as exc:
        logger.exception(exc)
        logger.error(&#34;Most probably the client connection was closed. Disconnecting...&#34;)
        self.disconnect()
        return False

    version = response

    if &#34;DAQ6510&#34; not in version:
        logger.error(
            f&#39;Device did not respond correctly to a &#34;VERSION&#34; command, response={response}. &#39;
            f&#34;Disconnecting...&#34;
        )
        self.disconnect()
        return False

    return True</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.trans"><code class="name flex">
<span>def <span class="ident">trans</span></span>(<span>self, command: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Send a single command to the device controller and block until a response from the
controller. This is seen as a transaction.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>is the command to be sent</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Either a string returned by the controller (on success), or an error message (on
failure).</p>
<h2 id="raises">Raises</h2>
<p>DeviceConnectionError when there was an I/O problem during communication with the
controller.</p>
<p>DeviceTimeoutError when there was a timeout in either sending the command or
receiving the response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trans(self, command: str) -&gt; str:
    &#34;&#34;&#34;
    Send a single command to the device controller and block until a response from the
    controller. This is seen as a transaction.

    Args:
        command: is the command to be sent
    Returns:
        Either a string returned by the controller (on success), or an error message (on
        failure).
    Raises:
        DeviceConnectionError when there was an I/O problem during communication with the
        controller.

        DeviceTimeoutError when there was a timeout in either sending the command or
        receiving the response.
    &#34;&#34;&#34;

    try:

        # Attempt to send the complete command

        command += &#34;\n&#34; if not command.endswith(&#34;\n&#34;) else &#34;&#34;

        self.sock.sendall(command.encode())

        # wait for, read and return the response from HUBER (will be at most TBD chars)

        return_string = self.read()

        response = return_string.decode().rstrip()

        return response

    except socket.timeout as e_timeout:
        raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
    except socket.error as e_socket:
        # Interpret any socket-related error as an I/O error
        raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
    except ConnectionError as exc:
        raise DeviceConnectionError(DEVICE_NAME, &#34;Connection error.&#34;) from exc
    except AttributeError:
        if not self.is_connection_open:
            raise DeviceConnectionError(
                DEVICE_NAME, &#34;Device not connected, use the connect() method.&#34;
            )
        raise</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, command: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a single command to the device controller without waiting for a response.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>an order command for the controller.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>DeviceConnectionError when the command could not be sent due to a
communication problem.</p>
<p>DeviceTimeoutError when the command could not be sent due to a timeout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, command: str):
    &#34;&#34;&#34;
    Send a single command to the device controller without waiting for a response.

    Args:
        command: an order command for the controller.

    Raises:
        DeviceConnectionError when the command could not be sent due to a
        communication problem.

        DeviceTimeoutError when the command could not be sent due to a timeout.
    &#34;&#34;&#34;

    try:

        command += &#34;\n&#34; if not command.endswith(&#34;\n&#34;) else &#34;&#34;

        self.sock.sendall(command.encode())

    except socket.timeout as e_timeout:
        raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
    except socket.error as e_socket:
        # Interpret any socket-related error as a connection error
        raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
    except AttributeError:
        if not self.is_connection_open:
            msg = &#34;The DAQ6510 is not connected, use the connect() method.&#34;
            raise DeviceConnectionError(DEVICE_NAME, msg)
        raise</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.read" href="../../device.html#egse.device.DeviceTransport.read">read</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.query" href="../../device.html#egse.device.DeviceTransport.query">query</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tempcontrol.keithley" href="index.html">egse.tempcontrol.keithley</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command">DAQ6510Command</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command.get_cmd_string" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface">DAQ6510EthernetInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.connect" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.disconnect" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.is_connected" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.trans" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.trans">trans</a></code></li>
<li><code><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.write" href="#egse.tempcontrol.keithley.daq6510_devif.DAQ6510EthernetInterface.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tempcontrol.spid.spid_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tempcontrol.spid.spid_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pathlib import Path

import sys
import argparse
import logging
import multiprocessing
import zmq
import pickle

import numpy as np
from zmq import ZMQError
from datetime import datetime

from PyQt5.QtCore import QThread, QObject, pyqtSignal, pyqtSlot, Qt, QSize, QLockFile

from PyQt5.QtGui import QCloseEvent
from PyQt5.QtWidgets import QMainWindow, QApplication, QLabel, QFrame, QHBoxLayout, QVBoxLayout, QGroupBox, QVBoxLayout, QGridLayout, \
    QLineEdit, QSizePolicy, QSpacerItem, QPushButton, QDoubleSpinBox, QScrollArea, QMessageBox

from egse.tempcontrol.spid.spid import PidProxy, PidSimulator
from egse.tempcontrol.spid.spid import CTRL_SETTINGS as PID_CTRL_SETTINGS

from egse.setup import get_setup
from egse.gui.led import LED
from egse.gui.buttons import ToggleButton
from egse.resource import get_resource
from egse.zmq_ser import connect_address
from egse.observer import Observer, Observable

multiprocessing.current_process().name = &#39;spid_ui&#39;

logger = logging.getLogger(__name__)

class PidMonitoringWorker(QObject):
    
    pid_timestamp_status_signal = pyqtSignal(list)
    pid_update_status_signal = pyqtSignal(list)
    pid_enabled_status_signal = pyqtSignal(dict)
    pid_setpoint_status_signal = pyqtSignal(list)
    pid_constants_status_signal = pyqtSignal(list)
    
    def __init__(self):
        super(PidMonitoringWorker, self).__init__()
        
        self.activate = False
        self.just_reconnected = True
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        self.previous_pid_update_status_signal = []
        self.previous_pid_timestamp_status_signal = []
        self.previous_pid_setpoint = []
        self.previous_pid_enabled_status_signal = []
        self.previous_pid_constants_status_signal = []
        
    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;
        

        try:
            transport   = PID_CTRL_SETTINGS.PROTOCOL
            hostname    = PID_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        
        &#34;&#34;&#34; Stop the monitoring worker.
        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;
        
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
        self.run()
        
    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
        
        If the beaglebone status has changed, update it in the GUI
        Raises:
            Exception: ZMQ Error
        &#34;&#34;&#34;
        
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                if self.monitoring_socket in socket_list:
                    try:
                        pickle_string = self.monitoring_socket.recv()
                    except Exception:
                        raise Exception

                    monitoring_info = pickle.loads(pickle_string)
                    
                    pid_enabled     = monitoring_info[&#39;Enabled&#39;]
                    pid_setpoint    = monitoring_info[&#39;Setpoint&#39;]
                    pid_timestamp   = monitoring_info[&#39;Timestamp&#39;]
                    pid_error       = monitoring_info[&#39;Error&#39;]
                    pid_isum        = monitoring_info[&#39;Isum&#39;]
                    pid_input       = monitoring_info[&#39;Input&#39;]
                    pid_output      = monitoring_info[&#39;Output&#39;]
                    pid_const       = monitoring_info[&#39;PidConst&#39;]
                    pid_state       = [pid_error, pid_isum, pid_input, pid_output]
                    
                    if pid_timestamp != self.previous_pid_timestamp_status_signal:
                        self.pid_timestamp_status_signal.emit(pid_timestamp)
                        
                    self.previous_pid_timestamp_status_signal = pid_timestamp
                    
                    if pid_setpoint != self.previous_pid_setpoint:
                        self.pid_setpoint_status_signal.emit(pid_setpoint)
                    
                    self.previous_pid_setpoint = pid_setpoint
                    
                    if pid_enabled != self.previous_pid_enabled_status_signal:
                        self.pid_enabled_status_signal.emit(pid_enabled)
                        
                    self.previous_pid_enabled_status_signal = pid_enabled
                    
                    if pid_state != self.previous_pid_update_status_signal:
                        self.pid_update_status_signal.emit(pid_state)
                    
                    self.previous_pid_update_status_signal = pid_state
                    
                    if pid_const != self.previous_pid_constants_status_signal:
                        self.pid_constants_status_signal.emit(pid_const)
                    
                    self.previous_pid_constants_status_signal = pid_const
                             
            except ZMQError as exc:
                raise exc



class pidChannelWidget(QGroupBox):
    def __init__(self, channel_info, parent=None):
        super().__init__(parent=parent)
     
        
        self.pid = channel_info[0]
        self.htr = channel_info[3]
        self.ch  = channel_info[4]
        self.setObjectName(&#34;PID channel {} widget&#34;.format(self.ch))
        self.setMinimumWidth(380)
        sizePolicy = QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.sizePolicy().hasHeightForWidth())
        self.setSizePolicy(sizePolicy)
        self.verticalLayout = QVBoxLayout(self)
        self.verticalLayout.setObjectName(&#34;verticalLayout&#34;)
        self.gridLayout = QGridLayout()
        self.gridLayout.setContentsMargins(0, -1, 0, -1)
        self.gridLayout.setObjectName(&#34;gridLayout&#34;)
        
        self.widget = ToggleButton(
            name=&#34;Turn On\Off PID Channel&#34;,
            status_tip=f&#34;Heater {self.htr} Channel {self.ch} On\Off&#34;,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        self.widget.setMinimumSize(QSize(35, 35))
        self.widget.setObjectName(&#34;widget&#34;)    
        self.gridLayout.addWidget(self.widget, 0, 0)
        self.label = QLabel(self)
        self.label.setMinimumSize(QSize(0, 0))
        self.label.setObjectName(&#34;label&#34;)
        self.label.setText(&#34;Heater {} Channel {}&#34;.format(int(self.htr + 1), chr(int(self.ch) + 65)))
        self.gridLayout.addWidget(self.label, 0, 1, 1, 5)
        self.label_2 = QLabel(self)
        self.label_2.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_2.setObjectName(&#34;label_2&#34;)
        self.label_2.setText(&#34;Setpoint:&#34;)
        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)
        self.label_3 = QLabel(self)
        self.label_3.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_3.setObjectName(&#34;label_3&#34;)
        self.label_3.setText(&#34;Input:&#34;)
        self.gridLayout.addWidget(self.label_3, 3, 0, 1, 1)
        self.label_6 = QLabel(self)
        self.label_6.setObjectName(&#34;label_6&#34;)
        self.label_6.setText(&#34;Err:&#34;)
        self.gridLayout.addWidget(self.label_6, 2, 2, 1, 1)
        self.doubleSpinBox = QDoubleSpinBox(self)
        self.doubleSpinBox.setMinimumSize(QSize(90, 0))
        self.doubleSpinBox.setProperty(&#34;value&#34;, 21.0)
        self.doubleSpinBox.setObjectName(&#34;doubleSpinBox&#34;)
        self.doubleSpinBox.setMinimum(-250)
        self.gridLayout.addWidget(self.doubleSpinBox, 2, 1, 1, 1)
        self.label_13 = QLabel(self)
        self.label_13.setObjectName(&#34;label_13&#34;)
        self.label_13.setText(&#34;Timestamp:&#34;)
        self.gridLayout.addWidget(self.label_13, 5, 1, 1, 2)
        self.label_12 = QLabel(self)
        self.label_12.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_12.setObjectName(&#34;label_12&#34;)
        self.label_12.setText(&#34;Out:&#34;)
        self.gridLayout.addWidget(self.label_12, 4, 0, 1, 1)
        self.label_7 = QLabel(self)
        self.label_7.setObjectName(&#34;label_7&#34;)
        self.label_7.setText(&#34;I:&#34;)
        self.gridLayout.addWidget(self.label_7, 3, 2, 1, 1)
        self.label_14 = QLabel(self)
        self.label_14.setObjectName(&#34;label_14&#34;)
        self.gridLayout.addWidget(self.label_14, 6, 1, 1, 4)
        self.lineEdit_3 = QLineEdit(self)
        self.lineEdit_3.setMinimumSize(QSize(90, 0))
        self.lineEdit_3.setReadOnly(True)
        self.lineEdit_3.setObjectName(&#34;lineEdit_3&#34;)
        self.gridLayout.addWidget(self.lineEdit_3, 3, 3, 1, 1)
        self.lineEdit_4 = QLineEdit(self)
        self.lineEdit_4.setMinimumSize(QSize(90, 0))
        self.lineEdit_4.setReadOnly(True)
        self.lineEdit_4.setObjectName(&#34;lineEdit_4&#34;)
        self.gridLayout.addWidget(self.lineEdit_4, 4, 1, 1, 1)
        self.lineEdit_2 = QLineEdit(self)
        self.lineEdit_2.setMinimumSize(QSize(90, 0))
        self.lineEdit_2.setReadOnly(True)
        self.lineEdit_2.setObjectName(&#34;lineEdit_2&#34;)
        self.gridLayout.addWidget(self.lineEdit_2, 3, 1, 1, 1)
        self.lineEdit = QLineEdit(self)
        self.lineEdit.setMinimumSize(QSize(90, 0))
        self.lineEdit.setReadOnly(True)
        self.lineEdit.setObjectName(&#34;lineEdit&#34;)
        self.gridLayout.addWidget(self.lineEdit, 2, 3, 1, 1)
        self.pushButton = QPushButton(self)
        self.pushButton.setMaximumSize(QSize(50, 16777215))
        self.pushButton.setObjectName(&#34;pushButton&#34;)
        self.pushButton.setText(&#34;Set&#34;)
        self.gridLayout.addWidget(self.pushButton, 2, 4, 1, 1)
        self.widget_2 = ToggleButton(
            width=10,
            height=10,
            name=&#34;More PID information&#34;,
            status_tip=f&#34;Show more information about pid channel&#34;,
            selected=get_resource(&#34;:/icons/more.svg&#34;),
            not_selected=get_resource(&#34;:/icons/arrow-up.svg&#34;)
        )
        self.widget_2.setObjectName(&#34;widget_2&#34;)
        self.gridLayout.addWidget(self.widget_2, 6, 5, 1, 1)
        self.horizontalLayout_2 = QHBoxLayout()
        self.horizontalLayout_2.setObjectName(&#34;horizontalLayout_2&#34;)
        self.label_4 = QLabel(self)
        self.label_4.setObjectName(&#34;label_4&#34;)
        self.label_4.setText(&#34;Kp:&#34;)
        self.horizontalLayout_2.addWidget(self.label_4)
        self.label_5 = QLabel(self)
        self.label_5.setObjectName(&#34;label_5&#34;)
        self.label_5.setText(&#34;0&#34;)
        self.horizontalLayout_2.addWidget(self.label_5)
        self.label_8 = QLabel(self)
        self.label_8.setObjectName(&#34;label_8&#34;)
        self.label_8.setText(&#34;Ki:&#34;)
        self.horizontalLayout_2.addWidget(self.label_8)
        self.label_9 = QLabel(self)
        self.label_9.setObjectName(&#34;label_9&#34;)
        self.label_9.setText(&#34;0&#34;)
        self.horizontalLayout_2.addWidget(self.label_9)
        self.label_10 =QLabel(self)
        self.label_10.setObjectName(&#34;label_10&#34;)
        self.label_10.setText(&#34;Kd:&#34;)
        self.horizontalLayout_2.addWidget(self.label_10)
        self.label_11 = QLabel(self)
        self.label_11.setObjectName(&#34;label_11&#34;)
        self.label_11.setText(&#34;0&#34;)
        self.horizontalLayout_2.addWidget(self.label_11)
        self.gridLayout.addLayout(self.horizontalLayout_2, 1, 0, 1, 6)
        self.verticalLayout.addLayout(self.gridLayout)

        self.widget_2.clicked.connect(self.show_more_less)
        
        self.show_less()
        
    def show_less(self):
        self.lineEdit_3.hide()
        self.lineEdit_4.hide()
        self.label_4.hide()
        self.label_5.hide()
        self.label_7.hide()
        self.label_8.hide()
        self.label_9.hide()
        self.label_10.hide()
        self.label_11.hide()
        self.label_12.hide()
    
    def show_more(self):
        self.lineEdit_3.show()
        self.lineEdit_4.show()
        self.label_4.show()
        self.label_5.show()
        self.label_7.show()
        self.label_8.show()
        self.label_9.show()
        self.label_10.show()
        self.label_11.show()
        self.label_12.show()
    
    def show_more_less(self):
        if not self.widget_2.is_selected():
            self.show_more()
        else:
            self.show_less()

class pidGroupbox(QGroupBox):
    def __init__(self, pid_name, channels, parent=None):
        super().__init__(parent=parent)
        self.setObjectName(&#34;{}&#34;.format(pid_name))
        self.setMaximumWidth(400)
        self.verticalLayout = QVBoxLayout(self)
        self.verticalLayout.setObjectName(&#34;verticalLayout&#34;)
        self.horizontalLayout = QHBoxLayout()
        self.horizontalLayout.setObjectName(&#34;horizontalLayout&#34;)
        self.label = QLabel(self)
        self.label.setText(pid_name)
        sizePolicy = QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setObjectName(&#34;label&#34;)
        self.horizontalLayout.addWidget(self.label)
        
        self.widget_2 = ToggleButton(
            name=&#34;Turn On\Off PID Channel&#34;,
            status_tip=pid_name,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        
        self.doubleSpinBox = QDoubleSpinBox(self)
        self.doubleSpinBox.setMinimumSize(QSize(90, 0))
        self.doubleSpinBox.setMinimum(-250)
        
        self.doubleSpinBox.setObjectName(&#34;doubleSpinBox&#34;)
        
        self.pushButton = QPushButton(&#39;set&#39;)
        self.pushButton.setMaximumSize(QSize(50, 16777215))
        
        self.horizontalLayout.addWidget(self.widget_2)
        spacerItem =QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.horizontalLayout.addWidget(self.doubleSpinBox)
        self.horizontalLayout.addWidget(self.pushButton)
        
        
        self.widget = LED()
        self.widget.setMinimumSize(QSize(25, 25))
        self.widget.setObjectName(&#34;widget&#34;)
        self.horizontalLayout.addWidget(self.widget)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.channels = [None] * len(channels)
        for idx, channel in enumerate(channels):
            if (channel[1] == 0 and channel[2] == 0):
                continue
            self.channels[idx] = pidChannelWidget(channel)
            self.verticalLayout.addWidget(self.channels[idx])
        spacerItem_2 =QSpacerItem(40, 20, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem_2)

class pidMainWindow(QMainWindow, Observable):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setWindowTitle(&#34;Beaglebone PID Controller&#34;)
        self.setGeometry(600, 100, 1250, 670)
        self.setMaximumWidth(1250)
        
        setup = get_setup()
        self.pid_configuration = setup.gse.spid.configuration.heaters
        self.pid_configuration[&#39;MaRi&#39;] = self.pid_configuration[&#39;TRP2&#39;] + self.pid_configuration[&#39;TRP3&#39;] + self.pid_configuration[&#39;TRP4&#39;]
        del self.pid_configuration[&#39;TRP2&#39;], self.pid_configuration[&#39;TRP3&#39;], self.pid_configuration[&#39;TRP4&#39;]

        self.pid_monitoring_thread = QThread(self)
        self.pid_monitoring_worker = PidMonitoringWorker()
        self.pid_monitoring_worker.moveToThread(self.pid_monitoring_thread)
        
        self.pid_monitoring_worker.pid_enabled_status_signal.connect(self.on_pid_enabled_status_signal)
        self.pid_monitoring_worker.pid_setpoint_status_signal.connect(self.on_pid_setpoint_status_signal)
        self.pid_monitoring_worker.pid_timestamp_status_signal.connect(self.on_pid_timestamp_status_signal)
        self.pid_monitoring_worker.pid_update_status_signal.connect(self.on_pid_update_status_signal)
        self.pid_monitoring_worker.pid_constants_status_signal.connect(self.on_pid_constant_status_signal)
        
        self.pid_monitoring_thread.started.connect(self.pid_monitoring_worker.start_process)
        self.pid_monitoring_thread.start()
        
        self.initUI()

    def on_pid_enabled_status_signal(self, monitoring_info:dict):
        monitoring_info = list(monitoring_info.values())
        
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            state_lin = len(self.pid_channels[idx].channels)
            pid_state = 0
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    state_lin -= 1
                    continue
                self.pid_channels[idx].channels[ch_idx].widget.set_selected(bool(monitoring_info[ch[0]]))
                ch_enabled = self.pid_channels[idx].channels[ch_idx].widget.is_selected()
                pid_state += 1 if int(ch_enabled) else 0
            if pid_state == state_lin:
                self.pid_channels[idx].widget.set_color(1)
                self.pid_channels[idx].widget_2.set_selected(True)
            elif  0 &lt; pid_state &lt; state_lin:
                self.pid_channels[idx].widget_2.set_selected(False)
                self.pid_channels[idx].widget.set_color(2)
            else:
                self.pid_channels[idx].widget_2.set_selected(False)
                self.pid_channels[idx].widget.set_color(0)
    
    def on_pid_constant_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].label_5.setText(f&#34;{monitoring_info[idx][0]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].label_9.setText(f&#34;{monitoring_info[idx][1]:.2e}&#34;)  
                self.pid_channels[idx].channels[ch_idx].label_11.setText(f&#34;{monitoring_info[idx][2]:.2e}&#34;)  
    
    def on_pid_setpoint_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            setpoint = []
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].doubleSpinBox.setValue(float(monitoring_info[ch[0]]))
                setpoint.append(float(monitoring_info[ch[0]]))
            self.pid_channels[idx].doubleSpinBox.setValue(float(np.amax(setpoint)))
                
    def on_pid_timestamp_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].label_14.setText(str(datetime.fromtimestamp(monitoring_info[int(ch[0])])))
    
    def on_pid_update_status_signal(self, monitoring_info):
        channels = 0
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].lineEdit.setText(f&#34;{monitoring_info[0][channels]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].lineEdit_3.setText(f&#34;{monitoring_info[1][channels]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].lineEdit_2.setText(f&#34;{monitoring_info[2][channels]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].lineEdit_4.setText(f&#34;{monitoring_info[3][channels]:.2e}&#34;)
                channels += 1

    def initUI(self):
        scroll_frame = QScrollArea()
        scroll_frame.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_frame.setWidgetResizable(True)
        app_frame = QFrame()
        grid_layout = QGridLayout()
        self.pid_channels = [None] * len(self.pid_configuration)
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            configuration.sort( key = lambda configuration: (configuration[3], configuration[4]))
            self.pid_channels[idx] = pidGroupbox(pid, configuration)
            
            self.pid_channels[idx].pushButton.clicked.connect(self.set_all_pid_setpoint)
            self.pid_channels[idx].widget_2.clicked.connect(self.set_all_pid_control)
            
            grid_layout.addWidget(self.pid_channels[idx], int(idx / 3), idx % 3)
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].widget.clicked.connect(self.set_pid_control)
                self.pid_channels[idx].channels[ch_idx].pushButton.clicked.connect(self.set_pid_setpoint)
        app_frame.setLayout(grid_layout)
        scroll_frame.setWidget(app_frame)
        self.setCentralWidget(scroll_frame)

    def set_all_pid_control(self):
        sender = self.sender()
        name = sender.parent().objectName()
        new_state = sender.is_selected()
        sender.set_selected(on=new_state)
        for channel in self.pid_configuration[name]:
            try:
                self.actionObservers({&#34;set_pid_control&#34; : [channel[0], bool(new_state)]})
            except Exception as e:
                warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                        if new_state else &#34;Disabled&#34;), e)
    def set_pid_control(self):
        sender = self.sender()
        state = sender.is_selected()
        new_state = state
        sender.set_selected(on=new_state)
        pid = sender.parent().pid
        htr = sender.parent().htr
        ch  = sender.parent().ch

        try:
            self.actionObservers({&#34;set_pid_control&#34; : [pid, bool(new_state)]})
        except Exception as e:
            warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                   if new_state else &#34;Disabled&#34;), e)
    
    def set_all_pid_setpoint(self):
        sender = self.sender()
        setpoint = float(sender.parent().doubleSpinBox.value())
        name = sender.parent().objectName()
        
        for channel in self.pid_configuration[name]:
            try:
                self.actionObservers({&#34;set_pid_setpoint&#34; : [channel[0], float(setpoint)]})
            except Exception as e:
                 warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                    if new_state else &#34;Disabled&#34;), e)
    
    def set_pid_setpoint(self):
        sender = self.sender()
        setpoint = float(sender.parent().doubleSpinBox.value())
        pid = sender.parent().pid
        htr = sender.parent().htr
        ch  = sender.parent().ch

        try:
            self.actionObservers({&#34;set_pid_setpoint&#34; : [pid, float(setpoint)]})
        except Exception as e:
            warning_popup(&#34;set_pid_setpoint : PID Channel {} to {} C&#34;.format(pid, setpoint), e)      
              
    def closeEvent(self, close_Event: QCloseEvent) -&gt; None:
        self.pid_monitoring_thread.quit()
        self.pid_monitoring_worker.stop()

def warning_popup(command, error):
    msgBox = QMessageBox()
    msgBox.setWindowTitle(&#34;OGSE error occured&#34;)
    msgBox.setIcon(QMessageBox.Warning)
    msgBox.setText(f&#34;An error occured while executing: {command}&#34;)
    msgBox.setInformativeText(f&#34;{error}&#34;)
    msgBox.setStandardButtons(QMessageBox.Ok)
    msgBox.exec_()

class PIDUIModel:
    def __init__(self, mode):
        self.mode = mode
        if self.mode == &#34;proxy&#34;:
            try:
                self.pid = PidProxy()
            except Exception as exc:
                raise exc
            
        elif self.mode == &#39;simulator&#39;:
            self.pid = PidSimulator()
        else:
            raise ValueError(f&#39;Unknown type of PID implementation passed into the model&#39;)
        
       
        if self.pid is not None:
                logger.debug(f&#39;Heater Controller initialized as {self.pid.__class__.__name__}&#39;)

    def set_pid_control(self, ch, state):
        with PidProxy() as pid:
            if state:
                pid.enable(int(ch))
            else:
                pid.disable(int(ch))

    
    def set_pid_setpoint(self, ch, sp):
        with PidProxy() as pid:
            pid.set_temperature(int(ch), float(sp))
    
    def has_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.has_commands()
            
        return True
                
    
    def load_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.load_commands()
    
    def is_simulator(self):
        with PidProxy() as pid:
            pid.is_simulator()

    
    def is_connected(self):
        with PidProxy() as pid:
            pid.is_cs_connected()
    
    def reconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                pid.reconnect()
            return self.pid.is_cs_connected()
        return False
    
    def disconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                return pid.disconnect_cs()

        elif self.mode == &#39;simulator&#39;:
            return self.pid.disconnect()


class PIDUIController(Observer):
    def __init__(self, model: PIDUIModel, view: pidMainWindow):
        self.model  = model
        self.view   = view
        self.view.addObserver(self)
        
    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                logger.debug(&#34;Reconnecting the Heater model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                logger.debug(&#34;Disconnecting the Heater model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return
        
    def do(self, actions):
        for action, value in actions.items():
            logger.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_pid_control&#34;:
                ch      = value[0]
                state   = value[1]

                self.model.set_pid_control(ch, state)
 
            if action == &#34;set_pid_setpoint&#34;:
                ch      = value[0]
                temp    = value[1]
                self.model.set_pid_setpoint(ch, temp)
        
def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;},
        help=&#34;Specify PID implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )

    args = parser.parse_args()
    return args


def main():

    lock_file = QLockFile(str(Path(&#34;~/spid_ui.app.lock&#34;).expanduser()))

    args = list(sys.argv)
    app = QApplication(args)

    if lock_file.tryLock(100):

        args = parse_arguments()
        if args.type == &#39;proxy&#39;:
            try:
                proxy = PidProxy()
            except Exception:
                raise Exception
        view = pidMainWindow()
        model = PIDUIModel(args.type)
        controller = PIDUIController(model, view)
        view.show()
        app.exec_()
    else:
        error_message = QMessageBox()
        error_message.setIcon(QMessageBox.Warning)
        error_message.setWindowTitle(&#34;Error&#34;)
        error_message.setText(&#34;The SPID tempcontrol GUI application is already running!&#34;)
        error_message.setStandardButtons(QMessageBox.Ok)

        return error_message.exec()


if __name__ == &#34;__main__&#34;:
    main()
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():

    lock_file = QLockFile(str(Path(&#34;~/spid_ui.app.lock&#34;).expanduser()))

    args = list(sys.argv)
    app = QApplication(args)

    if lock_file.tryLock(100):

        args = parse_arguments()
        if args.type == &#39;proxy&#39;:
            try:
                proxy = PidProxy()
            except Exception:
                raise Exception
        view = pidMainWindow()
        model = PIDUIModel(args.type)
        controller = PIDUIController(model, view)
        view.show()
        app.exec_()
    else:
        error_message = QMessageBox()
        error_message.setIcon(QMessageBox.Warning)
        error_message.setWindowTitle(&#34;Error&#34;)
        error_message.setText(&#34;The SPID tempcontrol GUI application is already running!&#34;)
        error_message.setStandardButtons(QMessageBox.Ok)

        return error_message.exec()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.parse_arguments"><code class="name flex">
<span>def <span class="ident">parse_arguments</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the arguments that are specific for this application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;},
        help=&#34;Specify PID implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )

    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.warning_popup"><code class="name flex">
<span>def <span class="ident">warning_popup</span></span>(<span>command, error)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def warning_popup(command, error):
    msgBox = QMessageBox()
    msgBox.setWindowTitle(&#34;OGSE error occured&#34;)
    msgBox.setIcon(QMessageBox.Warning)
    msgBox.setText(f&#34;An error occured while executing: {command}&#34;)
    msgBox.setInformativeText(f&#34;{error}&#34;)
    msgBox.setStandardButtons(QMessageBox.Ok)
    msgBox.exec_()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIController"><code class="flex name class">
<span>class <span class="ident">PIDUIController</span></span>
<span>(</span><span>model: <a title="egse.tempcontrol.spid.spid_ui.PIDUIModel" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel">PIDUIModel</a>, view: <a title="egse.tempcontrol.spid.spid_ui.pidMainWindow" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow">pidMainWindow</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDUIController(Observer):
    def __init__(self, model: PIDUIModel, view: pidMainWindow):
        self.model  = model
        self.view   = view
        self.view.addObserver(self)
        
    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                logger.debug(&#34;Reconnecting the Heater model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                logger.debug(&#34;Disconnecting the Heater model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return
        
    def do(self, actions):
        for action, value in actions.items():
            logger.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_pid_control&#34;:
                ch      = value[0]
                state   = value[1]

                self.model.set_pid_control(ch, state)
 
            if action == &#34;set_pid_setpoint&#34;:
                ch      = value[0]
                temp    = value[1]
                self.model.set_pid_setpoint(ch, temp)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.observer.Observer" href="../../observer.html#egse.observer.Observer">Observer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIController.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, actions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, actions):
    for action, value in actions.items():
        logger.debug(f&#34;do {action} with {value}&#34;)
        if action == &#34;set_pid_control&#34;:
            ch      = value[0]
            state   = value[1]

            self.model.set_pid_control(ch, state)

        if action == &#34;set_pid_setpoint&#34;:
            ch      = value[0]
            temp    = value[1]
            self.model.set_pid_setpoint(ch, temp)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIController.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, changed_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, changed_object):

    text = changed_object.text()

    if text == &#34;Reconnect&#34;:

        if changed_object.isChecked():

            logger.debug(&#34;Reconnecting the Heater model.&#34;)

            if self.model.reconnect():

                self.view.set_connection_state(True)

                if not self.model.has_commands():

                    self.model.load_commands()

            else:
                self.view.reconnect_action.setChecked(False)
        else:

            logger.debug(&#34;Disconnecting the Heater model.&#34;)
            self.model.disconnect()
            self.view.set_connection_state(False)

        return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel"><code class="flex name class">
<span>class <span class="ident">PIDUIModel</span></span>
<span>(</span><span>mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDUIModel:
    def __init__(self, mode):
        self.mode = mode
        if self.mode == &#34;proxy&#34;:
            try:
                self.pid = PidProxy()
            except Exception as exc:
                raise exc
            
        elif self.mode == &#39;simulator&#39;:
            self.pid = PidSimulator()
        else:
            raise ValueError(f&#39;Unknown type of PID implementation passed into the model&#39;)
        
       
        if self.pid is not None:
                logger.debug(f&#39;Heater Controller initialized as {self.pid.__class__.__name__}&#39;)

    def set_pid_control(self, ch, state):
        with PidProxy() as pid:
            if state:
                pid.enable(int(ch))
            else:
                pid.disable(int(ch))

    
    def set_pid_setpoint(self, ch, sp):
        with PidProxy() as pid:
            pid.set_temperature(int(ch), float(sp))
    
    def has_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.has_commands()
            
        return True
                
    
    def load_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.load_commands()
    
    def is_simulator(self):
        with PidProxy() as pid:
            pid.is_simulator()

    
    def is_connected(self):
        with PidProxy() as pid:
            pid.is_cs_connected()
    
    def reconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                pid.reconnect()
            return self.pid.is_cs_connected()
        return False
    
    def disconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                return pid.disconnect_cs()

        elif self.mode == &#39;simulator&#39;:
            return self.pid.disconnect()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    if self.mode == &#34;proxy&#34;:
        with PidProxy() as pid:
            return pid.disconnect_cs()

    elif self.mode == &#39;simulator&#39;:
        return self.pid.disconnect()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.has_commands"><code class="name flex">
<span>def <span class="ident">has_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_commands(self):
    if self.mode == &#39;proxy&#39;:
        with PidProxy() as pid:
            pid.has_commands()
        
    return True</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    with PidProxy() as pid:
        pid.is_cs_connected()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_simulator"><code class="name flex">
<span>def <span class="ident">is_simulator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulator(self):
    with PidProxy() as pid:
        pid.is_simulator()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(self):
    if self.mode == &#39;proxy&#39;:
        with PidProxy() as pid:
            pid.load_commands()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    if self.mode == &#34;proxy&#34;:
        with PidProxy() as pid:
            pid.reconnect()
        return self.pid.is_cs_connected()
    return False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_control"><code class="name flex">
<span>def <span class="ident">set_pid_control</span></span>(<span>self, ch, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_control(self, ch, state):
    with PidProxy() as pid:
        if state:
            pid.enable(int(ch))
        else:
            pid.disable(int(ch))</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_setpoint"><code class="name flex">
<span>def <span class="ident">set_pid_setpoint</span></span>(<span>self, ch, sp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_setpoint(self, ch, sp):
    with PidProxy() as pid:
        pid.set_temperature(int(ch), float(sp))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">PidMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PidMonitoringWorker(QObject):
    
    pid_timestamp_status_signal = pyqtSignal(list)
    pid_update_status_signal = pyqtSignal(list)
    pid_enabled_status_signal = pyqtSignal(dict)
    pid_setpoint_status_signal = pyqtSignal(list)
    pid_constants_status_signal = pyqtSignal(list)
    
    def __init__(self):
        super(PidMonitoringWorker, self).__init__()
        
        self.activate = False
        self.just_reconnected = True
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        self.previous_pid_update_status_signal = []
        self.previous_pid_timestamp_status_signal = []
        self.previous_pid_setpoint = []
        self.previous_pid_enabled_status_signal = []
        self.previous_pid_constants_status_signal = []
        
    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;
        

        try:
            transport   = PID_CTRL_SETTINGS.PROTOCOL
            hostname    = PID_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        
        &#34;&#34;&#34; Stop the monitoring worker.
        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;
        
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
        self.run()
        
    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
        
        If the beaglebone status has changed, update it in the GUI
        Raises:
            Exception: ZMQ Error
        &#34;&#34;&#34;
        
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                if self.monitoring_socket in socket_list:
                    try:
                        pickle_string = self.monitoring_socket.recv()
                    except Exception:
                        raise Exception

                    monitoring_info = pickle.loads(pickle_string)
                    
                    pid_enabled     = monitoring_info[&#39;Enabled&#39;]
                    pid_setpoint    = monitoring_info[&#39;Setpoint&#39;]
                    pid_timestamp   = monitoring_info[&#39;Timestamp&#39;]
                    pid_error       = monitoring_info[&#39;Error&#39;]
                    pid_isum        = monitoring_info[&#39;Isum&#39;]
                    pid_input       = monitoring_info[&#39;Input&#39;]
                    pid_output      = monitoring_info[&#39;Output&#39;]
                    pid_const       = monitoring_info[&#39;PidConst&#39;]
                    pid_state       = [pid_error, pid_isum, pid_input, pid_output]
                    
                    if pid_timestamp != self.previous_pid_timestamp_status_signal:
                        self.pid_timestamp_status_signal.emit(pid_timestamp)
                        
                    self.previous_pid_timestamp_status_signal = pid_timestamp
                    
                    if pid_setpoint != self.previous_pid_setpoint:
                        self.pid_setpoint_status_signal.emit(pid_setpoint)
                    
                    self.previous_pid_setpoint = pid_setpoint
                    
                    if pid_enabled != self.previous_pid_enabled_status_signal:
                        self.pid_enabled_status_signal.emit(pid_enabled)
                        
                    self.previous_pid_enabled_status_signal = pid_enabled
                    
                    if pid_state != self.previous_pid_update_status_signal:
                        self.pid_update_status_signal.emit(pid_state)
                    
                    self.previous_pid_update_status_signal = pid_state
                    
                    if pid_const != self.previous_pid_constants_status_signal:
                        self.pid_constants_status_signal.emit(pid_const)
                    
                    self.previous_pid_constants_status_signal = pid_const
                             
            except ZMQError as exc:
                raise exc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.
    &#34;&#34;&#34;
    

    try:
        transport   = PID_CTRL_SETTINGS.PROTOCOL
        hostname    = PID_CTRL_SETTINGS.HOSTNAME
        
        monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
        monitoring_address = connect_address(transport, hostname, monitoring_port)
        
        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
        
        self.monitoring_timeout = 0.5
        
        self.is_socket_connected = True
        
    except:
        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_constants_status_signal"><code class="name flex">
<span>def <span class="ident">pid_constants_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">pid_enabled_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_setpoint_status_signal"><code class="name flex">
<span>def <span class="ident">pid_setpoint_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_timestamp_status_signal"><code class="name flex">
<span>def <span class="ident">pid_timestamp_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_update_status_signal"><code class="name flex">
<span>def <span class="ident">pid_update_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on checkin whether the Beaglebone state has changed</p>
<p>If the beaglebone status has changed, update it in the GUI</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>ZMQ Error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
    
    If the beaglebone status has changed, update it in the GUI
    Raises:
        Exception: ZMQ Error
    &#34;&#34;&#34;
    
    self.active = True
    while self.is_socket_connected and self.active:
        
        try:
            socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            if self.monitoring_socket in socket_list:
                try:
                    pickle_string = self.monitoring_socket.recv()
                except Exception:
                    raise Exception

                monitoring_info = pickle.loads(pickle_string)
                
                pid_enabled     = monitoring_info[&#39;Enabled&#39;]
                pid_setpoint    = monitoring_info[&#39;Setpoint&#39;]
                pid_timestamp   = monitoring_info[&#39;Timestamp&#39;]
                pid_error       = monitoring_info[&#39;Error&#39;]
                pid_isum        = monitoring_info[&#39;Isum&#39;]
                pid_input       = monitoring_info[&#39;Input&#39;]
                pid_output      = monitoring_info[&#39;Output&#39;]
                pid_const       = monitoring_info[&#39;PidConst&#39;]
                pid_state       = [pid_error, pid_isum, pid_input, pid_output]
                
                if pid_timestamp != self.previous_pid_timestamp_status_signal:
                    self.pid_timestamp_status_signal.emit(pid_timestamp)
                    
                self.previous_pid_timestamp_status_signal = pid_timestamp
                
                if pid_setpoint != self.previous_pid_setpoint:
                    self.pid_setpoint_status_signal.emit(pid_setpoint)
                
                self.previous_pid_setpoint = pid_setpoint
                
                if pid_enabled != self.previous_pid_enabled_status_signal:
                    self.pid_enabled_status_signal.emit(pid_enabled)
                    
                self.previous_pid_enabled_status_signal = pid_enabled
                
                if pid_state != self.previous_pid_update_status_signal:
                    self.pid_update_status_signal.emit(pid_state)
                
                self.previous_pid_update_status_signal = pid_state
                
                if pid_const != self.previous_pid_constants_status_signal:
                    self.pid_constants_status_signal.emit(pid_const)
                
                self.previous_pid_constants_status_signal = pid_const
                         
        except ZMQError as exc:
            raise exc</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start updated the Beaglebone status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
    self.run()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the monitoring worker.
The monitoring socket is disconnected from the monitoring port and is then closed immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    
    &#34;&#34;&#34; Stop the monitoring worker.
    The monitoring socket is disconnected from the monitoring port and is then closed immediately.
    &#34;&#34;&#34;
    
    self.monitoring_socket.close()
    self.is_socket_connected = False
    
    self.active = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidChannelWidget"><code class="flex name class">
<span>class <span class="ident">pidChannelWidget</span></span>
<span>(</span><span>channel_info, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pidChannelWidget(QGroupBox):
    def __init__(self, channel_info, parent=None):
        super().__init__(parent=parent)
     
        
        self.pid = channel_info[0]
        self.htr = channel_info[3]
        self.ch  = channel_info[4]
        self.setObjectName(&#34;PID channel {} widget&#34;.format(self.ch))
        self.setMinimumWidth(380)
        sizePolicy = QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.sizePolicy().hasHeightForWidth())
        self.setSizePolicy(sizePolicy)
        self.verticalLayout = QVBoxLayout(self)
        self.verticalLayout.setObjectName(&#34;verticalLayout&#34;)
        self.gridLayout = QGridLayout()
        self.gridLayout.setContentsMargins(0, -1, 0, -1)
        self.gridLayout.setObjectName(&#34;gridLayout&#34;)
        
        self.widget = ToggleButton(
            name=&#34;Turn On\Off PID Channel&#34;,
            status_tip=f&#34;Heater {self.htr} Channel {self.ch} On\Off&#34;,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        self.widget.setMinimumSize(QSize(35, 35))
        self.widget.setObjectName(&#34;widget&#34;)    
        self.gridLayout.addWidget(self.widget, 0, 0)
        self.label = QLabel(self)
        self.label.setMinimumSize(QSize(0, 0))
        self.label.setObjectName(&#34;label&#34;)
        self.label.setText(&#34;Heater {} Channel {}&#34;.format(int(self.htr + 1), chr(int(self.ch) + 65)))
        self.gridLayout.addWidget(self.label, 0, 1, 1, 5)
        self.label_2 = QLabel(self)
        self.label_2.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_2.setObjectName(&#34;label_2&#34;)
        self.label_2.setText(&#34;Setpoint:&#34;)
        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)
        self.label_3 = QLabel(self)
        self.label_3.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_3.setObjectName(&#34;label_3&#34;)
        self.label_3.setText(&#34;Input:&#34;)
        self.gridLayout.addWidget(self.label_3, 3, 0, 1, 1)
        self.label_6 = QLabel(self)
        self.label_6.setObjectName(&#34;label_6&#34;)
        self.label_6.setText(&#34;Err:&#34;)
        self.gridLayout.addWidget(self.label_6, 2, 2, 1, 1)
        self.doubleSpinBox = QDoubleSpinBox(self)
        self.doubleSpinBox.setMinimumSize(QSize(90, 0))
        self.doubleSpinBox.setProperty(&#34;value&#34;, 21.0)
        self.doubleSpinBox.setObjectName(&#34;doubleSpinBox&#34;)
        self.doubleSpinBox.setMinimum(-250)
        self.gridLayout.addWidget(self.doubleSpinBox, 2, 1, 1, 1)
        self.label_13 = QLabel(self)
        self.label_13.setObjectName(&#34;label_13&#34;)
        self.label_13.setText(&#34;Timestamp:&#34;)
        self.gridLayout.addWidget(self.label_13, 5, 1, 1, 2)
        self.label_12 = QLabel(self)
        self.label_12.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_12.setObjectName(&#34;label_12&#34;)
        self.label_12.setText(&#34;Out:&#34;)
        self.gridLayout.addWidget(self.label_12, 4, 0, 1, 1)
        self.label_7 = QLabel(self)
        self.label_7.setObjectName(&#34;label_7&#34;)
        self.label_7.setText(&#34;I:&#34;)
        self.gridLayout.addWidget(self.label_7, 3, 2, 1, 1)
        self.label_14 = QLabel(self)
        self.label_14.setObjectName(&#34;label_14&#34;)
        self.gridLayout.addWidget(self.label_14, 6, 1, 1, 4)
        self.lineEdit_3 = QLineEdit(self)
        self.lineEdit_3.setMinimumSize(QSize(90, 0))
        self.lineEdit_3.setReadOnly(True)
        self.lineEdit_3.setObjectName(&#34;lineEdit_3&#34;)
        self.gridLayout.addWidget(self.lineEdit_3, 3, 3, 1, 1)
        self.lineEdit_4 = QLineEdit(self)
        self.lineEdit_4.setMinimumSize(QSize(90, 0))
        self.lineEdit_4.setReadOnly(True)
        self.lineEdit_4.setObjectName(&#34;lineEdit_4&#34;)
        self.gridLayout.addWidget(self.lineEdit_4, 4, 1, 1, 1)
        self.lineEdit_2 = QLineEdit(self)
        self.lineEdit_2.setMinimumSize(QSize(90, 0))
        self.lineEdit_2.setReadOnly(True)
        self.lineEdit_2.setObjectName(&#34;lineEdit_2&#34;)
        self.gridLayout.addWidget(self.lineEdit_2, 3, 1, 1, 1)
        self.lineEdit = QLineEdit(self)
        self.lineEdit.setMinimumSize(QSize(90, 0))
        self.lineEdit.setReadOnly(True)
        self.lineEdit.setObjectName(&#34;lineEdit&#34;)
        self.gridLayout.addWidget(self.lineEdit, 2, 3, 1, 1)
        self.pushButton = QPushButton(self)
        self.pushButton.setMaximumSize(QSize(50, 16777215))
        self.pushButton.setObjectName(&#34;pushButton&#34;)
        self.pushButton.setText(&#34;Set&#34;)
        self.gridLayout.addWidget(self.pushButton, 2, 4, 1, 1)
        self.widget_2 = ToggleButton(
            width=10,
            height=10,
            name=&#34;More PID information&#34;,
            status_tip=f&#34;Show more information about pid channel&#34;,
            selected=get_resource(&#34;:/icons/more.svg&#34;),
            not_selected=get_resource(&#34;:/icons/arrow-up.svg&#34;)
        )
        self.widget_2.setObjectName(&#34;widget_2&#34;)
        self.gridLayout.addWidget(self.widget_2, 6, 5, 1, 1)
        self.horizontalLayout_2 = QHBoxLayout()
        self.horizontalLayout_2.setObjectName(&#34;horizontalLayout_2&#34;)
        self.label_4 = QLabel(self)
        self.label_4.setObjectName(&#34;label_4&#34;)
        self.label_4.setText(&#34;Kp:&#34;)
        self.horizontalLayout_2.addWidget(self.label_4)
        self.label_5 = QLabel(self)
        self.label_5.setObjectName(&#34;label_5&#34;)
        self.label_5.setText(&#34;0&#34;)
        self.horizontalLayout_2.addWidget(self.label_5)
        self.label_8 = QLabel(self)
        self.label_8.setObjectName(&#34;label_8&#34;)
        self.label_8.setText(&#34;Ki:&#34;)
        self.horizontalLayout_2.addWidget(self.label_8)
        self.label_9 = QLabel(self)
        self.label_9.setObjectName(&#34;label_9&#34;)
        self.label_9.setText(&#34;0&#34;)
        self.horizontalLayout_2.addWidget(self.label_9)
        self.label_10 =QLabel(self)
        self.label_10.setObjectName(&#34;label_10&#34;)
        self.label_10.setText(&#34;Kd:&#34;)
        self.horizontalLayout_2.addWidget(self.label_10)
        self.label_11 = QLabel(self)
        self.label_11.setObjectName(&#34;label_11&#34;)
        self.label_11.setText(&#34;0&#34;)
        self.horizontalLayout_2.addWidget(self.label_11)
        self.gridLayout.addLayout(self.horizontalLayout_2, 1, 0, 1, 6)
        self.verticalLayout.addLayout(self.gridLayout)

        self.widget_2.clicked.connect(self.show_more_less)
        
        self.show_less()
        
    def show_less(self):
        self.lineEdit_3.hide()
        self.lineEdit_4.hide()
        self.label_4.hide()
        self.label_5.hide()
        self.label_7.hide()
        self.label_8.hide()
        self.label_9.hide()
        self.label_10.hide()
        self.label_11.hide()
        self.label_12.hide()
    
    def show_more(self):
        self.lineEdit_3.show()
        self.lineEdit_4.show()
        self.label_4.show()
        self.label_5.show()
        self.label_7.show()
        self.label_8.show()
        self.label_9.show()
        self.label_10.show()
        self.label_11.show()
        self.label_12.show()
    
    def show_more_less(self):
        if not self.widget_2.is_selected():
            self.show_more()
        else:
            self.show_less()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_less"><code class="name flex">
<span>def <span class="ident">show_less</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_less(self):
    self.lineEdit_3.hide()
    self.lineEdit_4.hide()
    self.label_4.hide()
    self.label_5.hide()
    self.label_7.hide()
    self.label_8.hide()
    self.label_9.hide()
    self.label_10.hide()
    self.label_11.hide()
    self.label_12.hide()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_more"><code class="name flex">
<span>def <span class="ident">show_more</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_more(self):
    self.lineEdit_3.show()
    self.lineEdit_4.show()
    self.label_4.show()
    self.label_5.show()
    self.label_7.show()
    self.label_8.show()
    self.label_9.show()
    self.label_10.show()
    self.label_11.show()
    self.label_12.show()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_more_less"><code class="name flex">
<span>def <span class="ident">show_more_less</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_more_less(self):
    if not self.widget_2.is_selected():
        self.show_more()
    else:
        self.show_less()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidGroupbox"><code class="flex name class">
<span>class <span class="ident">pidGroupbox</span></span>
<span>(</span><span>pid_name, channels, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pidGroupbox(QGroupBox):
    def __init__(self, pid_name, channels, parent=None):
        super().__init__(parent=parent)
        self.setObjectName(&#34;{}&#34;.format(pid_name))
        self.setMaximumWidth(400)
        self.verticalLayout = QVBoxLayout(self)
        self.verticalLayout.setObjectName(&#34;verticalLayout&#34;)
        self.horizontalLayout = QHBoxLayout()
        self.horizontalLayout.setObjectName(&#34;horizontalLayout&#34;)
        self.label = QLabel(self)
        self.label.setText(pid_name)
        sizePolicy = QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setObjectName(&#34;label&#34;)
        self.horizontalLayout.addWidget(self.label)
        
        self.widget_2 = ToggleButton(
            name=&#34;Turn On\Off PID Channel&#34;,
            status_tip=pid_name,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        
        self.doubleSpinBox = QDoubleSpinBox(self)
        self.doubleSpinBox.setMinimumSize(QSize(90, 0))
        self.doubleSpinBox.setMinimum(-250)
        
        self.doubleSpinBox.setObjectName(&#34;doubleSpinBox&#34;)
        
        self.pushButton = QPushButton(&#39;set&#39;)
        self.pushButton.setMaximumSize(QSize(50, 16777215))
        
        self.horizontalLayout.addWidget(self.widget_2)
        spacerItem =QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.horizontalLayout.addWidget(self.doubleSpinBox)
        self.horizontalLayout.addWidget(self.pushButton)
        
        
        self.widget = LED()
        self.widget.setMinimumSize(QSize(25, 25))
        self.widget.setObjectName(&#34;widget&#34;)
        self.horizontalLayout.addWidget(self.widget)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.channels = [None] * len(channels)
        for idx, channel in enumerate(channels):
            if (channel[1] == 0 and channel[2] == 0):
                continue
            self.channels[idx] = pidChannelWidget(channel)
            self.verticalLayout.addWidget(self.channels[idx])
        spacerItem_2 =QSpacerItem(40, 20, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem_2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow"><code class="flex name class">
<span>class <span class="ident">pidMainWindow</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pidMainWindow(QMainWindow, Observable):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setWindowTitle(&#34;Beaglebone PID Controller&#34;)
        self.setGeometry(600, 100, 1250, 670)
        self.setMaximumWidth(1250)
        
        setup = get_setup()
        self.pid_configuration = setup.gse.spid.configuration.heaters
        self.pid_configuration[&#39;MaRi&#39;] = self.pid_configuration[&#39;TRP2&#39;] + self.pid_configuration[&#39;TRP3&#39;] + self.pid_configuration[&#39;TRP4&#39;]
        del self.pid_configuration[&#39;TRP2&#39;], self.pid_configuration[&#39;TRP3&#39;], self.pid_configuration[&#39;TRP4&#39;]

        self.pid_monitoring_thread = QThread(self)
        self.pid_monitoring_worker = PidMonitoringWorker()
        self.pid_monitoring_worker.moveToThread(self.pid_monitoring_thread)
        
        self.pid_monitoring_worker.pid_enabled_status_signal.connect(self.on_pid_enabled_status_signal)
        self.pid_monitoring_worker.pid_setpoint_status_signal.connect(self.on_pid_setpoint_status_signal)
        self.pid_monitoring_worker.pid_timestamp_status_signal.connect(self.on_pid_timestamp_status_signal)
        self.pid_monitoring_worker.pid_update_status_signal.connect(self.on_pid_update_status_signal)
        self.pid_monitoring_worker.pid_constants_status_signal.connect(self.on_pid_constant_status_signal)
        
        self.pid_monitoring_thread.started.connect(self.pid_monitoring_worker.start_process)
        self.pid_monitoring_thread.start()
        
        self.initUI()

    def on_pid_enabled_status_signal(self, monitoring_info:dict):
        monitoring_info = list(monitoring_info.values())
        
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            state_lin = len(self.pid_channels[idx].channels)
            pid_state = 0
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    state_lin -= 1
                    continue
                self.pid_channels[idx].channels[ch_idx].widget.set_selected(bool(monitoring_info[ch[0]]))
                ch_enabled = self.pid_channels[idx].channels[ch_idx].widget.is_selected()
                pid_state += 1 if int(ch_enabled) else 0
            if pid_state == state_lin:
                self.pid_channels[idx].widget.set_color(1)
                self.pid_channels[idx].widget_2.set_selected(True)
            elif  0 &lt; pid_state &lt; state_lin:
                self.pid_channels[idx].widget_2.set_selected(False)
                self.pid_channels[idx].widget.set_color(2)
            else:
                self.pid_channels[idx].widget_2.set_selected(False)
                self.pid_channels[idx].widget.set_color(0)
    
    def on_pid_constant_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].label_5.setText(f&#34;{monitoring_info[idx][0]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].label_9.setText(f&#34;{monitoring_info[idx][1]:.2e}&#34;)  
                self.pid_channels[idx].channels[ch_idx].label_11.setText(f&#34;{monitoring_info[idx][2]:.2e}&#34;)  
    
    def on_pid_setpoint_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            setpoint = []
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].doubleSpinBox.setValue(float(monitoring_info[ch[0]]))
                setpoint.append(float(monitoring_info[ch[0]]))
            self.pid_channels[idx].doubleSpinBox.setValue(float(np.amax(setpoint)))
                
    def on_pid_timestamp_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].label_14.setText(str(datetime.fromtimestamp(monitoring_info[int(ch[0])])))
    
    def on_pid_update_status_signal(self, monitoring_info):
        channels = 0
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].lineEdit.setText(f&#34;{monitoring_info[0][channels]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].lineEdit_3.setText(f&#34;{monitoring_info[1][channels]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].lineEdit_2.setText(f&#34;{monitoring_info[2][channels]:.2e}&#34;)
                self.pid_channels[idx].channels[ch_idx].lineEdit_4.setText(f&#34;{monitoring_info[3][channels]:.2e}&#34;)
                channels += 1

    def initUI(self):
        scroll_frame = QScrollArea()
        scroll_frame.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll_frame.setWidgetResizable(True)
        app_frame = QFrame()
        grid_layout = QGridLayout()
        self.pid_channels = [None] * len(self.pid_configuration)
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            configuration.sort( key = lambda configuration: (configuration[3], configuration[4]))
            self.pid_channels[idx] = pidGroupbox(pid, configuration)
            
            self.pid_channels[idx].pushButton.clicked.connect(self.set_all_pid_setpoint)
            self.pid_channels[idx].widget_2.clicked.connect(self.set_all_pid_control)
            
            grid_layout.addWidget(self.pid_channels[idx], int(idx / 3), idx % 3)
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].widget.clicked.connect(self.set_pid_control)
                self.pid_channels[idx].channels[ch_idx].pushButton.clicked.connect(self.set_pid_setpoint)
        app_frame.setLayout(grid_layout)
        scroll_frame.setWidget(app_frame)
        self.setCentralWidget(scroll_frame)

    def set_all_pid_control(self):
        sender = self.sender()
        name = sender.parent().objectName()
        new_state = sender.is_selected()
        sender.set_selected(on=new_state)
        for channel in self.pid_configuration[name]:
            try:
                self.actionObservers({&#34;set_pid_control&#34; : [channel[0], bool(new_state)]})
            except Exception as e:
                warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                        if new_state else &#34;Disabled&#34;), e)
    def set_pid_control(self):
        sender = self.sender()
        state = sender.is_selected()
        new_state = state
        sender.set_selected(on=new_state)
        pid = sender.parent().pid
        htr = sender.parent().htr
        ch  = sender.parent().ch

        try:
            self.actionObservers({&#34;set_pid_control&#34; : [pid, bool(new_state)]})
        except Exception as e:
            warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                   if new_state else &#34;Disabled&#34;), e)
    
    def set_all_pid_setpoint(self):
        sender = self.sender()
        setpoint = float(sender.parent().doubleSpinBox.value())
        name = sender.parent().objectName()
        
        for channel in self.pid_configuration[name]:
            try:
                self.actionObservers({&#34;set_pid_setpoint&#34; : [channel[0], float(setpoint)]})
            except Exception as e:
                 warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                    if new_state else &#34;Disabled&#34;), e)
    
    def set_pid_setpoint(self):
        sender = self.sender()
        setpoint = float(sender.parent().doubleSpinBox.value())
        pid = sender.parent().pid
        htr = sender.parent().htr
        ch  = sender.parent().ch

        try:
            self.actionObservers({&#34;set_pid_setpoint&#34; : [pid, float(setpoint)]})
        except Exception as e:
            warning_popup(&#34;set_pid_setpoint : PID Channel {} to {} C&#34;.format(pid, setpoint), e)      
              
    def closeEvent(self, close_Event: QCloseEvent) -&gt; None:
        self.pid_monitoring_thread.quit()
        self.pid_monitoring_worker.stop()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li><a title="egse.observer.Observable" href="../../observer.html#egse.observer.Observable">Observable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, close_Event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>closeEvent(self, QCloseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, close_Event: QCloseEvent) -&gt; None:
    self.pid_monitoring_thread.quit()
    self.pid_monitoring_worker.stop()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    scroll_frame = QScrollArea()
    scroll_frame.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    scroll_frame.setWidgetResizable(True)
    app_frame = QFrame()
    grid_layout = QGridLayout()
    self.pid_channels = [None] * len(self.pid_configuration)
    for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
        configuration.sort( key = lambda configuration: (configuration[3], configuration[4]))
        self.pid_channels[idx] = pidGroupbox(pid, configuration)
        
        self.pid_channels[idx].pushButton.clicked.connect(self.set_all_pid_setpoint)
        self.pid_channels[idx].widget_2.clicked.connect(self.set_all_pid_control)
        
        grid_layout.addWidget(self.pid_channels[idx], int(idx / 3), idx % 3)
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue
            self.pid_channels[idx].channels[ch_idx].widget.clicked.connect(self.set_pid_control)
            self.pid_channels[idx].channels[ch_idx].pushButton.clicked.connect(self.set_pid_setpoint)
    app_frame.setLayout(grid_layout)
    scroll_frame.setWidget(app_frame)
    self.setCentralWidget(scroll_frame)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_constant_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_constant_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_constant_status_signal(self, monitoring_info):
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue                
            self.pid_channels[idx].channels[ch_idx].label_5.setText(f&#34;{monitoring_info[idx][0]:.2e}&#34;)
            self.pid_channels[idx].channels[ch_idx].label_9.setText(f&#34;{monitoring_info[idx][1]:.2e}&#34;)  
            self.pid_channels[idx].channels[ch_idx].label_11.setText(f&#34;{monitoring_info[idx][2]:.2e}&#34;)  </code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_enabled_status_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_enabled_status_signal(self, monitoring_info:dict):
    monitoring_info = list(monitoring_info.values())
    
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        state_lin = len(self.pid_channels[idx].channels)
        pid_state = 0
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                state_lin -= 1
                continue
            self.pid_channels[idx].channels[ch_idx].widget.set_selected(bool(monitoring_info[ch[0]]))
            ch_enabled = self.pid_channels[idx].channels[ch_idx].widget.is_selected()
            pid_state += 1 if int(ch_enabled) else 0
        if pid_state == state_lin:
            self.pid_channels[idx].widget.set_color(1)
            self.pid_channels[idx].widget_2.set_selected(True)
        elif  0 &lt; pid_state &lt; state_lin:
            self.pid_channels[idx].widget_2.set_selected(False)
            self.pid_channels[idx].widget.set_color(2)
        else:
            self.pid_channels[idx].widget_2.set_selected(False)
            self.pid_channels[idx].widget.set_color(0)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_setpoint_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_setpoint_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_setpoint_status_signal(self, monitoring_info):
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        setpoint = []
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue                
            self.pid_channels[idx].channels[ch_idx].doubleSpinBox.setValue(float(monitoring_info[ch[0]]))
            setpoint.append(float(monitoring_info[ch[0]]))
        self.pid_channels[idx].doubleSpinBox.setValue(float(np.amax(setpoint)))</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_timestamp_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_timestamp_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_timestamp_status_signal(self, monitoring_info):
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue
            self.pid_channels[idx].channels[ch_idx].label_14.setText(str(datetime.fromtimestamp(monitoring_info[int(ch[0])])))</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_update_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_update_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_update_status_signal(self, monitoring_info):
    channels = 0
    for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue
            self.pid_channels[idx].channels[ch_idx].lineEdit.setText(f&#34;{monitoring_info[0][channels]:.2e}&#34;)
            self.pid_channels[idx].channels[ch_idx].lineEdit_3.setText(f&#34;{monitoring_info[1][channels]:.2e}&#34;)
            self.pid_channels[idx].channels[ch_idx].lineEdit_2.setText(f&#34;{monitoring_info[2][channels]:.2e}&#34;)
            self.pid_channels[idx].channels[ch_idx].lineEdit_4.setText(f&#34;{monitoring_info[3][channels]:.2e}&#34;)
            channels += 1</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_all_pid_control"><code class="name flex">
<span>def <span class="ident">set_all_pid_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all_pid_control(self):
    sender = self.sender()
    name = sender.parent().objectName()
    new_state = sender.is_selected()
    sender.set_selected(on=new_state)
    for channel in self.pid_configuration[name]:
        try:
            self.actionObservers({&#34;set_pid_control&#34; : [channel[0], bool(new_state)]})
        except Exception as e:
            warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                    if new_state else &#34;Disabled&#34;), e)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_all_pid_setpoint"><code class="name flex">
<span>def <span class="ident">set_all_pid_setpoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all_pid_setpoint(self):
    sender = self.sender()
    setpoint = float(sender.parent().doubleSpinBox.value())
    name = sender.parent().objectName()
    
    for channel in self.pid_configuration[name]:
        try:
            self.actionObservers({&#34;set_pid_setpoint&#34; : [channel[0], float(setpoint)]})
        except Exception as e:
             warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                                if new_state else &#34;Disabled&#34;), e)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_pid_control"><code class="name flex">
<span>def <span class="ident">set_pid_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_control(self):
    sender = self.sender()
    state = sender.is_selected()
    new_state = state
    sender.set_selected(on=new_state)
    pid = sender.parent().pid
    htr = sender.parent().htr
    ch  = sender.parent().ch

    try:
        self.actionObservers({&#34;set_pid_control&#34; : [pid, bool(new_state)]})
    except Exception as e:
        warning_popup(&#34;set_pid_control : Channel {} {}&#34;.format(pid, &#34;Enabled&#34; 
                                                               if new_state else &#34;Disabled&#34;), e)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_pid_setpoint"><code class="name flex">
<span>def <span class="ident">set_pid_setpoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_setpoint(self):
    sender = self.sender()
    setpoint = float(sender.parent().doubleSpinBox.value())
    pid = sender.parent().pid
    htr = sender.parent().htr
    ch  = sender.parent().ch

    try:
        self.actionObservers({&#34;set_pid_setpoint&#34; : [pid, float(setpoint)]})
    except Exception as e:
        warning_popup(&#34;set_pid_setpoint : PID Channel {} to {} C&#34;.format(pid, setpoint), e)      </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tempcontrol.spid" href="index.html">egse.tempcontrol.spid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.main" href="#egse.tempcontrol.spid.spid_ui.main">main</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.parse_arguments" href="#egse.tempcontrol.spid.spid_ui.parse_arguments">parse_arguments</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.warning_popup" href="#egse.tempcontrol.spid.spid_ui.warning_popup">warning_popup</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIController" href="#egse.tempcontrol.spid.spid_ui.PIDUIController">PIDUIController</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIController.do" href="#egse.tempcontrol.spid.spid_ui.PIDUIController.do">do</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIController.update" href="#egse.tempcontrol.spid.spid_ui.PIDUIController.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel">PIDUIModel</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.disconnect" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.has_commands" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.has_commands">has_commands</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_connected" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_simulator" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.load_commands" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.load_commands">load_commands</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.reconnect" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_control" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_control">set_pid_control</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_setpoint" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_setpoint">set_pid_setpoint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker">PidMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.connect_socket" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_constants_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_constants_status_signal">pid_constants_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_enabled_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_enabled_status_signal">pid_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_setpoint_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_setpoint_status_signal">pid_setpoint_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_timestamp_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_timestamp_status_signal">pid_timestamp_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_update_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_update_status_signal">pid_update_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.run" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.start_process" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.stop" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.pidChannelWidget" href="#egse.tempcontrol.spid.spid_ui.pidChannelWidget">pidChannelWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_less" href="#egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_less">show_less</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_more" href="#egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_more">show_more</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_more_less" href="#egse.tempcontrol.spid.spid_ui.pidChannelWidget.show_more_less">show_more_less</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.pidGroupbox" href="#egse.tempcontrol.spid.spid_ui.pidGroupbox">pidGroupbox</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow">pidMainWindow</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.closeEvent" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.closeEvent">closeEvent</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.initUI" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.initUI">initUI</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_constant_status_signal" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_constant_status_signal">on_pid_constant_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_enabled_status_signal" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_enabled_status_signal">on_pid_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_setpoint_status_signal" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_setpoint_status_signal">on_pid_setpoint_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_timestamp_status_signal" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_timestamp_status_signal">on_pid_timestamp_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_update_status_signal" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.on_pid_update_status_signal">on_pid_update_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_all_pid_control" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.set_all_pid_control">set_all_pid_control</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_all_pid_setpoint" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.set_all_pid_setpoint">set_all_pid_setpoint</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_pid_control" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.set_pid_control">set_pid_control</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.pidMainWindow.set_pid_setpoint" href="#egse.tempcontrol.spid.spid_ui.pidMainWindow.set_pid_setpoint">set_pid_setpoint</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
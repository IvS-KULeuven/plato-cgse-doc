<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tempcontrol.spid.spid_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tempcontrol.spid.spid_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
from subprocess import check_output
import multiprocessing
import os
from signal import SIGKILL
import logging
import pickle
import sys
import zmq
from zmq import ZMQError
from PyQt5.QtCore import QThread, QObject, pyqtSignal, pyqtSlot, Qt

from PyQt5.QtGui import QCloseEvent, QIntValidator
from PyQt5.QtWidgets import QMainWindow, QApplication, QLabel, QFrame, QHBoxLayout, QVBoxLayout, QGroupBox, QVBoxLayout, QGridLayout, \
    QLineEdit

from datetime import datetime

from egse.tempcontrol.spid.spid import PidProxy, PidSimulator
from egse.tempcontrol.spid.spid import CTRL_SETTINGS as PID_CTRL_SETTINGS

from egse.setup import get_setup
from egse.gui.buttons import ToggleButton
from egse.gui.led import Led, Indic as LedIndic
from egse.observer import Observer, Observable
from egse.zmq_ser import connect_address
from egse.resource import get_resource

multiprocessing.current_process().name = &#39;spid_ui&#39;

logger = logging.getLogger(__name__)

class PidMonitoringWorker(QObject):
    
    pid_timestamp_status_signal = pyqtSignal(list)
    pid_update_status_signal = pyqtSignal(list)
    pid_enabled_status_signal = pyqtSignal(dict)
    pid_setpoint_status_signal = pyqtSignal(list)
    # pid_constants_status_signal = pyqtSignal(list)
    
    def __init__(self):
        super(PidMonitoringWorker, self).__init__()
        
        self.activate = False
        self.just_reconnected = True
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        self.previous_pid_update_status_signal = []
        self.previous_pid_timestamp_status_signal = []
        self.previous_pid_setpoint = []
        self.previous_pid_enabled_status_signal = []
        # self.previous_pid_constants_status_signal = []
        
    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;
        

        try:
            transport   = PID_CTRL_SETTINGS.PROTOCOL
            hostname    = PID_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        
        &#34;&#34;&#34; Stop the monitoring worker.
        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;
        
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
        self.run()
        
    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
        
        If the beaglebone status has changed, update it in the GUI
        Raises:
            Exception: ZMQ Error
        &#34;&#34;&#34;
        
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                if self.monitoring_socket in socket_list:
                    try:
                        pickle_string = self.monitoring_socket.recv()
                    except Exception:
                        raise Exception

                    monitoring_info = pickle.loads(pickle_string)
                    
                    pid_enabled     = monitoring_info[&#39;Enabled&#39;]
                    pid_setpoint    = monitoring_info[&#39;Setpoint&#39;]
                    pid_timestamp   = monitoring_info[&#39;Timestamp&#39;]
                    pid_error       = monitoring_info[&#39;Error&#39;]
                    pid_isum        = monitoring_info[&#39;Isum&#39;]
                    pid_input       = monitoring_info[&#39;Input&#39;]
                    pid_output      = monitoring_info[&#39;Output&#39;]
                    # pid_const       = monitoring_info[&#39;PidConst&#39;]
                    pid_state       = [pid_error, pid_isum, pid_input, pid_output]
                    
                    if pid_timestamp != self.previous_pid_timestamp_status_signal:
                        self.pid_timestamp_status_signal.emit(pid_timestamp)
                        
                    self.previous_pid_timestamp_status_signal = pid_timestamp
                    
                    if pid_setpoint != self.previous_pid_setpoint:
                        self.pid_setpoint_status_signal.emit(pid_setpoint)
                    
                    self.previous_pid_setpoint = pid_setpoint
                    
                    if pid_enabled != self.previous_pid_enabled_status_signal:
                        self.pid_enabled_status_signal.emit(pid_enabled)
                        
                    self.previous_pid_enabled_status_signal = pid_enabled
                    
                    if pid_state != self.previous_pid_update_status_signal:
                        self.pid_update_status_signal.emit(pid_state)
                    
                    self.previous_pid_update_status_signal = pid_state
                    
                    # if pid_const != self.previous_pid_constants_status_signal:
                        # self.pid_update_constants_signal.emit(pid_const)
                    
                    # self.previous_pid_constants_status_signal = pid_const
                             
            except ZMQError as exc:
                raise exc
        
        
class ChannelWidget(QGroupBox):
    
    def __init__(self, channel_info):
        super().__init__()

        self.layout = QGridLayout()
        self.pid = channel_info[0]
        self.htr = channel_info[3]
        self.ch = channel_info[4]
        textbox_width = 60
        self.switch = ToggleButton(
            name=&#34;Turn On\Off PID Channel&#34;,
            status_tip=f&#34;Heater {self.htr} Channel {self.ch} On\Off&#34;,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        self.switch.setObjectName(f&#34;{self.pid} {self.htr} {self.ch} Switch&#34;)
        
        self.more = ToggleButton(
            width=10,
            height=10,
            name=&#34;More PID information&#34;,
            status_tip=f&#34;Show more information about pid channel {self.ch}&#34;,
            selected=get_resource(&#34;:/icons/more.svg&#34;),
            not_selected=get_resource(&#34;:/icons/arrow-up.svg&#34;)
        )
        self.more.setObjectName(f&#34;{self.pid} {self.htr} {self.ch} More&#34;)
        
        self.labels = [QLabel(f&#34;Heater {self.htr} Channel {self.ch}&#34;), QLabel(&#34;SP (°C)&#34;), QLabel(&#34;Err&#34;), QLabel(&#34;ISum&#34;), QLabel(&#34;Timestamp:&#34;), QLabel(&#34;In  (°C)&#34;), QLabel(&#34;Out&#34;)]
        
        self.sp_text_box        = QLineEdit(self)
        self.sp_text_box.setValidator(QIntValidator(-300, 50))
        self.sp_text_box.setMinimumWidth(textbox_width)
        self.sp_text_box.setObjectName(f&#34;{self.pid} {self.htr} {self.ch} SetpointTextBox&#34;)
        
        self.pid_const = [QLabel(&#34;Kp:&#34;), QLabel(&#34;Ki:&#34;), QLabel(&#34;Kd:&#34;)]
        self.pid_val = [QLabel(&#34;0&#34;), QLabel(&#34;0&#34;), QLabel(&#34;0&#34;)]
        
        self.err_text_box       = QLineEdit(self)
        self.err_text_box.setValidator(QIntValidator(-1000, 1000))
        self.err_text_box.setReadOnly(True)
        self.err_text_box.setMinimumWidth(textbox_width)
        
        self.in_text_box       = QLineEdit(self)
        self.in_text_box.setValidator(QIntValidator(-1000, 1000))
        self.in_text_box.setReadOnly(True)
        self.in_text_box.setMinimumWidth(textbox_width)
        
        self.out_text_box       = QLineEdit(self)
        self.out_text_box.setValidator(QIntValidator(-1000, 1000))
        self.out_text_box.setReadOnly(True)
        self.out_text_box.setMinimumWidth(textbox_width)
        
        self.isum_text_box      = QLineEdit(self)
        self.isum_text_box.setValidator(QIntValidator(-1000, 1000))
        self.isum_text_box.setReadOnly(True)
        self.isum_text_box.setMinimumWidth(textbox_width)
        
        self.last_sample_time   = QLabel(&#34;DUMM-YD:DATET:IM:EX.XXX+XXXX&#34;)
        
        self.layout.addWidget(self.switch, 0, 0)
        self.layout.addWidget(self.labels[0], 0, 1, 1, 5)
        
        self.layout.addWidget(self.pid_const[0], 1, 1)
        self.layout.addWidget(self.pid_val[0], 1, 2)
        self.layout.addWidget(self.pid_const[1], 1, 3)
        self.layout.addWidget(self.pid_val[1], 1, 4)
        self.layout.addWidget(self.pid_const[2], 1, 5)
        self.layout.addWidget(self.pid_val[2], 1, 6)  
             
        self.layout.addWidget(self.labels[1], 2, 0)
        self.layout.addWidget(self.sp_text_box, 2, 1)
        self.layout.addWidget(self.labels[2], 2, 2)
        self.layout.addWidget(self.err_text_box, 2, 3)
        self.layout.addWidget(self.labels[3], 2, 4)
        self.layout.addWidget(self.isum_text_box, 2, 5)
        self.layout.addWidget(self.in_text_box, 3, 1)
        self.layout.addWidget(self.labels[5], 3, 0)
        self.layout.addWidget(self.labels[6], 3, 4)
        self.layout.addWidget(self.out_text_box, 3, 5)
        self.layout.addWidget(self.labels[4], 4, 1, 1, 5)
        self.layout.addWidget(self.last_sample_time, 5, 1, 1, 5)
        self.layout.addWidget(self.more, 5, 6)
        
        self.show_less()
        self.more.show_more = self.show_more
        self.more.show_less = self.show_less
        
        self.setLayout(self.layout)
        
    def show_more(self):
        [const.show() for const in self.pid_const]
        [val.show() for val in self.pid_val]
        [lab.show() for lab in self.labels[5:7]]
        self.out_text_box.show()
        self.in_text_box.show()
        
    def show_less(self):
        [const.hide() for const in self.pid_const]
        [val.hide() for val in self.pid_val]
        [lab.hide() for lab in self.labels[5:7]]
        self.out_text_box.hide()
        self.in_text_box.hide()

class PIDWidget(QGroupBox):
    def __init__(self, pid_name):
        super().__init__()
        
        self.name = QLabel(pid_name)
        self.led = Led(self)
        layout = QHBoxLayout()
        
        layout.addWidget(self.name)
        layout.addWidget(self.led)
        
        self.setLayout(layout)        

class ToolbarWidget(QGroupBox):
    def __init__(self):
        super().__init__()
        
        self.layout = QHBoxLayout()
        
        self.kill_button = ToggleButton(
            height=42,
            width=42,
            name=&#34;Kill SPID processes&#34;,
            status_tip=&#34;Kill every SPID process that is currently running&#34;,
            selected=get_resource(&#34;:/icons/stop-button.svg&#34;),
            not_selected=get_resource(&#34;:/icons/stop-button-disabled.svg&#34;)
        )
        
        self.release_control = ToggleButton(
            height=42,
            width=42,
            name=&#34;Stop all PID control&#34;,
            status_tip=&#34;Release the PID control of all running heaters&#34;,
            selected=get_resource(&#34;:/icons/remote-control-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/remote-control-off.svg&#34;)
        )
        
        self.layout.addWidget(self.release_control )
        self.layout.addWidget(self.kill_button)
        self.layout.setAlignment(Qt.AlignRight)
        self.setLayout(self.layout)
        
        
        
class PIDWindow(QGroupBox):
    def __init__(self, pid_name, channels):
        super().__init__()
        

        self.layout = QGridLayout()
        # self.layout = QVBoxLayout()
        # self.layout.setSpacing(0)
        self.name = QLabel(pid_name)
        self.led = Led(self)
        pid_layout = QHBoxLayout()
        
        pid_layout.addWidget(self.name)
        pid_layout.addWidget(self.led)
        self.layout.addLayout(pid_layout, 0, 0, 1, 0)
        self.channels = [None] * len(channels)
        self.chan_layout = QVBoxLayout()
        self.chan_layout.setSpacing(0)
        for idx, channel in enumerate(channels):
            if (channel[1] == 0 and channel[2] == 0):
                continue
            self.channels[idx] = ChannelWidget(channel)
            self.channels[idx].setMaximumHeight(180)
            self.chan_layout.addWidget(self.channels[idx])
            
        self.layout.addLayout(self.chan_layout, 1, 0)
        self.layout.setRowStretch(2, 1)
        self.setLayout(self.layout)  


class PIDUIView(QMainWindow, Observable):
    def __init__(self):
        super().__init__()
        
        self.setWindowTitle(&#34;Beaglebone PID Controller&#34;)
        
        setup = get_setup()
        self.pid_configuration = setup.gse.spid.configuration.heaters
        self.pid_configuration[&#39;MaRi&#39;] = self.pid_configuration[&#39;TRP2&#39;] + self.pid_configuration[&#39;TRP3&#39;] + self.pid_configuration[&#39;TRP4&#39;]
        del self.pid_configuration[&#39;TRP2&#39;], self.pid_configuration[&#39;TRP3&#39;], self.pid_configuration[&#39;TRP4&#39;]

        self.initUI()
        
        self.pid_monitoring_thread = QThread(self)
        self.pid_monitoring_worker = PidMonitoringWorker()
        self.pid_monitoring_worker.moveToThread(self.pid_monitoring_thread)
        
        self.pid_monitoring_worker.pid_enabled_status_signal.connect(self.on_pid_enabled_status_signal)
        self.pid_monitoring_worker.pid_setpoint_status_signal.connect(self.on_pid_setpoint_status_signal)
        self.pid_monitoring_worker.pid_timestamp_status_signal.connect(self.on_pid_timestamp_status_signal)
        self.pid_monitoring_worker.pid_update_status_signal.connect(self.on_pid_update_status_signal)
        self.pid_monitoring_worker.pid_constants_status_signal.connect(self.on_pid_constant_status_signal)
        
        self.pid_monitoring_thread.started.connect(self.pid_monitoring_worker.start_process)
        self.pid_monitoring_thread.start()
        
    def on_pid_enabled_status_signal(self, monitoring_info:dict):
        monitoring_info = list(monitoring_info.values())
        
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            state_lin = len(self.pid_channels[idx].channels)
            pid_state = 0
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    state_lin -= 1
                    continue
                self.pid_channels[idx].channels[ch_idx].switch.set_selected(bool(monitoring_info[ch[0]]))
                ch_enabled = self.pid_channels[idx].channels[ch_idx].switch.is_selected()
                pid_state += 1 if int(ch_enabled) else 0
            # print(pid_state)
            if pid_state == state_lin:
                self.pid_channels[idx].led.set_color(1)
            elif  0 &lt; pid_state &lt; state_lin:
                self.pid_channels[idx].led.set_color(2)
            else:
                self.pid_channels[idx].led.set_color(0)
    
    def on_pid_constant_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].pid_val[0].setText(f&#34;{monitoring_info[0]:.4f}&#34;)
                self.pid_channels[idx].channels[ch_idx].pid_val[1].setText(f&#34;{monitoring_info[1]:.4f}&#34;)  
                self.pid_channels[idx].channels[ch_idx].pid_val[2].setText(f&#34;{monitoring_info[2]:.4f}&#34;)  
    
    def on_pid_setpoint_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].sp_text_box.setText(f&#34;{monitoring_info[ch[0]]:.1f}&#34;)
    
    def on_pid_timestamp_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].last_sample_time.setText(str(datetime.fromtimestamp(monitoring_info[int(ch[0])])))
    
    def on_pid_update_status_signal(self, monitoring_info):
        channels = 0
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].err_text_box.setText(f&#34;{monitoring_info[0][channels]:.1f}&#34;)
                self.pid_channels[idx].channels[ch_idx].isum_text_box.setText(f&#34;{monitoring_info[1][channels]:.1f}&#34;)
                self.pid_channels[idx].channels[ch_idx].in_text_box.setText(f&#34;{monitoring_info[2][channels]:.1f}&#34;)
                self.pid_channels[idx].channels[ch_idx].out_text_box.setText(f&#34;{monitoring_info[3][channels]:.1f}&#34;)
                channels += 1
                
                
        
    def initUI(self):
        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)
        full_layout = QVBoxLayout()
        toolbar_widget = ToolbarWidget()
        toolbar_widget.kill_button.clicked.connect(self.kill_all_pid_processes)
        # body_layout = QHBoxLayout()
        body_layout = QGridLayout()
        self.pid_channels = [None] * len(self.pid_configuration)
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            configuration.sort( key = lambda configuration: (configuration[3], configuration[4]))
            self.pid_channels[idx] = PIDWindow(pid, configuration)
            # body_layout.addWidget(self.pid_channels[idx])
            body_layout.addWidget(self.pid_channels[idx], 0 if idx &lt; 4 else 1, idx if idx &lt; 4 else idx - 4)
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].switch.clicked.connect(self.set_pid_control)
                self.pid_channels[idx].channels[ch_idx].more.clicked.connect(self.show_more_information)
                self.pid_channels[idx].channels[ch_idx].sp_text_box.returnPressed.connect(self.set_pid_setpoint)
        full_layout.addWidget(toolbar_widget)
        full_layout.addLayout(body_layout)
        app_frame.setLayout(full_layout)
        self.setCentralWidget(app_frame)

    def kill_all_pid_processes(self):
        sender = self.sender()
        state = sender.is_selected()
        if not state:
            ProcessId = map(int, check_output([&#39;pgrep&#39;, &#34;-f&#34;, &#34;spid_cs&#34;]).split())
            logger.info(f&#34;Killing all PID processes - {list(ProcessId)}&#34;)
            for pid in list(ProcessId):
                try:
                    os.kill(pid, 9)
                except Exception as exc:
                    logger.info(f&#34;{exc}&#34;)

            ProcessId = map(int, check_output([&#39;pgrep&#39;, &#34;-f&#34;, &#34;spid&#34;]).split())     
            logger.info(f&#34;Remaining PID Processes - {list(ProcessId)}&#34;)       
    
    def show_more_information(self):
        sender = self.sender()
        state = sender.is_selected()
        if state:
            sender.show_less()
        else:
            sender.show_more()
        

    def set_pid_control(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        state = sender.is_selected()
        new_state = state
        sender.set_selected(on=new_state)
        pid = command[0]
        htr = command[1]
        ch = command[2]
        logger.info(f&#39;PID channel {pid} Heater {htr} Channel {ch} has been set to: {new_state}&#39;)
        self.actionObservers({&#34;set_pid_control&#34; : [pid, bool(new_state)]})
    
    def set_pid_setpoint(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        setpoint = int(sender.text())
        pid = command[0]
        htr = command[1]
        ch = command[2]
        logger.info(f&#39;PID channel {pid} Heater {htr} Channel {ch} setpoint has been set to: {setpoint}&#39;)
        self.actionObservers({&#34;set_pid_setpoint&#34; : [pid, float(setpoint)]})

    def closeEvent(self, close_Event: QCloseEvent) -&gt; None:
        self.pid_monitoring_thread.quit()
        self.pid_monitoring_worker.stop()

class PIDUIModel:
    def __init__(self, mode):
        self.mode = mode
        if self.mode == &#34;proxy&#34;:
            try:
                self.pid = PidProxy()
            except Exception as exc:
                raise exc
            
        elif self.mode == &#39;simulator&#39;:
            self.pid = PidSimulator()
        else:
            raise ValueError(f&#39;Unknown type of PID implementation passed into the model&#39;)
        
       
        if self.pid is not None:
                logger.debug(f&#39;Heater Controller initialized as {self.pid.__class__.__name__}&#39;)

    def set_pid_control(self, ch, state):
        with PidProxy() as pid:
            if state:
                pid.enable(int(ch))
            else:
                pid.disable(int(ch))

    
    def set_pid_setpoint(self, ch, sp):
        with PidProxy() as pid:
            pid.set_temperature(int(ch), float(sp))
    
    def has_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.has_commands()
            
        return True
                
    
    def load_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.load_commands()
    
    def is_simulator(self):
        with PidProxy() as pid:
            pid.is_simulator()

    
    def is_connected(self):
        with PidProxy() as pid:
            pid.is_cs_connected()
    
    def reconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                pid.reconnect()
            return self.pid.is_cs_connected()
        return False
    
    def disconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                return pid.disconnect_cs()

        elif self.mode == &#39;simulator&#39;:
            return self.pid.disconnect()


class PIDUIController(Observer):
    def __init__(self, model: PIDUIModel, view: PIDUIView):
        self.model  = model
        self.view   = view
        self.view.addObserver(self)
        
    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                logger.debug(&#34;Reconnecting the Heater model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                logger.debug(&#34;Disconnecting the Heater model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return
        
    def do(self, actions):
        for action, value in actions.items():
            logger.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_pid_control&#34;:
                ch      = value[0]
                state   = value[1]

                self.model.set_pid_control(ch, state)
 
            if action == &#34;set_pid_setpoint&#34;:
                ch      = value[0]
                temp    = value[1]
                self.model.set_pid_setpoint(ch, temp)
        
def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;},
        help=&#34;Specify PID implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )

    args = parser.parse_args()
    return args

if __name__ == &#39;__main__&#39;:
    args = list(sys.argv)
    app = QApplication(args)

    args = parse_arguments()
    
    if args.type == &#39;proxy&#39;:
        try:
            proxy = PidProxy()
        except Exception:
            raise Exception
        
    view        = PIDUIView()
    model       = PIDUIModel(args.type)
    controller  = PIDUIController(model, view)
    view.show()
    sys.exit(app.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.parse_arguments"><code class="name flex">
<span>def <span class="ident">parse_arguments</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the arguments that are specific for this application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;},
        help=&#34;Specify PID implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )

    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.ChannelWidget"><code class="flex name class">
<span>class <span class="ident">ChannelWidget</span></span>
<span>(</span><span>channel_info)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelWidget(QGroupBox):
    
    def __init__(self, channel_info):
        super().__init__()

        self.layout = QGridLayout()
        self.pid = channel_info[0]
        self.htr = channel_info[3]
        self.ch = channel_info[4]
        textbox_width = 60
        self.switch = ToggleButton(
            name=&#34;Turn On\Off PID Channel&#34;,
            status_tip=f&#34;Heater {self.htr} Channel {self.ch} On\Off&#34;,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        self.switch.setObjectName(f&#34;{self.pid} {self.htr} {self.ch} Switch&#34;)
        
        self.more = ToggleButton(
            width=10,
            height=10,
            name=&#34;More PID information&#34;,
            status_tip=f&#34;Show more information about pid channel {self.ch}&#34;,
            selected=get_resource(&#34;:/icons/more.svg&#34;),
            not_selected=get_resource(&#34;:/icons/arrow-up.svg&#34;)
        )
        self.more.setObjectName(f&#34;{self.pid} {self.htr} {self.ch} More&#34;)
        
        self.labels = [QLabel(f&#34;Heater {self.htr} Channel {self.ch}&#34;), QLabel(&#34;SP (°C)&#34;), QLabel(&#34;Err&#34;), QLabel(&#34;ISum&#34;), QLabel(&#34;Timestamp:&#34;), QLabel(&#34;In  (°C)&#34;), QLabel(&#34;Out&#34;)]
        
        self.sp_text_box        = QLineEdit(self)
        self.sp_text_box.setValidator(QIntValidator(-300, 50))
        self.sp_text_box.setMinimumWidth(textbox_width)
        self.sp_text_box.setObjectName(f&#34;{self.pid} {self.htr} {self.ch} SetpointTextBox&#34;)
        
        self.pid_const = [QLabel(&#34;Kp:&#34;), QLabel(&#34;Ki:&#34;), QLabel(&#34;Kd:&#34;)]
        self.pid_val = [QLabel(&#34;0&#34;), QLabel(&#34;0&#34;), QLabel(&#34;0&#34;)]
        
        self.err_text_box       = QLineEdit(self)
        self.err_text_box.setValidator(QIntValidator(-1000, 1000))
        self.err_text_box.setReadOnly(True)
        self.err_text_box.setMinimumWidth(textbox_width)
        
        self.in_text_box       = QLineEdit(self)
        self.in_text_box.setValidator(QIntValidator(-1000, 1000))
        self.in_text_box.setReadOnly(True)
        self.in_text_box.setMinimumWidth(textbox_width)
        
        self.out_text_box       = QLineEdit(self)
        self.out_text_box.setValidator(QIntValidator(-1000, 1000))
        self.out_text_box.setReadOnly(True)
        self.out_text_box.setMinimumWidth(textbox_width)
        
        self.isum_text_box      = QLineEdit(self)
        self.isum_text_box.setValidator(QIntValidator(-1000, 1000))
        self.isum_text_box.setReadOnly(True)
        self.isum_text_box.setMinimumWidth(textbox_width)
        
        self.last_sample_time   = QLabel(&#34;DUMM-YD:DATET:IM:EX.XXX+XXXX&#34;)
        
        self.layout.addWidget(self.switch, 0, 0)
        self.layout.addWidget(self.labels[0], 0, 1, 1, 5)
        
        self.layout.addWidget(self.pid_const[0], 1, 1)
        self.layout.addWidget(self.pid_val[0], 1, 2)
        self.layout.addWidget(self.pid_const[1], 1, 3)
        self.layout.addWidget(self.pid_val[1], 1, 4)
        self.layout.addWidget(self.pid_const[2], 1, 5)
        self.layout.addWidget(self.pid_val[2], 1, 6)  
             
        self.layout.addWidget(self.labels[1], 2, 0)
        self.layout.addWidget(self.sp_text_box, 2, 1)
        self.layout.addWidget(self.labels[2], 2, 2)
        self.layout.addWidget(self.err_text_box, 2, 3)
        self.layout.addWidget(self.labels[3], 2, 4)
        self.layout.addWidget(self.isum_text_box, 2, 5)
        self.layout.addWidget(self.in_text_box, 3, 1)
        self.layout.addWidget(self.labels[5], 3, 0)
        self.layout.addWidget(self.labels[6], 3, 4)
        self.layout.addWidget(self.out_text_box, 3, 5)
        self.layout.addWidget(self.labels[4], 4, 1, 1, 5)
        self.layout.addWidget(self.last_sample_time, 5, 1, 1, 5)
        self.layout.addWidget(self.more, 5, 6)
        
        self.show_less()
        self.more.show_more = self.show_more
        self.more.show_less = self.show_less
        
        self.setLayout(self.layout)
        
    def show_more(self):
        [const.show() for const in self.pid_const]
        [val.show() for val in self.pid_val]
        [lab.show() for lab in self.labels[5:7]]
        self.out_text_box.show()
        self.in_text_box.show()
        
    def show_less(self):
        [const.hide() for const in self.pid_const]
        [val.hide() for val in self.pid_val]
        [lab.hide() for lab in self.labels[5:7]]
        self.out_text_box.hide()
        self.in_text_box.hide()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.ChannelWidget.show_less"><code class="name flex">
<span>def <span class="ident">show_less</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_less(self):
    [const.hide() for const in self.pid_const]
    [val.hide() for val in self.pid_val]
    [lab.hide() for lab in self.labels[5:7]]
    self.out_text_box.hide()
    self.in_text_box.hide()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.ChannelWidget.show_more"><code class="name flex">
<span>def <span class="ident">show_more</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_more(self):
    [const.show() for const in self.pid_const]
    [val.show() for val in self.pid_val]
    [lab.show() for lab in self.labels[5:7]]
    self.out_text_box.show()
    self.in_text_box.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIController"><code class="flex name class">
<span>class <span class="ident">PIDUIController</span></span>
<span>(</span><span>model: <a title="egse.tempcontrol.spid.spid_ui.PIDUIModel" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel">PIDUIModel</a>, view: <a title="egse.tempcontrol.spid.spid_ui.PIDUIView" href="#egse.tempcontrol.spid.spid_ui.PIDUIView">PIDUIView</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDUIController(Observer):
    def __init__(self, model: PIDUIModel, view: PIDUIView):
        self.model  = model
        self.view   = view
        self.view.addObserver(self)
        
    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                logger.debug(&#34;Reconnecting the Heater model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                logger.debug(&#34;Disconnecting the Heater model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return
        
    def do(self, actions):
        for action, value in actions.items():
            logger.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_pid_control&#34;:
                ch      = value[0]
                state   = value[1]

                self.model.set_pid_control(ch, state)
 
            if action == &#34;set_pid_setpoint&#34;:
                ch      = value[0]
                temp    = value[1]
                self.model.set_pid_setpoint(ch, temp)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.observer.Observer" href="../../observer.html#egse.observer.Observer">Observer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIController.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, actions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, actions):
    for action, value in actions.items():
        logger.debug(f&#34;do {action} with {value}&#34;)
        if action == &#34;set_pid_control&#34;:
            ch      = value[0]
            state   = value[1]

            self.model.set_pid_control(ch, state)

        if action == &#34;set_pid_setpoint&#34;:
            ch      = value[0]
            temp    = value[1]
            self.model.set_pid_setpoint(ch, temp)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIController.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, changed_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, changed_object):

    text = changed_object.text()

    if text == &#34;Reconnect&#34;:

        if changed_object.isChecked():

            logger.debug(&#34;Reconnecting the Heater model.&#34;)

            if self.model.reconnect():

                self.view.set_connection_state(True)

                if not self.model.has_commands():

                    self.model.load_commands()

            else:
                self.view.reconnect_action.setChecked(False)
        else:

            logger.debug(&#34;Disconnecting the Heater model.&#34;)
            self.model.disconnect()
            self.view.set_connection_state(False)

        return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel"><code class="flex name class">
<span>class <span class="ident">PIDUIModel</span></span>
<span>(</span><span>mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDUIModel:
    def __init__(self, mode):
        self.mode = mode
        if self.mode == &#34;proxy&#34;:
            try:
                self.pid = PidProxy()
            except Exception as exc:
                raise exc
            
        elif self.mode == &#39;simulator&#39;:
            self.pid = PidSimulator()
        else:
            raise ValueError(f&#39;Unknown type of PID implementation passed into the model&#39;)
        
       
        if self.pid is not None:
                logger.debug(f&#39;Heater Controller initialized as {self.pid.__class__.__name__}&#39;)

    def set_pid_control(self, ch, state):
        with PidProxy() as pid:
            if state:
                pid.enable(int(ch))
            else:
                pid.disable(int(ch))

    
    def set_pid_setpoint(self, ch, sp):
        with PidProxy() as pid:
            pid.set_temperature(int(ch), float(sp))
    
    def has_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.has_commands()
            
        return True
                
    
    def load_commands(self):
        if self.mode == &#39;proxy&#39;:
            with PidProxy() as pid:
                pid.load_commands()
    
    def is_simulator(self):
        with PidProxy() as pid:
            pid.is_simulator()

    
    def is_connected(self):
        with PidProxy() as pid:
            pid.is_cs_connected()
    
    def reconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                pid.reconnect()
            return self.pid.is_cs_connected()
        return False
    
    def disconnect(self):
        if self.mode == &#34;proxy&#34;:
            with PidProxy() as pid:
                return pid.disconnect_cs()

        elif self.mode == &#39;simulator&#39;:
            return self.pid.disconnect()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    if self.mode == &#34;proxy&#34;:
        with PidProxy() as pid:
            return pid.disconnect_cs()

    elif self.mode == &#39;simulator&#39;:
        return self.pid.disconnect()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.has_commands"><code class="name flex">
<span>def <span class="ident">has_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_commands(self):
    if self.mode == &#39;proxy&#39;:
        with PidProxy() as pid:
            pid.has_commands()
        
    return True</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    with PidProxy() as pid:
        pid.is_cs_connected()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_simulator"><code class="name flex">
<span>def <span class="ident">is_simulator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulator(self):
    with PidProxy() as pid:
        pid.is_simulator()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(self):
    if self.mode == &#39;proxy&#39;:
        with PidProxy() as pid:
            pid.load_commands()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    if self.mode == &#34;proxy&#34;:
        with PidProxy() as pid:
            pid.reconnect()
        return self.pid.is_cs_connected()
    return False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_control"><code class="name flex">
<span>def <span class="ident">set_pid_control</span></span>(<span>self, ch, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_control(self, ch, state):
    with PidProxy() as pid:
        if state:
            pid.enable(int(ch))
        else:
            pid.disable(int(ch))</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_setpoint"><code class="name flex">
<span>def <span class="ident">set_pid_setpoint</span></span>(<span>self, ch, sp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_setpoint(self, ch, sp):
    with PidProxy() as pid:
        pid.set_temperature(int(ch), float(sp))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView"><code class="flex name class">
<span>class <span class="ident">PIDUIView</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDUIView(QMainWindow, Observable):
    def __init__(self):
        super().__init__()
        
        self.setWindowTitle(&#34;Beaglebone PID Controller&#34;)
        
        setup = get_setup()
        self.pid_configuration = setup.gse.spid.configuration.heaters
        self.pid_configuration[&#39;MaRi&#39;] = self.pid_configuration[&#39;TRP2&#39;] + self.pid_configuration[&#39;TRP3&#39;] + self.pid_configuration[&#39;TRP4&#39;]
        del self.pid_configuration[&#39;TRP2&#39;], self.pid_configuration[&#39;TRP3&#39;], self.pid_configuration[&#39;TRP4&#39;]

        self.initUI()
        
        self.pid_monitoring_thread = QThread(self)
        self.pid_monitoring_worker = PidMonitoringWorker()
        self.pid_monitoring_worker.moveToThread(self.pid_monitoring_thread)
        
        self.pid_monitoring_worker.pid_enabled_status_signal.connect(self.on_pid_enabled_status_signal)
        self.pid_monitoring_worker.pid_setpoint_status_signal.connect(self.on_pid_setpoint_status_signal)
        self.pid_monitoring_worker.pid_timestamp_status_signal.connect(self.on_pid_timestamp_status_signal)
        self.pid_monitoring_worker.pid_update_status_signal.connect(self.on_pid_update_status_signal)
        self.pid_monitoring_worker.pid_constants_status_signal.connect(self.on_pid_constant_status_signal)
        
        self.pid_monitoring_thread.started.connect(self.pid_monitoring_worker.start_process)
        self.pid_monitoring_thread.start()
        
    def on_pid_enabled_status_signal(self, monitoring_info:dict):
        monitoring_info = list(monitoring_info.values())
        
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            state_lin = len(self.pid_channels[idx].channels)
            pid_state = 0
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    state_lin -= 1
                    continue
                self.pid_channels[idx].channels[ch_idx].switch.set_selected(bool(monitoring_info[ch[0]]))
                ch_enabled = self.pid_channels[idx].channels[ch_idx].switch.is_selected()
                pid_state += 1 if int(ch_enabled) else 0
            # print(pid_state)
            if pid_state == state_lin:
                self.pid_channels[idx].led.set_color(1)
            elif  0 &lt; pid_state &lt; state_lin:
                self.pid_channels[idx].led.set_color(2)
            else:
                self.pid_channels[idx].led.set_color(0)
    
    def on_pid_constant_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].pid_val[0].setText(f&#34;{monitoring_info[0]:.4f}&#34;)
                self.pid_channels[idx].channels[ch_idx].pid_val[1].setText(f&#34;{monitoring_info[1]:.4f}&#34;)  
                self.pid_channels[idx].channels[ch_idx].pid_val[2].setText(f&#34;{monitoring_info[2]:.4f}&#34;)  
    
    def on_pid_setpoint_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue                
                self.pid_channels[idx].channels[ch_idx].sp_text_box.setText(f&#34;{monitoring_info[ch[0]]:.1f}&#34;)
    
    def on_pid_timestamp_status_signal(self, monitoring_info):
        for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].last_sample_time.setText(str(datetime.fromtimestamp(monitoring_info[int(ch[0])])))
    
    def on_pid_update_status_signal(self, monitoring_info):
        channels = 0
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].err_text_box.setText(f&#34;{monitoring_info[0][channels]:.1f}&#34;)
                self.pid_channels[idx].channels[ch_idx].isum_text_box.setText(f&#34;{monitoring_info[1][channels]:.1f}&#34;)
                self.pid_channels[idx].channels[ch_idx].in_text_box.setText(f&#34;{monitoring_info[2][channels]:.1f}&#34;)
                self.pid_channels[idx].channels[ch_idx].out_text_box.setText(f&#34;{monitoring_info[3][channels]:.1f}&#34;)
                channels += 1
                
                
        
    def initUI(self):
        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)
        full_layout = QVBoxLayout()
        toolbar_widget = ToolbarWidget()
        toolbar_widget.kill_button.clicked.connect(self.kill_all_pid_processes)
        # body_layout = QHBoxLayout()
        body_layout = QGridLayout()
        self.pid_channels = [None] * len(self.pid_configuration)
        for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
            configuration.sort( key = lambda configuration: (configuration[3], configuration[4]))
            self.pid_channels[idx] = PIDWindow(pid, configuration)
            # body_layout.addWidget(self.pid_channels[idx])
            body_layout.addWidget(self.pid_channels[idx], 0 if idx &lt; 4 else 1, idx if idx &lt; 4 else idx - 4)
            for ch_idx, ch in enumerate(configuration):
                if (ch[1] == 0 and ch[2] == 0):
                    continue
                self.pid_channels[idx].channels[ch_idx].switch.clicked.connect(self.set_pid_control)
                self.pid_channels[idx].channels[ch_idx].more.clicked.connect(self.show_more_information)
                self.pid_channels[idx].channels[ch_idx].sp_text_box.returnPressed.connect(self.set_pid_setpoint)
        full_layout.addWidget(toolbar_widget)
        full_layout.addLayout(body_layout)
        app_frame.setLayout(full_layout)
        self.setCentralWidget(app_frame)

    def kill_all_pid_processes(self):
        sender = self.sender()
        state = sender.is_selected()
        if not state:
            ProcessId = map(int, check_output([&#39;pgrep&#39;, &#34;-f&#34;, &#34;spid_cs&#34;]).split())
            logger.info(f&#34;Killing all PID processes - {list(ProcessId)}&#34;)
            for pid in list(ProcessId):
                try:
                    os.kill(pid, 9)
                except Exception as exc:
                    logger.info(f&#34;{exc}&#34;)

            ProcessId = map(int, check_output([&#39;pgrep&#39;, &#34;-f&#34;, &#34;spid&#34;]).split())     
            logger.info(f&#34;Remaining PID Processes - {list(ProcessId)}&#34;)       
    
    def show_more_information(self):
        sender = self.sender()
        state = sender.is_selected()
        if state:
            sender.show_less()
        else:
            sender.show_more()
        

    def set_pid_control(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        state = sender.is_selected()
        new_state = state
        sender.set_selected(on=new_state)
        pid = command[0]
        htr = command[1]
        ch = command[2]
        logger.info(f&#39;PID channel {pid} Heater {htr} Channel {ch} has been set to: {new_state}&#39;)
        self.actionObservers({&#34;set_pid_control&#34; : [pid, bool(new_state)]})
    
    def set_pid_setpoint(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        setpoint = int(sender.text())
        pid = command[0]
        htr = command[1]
        ch = command[2]
        logger.info(f&#39;PID channel {pid} Heater {htr} Channel {ch} setpoint has been set to: {setpoint}&#39;)
        self.actionObservers({&#34;set_pid_setpoint&#34; : [pid, float(setpoint)]})

    def closeEvent(self, close_Event: QCloseEvent) -&gt; None:
        self.pid_monitoring_thread.quit()
        self.pid_monitoring_worker.stop()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li><a title="egse.observer.Observable" href="../../observer.html#egse.observer.Observable">Observable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, close_Event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>closeEvent(self, QCloseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, close_Event: QCloseEvent) -&gt; None:
    self.pid_monitoring_thread.quit()
    self.pid_monitoring_worker.stop()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    app_frame = QFrame()
    app_frame.setObjectName(&#34;AppFrame&#34;)
    full_layout = QVBoxLayout()
    toolbar_widget = ToolbarWidget()
    toolbar_widget.kill_button.clicked.connect(self.kill_all_pid_processes)
    # body_layout = QHBoxLayout()
    body_layout = QGridLayout()
    self.pid_channels = [None] * len(self.pid_configuration)
    for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
        configuration.sort( key = lambda configuration: (configuration[3], configuration[4]))
        self.pid_channels[idx] = PIDWindow(pid, configuration)
        # body_layout.addWidget(self.pid_channels[idx])
        body_layout.addWidget(self.pid_channels[idx], 0 if idx &lt; 4 else 1, idx if idx &lt; 4 else idx - 4)
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue
            self.pid_channels[idx].channels[ch_idx].switch.clicked.connect(self.set_pid_control)
            self.pid_channels[idx].channels[ch_idx].more.clicked.connect(self.show_more_information)
            self.pid_channels[idx].channels[ch_idx].sp_text_box.returnPressed.connect(self.set_pid_setpoint)
    full_layout.addWidget(toolbar_widget)
    full_layout.addLayout(body_layout)
    app_frame.setLayout(full_layout)
    self.setCentralWidget(app_frame)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.kill_all_pid_processes"><code class="name flex">
<span>def <span class="ident">kill_all_pid_processes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_all_pid_processes(self):
    sender = self.sender()
    state = sender.is_selected()
    if not state:
        ProcessId = map(int, check_output([&#39;pgrep&#39;, &#34;-f&#34;, &#34;spid_cs&#34;]).split())
        logger.info(f&#34;Killing all PID processes - {list(ProcessId)}&#34;)
        for pid in list(ProcessId):
            try:
                os.kill(pid, 9)
            except Exception as exc:
                logger.info(f&#34;{exc}&#34;)

        ProcessId = map(int, check_output([&#39;pgrep&#39;, &#34;-f&#34;, &#34;spid&#34;]).split())     
        logger.info(f&#34;Remaining PID Processes - {list(ProcessId)}&#34;)       </code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_constant_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_constant_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_constant_status_signal(self, monitoring_info):
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue                
            self.pid_channels[idx].channels[ch_idx].pid_val[0].setText(f&#34;{monitoring_info[0]:.4f}&#34;)
            self.pid_channels[idx].channels[ch_idx].pid_val[1].setText(f&#34;{monitoring_info[1]:.4f}&#34;)  
            self.pid_channels[idx].channels[ch_idx].pid_val[2].setText(f&#34;{monitoring_info[2]:.4f}&#34;)  </code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_enabled_status_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_enabled_status_signal(self, monitoring_info:dict):
    monitoring_info = list(monitoring_info.values())
    
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        state_lin = len(self.pid_channels[idx].channels)
        pid_state = 0
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                state_lin -= 1
                continue
            self.pid_channels[idx].channels[ch_idx].switch.set_selected(bool(monitoring_info[ch[0]]))
            ch_enabled = self.pid_channels[idx].channels[ch_idx].switch.is_selected()
            pid_state += 1 if int(ch_enabled) else 0
        # print(pid_state)
        if pid_state == state_lin:
            self.pid_channels[idx].led.set_color(1)
        elif  0 &lt; pid_state &lt; state_lin:
            self.pid_channels[idx].led.set_color(2)
        else:
            self.pid_channels[idx].led.set_color(0)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_setpoint_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_setpoint_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_setpoint_status_signal(self, monitoring_info):
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue                
            self.pid_channels[idx].channels[ch_idx].sp_text_box.setText(f&#34;{monitoring_info[ch[0]]:.1f}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_timestamp_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_timestamp_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_timestamp_status_signal(self, monitoring_info):
    for idx, (_, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue
            self.pid_channels[idx].channels[ch_idx].last_sample_time.setText(str(datetime.fromtimestamp(monitoring_info[int(ch[0])])))</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_update_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_update_status_signal</span></span>(<span>self, monitoring_info)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_update_status_signal(self, monitoring_info):
    channels = 0
    for idx, (pid, configuration) in enumerate(self.pid_configuration.items()):
        for ch_idx, ch in enumerate(configuration):
            if (ch[1] == 0 and ch[2] == 0):
                continue
            self.pid_channels[idx].channels[ch_idx].err_text_box.setText(f&#34;{monitoring_info[0][channels]:.1f}&#34;)
            self.pid_channels[idx].channels[ch_idx].isum_text_box.setText(f&#34;{monitoring_info[1][channels]:.1f}&#34;)
            self.pid_channels[idx].channels[ch_idx].in_text_box.setText(f&#34;{monitoring_info[2][channels]:.1f}&#34;)
            self.pid_channels[idx].channels[ch_idx].out_text_box.setText(f&#34;{monitoring_info[3][channels]:.1f}&#34;)
            channels += 1</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.set_pid_control"><code class="name flex">
<span>def <span class="ident">set_pid_control</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_control(self):
    sender = self.sender()
    command = sender.objectName().split(&#34; &#34;)
    state = sender.is_selected()
    new_state = state
    sender.set_selected(on=new_state)
    pid = command[0]
    htr = command[1]
    ch = command[2]
    logger.info(f&#39;PID channel {pid} Heater {htr} Channel {ch} has been set to: {new_state}&#39;)
    self.actionObservers({&#34;set_pid_control&#34; : [pid, bool(new_state)]})</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.set_pid_setpoint"><code class="name flex">
<span>def <span class="ident">set_pid_setpoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_setpoint(self):
    sender = self.sender()
    command = sender.objectName().split(&#34; &#34;)
    setpoint = int(sender.text())
    pid = command[0]
    htr = command[1]
    ch = command[2]
    logger.info(f&#39;PID channel {pid} Heater {htr} Channel {ch} setpoint has been set to: {setpoint}&#39;)
    self.actionObservers({&#34;set_pid_setpoint&#34; : [pid, float(setpoint)]})</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDUIView.show_more_information"><code class="name flex">
<span>def <span class="ident">show_more_information</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_more_information(self):
    sender = self.sender()
    state = sender.is_selected()
    if state:
        sender.show_less()
    else:
        sender.show_more()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDWidget"><code class="flex name class">
<span>class <span class="ident">PIDWidget</span></span>
<span>(</span><span>pid_name)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDWidget(QGroupBox):
    def __init__(self, pid_name):
        super().__init__()
        
        self.name = QLabel(pid_name)
        self.led = Led(self)
        layout = QHBoxLayout()
        
        layout.addWidget(self.name)
        layout.addWidget(self.led)
        
        self.setLayout(layout)        </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PIDWindow"><code class="flex name class">
<span>class <span class="ident">PIDWindow</span></span>
<span>(</span><span>pid_name, channels)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PIDWindow(QGroupBox):
    def __init__(self, pid_name, channels):
        super().__init__()
        

        self.layout = QGridLayout()
        # self.layout = QVBoxLayout()
        # self.layout.setSpacing(0)
        self.name = QLabel(pid_name)
        self.led = Led(self)
        pid_layout = QHBoxLayout()
        
        pid_layout.addWidget(self.name)
        pid_layout.addWidget(self.led)
        self.layout.addLayout(pid_layout, 0, 0, 1, 0)
        self.channels = [None] * len(channels)
        self.chan_layout = QVBoxLayout()
        self.chan_layout.setSpacing(0)
        for idx, channel in enumerate(channels):
            if (channel[1] == 0 and channel[2] == 0):
                continue
            self.channels[idx] = ChannelWidget(channel)
            self.channels[idx].setMaximumHeight(180)
            self.chan_layout.addWidget(self.channels[idx])
            
        self.layout.addLayout(self.chan_layout, 1, 0)
        self.layout.setRowStretch(2, 1)
        self.setLayout(self.layout)  </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">PidMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PidMonitoringWorker(QObject):
    
    pid_timestamp_status_signal = pyqtSignal(list)
    pid_update_status_signal = pyqtSignal(list)
    pid_enabled_status_signal = pyqtSignal(dict)
    pid_setpoint_status_signal = pyqtSignal(list)
    # pid_constants_status_signal = pyqtSignal(list)
    
    def __init__(self):
        super(PidMonitoringWorker, self).__init__()
        
        self.activate = False
        self.just_reconnected = True
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        self.previous_pid_update_status_signal = []
        self.previous_pid_timestamp_status_signal = []
        self.previous_pid_setpoint = []
        self.previous_pid_enabled_status_signal = []
        # self.previous_pid_constants_status_signal = []
        
    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;
        

        try:
            transport   = PID_CTRL_SETTINGS.PROTOCOL
            hostname    = PID_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        
        &#34;&#34;&#34; Stop the monitoring worker.
        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;
        
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
        self.run()
        
    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
        
        If the beaglebone status has changed, update it in the GUI
        Raises:
            Exception: ZMQ Error
        &#34;&#34;&#34;
        
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                if self.monitoring_socket in socket_list:
                    try:
                        pickle_string = self.monitoring_socket.recv()
                    except Exception:
                        raise Exception

                    monitoring_info = pickle.loads(pickle_string)
                    
                    pid_enabled     = monitoring_info[&#39;Enabled&#39;]
                    pid_setpoint    = monitoring_info[&#39;Setpoint&#39;]
                    pid_timestamp   = monitoring_info[&#39;Timestamp&#39;]
                    pid_error       = monitoring_info[&#39;Error&#39;]
                    pid_isum        = monitoring_info[&#39;Isum&#39;]
                    pid_input       = monitoring_info[&#39;Input&#39;]
                    pid_output      = monitoring_info[&#39;Output&#39;]
                    # pid_const       = monitoring_info[&#39;PidConst&#39;]
                    pid_state       = [pid_error, pid_isum, pid_input, pid_output]
                    
                    if pid_timestamp != self.previous_pid_timestamp_status_signal:
                        self.pid_timestamp_status_signal.emit(pid_timestamp)
                        
                    self.previous_pid_timestamp_status_signal = pid_timestamp
                    
                    if pid_setpoint != self.previous_pid_setpoint:
                        self.pid_setpoint_status_signal.emit(pid_setpoint)
                    
                    self.previous_pid_setpoint = pid_setpoint
                    
                    if pid_enabled != self.previous_pid_enabled_status_signal:
                        self.pid_enabled_status_signal.emit(pid_enabled)
                        
                    self.previous_pid_enabled_status_signal = pid_enabled
                    
                    if pid_state != self.previous_pid_update_status_signal:
                        self.pid_update_status_signal.emit(pid_state)
                    
                    self.previous_pid_update_status_signal = pid_state
                    
                    # if pid_const != self.previous_pid_constants_status_signal:
                        # self.pid_update_constants_signal.emit(pid_const)
                    
                    # self.previous_pid_constants_status_signal = pid_const
                             
            except ZMQError as exc:
                raise exc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.
    &#34;&#34;&#34;
    

    try:
        transport   = PID_CTRL_SETTINGS.PROTOCOL
        hostname    = PID_CTRL_SETTINGS.HOSTNAME
        
        monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
        monitoring_address = connect_address(transport, hostname, monitoring_port)
        
        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
        
        self.monitoring_timeout = 0.5
        
        self.is_socket_connected = True
        
    except:
        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">pid_enabled_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_setpoint_status_signal"><code class="name flex">
<span>def <span class="ident">pid_setpoint_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_timestamp_status_signal"><code class="name flex">
<span>def <span class="ident">pid_timestamp_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_update_status_signal"><code class="name flex">
<span>def <span class="ident">pid_update_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on checkin whether the Beaglebone state has changed</p>
<p>If the beaglebone status has changed, update it in the GUI</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>ZMQ Error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
    
    If the beaglebone status has changed, update it in the GUI
    Raises:
        Exception: ZMQ Error
    &#34;&#34;&#34;
    
    self.active = True
    while self.is_socket_connected and self.active:
        
        try:
            socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            if self.monitoring_socket in socket_list:
                try:
                    pickle_string = self.monitoring_socket.recv()
                except Exception:
                    raise Exception

                monitoring_info = pickle.loads(pickle_string)
                
                pid_enabled     = monitoring_info[&#39;Enabled&#39;]
                pid_setpoint    = monitoring_info[&#39;Setpoint&#39;]
                pid_timestamp   = monitoring_info[&#39;Timestamp&#39;]
                pid_error       = monitoring_info[&#39;Error&#39;]
                pid_isum        = monitoring_info[&#39;Isum&#39;]
                pid_input       = monitoring_info[&#39;Input&#39;]
                pid_output      = monitoring_info[&#39;Output&#39;]
                # pid_const       = monitoring_info[&#39;PidConst&#39;]
                pid_state       = [pid_error, pid_isum, pid_input, pid_output]
                
                if pid_timestamp != self.previous_pid_timestamp_status_signal:
                    self.pid_timestamp_status_signal.emit(pid_timestamp)
                    
                self.previous_pid_timestamp_status_signal = pid_timestamp
                
                if pid_setpoint != self.previous_pid_setpoint:
                    self.pid_setpoint_status_signal.emit(pid_setpoint)
                
                self.previous_pid_setpoint = pid_setpoint
                
                if pid_enabled != self.previous_pid_enabled_status_signal:
                    self.pid_enabled_status_signal.emit(pid_enabled)
                    
                self.previous_pid_enabled_status_signal = pid_enabled
                
                if pid_state != self.previous_pid_update_status_signal:
                    self.pid_update_status_signal.emit(pid_state)
                
                self.previous_pid_update_status_signal = pid_state
                
                # if pid_const != self.previous_pid_constants_status_signal:
                    # self.pid_update_constants_signal.emit(pid_const)
                
                # self.previous_pid_constants_status_signal = pid_const
                         
        except ZMQError as exc:
            raise exc</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start updated the Beaglebone status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
    self.run()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the monitoring worker.
The monitoring socket is disconnected from the monitoring port and is then closed immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    
    &#34;&#34;&#34; Stop the monitoring worker.
    The monitoring socket is disconnected from the monitoring port and is then closed immediately.
    &#34;&#34;&#34;
    
    self.monitoring_socket.close()
    self.is_socket_connected = False
    
    self.active = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.spid.spid_ui.ToolbarWidget"><code class="flex name class">
<span>class <span class="ident">ToolbarWidget</span></span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolbarWidget(QGroupBox):
    def __init__(self):
        super().__init__()
        
        self.layout = QHBoxLayout()
        
        self.kill_button = ToggleButton(
            height=42,
            width=42,
            name=&#34;Kill SPID processes&#34;,
            status_tip=&#34;Kill every SPID process that is currently running&#34;,
            selected=get_resource(&#34;:/icons/stop-button.svg&#34;),
            not_selected=get_resource(&#34;:/icons/stop-button-disabled.svg&#34;)
        )
        
        self.release_control = ToggleButton(
            height=42,
            width=42,
            name=&#34;Stop all PID control&#34;,
            status_tip=&#34;Release the PID control of all running heaters&#34;,
            selected=get_resource(&#34;:/icons/remote-control-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/remote-control-off.svg&#34;)
        )
        
        self.layout.addWidget(self.release_control )
        self.layout.addWidget(self.kill_button)
        self.layout.setAlignment(Qt.AlignRight)
        self.setLayout(self.layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tempcontrol.spid" href="index.html">egse.tempcontrol.spid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.parse_arguments" href="#egse.tempcontrol.spid.spid_ui.parse_arguments">parse_arguments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.ChannelWidget" href="#egse.tempcontrol.spid.spid_ui.ChannelWidget">ChannelWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.ChannelWidget.show_less" href="#egse.tempcontrol.spid.spid_ui.ChannelWidget.show_less">show_less</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.ChannelWidget.show_more" href="#egse.tempcontrol.spid.spid_ui.ChannelWidget.show_more">show_more</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIController" href="#egse.tempcontrol.spid.spid_ui.PIDUIController">PIDUIController</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIController.do" href="#egse.tempcontrol.spid.spid_ui.PIDUIController.do">do</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIController.update" href="#egse.tempcontrol.spid.spid_ui.PIDUIController.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel">PIDUIModel</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.disconnect" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.has_commands" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.has_commands">has_commands</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_connected" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.is_simulator" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.load_commands" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.load_commands">load_commands</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.reconnect" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_control" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_control">set_pid_control</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_setpoint" href="#egse.tempcontrol.spid.spid_ui.PIDUIModel.set_pid_setpoint">set_pid_setpoint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView" href="#egse.tempcontrol.spid.spid_ui.PIDUIView">PIDUIView</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.closeEvent" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.closeEvent">closeEvent</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.initUI" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.initUI">initUI</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.kill_all_pid_processes" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.kill_all_pid_processes">kill_all_pid_processes</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_constant_status_signal" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_constant_status_signal">on_pid_constant_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_enabled_status_signal" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_enabled_status_signal">on_pid_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_setpoint_status_signal" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_setpoint_status_signal">on_pid_setpoint_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_timestamp_status_signal" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_timestamp_status_signal">on_pid_timestamp_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_update_status_signal" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.on_pid_update_status_signal">on_pid_update_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.set_pid_control" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.set_pid_control">set_pid_control</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.set_pid_setpoint" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.set_pid_setpoint">set_pid_setpoint</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PIDUIView.show_more_information" href="#egse.tempcontrol.spid.spid_ui.PIDUIView.show_more_information">show_more_information</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDWidget" href="#egse.tempcontrol.spid.spid_ui.PIDWidget">PIDWidget</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PIDWindow" href="#egse.tempcontrol.spid.spid_ui.PIDWindow">PIDWindow</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker">PidMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.connect_socket" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_enabled_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_enabled_status_signal">pid_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_setpoint_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_setpoint_status_signal">pid_setpoint_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_timestamp_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_timestamp_status_signal">pid_timestamp_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_update_status_signal" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.pid_update_status_signal">pid_update_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.run" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.start_process" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.stop" href="#egse.tempcontrol.spid.spid_ui.PidMonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.spid.spid_ui.ToolbarWidget" href="#egse.tempcontrol.spid.spid_ui.ToolbarWidget">ToolbarWidget</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
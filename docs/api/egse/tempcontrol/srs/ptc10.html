<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tempcontrol.srs.ptc10 API documentation</title>
<meta name="description" content="This module defines the basic classes to access the MaRi regulation ensured by
SRS PTC10 controller that will be used in the IAS TVAC setup." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tempcontrol.srs.ptc10</code></h1>
</header>
<section id="section-intro">
<p>This module defines the basic classes to access the MaRi regulation ensured by
SRS PTC10 controller that will be used in the IAS TVAC setup.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the basic classes to access the MaRi regulation ensured by
SRS PTC10 controller that will be used in the IAS TVAC setup.
&#34;&#34;&#34;
import logging
from typing import List


from egse.decorators import dynamic_interface
from egse.device import DeviceInterface
from egse.tempcontrol.srs.ptc10_devif import ptc10Error
from egse.tempcontrol.srs.ptc10_devif import ptc10TelnetInterface
from egse.proxy import Proxy
from egse.settings import Settings
from egse.zmq_ser import connect_address
from egse.mixin import dynamic_command
from egse.mixin import add_lf
from time import sleep, strftime, gmtime
from egse.confman import ConfigurationManagerProxy
from egse.system import format_datetime
from datetime import datetime


LOGGER = logging.getLogger(__name__)

CTRL_SETTINGS = Settings.load(&#34;SRS PTC10 Control Server&#34;)
PTC10_SETTINGS = Settings.load(&#34;SRS PTC10 Controller&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;ptc10.yaml&#34;)

def load_setup_from_configuration_manager():
    &#34;&#34;&#34;Loads a Setup YAML file from the Configuration Manager.&#34;&#34;&#34;
    with ConfigurationManagerProxy() as cm:
        setup = cm.get_setup()

    return setup


class ptc10Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Temp regulation SRS PTC10 Controller, Simulator and Proxy..
    &#34;&#34;&#34;

    @dynamic_interface
    def connect(self):
        &#34;&#34;&#34;Connects to the Temp regulation device.

        Raises:
            DeviceNotFoundError: when the Temp regulation device is not connected.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def disconnect(self):
        raise NotImplementedError

    @dynamic_interface
    def reconnect(self):
        raise NotImplementedError

    @dynamic_interface
    def is_connected(self):
        &#34;&#34;&#34;Check if the Temp Controller is connected.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_simulator(self):
        raise NotImplementedError

    @dynamic_interface
    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Returns basic information about the device, its name, firmwre version etc.
        Returns:
            An identification string of the instrument.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def alarm_status(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the current value of the Alarm Status Register (ASR), and then clears the register.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_names(self):
        &#34;&#34;&#34;
        Returns a tuple of 2 lists with the names of inputs (3 sensors) in the first list and the names of
        outputs (3 heaters) in the second list.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_name(self, old_name: str, new_name: str):
        &#34;&#34;&#34;Modifies the name of the specified channel (input or output).&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def clear_error(self):
        &#34;&#34;&#34;
        Erases all error messages for the port over which the instruction was transmitted. Also clears all messages
        from the System.Com. Errors window regardless of which port generated them.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def stop(self):
        &#34;&#34;&#34;
        kill.all stops all currently running macros with the given runtime name. The runtime name is assigned with the
        &#34;name&#34; instruction and is not necessarily the same as the file name that a macro may be saved under.
        The kill.all instruction stops all currently-running macros regardless of name or which port started the macro.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def standby(self):
        &#34;&#34;&#34;
        Puts the PTC10 into stby mode, in which the outputs are turned off, data acquisition is paused, macros are
        paused, the front panel display and system fan are shut off, and the system does not respond to remote commands.
        The PTC321&#39;s excitation currents remain on, and the chassis cooling fan may switch on occassionally.
        Press the &#34;Output Enable&#34; key to exit standby mode. There is no remote command to leave stand by mode.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;,
        cmd_string=&#34;*RST&#34;,
        process_cmd_string=add_lf,
    )
    def reset(self):
        &#34;&#34;&#34;
        Resets the PTC10.

        The *RST instruction is equivalent to turning the instrument off and back on again, except the Power On bit of
        the Event Status Register is not set. *RST has the following effects:
        - Outputs are disabled (as if the “Output enable” button were pressed).
        - All currently-running macros are stopped, regardless of whether the macros were started by the GPIB interface,
        another I/O port, or the Program screen.
        - The instrument returns to the Select screen.
        -Partially-received instructions on all I/O ports are cleared.
        - All pending transmissions on all I/O ports are cancelled.
        - The error queues for all I/O ports are cleared.
        - The plot screen returns to showing the most recent data on autoscaled Y axes.
        - The instrument automatically triggers at the rate set with the “A/D rate” control.
        - Clears all locally-stored log data. Logs on USB devices are not affected. If data is not being logged to a
        USB storage device, the Plot screen shows no accumulated data immediately after a *RST command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def read_temperature(self):
        &#34;&#34;&#34;
        Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.

        Notes: &lt;channel&gt;.value? returns the current value of the channel. Ex: 2A.value? queries the output of channel 2A
                &lt;channel&gt;? also works
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def read_heater(self):
        &#34;&#34;&#34;
        Reads the 3x heater outputs with the unit (W, A or V).
        Returns a tuple. 1st element is a list with the 3 values of the heaters. 2nd element is a string with the unit
        (&#39;W&#39;, &#39;A&#39; or &#39;V&#39;).
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def disable_heater(self, output_ch: int):
        &#34;&#34;&#34;
        Disables the specified heater output. output_ch = 1, 2, 3

        Notes: &lt;channel&gt;.Off cancels any active autotuning process, turns PID feedback off, and sets the channel&#39;s
        output to zero or the lower limit.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def outputs_enable(self):
        &#34;&#34;&#34;Enables all outputs. Equivalent to press the red button twice on the front panel of the PTC10 when outputs disabled.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def outputs_disable(self):
        &#34;&#34;&#34;Disables all outputs. Equivalent to press the red button on the front panel of the PTC10 when output enabled.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def disable_all(self):
        &#34;&#34;&#34;Both disable_heater function used for all heaters AND outputs_disable.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_outputs_enable(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns a boolean corresponding to the state of the red button/light on the front panel of the PTC10.
        True means outputs enabled (red light switch on)
        False means outputs disabled (red light switch off)
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def output_limit(self, output_ch: int, low: float, high: float):
        &#34;&#34;&#34;
        Sets the min and max output and can be used to prevent the PID loop for delivering excessive power to a
        heater. The limits must be expressed in the same units that the output is expressed in. The limits must
        normally be reset when the output units are changed, since the limits are not converted to the new units.
        output_ch = 1, 2, 3
        low = float &gt;= 0
        high = float &gt; low

        Notes:
            by default the DC heater driver output is measured in watts. But can be changed to either A or V.
            &lt;channel&gt;.Units{W, A, V}
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def output_unit(self, unit: str):
        &#34;&#34;&#34;
        Sets the unit for the 3 heaters
        unit = W, A, V, or in lowercase w, a, v
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_heater_input(self, output_ch: int, input: str):
        &#34;&#34;&#34;
        Sets the sensor as input for the specified heater.
        output_ch = 1, 2, 3
        input = name of the sensor (e.g. TRP2)
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def setpoint(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Sets the temperature setpoint. The PID attemps to keep the input at this value by changing the output.
        output_ch = 1, 2, 3
        setpoint = float (°C)

        Notes:
            usage: &lt;channel&gt;.PID.Setpoint&lt;setpoint&gt;
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def get_PID(self, output_ch: int) -&gt; dict:
        &#34;&#34;&#34;
        Returns a dictionary with P, I and D parameters as float, {&#34;P&#34;: P_value, &#34;I&#34;: I_value, &#34;D&#34;: D_value}
        output_ch = 1, 2, 3
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_PID(self, input_ch: int, output_ch: int, PID: List[float]):
        &#34;&#34;&#34;
        The input must be stable before either Step or Relay tuning is started. Furthermore, the output must be greater
        than half the step height before starting relay tuning. The best time to start a step response is when the
        system is first turned on at the beginning of the day, i.e the heater is cold and its temperature stable.
        See User Manual for further details.
        input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
        output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
        PID parameter sets the three coefficients respectively in P, I and D. PID = [float, float, float]

        Notes
        PID: &lt;channel&gt;.PID.D&lt;value&gt;, &lt;channel&gt;.PID.I&lt;value&gt;, &lt;channel&gt;.PID.P&lt;value&gt;
        &lt;channel&gt;.PID.Input&lt;channel name&gt;
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def autotune_PID(self, input_ch: int, output_ch: int):
        &#34;&#34;&#34;

        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_auto(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Enables the specified output to reach the specified setpoint automatically.
        output_ch = 1, 2, 3
        setpoint = float (°C)
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_manual(self, output_ch: int, value: float):
        &#34;&#34;&#34;
        Enables the specified output manually with the specified value.
        The unit is the one currently in effect (W, A or V).
        output_ch = 1, 2, 3
        value = float &gt;= 0
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_survival(self):
        &#34;&#34;&#34;
        Sets all outputs to the min Non op temperature for TRP2, TRP3 and TRP4 as given in the Setup YAML file.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_stable(self, setpoint: float):
        &#34;&#34;&#34;
        Sets all outputs to the same temperature setpoint given as parameter.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_custom(self, outputs_dict: dict):
        &#34;&#34;&#34;
        Sets the outputs given as parameter to the corresponding temperature given as parameter.
        If an output channel is not given as parameter in the dictionary outputs_dict, this output channel will remain
        at the same state and with same setpoint as before.
        outputs_dict = {output_ch: setpoint} for example: {3: -110, 1: -106}
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def heater_sensor_error(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list with names of sensors (TRP) and heaters which cannot be read by the PTC10.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def disable_heater_error(self):
        &#34;&#34;&#34;
        Disables heaters whose PT1000 sensors are faulty.
        This function does not re-enable heater if a PT1000 is no longer faulty.
        &#34;&#34;&#34;

        raise NotImplementedError


class ptc10Simulator(ptc10Interface):
    &#34;&#34;&#34;
    The ptc10 Simulator class.
    &#34;&#34;&#34;

    def __init__(self):
        self._is_connected = True
        self.temp_operation = False

    def is_connected(self):
        return self._is_connected

    def is_simulator(self):
        return True

    def connect(self):
        self._is_connected = True

    def disconnect(self):
        self._is_connected = False

    def reconnect(self):
        self.connect()

    def info(self):
        pass

    def read_temperature(self):
        pass

    def read_heater(self):
        pass


class ptc10Controller(ptc10Interface):
    &#34;&#34;&#34;The ptc10Controller allows controlling a SRS ptc10 temperature regulation device.&#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the ptc10 Controller interface.&#34;&#34;&#34;
        self.output_mode_var = None
        self.setpoint_var = None
        self.PID = None
        self.limits = None
        setup = load_setup_from_configuration_manager()
        self.T_min_NOP = setup.gse.PTC10.T_min_NOP # TRP2, TRP3 and TRP4 min NOP (°C)

        super().__init__()

        LOGGER.debug(&#34;Initializing PTC10&#34;)

        try:
            self.temp = ptc10TelnetInterface()
            self.temp.connect(PTC10_SETTINGS.HOSTNAME)
        except ptc10Error as exc:
            LOGGER.warning(f&#34;TempError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ptc10Error(
                &#34;Couldn&#39;t establish a connection with the Temp PTC10 controller.&#34;
            ) from exc

    def connect(self):
        &#34;&#34;&#34;Connects to the Temp regulation device.

        Raises:
            DeviceNotFoundError: when the Temp regulation device is not connected.
        &#34;&#34;&#34;
        try:
            self.temp.connect(PTC10_SETTINGS.HOSTNAME)
        except ptc10Error as exc:
             LOGGER.warning(f&#34;ptc10Error caught: Couldn&#39;t establish connection ({exc})&#34;)
             raise ConnectionError(&#34;Couldn&#39;t establish a connection with the SRS PTC10 controller.&#34;) from exc

    def disconnect(self):
        try:
            self.temp.disconnect()
        except ptc10Error as exc:
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the SRS PTC10 controller.&#34;) from exc

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
            sleep(1)
        self.connect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the Temp Controller is connected.&#34;&#34;&#34;
        return self.temp.is_connected()

    def is_simulator(self):
        return False

    def info(self):
        &#34;&#34;&#34;
        Returns basic information about the device, its name, firmwre version etc.
        Returns:
            An identification string of the instrument.
        &#34;&#34;&#34;

        self.temp.write(&#34;*IDN?&#34;)
        _info = self.temp.read()
        return _info

    def alarm_status(self) -&gt; str:
        &#34;&#34;&#34;Returns the current value of the Alarm Status Register (ASR), and then clears the register.&#34;&#34;&#34;

        self.temp.write(&#34;*ASR?&#34;)
        status = self.temp.read()
        return status

    def get_names(self):
        &#34;&#34;&#34;
        Returns a tuple of 2 lists with the names of inputs (3 sensors) in the first list and the names of
        outputs (3 heaters) in the second list.
        &#34;&#34;&#34;

        self.temp.write(&#34;getOutput.names&#34;)
        NAMES = self.temp.read().split(&#34;, &#34;)

        Sensors = NAMES[3:5]
        Sensors.append(NAMES[6])

        Heaters = NAMES[:3]

        return Sensors, Heaters

    def set_name(self, old_name: str, new_name: str):
        &#34;&#34;&#34;Modifies the name of the specified channel (input or output).&#34;&#34;&#34;

        self.temp.write(f&#39;({old_name}.Name) &#34;{new_name}&#34;&#39;)

    def clear_error(self):
        &#34;&#34;&#34;
        Erases all error messages for the port over which the instruction was transmitted. Also clears all messages
        from the System.Com. Errors window regardless of which port generated them.
        &#34;&#34;&#34;

        self.temp.write(&#34;clearerrors&#34;)

    def stop(self):
        &#34;&#34;&#34;
        kill.all stops all currently running macros with the given runtime name. The runtime name is assigned with the
        &#34;name&#34; instruction and is not necessarily the same as the file name that a macro may be saved under.
        The kill.all instruction stops all currently-running macros regardless of name or which port started the macro.
        &#34;&#34;&#34;

        self.temp.write(&#34;kill.all&#34;)

    def standby(self):
        &#34;&#34;&#34;
        Puts the PTC10 into stby mode, in which the outputs are turned off, data acquisition is paused, macros are
        paused, the front panel display and system fan are shut off, and the system does not respond to remote commands.
        The PTC321&#39;s excitation currents remain on, and the chassis cooling fan may switch on occassionally.
        Press the &#34;Output Enable&#34; key to exit standby mode. There is no remote command to leave stand by mode.
        &#34;&#34;&#34;

        self.temp.write(&#34;standby&#34;)

    def reset(self):
        &#34;&#34;&#34;
        Resets the PTC10.

        The *RST instruction is equivalent to turning the instrument off and back on again, except the Power On bit of
        the Event Status Register is not set. *RST has the following effects:
        - Outputs are disabled (as if the “Output enable” button were pressed).
        - All currently-running macros are stopped, regardless of whether the macros were started by the GPIB interface,
        another I/O port, or the Program screen.
        - The instrument returns to the Select screen.
        -Partially-received instructions on all I/O ports are cleared.
        - All pending transmissions on all I/O ports are cancelled.
        - The error queues for all I/O ports are cleared.
        - The plot screen returns to showing the most recent data on autoscaled Y axes.
        - The instrument automatically triggers at the rate set with the “A/D rate” control.
        - Clears all locally-stored log data. Logs on USB devices are not affected. If data is not being logged to a
        USB storage device, the Plot screen shows no accumulated data immediately after a *RST command.
        &#34;&#34;&#34;

        self.temp.write(&#34;*RST&#34;)

    def read_temperature(self) -&gt; list:
        &#34;&#34;&#34;Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.&#34;&#34;&#34;

        Sensor_names = self.get_names()[0]
        Sensors_values = []
        for channel_name in Sensor_names:
            self.temp.write(f&#34;({channel_name}?)&#34;)
            Sensors_values.append(float(self.temp.read()))
        return Sensors_values

    def read_heater(self) -&gt; tuple:
        &#34;&#34;&#34;
        Reads the 3x heater outputs with the unit (W, A or V).
        Returns a tuple. 1st element is a list with the 3 values of the heaters. 2nd element is a string with the unit
        (&#39;W&#39;, &#39;A&#39; or &#39;V&#39;).
        &#34;&#34;&#34;

        Heater_names = self.get_names()[1]
        Heaters_values = []
        for channel_name in Heater_names:
            self.temp.write(f&#34;({channel_name}?)&#34;)
            Heaters_values.append(float(self.temp.read()))
        self.temp.write(f&#34;({Heater_names[0]}.Units?)&#34;)
        heater_unit = self.temp.read()
        return Heaters_values, heater_unit

    def disable_heater(self, output_ch: int):
        &#34;&#34;&#34;
        Disables the specified heater output. output_ch = 1, 2, 3

        Notes: &lt;channel&gt;.Off cancels any active autotuning process, turns PID feedback off, and sets the channel&#39;s
        output to zero or the lower limit.
        &#34;&#34;&#34;

        self.temp.write(f&#34;({self.get_names()[1][output_ch - 1]}.Off)&#34;)

    def outputs_enable(self):
        &#34;&#34;&#34;Enables all outputs. Equivalent to press the red button twice on the front panel of the PTC10 when outputs disabled.&#34;&#34;&#34;

        self.temp.write(&#34;outputEnable = on&#34;)

    def outputs_disable(self):
        &#34;&#34;&#34;Disables all outputs. Equivalent to press the red button on the front panel of the PTC10 when output enabled.&#34;&#34;&#34;

        self.temp.write(&#34;outputEnable = off&#34;)

    def disable_all(self):
        &#34;&#34;&#34;Both disable_heater function used for all heaters AND outputs_disable.&#34;&#34;&#34;

        for output_ch in [1,2,3]:
            self.disable_heater(output_ch)
        self.outputs_disable()

    def is_outputs_enable(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns a boolean corresponding to the state of the red button/light on the front panel of the PTC10.
        True means outputs enabled (red light switch on)
        False means outputs disabled (red light switch off)
        &#34;&#34;&#34;

        is_enable = {&#34;On&#34;: True, &#34;Off&#34;: False}
        self.temp.write(&#34;outputEnable?&#34;)
        return is_enable[self.temp.read()]

    def output_limit(self, output_ch: int, low: float, high: float):
        &#34;&#34;&#34;
        Sets the min and max output and can be used to prevent the PID loop for delivering excessive power to a
        heater. The limits must be expressed in the same units that the output is expressed in. The limits must
        normally be reset when the output units are changed, since the limits are not converted to the new units.
        output_ch = 1, 2, 3
        low = float &gt;= 0
        high = float &gt; low

        Notes:
            by default the DC heater driver output is measured in watts. But can be changed to either A or V.
            &lt;channel&gt;.Units{W, A, V}
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#34;({heater}.Low lmt) {low}&#34;)
        self.temp.write(f&#34;({heater}.Hi lmt) {high}&#34;)

    def output_unit(self, unit: str):
        &#34;&#34;&#34;
        Sets the unit for the 3 heaters
        unit = W, A, V, or in lowercase w, a, v
        &#34;&#34;&#34;

        unit = unit.upper()
        for output_ch in [1, 2, 3]:
            heater = self.get_names()[1][output_ch - 1]
            self.temp.write(f&#39;({heater}.Units) &#34;{unit}&#34;&#39;)

    def set_heater_input(self, output_ch: int, input: str):
        &#34;&#34;&#34;
        Sets the sensor as input for the specified heater.
        output_ch = 1, 2, 3
        input = name of the sensor (e.g. TRP2)
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#39;({heater}.PID.Input) &#34;{input}&#34;&#39;)

    def setpoint(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Sets the temperature setpoint. The PID attemps to keep the input at this value by changing the output.
        output_ch = 1, 2, 3
        setpoint = float (°C)

        Notes:
            usage: &lt;channel&gt;.PID.Setpoint&lt;setpoint&gt;
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#34;({heater}.PID.Setpoint) {setpoint}&#34;)

    def get_PID(self, output_ch: int) -&gt; dict:
        &#34;&#34;&#34;
        Returns a dictionary with P, I and D parameters as float, {&#34;P&#34;: P_value, &#34;I&#34;: I_value, &#34;D&#34;: D_value}
        output_ch = 1, 2, 3
        &#34;&#34;&#34;
        heater = self.get_names()[1][output_ch - 1]

        self.temp.write(f&#34;({heater}.PID.P?)&#34;)
        P = float(self.temp.read())
        self.temp.write(f&#34;({heater}.PID.I?)&#34;)
        I = float(self.temp.read())
        self.temp.write(f&#34;({heater}.PID.D?)&#34;)
        D = float(self.temp.read())

        return {&#34;P&#34;: P, &#34;I&#34;: I, &#34;D&#34;: D}

    def set_PID(self, input_ch: int, output_ch: int, PID: List[float]):
        &#34;&#34;&#34;
        The input must be stable before either Step or Relay tuning is started. Furthermore, the output must be greater
        than half the step height before starting relay tuning. The best time to start a step response is when the
        system is first turned on at the beginning of the day, i.e the heater is cold and its temperature stable.
        See User Manual for further details.
        input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
        output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
        PID parameter sets the three coefficients respectively in P, I and D. PID = [float, float, float]

        Notes
        PID: &lt;channel&gt;.PID.D&lt;value&gt;, &lt;channel&gt;.PID.I&lt;value&gt;, &lt;channel&gt;.PID.P&lt;value&gt;
        &lt;channel&gt;.PID.Input&lt;channel name&gt;
        &#34;&#34;&#34;

        sensor = self.get_names()[0][input_ch - 1]
        heater = self.get_names()[1][output_ch - 1]

        self.temp.write(f&#39;({heater}.PID.Input) &#34;{sensor}&#34;&#39;)
        PID_dict = {&#34;P&#34;: PID[0], &#34;I&#34;: PID[1], &#34;D&#34;: PID[2]}
        for corrector in PID_dict:
            self.temp.write(f&#34;({heater}.PID.{corrector}) {PID_dict[corrector]}&#34;)

    def autotune_PID(self, input_ch: int, output_ch: int):
        &#34;&#34;&#34;
        Configures the PID with autotune.
        User Manual p.50 &#34;If the system has never been tuned, start with the feedback turned off and the heater at ambient temperature.
        If the system has been tuned before, it’s better to wait for the temperature to stabilize at the setpoint.
        In either case, the key to successful autotuning is to start with a stable temperature.&#34;
        Prints message if failure to autotune PID. Old values for P, I and D are retained.
        input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
        output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
        &#34;&#34;&#34;

        sensor = self.get_names()[0][input_ch - 1]
        heater = self.get_names()[1][output_ch - 1]
        output_enable_state = self.is_outputs_enable()
        self.temp.write(f&#34;({heater}.PID.Mode?)&#34;)
        PID_mode = self.temp.read()
        self.temp.write(f&#34;({heater}.Value?)&#34;)
        heater_initial_value = self.temp.read()

        PID_initial = self.get_PID(output_ch)

        self.temp.write(f&#34;({heater}.PID.Mode) off&#34;)
        self.temp.write(f&#39;({heater}.PID.Input) &#34;{sensor}&#34;&#39;)
        if not output_enable_state:
            self.temp.write(&#34;outputEnable = on&#34;)
        self.temp.write(f&#34;({heater}.Tune.Mode) Auto&#34;)

        self.temp.write(f&#34;({heater}.Tune.mode?)&#34;)
        Tune_mode = self.temp.read()
        while Tune_mode != &#34;Off&#34;:
            self.temp.write(f&#34;({heater}.Tune.mode?)&#34;)
            Tune_mode = self.temp.read()
        self.temp.write(f&#34;({heater}.PID.Mode) {PID_mode}&#34;)
        if PID_mode == &#34;Off&#34;:
            self.temp.write(f&#34;({heater}.Value) {heater_initial_value}&#34;)
        if not output_enable_state:
            self.temp.write(&#34;outputEnable = off&#34;)

        #TODO: investigate to find a better way to know if autotune was successful or not (maybe with status function?)
        PID_final = self.get_PID(output_ch)
        if PID_initial == PID_final:
            print(f&#34;Failure to autotune PID. Old values for P, I and D are retained.\nP = {PID_final[&#39;P&#39;]}\nI = {PID_final[&#39;I&#39;]}\nD = {PID_final[&#39;D&#39;]}\n&#34;
                  &#34;The key to successful autotuning is to start with a stable temperature.&#34;)
        else:
            print(f&#34;Successful PID autotuning!!\nP = {PID_final[&#39;P&#39;]}\nI = {PID_final[&#39;I&#39;]}\nD = {PID_final[&#39;D&#39;]}&#34;)

    def set_auto(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Enables the specified output to reach the specified setpoint automatically.
        output_ch = 1, 2, 3
        setpoint = float (°C)
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#34;({heater}.PID.Setpoint) {setpoint}&#34;)
        self.temp.write(f&#34;({heater}.PID.mode) on&#34;)

        if not self.is_outputs_enable():
            self.temp.write(&#34;outputEnable = on&#34;)

    def set_manual(self, output_ch: int, value: float):
        &#34;&#34;&#34;
        Enables the specified output manually with the specified value.
        The unit is the one currently in effect (W, A or V).
        output_ch = 1, 2, 3
        value = float &gt;= 0
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        output_enable_state = self.is_outputs_enable()
        if not output_enable_state:
            self.temp.write(&#34;outputEnable = on&#34;)

        self.temp.write(f&#34;({heater}.PID.mode) off&#34;)
        self.temp.write(f&#34;({heater}.Value) {value}&#34;)
        response = self.temp.read()
        if response != &#34;&#34;:
            print(f&#34;{response}. The old value is retained.&#34;)
            if not output_enable_state:
                self.temp.write(&#34;outputEnable = off&#34;)

    def set_survival(self):
        &#34;&#34;&#34;
        Sets all outputs to the min Non op temperature for TRP2, TRP3 and TRP4 as given in the Setup YAML file.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        for output_ch in [1,2,3]:
            self.set_auto(output_ch, self.T_min_NOP)

    def set_stable(self, setpoint: float):
        &#34;&#34;&#34;
        Sets all outputs to the same temperature setpoint given as parameter.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        for output_ch in [1, 2, 3]:
            self.set_auto(output_ch, setpoint)

    def set_custom(self, outputs_dict: dict):
        &#34;&#34;&#34;
        Sets the outputs given as parameter to the corresponding temperature given as parameter.
        If an output channel is not given as parameter in the dictionary outputs_dict, this output channel will remain
        at the same state and with same setpoint as before.
        outputs_dict = {output_ch: setpoint} for example: {3: -110, 1: -106}
        &#34;&#34;&#34;

        channels =  [1,2,3]
        for output_ch in channels:
            if output_ch in outputs_dict:
                self.set_auto(output_ch, outputs_dict[output_ch])

    def heater_sensor_error(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list with names of sensors (TRP) and heaters which cannot be read by the PTC10.
        &#34;&#34;&#34;

        INPUTS_OUTPUTS = self.read_temperature() + self.read_heater()[0]
        NAMES = self.get_names()
        NAMES = NAMES[0] + NAMES[1]
        ERROR = []
        for i in range(len(INPUTS_OUTPUTS)):
            in_out = INPUTS_OUTPUTS[i]
            if in_out != in_out: # This line tests if in_out is NaN
                ERROR.append(NAMES[i])
        return ERROR

    def disable_heater_error(self):
        &#34;&#34;&#34;
        Disables heaters whose PT1000 sensors are faulty.
        This function does not re-enable heater if a PT1000 is no longer faulty.
        &#34;&#34;&#34;

        list_error = self.heater_sensor_error()
        Sensor_names = self.get_names()[0]
        for i in [&#34;TRP2&#34;, &#34;TRP3&#34;, &#34;TRP4&#34;]:
            if i in list_error[:3]:
                self.disable_heater(Sensor_names.index(i) + 1)

    def get_time(self) -&gt; str:
        smhdmy = self.temp.trans(&#34;Systemtime.smh?&#34;)
        timestamp = format_datetime(datetime.strptime(smhdmy + &#34; +0000&#34;, &#39;%S %M %H %d %m %Y %z&#39;))
        return timestamp


    def update_time(self):
        &#34;&#34;&#34;Updates the PTC10 date and time in UTC from the server&#39;s time which is ntp synchronised.&#34;&#34;&#34;
        self.temp.write(&#34;systemtime.dmy &#34; + strftime(&#34;%d/%m/%Y&#34;, gmtime()))
        self.temp.write(&#34;systemtime.hms &#34; + strftime(&#34;%H:%M:%S&#34;, gmtime()))

class ptc10Proxy(Proxy, ptc10Interface):
    &#34;&#34;&#34;The ptc10Proxy class is used to connect to the control server and send commands to
    the SRS PTC10 device remotely.&#34;&#34;&#34;
    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
        timeout=CTRL_SETTINGS.TIMEOUT * 1000 # timeout in ms
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.tempcontrol.srs.ptc10.load_setup_from_configuration_manager"><code class="name flex">
<span>def <span class="ident">load_setup_from_configuration_manager</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a Setup YAML file from the Configuration Manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_setup_from_configuration_manager():
    &#34;&#34;&#34;Loads a Setup YAML file from the Configuration Manager.&#34;&#34;&#34;
    with ConfigurationManagerProxy() as cm:
        setup = cm.get_setup()

    return setup</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Controller"><code class="flex name class">
<span>class <span class="ident">ptc10Controller</span></span>
</code></dt>
<dd>
<div class="desc"><p>The ptc10Controller allows controlling a SRS ptc10 temperature regulation device.</p>
<p>Initialize the ptc10 Controller interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ptc10Controller(ptc10Interface):
    &#34;&#34;&#34;The ptc10Controller allows controlling a SRS ptc10 temperature regulation device.&#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initialize the ptc10 Controller interface.&#34;&#34;&#34;
        self.output_mode_var = None
        self.setpoint_var = None
        self.PID = None
        self.limits = None
        setup = load_setup_from_configuration_manager()
        self.T_min_NOP = setup.gse.PTC10.T_min_NOP # TRP2, TRP3 and TRP4 min NOP (°C)

        super().__init__()

        LOGGER.debug(&#34;Initializing PTC10&#34;)

        try:
            self.temp = ptc10TelnetInterface()
            self.temp.connect(PTC10_SETTINGS.HOSTNAME)
        except ptc10Error as exc:
            LOGGER.warning(f&#34;TempError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ptc10Error(
                &#34;Couldn&#39;t establish a connection with the Temp PTC10 controller.&#34;
            ) from exc

    def connect(self):
        &#34;&#34;&#34;Connects to the Temp regulation device.

        Raises:
            DeviceNotFoundError: when the Temp regulation device is not connected.
        &#34;&#34;&#34;
        try:
            self.temp.connect(PTC10_SETTINGS.HOSTNAME)
        except ptc10Error as exc:
             LOGGER.warning(f&#34;ptc10Error caught: Couldn&#39;t establish connection ({exc})&#34;)
             raise ConnectionError(&#34;Couldn&#39;t establish a connection with the SRS PTC10 controller.&#34;) from exc

    def disconnect(self):
        try:
            self.temp.disconnect()
        except ptc10Error as exc:
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the SRS PTC10 controller.&#34;) from exc

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
            sleep(1)
        self.connect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the Temp Controller is connected.&#34;&#34;&#34;
        return self.temp.is_connected()

    def is_simulator(self):
        return False

    def info(self):
        &#34;&#34;&#34;
        Returns basic information about the device, its name, firmwre version etc.
        Returns:
            An identification string of the instrument.
        &#34;&#34;&#34;

        self.temp.write(&#34;*IDN?&#34;)
        _info = self.temp.read()
        return _info

    def alarm_status(self) -&gt; str:
        &#34;&#34;&#34;Returns the current value of the Alarm Status Register (ASR), and then clears the register.&#34;&#34;&#34;

        self.temp.write(&#34;*ASR?&#34;)
        status = self.temp.read()
        return status

    def get_names(self):
        &#34;&#34;&#34;
        Returns a tuple of 2 lists with the names of inputs (3 sensors) in the first list and the names of
        outputs (3 heaters) in the second list.
        &#34;&#34;&#34;

        self.temp.write(&#34;getOutput.names&#34;)
        NAMES = self.temp.read().split(&#34;, &#34;)

        Sensors = NAMES[3:5]
        Sensors.append(NAMES[6])

        Heaters = NAMES[:3]

        return Sensors, Heaters

    def set_name(self, old_name: str, new_name: str):
        &#34;&#34;&#34;Modifies the name of the specified channel (input or output).&#34;&#34;&#34;

        self.temp.write(f&#39;({old_name}.Name) &#34;{new_name}&#34;&#39;)

    def clear_error(self):
        &#34;&#34;&#34;
        Erases all error messages for the port over which the instruction was transmitted. Also clears all messages
        from the System.Com. Errors window regardless of which port generated them.
        &#34;&#34;&#34;

        self.temp.write(&#34;clearerrors&#34;)

    def stop(self):
        &#34;&#34;&#34;
        kill.all stops all currently running macros with the given runtime name. The runtime name is assigned with the
        &#34;name&#34; instruction and is not necessarily the same as the file name that a macro may be saved under.
        The kill.all instruction stops all currently-running macros regardless of name or which port started the macro.
        &#34;&#34;&#34;

        self.temp.write(&#34;kill.all&#34;)

    def standby(self):
        &#34;&#34;&#34;
        Puts the PTC10 into stby mode, in which the outputs are turned off, data acquisition is paused, macros are
        paused, the front panel display and system fan are shut off, and the system does not respond to remote commands.
        The PTC321&#39;s excitation currents remain on, and the chassis cooling fan may switch on occassionally.
        Press the &#34;Output Enable&#34; key to exit standby mode. There is no remote command to leave stand by mode.
        &#34;&#34;&#34;

        self.temp.write(&#34;standby&#34;)

    def reset(self):
        &#34;&#34;&#34;
        Resets the PTC10.

        The *RST instruction is equivalent to turning the instrument off and back on again, except the Power On bit of
        the Event Status Register is not set. *RST has the following effects:
        - Outputs are disabled (as if the “Output enable” button were pressed).
        - All currently-running macros are stopped, regardless of whether the macros were started by the GPIB interface,
        another I/O port, or the Program screen.
        - The instrument returns to the Select screen.
        -Partially-received instructions on all I/O ports are cleared.
        - All pending transmissions on all I/O ports are cancelled.
        - The error queues for all I/O ports are cleared.
        - The plot screen returns to showing the most recent data on autoscaled Y axes.
        - The instrument automatically triggers at the rate set with the “A/D rate” control.
        - Clears all locally-stored log data. Logs on USB devices are not affected. If data is not being logged to a
        USB storage device, the Plot screen shows no accumulated data immediately after a *RST command.
        &#34;&#34;&#34;

        self.temp.write(&#34;*RST&#34;)

    def read_temperature(self) -&gt; list:
        &#34;&#34;&#34;Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.&#34;&#34;&#34;

        Sensor_names = self.get_names()[0]
        Sensors_values = []
        for channel_name in Sensor_names:
            self.temp.write(f&#34;({channel_name}?)&#34;)
            Sensors_values.append(float(self.temp.read()))
        return Sensors_values

    def read_heater(self) -&gt; tuple:
        &#34;&#34;&#34;
        Reads the 3x heater outputs with the unit (W, A or V).
        Returns a tuple. 1st element is a list with the 3 values of the heaters. 2nd element is a string with the unit
        (&#39;W&#39;, &#39;A&#39; or &#39;V&#39;).
        &#34;&#34;&#34;

        Heater_names = self.get_names()[1]
        Heaters_values = []
        for channel_name in Heater_names:
            self.temp.write(f&#34;({channel_name}?)&#34;)
            Heaters_values.append(float(self.temp.read()))
        self.temp.write(f&#34;({Heater_names[0]}.Units?)&#34;)
        heater_unit = self.temp.read()
        return Heaters_values, heater_unit

    def disable_heater(self, output_ch: int):
        &#34;&#34;&#34;
        Disables the specified heater output. output_ch = 1, 2, 3

        Notes: &lt;channel&gt;.Off cancels any active autotuning process, turns PID feedback off, and sets the channel&#39;s
        output to zero or the lower limit.
        &#34;&#34;&#34;

        self.temp.write(f&#34;({self.get_names()[1][output_ch - 1]}.Off)&#34;)

    def outputs_enable(self):
        &#34;&#34;&#34;Enables all outputs. Equivalent to press the red button twice on the front panel of the PTC10 when outputs disabled.&#34;&#34;&#34;

        self.temp.write(&#34;outputEnable = on&#34;)

    def outputs_disable(self):
        &#34;&#34;&#34;Disables all outputs. Equivalent to press the red button on the front panel of the PTC10 when output enabled.&#34;&#34;&#34;

        self.temp.write(&#34;outputEnable = off&#34;)

    def disable_all(self):
        &#34;&#34;&#34;Both disable_heater function used for all heaters AND outputs_disable.&#34;&#34;&#34;

        for output_ch in [1,2,3]:
            self.disable_heater(output_ch)
        self.outputs_disable()

    def is_outputs_enable(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns a boolean corresponding to the state of the red button/light on the front panel of the PTC10.
        True means outputs enabled (red light switch on)
        False means outputs disabled (red light switch off)
        &#34;&#34;&#34;

        is_enable = {&#34;On&#34;: True, &#34;Off&#34;: False}
        self.temp.write(&#34;outputEnable?&#34;)
        return is_enable[self.temp.read()]

    def output_limit(self, output_ch: int, low: float, high: float):
        &#34;&#34;&#34;
        Sets the min and max output and can be used to prevent the PID loop for delivering excessive power to a
        heater. The limits must be expressed in the same units that the output is expressed in. The limits must
        normally be reset when the output units are changed, since the limits are not converted to the new units.
        output_ch = 1, 2, 3
        low = float &gt;= 0
        high = float &gt; low

        Notes:
            by default the DC heater driver output is measured in watts. But can be changed to either A or V.
            &lt;channel&gt;.Units{W, A, V}
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#34;({heater}.Low lmt) {low}&#34;)
        self.temp.write(f&#34;({heater}.Hi lmt) {high}&#34;)

    def output_unit(self, unit: str):
        &#34;&#34;&#34;
        Sets the unit for the 3 heaters
        unit = W, A, V, or in lowercase w, a, v
        &#34;&#34;&#34;

        unit = unit.upper()
        for output_ch in [1, 2, 3]:
            heater = self.get_names()[1][output_ch - 1]
            self.temp.write(f&#39;({heater}.Units) &#34;{unit}&#34;&#39;)

    def set_heater_input(self, output_ch: int, input: str):
        &#34;&#34;&#34;
        Sets the sensor as input for the specified heater.
        output_ch = 1, 2, 3
        input = name of the sensor (e.g. TRP2)
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#39;({heater}.PID.Input) &#34;{input}&#34;&#39;)

    def setpoint(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Sets the temperature setpoint. The PID attemps to keep the input at this value by changing the output.
        output_ch = 1, 2, 3
        setpoint = float (°C)

        Notes:
            usage: &lt;channel&gt;.PID.Setpoint&lt;setpoint&gt;
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#34;({heater}.PID.Setpoint) {setpoint}&#34;)

    def get_PID(self, output_ch: int) -&gt; dict:
        &#34;&#34;&#34;
        Returns a dictionary with P, I and D parameters as float, {&#34;P&#34;: P_value, &#34;I&#34;: I_value, &#34;D&#34;: D_value}
        output_ch = 1, 2, 3
        &#34;&#34;&#34;
        heater = self.get_names()[1][output_ch - 1]

        self.temp.write(f&#34;({heater}.PID.P?)&#34;)
        P = float(self.temp.read())
        self.temp.write(f&#34;({heater}.PID.I?)&#34;)
        I = float(self.temp.read())
        self.temp.write(f&#34;({heater}.PID.D?)&#34;)
        D = float(self.temp.read())

        return {&#34;P&#34;: P, &#34;I&#34;: I, &#34;D&#34;: D}

    def set_PID(self, input_ch: int, output_ch: int, PID: List[float]):
        &#34;&#34;&#34;
        The input must be stable before either Step or Relay tuning is started. Furthermore, the output must be greater
        than half the step height before starting relay tuning. The best time to start a step response is when the
        system is first turned on at the beginning of the day, i.e the heater is cold and its temperature stable.
        See User Manual for further details.
        input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
        output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
        PID parameter sets the three coefficients respectively in P, I and D. PID = [float, float, float]

        Notes
        PID: &lt;channel&gt;.PID.D&lt;value&gt;, &lt;channel&gt;.PID.I&lt;value&gt;, &lt;channel&gt;.PID.P&lt;value&gt;
        &lt;channel&gt;.PID.Input&lt;channel name&gt;
        &#34;&#34;&#34;

        sensor = self.get_names()[0][input_ch - 1]
        heater = self.get_names()[1][output_ch - 1]

        self.temp.write(f&#39;({heater}.PID.Input) &#34;{sensor}&#34;&#39;)
        PID_dict = {&#34;P&#34;: PID[0], &#34;I&#34;: PID[1], &#34;D&#34;: PID[2]}
        for corrector in PID_dict:
            self.temp.write(f&#34;({heater}.PID.{corrector}) {PID_dict[corrector]}&#34;)

    def autotune_PID(self, input_ch: int, output_ch: int):
        &#34;&#34;&#34;
        Configures the PID with autotune.
        User Manual p.50 &#34;If the system has never been tuned, start with the feedback turned off and the heater at ambient temperature.
        If the system has been tuned before, it’s better to wait for the temperature to stabilize at the setpoint.
        In either case, the key to successful autotuning is to start with a stable temperature.&#34;
        Prints message if failure to autotune PID. Old values for P, I and D are retained.
        input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
        output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
        &#34;&#34;&#34;

        sensor = self.get_names()[0][input_ch - 1]
        heater = self.get_names()[1][output_ch - 1]
        output_enable_state = self.is_outputs_enable()
        self.temp.write(f&#34;({heater}.PID.Mode?)&#34;)
        PID_mode = self.temp.read()
        self.temp.write(f&#34;({heater}.Value?)&#34;)
        heater_initial_value = self.temp.read()

        PID_initial = self.get_PID(output_ch)

        self.temp.write(f&#34;({heater}.PID.Mode) off&#34;)
        self.temp.write(f&#39;({heater}.PID.Input) &#34;{sensor}&#34;&#39;)
        if not output_enable_state:
            self.temp.write(&#34;outputEnable = on&#34;)
        self.temp.write(f&#34;({heater}.Tune.Mode) Auto&#34;)

        self.temp.write(f&#34;({heater}.Tune.mode?)&#34;)
        Tune_mode = self.temp.read()
        while Tune_mode != &#34;Off&#34;:
            self.temp.write(f&#34;({heater}.Tune.mode?)&#34;)
            Tune_mode = self.temp.read()
        self.temp.write(f&#34;({heater}.PID.Mode) {PID_mode}&#34;)
        if PID_mode == &#34;Off&#34;:
            self.temp.write(f&#34;({heater}.Value) {heater_initial_value}&#34;)
        if not output_enable_state:
            self.temp.write(&#34;outputEnable = off&#34;)

        #TODO: investigate to find a better way to know if autotune was successful or not (maybe with status function?)
        PID_final = self.get_PID(output_ch)
        if PID_initial == PID_final:
            print(f&#34;Failure to autotune PID. Old values for P, I and D are retained.\nP = {PID_final[&#39;P&#39;]}\nI = {PID_final[&#39;I&#39;]}\nD = {PID_final[&#39;D&#39;]}\n&#34;
                  &#34;The key to successful autotuning is to start with a stable temperature.&#34;)
        else:
            print(f&#34;Successful PID autotuning!!\nP = {PID_final[&#39;P&#39;]}\nI = {PID_final[&#39;I&#39;]}\nD = {PID_final[&#39;D&#39;]}&#34;)

    def set_auto(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Enables the specified output to reach the specified setpoint automatically.
        output_ch = 1, 2, 3
        setpoint = float (°C)
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        self.temp.write(f&#34;({heater}.PID.Setpoint) {setpoint}&#34;)
        self.temp.write(f&#34;({heater}.PID.mode) on&#34;)

        if not self.is_outputs_enable():
            self.temp.write(&#34;outputEnable = on&#34;)

    def set_manual(self, output_ch: int, value: float):
        &#34;&#34;&#34;
        Enables the specified output manually with the specified value.
        The unit is the one currently in effect (W, A or V).
        output_ch = 1, 2, 3
        value = float &gt;= 0
        &#34;&#34;&#34;

        heater = self.get_names()[1][output_ch - 1]
        output_enable_state = self.is_outputs_enable()
        if not output_enable_state:
            self.temp.write(&#34;outputEnable = on&#34;)

        self.temp.write(f&#34;({heater}.PID.mode) off&#34;)
        self.temp.write(f&#34;({heater}.Value) {value}&#34;)
        response = self.temp.read()
        if response != &#34;&#34;:
            print(f&#34;{response}. The old value is retained.&#34;)
            if not output_enable_state:
                self.temp.write(&#34;outputEnable = off&#34;)

    def set_survival(self):
        &#34;&#34;&#34;
        Sets all outputs to the min Non op temperature for TRP2, TRP3 and TRP4 as given in the Setup YAML file.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        for output_ch in [1,2,3]:
            self.set_auto(output_ch, self.T_min_NOP)

    def set_stable(self, setpoint: float):
        &#34;&#34;&#34;
        Sets all outputs to the same temperature setpoint given as parameter.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        for output_ch in [1, 2, 3]:
            self.set_auto(output_ch, setpoint)

    def set_custom(self, outputs_dict: dict):
        &#34;&#34;&#34;
        Sets the outputs given as parameter to the corresponding temperature given as parameter.
        If an output channel is not given as parameter in the dictionary outputs_dict, this output channel will remain
        at the same state and with same setpoint as before.
        outputs_dict = {output_ch: setpoint} for example: {3: -110, 1: -106}
        &#34;&#34;&#34;

        channels =  [1,2,3]
        for output_ch in channels:
            if output_ch in outputs_dict:
                self.set_auto(output_ch, outputs_dict[output_ch])

    def heater_sensor_error(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list with names of sensors (TRP) and heaters which cannot be read by the PTC10.
        &#34;&#34;&#34;

        INPUTS_OUTPUTS = self.read_temperature() + self.read_heater()[0]
        NAMES = self.get_names()
        NAMES = NAMES[0] + NAMES[1]
        ERROR = []
        for i in range(len(INPUTS_OUTPUTS)):
            in_out = INPUTS_OUTPUTS[i]
            if in_out != in_out: # This line tests if in_out is NaN
                ERROR.append(NAMES[i])
        return ERROR

    def disable_heater_error(self):
        &#34;&#34;&#34;
        Disables heaters whose PT1000 sensors are faulty.
        This function does not re-enable heater if a PT1000 is no longer faulty.
        &#34;&#34;&#34;

        list_error = self.heater_sensor_error()
        Sensor_names = self.get_names()[0]
        for i in [&#34;TRP2&#34;, &#34;TRP3&#34;, &#34;TRP4&#34;]:
            if i in list_error[:3]:
                self.disable_heater(Sensor_names.index(i) + 1)

    def get_time(self) -&gt; str:
        smhdmy = self.temp.trans(&#34;Systemtime.smh?&#34;)
        timestamp = format_datetime(datetime.strptime(smhdmy + &#34; +0000&#34;, &#39;%S %M %H %d %m %Y %z&#39;))
        return timestamp


    def update_time(self):
        &#34;&#34;&#34;Updates the PTC10 date and time in UTC from the server&#39;s time which is ntp synchronised.&#34;&#34;&#34;
        self.temp.write(&#34;systemtime.dmy &#34; + strftime(&#34;%d/%m/%Y&#34;, gmtime()))
        self.temp.write(&#34;systemtime.hms &#34; + strftime(&#34;%H:%M:%S&#34;, gmtime()))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Controller.autotune_PID"><code class="name flex">
<span>def <span class="ident">autotune_PID</span></span>(<span>self, input_ch: int, output_ch: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the PID with autotune.
User Manual p.50 "If the system has never been tuned, start with the feedback turned off and the heater at ambient temperature.
If the system has been tuned before, it’s better to wait for the temperature to stabilize at the setpoint.
In either case, the key to successful autotuning is to start with a stable temperature."
Prints message if failure to autotune PID. Old values for P, I and D are retained.
input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
output_ch parameter sets the PID output channel. output_ch = 1, 2, 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autotune_PID(self, input_ch: int, output_ch: int):
    &#34;&#34;&#34;
    Configures the PID with autotune.
    User Manual p.50 &#34;If the system has never been tuned, start with the feedback turned off and the heater at ambient temperature.
    If the system has been tuned before, it’s better to wait for the temperature to stabilize at the setpoint.
    In either case, the key to successful autotuning is to start with a stable temperature.&#34;
    Prints message if failure to autotune PID. Old values for P, I and D are retained.
    input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
    output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
    &#34;&#34;&#34;

    sensor = self.get_names()[0][input_ch - 1]
    heater = self.get_names()[1][output_ch - 1]
    output_enable_state = self.is_outputs_enable()
    self.temp.write(f&#34;({heater}.PID.Mode?)&#34;)
    PID_mode = self.temp.read()
    self.temp.write(f&#34;({heater}.Value?)&#34;)
    heater_initial_value = self.temp.read()

    PID_initial = self.get_PID(output_ch)

    self.temp.write(f&#34;({heater}.PID.Mode) off&#34;)
    self.temp.write(f&#39;({heater}.PID.Input) &#34;{sensor}&#34;&#39;)
    if not output_enable_state:
        self.temp.write(&#34;outputEnable = on&#34;)
    self.temp.write(f&#34;({heater}.Tune.Mode) Auto&#34;)

    self.temp.write(f&#34;({heater}.Tune.mode?)&#34;)
    Tune_mode = self.temp.read()
    while Tune_mode != &#34;Off&#34;:
        self.temp.write(f&#34;({heater}.Tune.mode?)&#34;)
        Tune_mode = self.temp.read()
    self.temp.write(f&#34;({heater}.PID.Mode) {PID_mode}&#34;)
    if PID_mode == &#34;Off&#34;:
        self.temp.write(f&#34;({heater}.Value) {heater_initial_value}&#34;)
    if not output_enable_state:
        self.temp.write(&#34;outputEnable = off&#34;)

    #TODO: investigate to find a better way to know if autotune was successful or not (maybe with status function?)
    PID_final = self.get_PID(output_ch)
    if PID_initial == PID_final:
        print(f&#34;Failure to autotune PID. Old values for P, I and D are retained.\nP = {PID_final[&#39;P&#39;]}\nI = {PID_final[&#39;I&#39;]}\nD = {PID_final[&#39;D&#39;]}\n&#34;
              &#34;The key to successful autotuning is to start with a stable temperature.&#34;)
    else:
        print(f&#34;Successful PID autotuning!!\nP = {PID_final[&#39;P&#39;]}\nI = {PID_final[&#39;I&#39;]}\nD = {PID_final[&#39;D&#39;]}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Controller.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self) -&gt; str:
    smhdmy = self.temp.trans(&#34;Systemtime.smh?&#34;)
    timestamp = format_datetime(datetime.strptime(smhdmy + &#34; +0000&#34;, &#39;%S %M %H %d %m %Y %z&#39;))
    return timestamp</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Controller.read_temperature"><code class="name flex">
<span>def <span class="ident">read_temperature</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_temperature(self) -&gt; list:
    &#34;&#34;&#34;Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.&#34;&#34;&#34;

    Sensor_names = self.get_names()[0]
    Sensors_values = []
    for channel_name in Sensor_names:
        self.temp.write(f&#34;({channel_name}?)&#34;)
        Sensors_values.append(float(self.temp.read()))
    return Sensors_values</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Controller.update_time"><code class="name flex">
<span>def <span class="ident">update_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the PTC10 date and time in UTC from the server's time which is ntp synchronised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_time(self):
    &#34;&#34;&#34;Updates the PTC10 date and time in UTC from the server&#39;s time which is ntp synchronised.&#34;&#34;&#34;
    self.temp.write(&#34;systemtime.dmy &#34; + strftime(&#34;%d/%m/%Y&#34;, gmtime()))
    self.temp.write(&#34;systemtime.hms &#34; + strftime(&#34;%H:%M:%S&#34;, gmtime()))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status">alarm_status</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.connect" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all">disable_all</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater">disable_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error">disable_heater_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID">get_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_names" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_names">get_names</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error">heater_sensor_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.info" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable">is_outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit">output_limit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit">output_unit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable">outputs_disable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable">outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater">read_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reset" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID">set_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto">set_auto</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom">set_custom</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input">set_heater_input</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual">set_manual</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_name" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_name">set_name</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable">set_stable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival">set_survival</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint">setpoint</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.standby" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.standby">standby</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.stop" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface"><code class="flex name class">
<span>class <span class="ident">ptc10Interface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Temp regulation SRS PTC10 Controller, Simulator and Proxy..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ptc10Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Temp regulation SRS PTC10 Controller, Simulator and Proxy..
    &#34;&#34;&#34;

    @dynamic_interface
    def connect(self):
        &#34;&#34;&#34;Connects to the Temp regulation device.

        Raises:
            DeviceNotFoundError: when the Temp regulation device is not connected.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def disconnect(self):
        raise NotImplementedError

    @dynamic_interface
    def reconnect(self):
        raise NotImplementedError

    @dynamic_interface
    def is_connected(self):
        &#34;&#34;&#34;Check if the Temp Controller is connected.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_simulator(self):
        raise NotImplementedError

    @dynamic_interface
    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Returns basic information about the device, its name, firmwre version etc.
        Returns:
            An identification string of the instrument.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def alarm_status(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the current value of the Alarm Status Register (ASR), and then clears the register.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_names(self):
        &#34;&#34;&#34;
        Returns a tuple of 2 lists with the names of inputs (3 sensors) in the first list and the names of
        outputs (3 heaters) in the second list.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_name(self, old_name: str, new_name: str):
        &#34;&#34;&#34;Modifies the name of the specified channel (input or output).&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def clear_error(self):
        &#34;&#34;&#34;
        Erases all error messages for the port over which the instruction was transmitted. Also clears all messages
        from the System.Com. Errors window regardless of which port generated them.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def stop(self):
        &#34;&#34;&#34;
        kill.all stops all currently running macros with the given runtime name. The runtime name is assigned with the
        &#34;name&#34; instruction and is not necessarily the same as the file name that a macro may be saved under.
        The kill.all instruction stops all currently-running macros regardless of name or which port started the macro.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def standby(self):
        &#34;&#34;&#34;
        Puts the PTC10 into stby mode, in which the outputs are turned off, data acquisition is paused, macros are
        paused, the front panel display and system fan are shut off, and the system does not respond to remote commands.
        The PTC321&#39;s excitation currents remain on, and the chassis cooling fan may switch on occassionally.
        Press the &#34;Output Enable&#34; key to exit standby mode. There is no remote command to leave stand by mode.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;,
        cmd_string=&#34;*RST&#34;,
        process_cmd_string=add_lf,
    )
    def reset(self):
        &#34;&#34;&#34;
        Resets the PTC10.

        The *RST instruction is equivalent to turning the instrument off and back on again, except the Power On bit of
        the Event Status Register is not set. *RST has the following effects:
        - Outputs are disabled (as if the “Output enable” button were pressed).
        - All currently-running macros are stopped, regardless of whether the macros were started by the GPIB interface,
        another I/O port, or the Program screen.
        - The instrument returns to the Select screen.
        -Partially-received instructions on all I/O ports are cleared.
        - All pending transmissions on all I/O ports are cancelled.
        - The error queues for all I/O ports are cleared.
        - The plot screen returns to showing the most recent data on autoscaled Y axes.
        - The instrument automatically triggers at the rate set with the “A/D rate” control.
        - Clears all locally-stored log data. Logs on USB devices are not affected. If data is not being logged to a
        USB storage device, the Plot screen shows no accumulated data immediately after a *RST command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def read_temperature(self):
        &#34;&#34;&#34;
        Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.

        Notes: &lt;channel&gt;.value? returns the current value of the channel. Ex: 2A.value? queries the output of channel 2A
                &lt;channel&gt;? also works
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def read_heater(self):
        &#34;&#34;&#34;
        Reads the 3x heater outputs with the unit (W, A or V).
        Returns a tuple. 1st element is a list with the 3 values of the heaters. 2nd element is a string with the unit
        (&#39;W&#39;, &#39;A&#39; or &#39;V&#39;).
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def disable_heater(self, output_ch: int):
        &#34;&#34;&#34;
        Disables the specified heater output. output_ch = 1, 2, 3

        Notes: &lt;channel&gt;.Off cancels any active autotuning process, turns PID feedback off, and sets the channel&#39;s
        output to zero or the lower limit.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def outputs_enable(self):
        &#34;&#34;&#34;Enables all outputs. Equivalent to press the red button twice on the front panel of the PTC10 when outputs disabled.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def outputs_disable(self):
        &#34;&#34;&#34;Disables all outputs. Equivalent to press the red button on the front panel of the PTC10 when output enabled.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def disable_all(self):
        &#34;&#34;&#34;Both disable_heater function used for all heaters AND outputs_disable.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_outputs_enable(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns a boolean corresponding to the state of the red button/light on the front panel of the PTC10.
        True means outputs enabled (red light switch on)
        False means outputs disabled (red light switch off)
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def output_limit(self, output_ch: int, low: float, high: float):
        &#34;&#34;&#34;
        Sets the min and max output and can be used to prevent the PID loop for delivering excessive power to a
        heater. The limits must be expressed in the same units that the output is expressed in. The limits must
        normally be reset when the output units are changed, since the limits are not converted to the new units.
        output_ch = 1, 2, 3
        low = float &gt;= 0
        high = float &gt; low

        Notes:
            by default the DC heater driver output is measured in watts. But can be changed to either A or V.
            &lt;channel&gt;.Units{W, A, V}
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def output_unit(self, unit: str):
        &#34;&#34;&#34;
        Sets the unit for the 3 heaters
        unit = W, A, V, or in lowercase w, a, v
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_heater_input(self, output_ch: int, input: str):
        &#34;&#34;&#34;
        Sets the sensor as input for the specified heater.
        output_ch = 1, 2, 3
        input = name of the sensor (e.g. TRP2)
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def setpoint(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Sets the temperature setpoint. The PID attemps to keep the input at this value by changing the output.
        output_ch = 1, 2, 3
        setpoint = float (°C)

        Notes:
            usage: &lt;channel&gt;.PID.Setpoint&lt;setpoint&gt;
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def get_PID(self, output_ch: int) -&gt; dict:
        &#34;&#34;&#34;
        Returns a dictionary with P, I and D parameters as float, {&#34;P&#34;: P_value, &#34;I&#34;: I_value, &#34;D&#34;: D_value}
        output_ch = 1, 2, 3
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_PID(self, input_ch: int, output_ch: int, PID: List[float]):
        &#34;&#34;&#34;
        The input must be stable before either Step or Relay tuning is started. Furthermore, the output must be greater
        than half the step height before starting relay tuning. The best time to start a step response is when the
        system is first turned on at the beginning of the day, i.e the heater is cold and its temperature stable.
        See User Manual for further details.
        input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
        output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
        PID parameter sets the three coefficients respectively in P, I and D. PID = [float, float, float]

        Notes
        PID: &lt;channel&gt;.PID.D&lt;value&gt;, &lt;channel&gt;.PID.I&lt;value&gt;, &lt;channel&gt;.PID.P&lt;value&gt;
        &lt;channel&gt;.PID.Input&lt;channel name&gt;
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def autotune_PID(self, input_ch: int, output_ch: int):
        &#34;&#34;&#34;

        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_auto(self, output_ch: int, setpoint: float):
        &#34;&#34;&#34;
        Enables the specified output to reach the specified setpoint automatically.
        output_ch = 1, 2, 3
        setpoint = float (°C)
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_manual(self, output_ch: int, value: float):
        &#34;&#34;&#34;
        Enables the specified output manually with the specified value.
        The unit is the one currently in effect (W, A or V).
        output_ch = 1, 2, 3
        value = float &gt;= 0
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_survival(self):
        &#34;&#34;&#34;
        Sets all outputs to the min Non op temperature for TRP2, TRP3 and TRP4 as given in the Setup YAML file.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_stable(self, setpoint: float):
        &#34;&#34;&#34;
        Sets all outputs to the same temperature setpoint given as parameter.
        We assume that P, I and D coefficients are already correctly set.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_custom(self, outputs_dict: dict):
        &#34;&#34;&#34;
        Sets the outputs given as parameter to the corresponding temperature given as parameter.
        If an output channel is not given as parameter in the dictionary outputs_dict, this output channel will remain
        at the same state and with same setpoint as before.
        outputs_dict = {output_ch: setpoint} for example: {3: -110, 1: -106}
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def heater_sensor_error(self) -&gt; list:
        &#34;&#34;&#34;
        Returns a list with names of sensors (TRP) and heaters which cannot be read by the PTC10.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def disable_heater_error(self):
        &#34;&#34;&#34;
        Disables heaters whose PT1000 sensors are faulty.
        This function does not re-enable heater if a PT1000 is no longer faulty.
        &#34;&#34;&#34;

        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Controller" href="#egse.tempcontrol.srs.ptc10.ptc10Controller">ptc10Controller</a></li>
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Proxy" href="#egse.tempcontrol.srs.ptc10.ptc10Proxy">ptc10Proxy</a></li>
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Simulator" href="#egse.tempcontrol.srs.ptc10.ptc10Simulator">ptc10Simulator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status"><code class="name flex">
<span>def <span class="ident">alarm_status</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current value of the Alarm Status Register (ASR), and then clears the register.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def alarm_status(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the current value of the Alarm Status Register (ASR), and then clears the register.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.autotune_PID"><code class="name flex">
<span>def <span class="ident">autotune_PID</span></span>(<span>self, input_ch: int, output_ch: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def autotune_PID(self, input_ch: int, output_ch: int):
    &#34;&#34;&#34;

    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error"><code class="name flex">
<span>def <span class="ident">clear_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Erases all error messages for the port over which the instruction was transmitted. Also clears all messages
from the System.Com. Errors window regardless of which port generated them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def clear_error(self):
    &#34;&#34;&#34;
    Erases all error messages for the port over which the instruction was transmitted. Also clears all messages
    from the System.Com. Errors window regardless of which port generated them.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connects to the Temp regulation device.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>DeviceNotFoundError</code></dt>
<dd>when the Temp regulation device is not connected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def connect(self):
    &#34;&#34;&#34;Connects to the Temp regulation device.

    Raises:
        DeviceNotFoundError: when the Temp regulation device is not connected.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all"><code class="name flex">
<span>def <span class="ident">disable_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Both disable_heater function used for all heaters AND outputs_disable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def disable_all(self):
    &#34;&#34;&#34;Both disable_heater function used for all heaters AND outputs_disable.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater"><code class="name flex">
<span>def <span class="ident">disable_heater</span></span>(<span>self, output_ch: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the specified heater output. output_ch = 1, 2, 3</p>
<p>Notes: <channel>.Off cancels any active autotuning process, turns PID feedback off, and sets the channel's
output to zero or the lower limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def disable_heater(self, output_ch: int):
    &#34;&#34;&#34;
    Disables the specified heater output. output_ch = 1, 2, 3

    Notes: &lt;channel&gt;.Off cancels any active autotuning process, turns PID feedback off, and sets the channel&#39;s
    output to zero or the lower limit.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error"><code class="name flex">
<span>def <span class="ident">disable_heater_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables heaters whose PT1000 sensors are faulty.
This function does not re-enable heater if a PT1000 is no longer faulty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def disable_heater_error(self):
    &#34;&#34;&#34;
    Disables heaters whose PT1000 sensors are faulty.
    This function does not re-enable heater if a PT1000 is no longer faulty.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID"><code class="name flex">
<span>def <span class="ident">get_PID</span></span>(<span>self, output_ch: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with P, I and D parameters as float, {"P": P_value, "I": I_value, "D": D_value}
output_ch = 1, 2, 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_PID(self, output_ch: int) -&gt; dict:
    &#34;&#34;&#34;
    Returns a dictionary with P, I and D parameters as float, {&#34;P&#34;: P_value, &#34;I&#34;: I_value, &#34;D&#34;: D_value}
    output_ch = 1, 2, 3
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.get_names"><code class="name flex">
<span>def <span class="ident">get_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of 2 lists with the names of inputs (3 sensors) in the first list and the names of
outputs (3 heaters) in the second list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_names(self):
    &#34;&#34;&#34;
    Returns a tuple of 2 lists with the names of inputs (3 sensors) in the first list and the names of
    outputs (3 heaters) in the second list.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error"><code class="name flex">
<span>def <span class="ident">heater_sensor_error</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list with names of sensors (TRP) and heaters which cannot be read by the PTC10.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def heater_sensor_error(self) -&gt; list:
    &#34;&#34;&#34;
    Returns a list with names of sensors (TRP) and heaters which cannot be read by the PTC10.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns basic information about the device, its name, firmwre version etc.</p>
<h2 id="returns">Returns</h2>
<p>An identification string of the instrument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def info(self) -&gt; str:
    &#34;&#34;&#34;
    Returns basic information about the device, its name, firmwre version etc.
    Returns:
        An identification string of the instrument.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the Temp Controller is connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def is_connected(self):
    &#34;&#34;&#34;Check if the Temp Controller is connected.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable"><code class="name flex">
<span>def <span class="ident">is_outputs_enable</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a boolean corresponding to the state of the red button/light on the front panel of the PTC10.
True means outputs enabled (red light switch on)
False means outputs disabled (red light switch off)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def is_outputs_enable(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns a boolean corresponding to the state of the red button/light on the front panel of the PTC10.
    True means outputs enabled (red light switch on)
    False means outputs disabled (red light switch off)
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit"><code class="name flex">
<span>def <span class="ident">output_limit</span></span>(<span>self, output_ch: int, low: float, high: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the min and max output and can be used to prevent the PID loop for delivering excessive power to a
heater. The limits must be expressed in the same units that the output is expressed in. The limits must
normally be reset when the output units are changed, since the limits are not converted to the new units.
output_ch = 1, 2, 3
low = float &gt;= 0
high = float &gt; low</p>
<h2 id="notes">Notes</h2>
<p>by default the DC heater driver output is measured in watts. But can be changed to either A or V.
<channel>.Units{W, A, V}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def output_limit(self, output_ch: int, low: float, high: float):
    &#34;&#34;&#34;
    Sets the min and max output and can be used to prevent the PID loop for delivering excessive power to a
    heater. The limits must be expressed in the same units that the output is expressed in. The limits must
    normally be reset when the output units are changed, since the limits are not converted to the new units.
    output_ch = 1, 2, 3
    low = float &gt;= 0
    high = float &gt; low

    Notes:
        by default the DC heater driver output is measured in watts. But can be changed to either A or V.
        &lt;channel&gt;.Units{W, A, V}
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit"><code class="name flex">
<span>def <span class="ident">output_unit</span></span>(<span>self, unit: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the unit for the 3 heaters
unit = W, A, V, or in lowercase w, a, v</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def output_unit(self, unit: str):
    &#34;&#34;&#34;
    Sets the unit for the 3 heaters
    unit = W, A, V, or in lowercase w, a, v
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable"><code class="name flex">
<span>def <span class="ident">outputs_disable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables all outputs. Equivalent to press the red button on the front panel of the PTC10 when output enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def outputs_disable(self):
    &#34;&#34;&#34;Disables all outputs. Equivalent to press the red button on the front panel of the PTC10 when output enabled.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable"><code class="name flex">
<span>def <span class="ident">outputs_enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables all outputs. Equivalent to press the red button twice on the front panel of the PTC10 when outputs disabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def outputs_enable(self):
    &#34;&#34;&#34;Enables all outputs. Equivalent to press the red button twice on the front panel of the PTC10 when outputs disabled.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater"><code class="name flex">
<span>def <span class="ident">read_heater</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the 3x heater outputs with the unit (W, A or V).
Returns a tuple. 1st element is a list with the 3 values of the heaters. 2nd element is a string with the unit
('W', 'A' or 'V').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def read_heater(self):
    &#34;&#34;&#34;
    Reads the 3x heater outputs with the unit (W, A or V).
    Returns a tuple. 1st element is a list with the 3 values of the heaters. 2nd element is a string with the unit
    (&#39;W&#39;, &#39;A&#39; or &#39;V&#39;).
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature"><code class="name flex">
<span>def <span class="ident">read_temperature</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.</p>
<p>Notes: <channel>.value? returns the current value of the channel. Ex: 2A.value? queries the output of channel 2A
<channel>? also works</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def read_temperature(self):
    &#34;&#34;&#34;
    Reads the temperature from the 3 PT1000 corresponding to TRP2/TRP3/TRP4.

    Notes: &lt;channel&gt;.value? returns the current value of the channel. Ex: 2A.value? queries the output of channel 2A
            &lt;channel&gt;? also works
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the PTC10.</p>
<p>The <em>RST instruction is equivalent to turning the instrument off and back on again, except the Power On bit of
the Event Status Register is not set. </em>RST has the following effects:
- Outputs are disabled (as if the “Output enable” button were pressed).
- All currently-running macros are stopped, regardless of whether the macros were started by the GPIB interface,
another I/O port, or the Program screen.
- The instrument returns to the Select screen.
-Partially-received instructions on all I/O ports are cleared.
- All pending transmissions on all I/O ports are cancelled.
- The error queues for all I/O ports are cleared.
- The plot screen returns to showing the most recent data on autoscaled Y axes.
- The instrument automatically triggers at the rate set with the “A/D rate” control.
- Clears all locally-stored log data. Logs on USB devices are not affected. If data is not being logged to a
USB storage device, the Plot screen shows no accumulated data immediately after a *RST command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;,
    cmd_string=&#34;*RST&#34;,
    process_cmd_string=add_lf,
)
def reset(self):
    &#34;&#34;&#34;
    Resets the PTC10.

    The *RST instruction is equivalent to turning the instrument off and back on again, except the Power On bit of
    the Event Status Register is not set. *RST has the following effects:
    - Outputs are disabled (as if the “Output enable” button were pressed).
    - All currently-running macros are stopped, regardless of whether the macros were started by the GPIB interface,
    another I/O port, or the Program screen.
    - The instrument returns to the Select screen.
    -Partially-received instructions on all I/O ports are cleared.
    - All pending transmissions on all I/O ports are cancelled.
    - The error queues for all I/O ports are cleared.
    - The plot screen returns to showing the most recent data on autoscaled Y axes.
    - The instrument automatically triggers at the rate set with the “A/D rate” control.
    - Clears all locally-stored log data. Logs on USB devices are not affected. If data is not being logged to a
    USB storage device, the Plot screen shows no accumulated data immediately after a *RST command.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID"><code class="name flex">
<span>def <span class="ident">set_PID</span></span>(<span>self, input_ch: int, output_ch: int, PID: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>The input must be stable before either Step or Relay tuning is started. Furthermore, the output must be greater
than half the step height before starting relay tuning. The best time to start a step response is when the
system is first turned on at the beginning of the day, i.e the heater is cold and its temperature stable.
See User Manual for further details.
input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
PID parameter sets the three coefficients respectively in P, I and D. PID = [float, float, float]</p>
<p>Notes
PID: <channel>.PID.D<value>, <channel>.PID.I<value>, <channel>.PID.P<value>
<channel>.PID.Input<channel name></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_PID(self, input_ch: int, output_ch: int, PID: List[float]):
    &#34;&#34;&#34;
    The input must be stable before either Step or Relay tuning is started. Furthermore, the output must be greater
    than half the step height before starting relay tuning. The best time to start a step response is when the
    system is first turned on at the beginning of the day, i.e the heater is cold and its temperature stable.
    See User Manual for further details.
    input_ch parameter sets the PID input channel which is the temperature that the PID feedback loop controls. intput_ch = 1, 2, 3
    output_ch parameter sets the PID output channel. output_ch = 1, 2, 3
    PID parameter sets the three coefficients respectively in P, I and D. PID = [float, float, float]

    Notes
    PID: &lt;channel&gt;.PID.D&lt;value&gt;, &lt;channel&gt;.PID.I&lt;value&gt;, &lt;channel&gt;.PID.P&lt;value&gt;
    &lt;channel&gt;.PID.Input&lt;channel name&gt;
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto"><code class="name flex">
<span>def <span class="ident">set_auto</span></span>(<span>self, output_ch: int, setpoint: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the specified output to reach the specified setpoint automatically.
output_ch = 1, 2, 3
setpoint = float (°C)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_auto(self, output_ch: int, setpoint: float):
    &#34;&#34;&#34;
    Enables the specified output to reach the specified setpoint automatically.
    output_ch = 1, 2, 3
    setpoint = float (°C)
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom"><code class="name flex">
<span>def <span class="ident">set_custom</span></span>(<span>self, outputs_dict: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the outputs given as parameter to the corresponding temperature given as parameter.
If an output channel is not given as parameter in the dictionary outputs_dict, this output channel will remain
at the same state and with same setpoint as before.
outputs_dict = {output_ch: setpoint} for example: {3: -110, 1: -106}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_custom(self, outputs_dict: dict):
    &#34;&#34;&#34;
    Sets the outputs given as parameter to the corresponding temperature given as parameter.
    If an output channel is not given as parameter in the dictionary outputs_dict, this output channel will remain
    at the same state and with same setpoint as before.
    outputs_dict = {output_ch: setpoint} for example: {3: -110, 1: -106}
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input"><code class="name flex">
<span>def <span class="ident">set_heater_input</span></span>(<span>self, output_ch: int, input: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the sensor as input for the specified heater.
output_ch = 1, 2, 3
input = name of the sensor (e.g. TRP2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_heater_input(self, output_ch: int, input: str):
    &#34;&#34;&#34;
    Sets the sensor as input for the specified heater.
    output_ch = 1, 2, 3
    input = name of the sensor (e.g. TRP2)
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual"><code class="name flex">
<span>def <span class="ident">set_manual</span></span>(<span>self, output_ch: int, value: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables the specified output manually with the specified value.
The unit is the one currently in effect (W, A or V).
output_ch = 1, 2, 3
value = float &gt;= 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_manual(self, output_ch: int, value: float):
    &#34;&#34;&#34;
    Enables the specified output manually with the specified value.
    The unit is the one currently in effect (W, A or V).
    output_ch = 1, 2, 3
    value = float &gt;= 0
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, old_name: str, new_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the name of the specified channel (input or output).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_name(self, old_name: str, new_name: str):
    &#34;&#34;&#34;Modifies the name of the specified channel (input or output).&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable"><code class="name flex">
<span>def <span class="ident">set_stable</span></span>(<span>self, setpoint: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets all outputs to the same temperature setpoint given as parameter.
We assume that P, I and D coefficients are already correctly set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_stable(self, setpoint: float):
    &#34;&#34;&#34;
    Sets all outputs to the same temperature setpoint given as parameter.
    We assume that P, I and D coefficients are already correctly set.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival"><code class="name flex">
<span>def <span class="ident">set_survival</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets all outputs to the min Non op temperature for TRP2, TRP3 and TRP4 as given in the Setup YAML file.
We assume that P, I and D coefficients are already correctly set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_survival(self):
    &#34;&#34;&#34;
    Sets all outputs to the min Non op temperature for TRP2, TRP3 and TRP4 as given in the Setup YAML file.
    We assume that P, I and D coefficients are already correctly set.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint"><code class="name flex">
<span>def <span class="ident">setpoint</span></span>(<span>self, output_ch: int, setpoint: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the temperature setpoint. The PID attemps to keep the input at this value by changing the output.
output_ch = 1, 2, 3
setpoint = float (°C)</p>
<h2 id="notes">Notes</h2>
<p>usage: <channel>.PID.Setpoint<setpoint></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def setpoint(self, output_ch: int, setpoint: float):
    &#34;&#34;&#34;
    Sets the temperature setpoint. The PID attemps to keep the input at this value by changing the output.
    output_ch = 1, 2, 3
    setpoint = float (°C)

    Notes:
        usage: &lt;channel&gt;.PID.Setpoint&lt;setpoint&gt;
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.standby"><code class="name flex">
<span>def <span class="ident">standby</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts the PTC10 into stby mode, in which the outputs are turned off, data acquisition is paused, macros are
paused, the front panel display and system fan are shut off, and the system does not respond to remote commands.
The PTC321's excitation currents remain on, and the chassis cooling fan may switch on occassionally.
Press the "Output Enable" key to exit standby mode. There is no remote command to leave stand by mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def standby(self):
    &#34;&#34;&#34;
    Puts the PTC10 into stby mode, in which the outputs are turned off, data acquisition is paused, macros are
    paused, the front panel display and system fan are shut off, and the system does not respond to remote commands.
    The PTC321&#39;s excitation currents remain on, and the chassis cooling fan may switch on occassionally.
    Press the &#34;Output Enable&#34; key to exit standby mode. There is no remote command to leave stand by mode.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Interface.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>kill.all stops all currently running macros with the given runtime name. The runtime name is assigned with the
"name" instruction and is not necessarily the same as the file name that a macro may be saved under.
The kill.all instruction stops all currently-running macros regardless of name or which port started the macro.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def stop(self):
    &#34;&#34;&#34;
    kill.all stops all currently running macros with the given runtime name. The runtime name is assigned with the
    &#34;name&#34; instruction and is not necessarily the same as the file name that a macro may be saved under.
    The kill.all instruction stops all currently-running macros regardless of name or which port started the macro.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Proxy"><code class="flex name class">
<span>class <span class="ident">ptc10Proxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6808, timeout=60000)</span>
</code></dt>
<dd>
<div class="desc"><p>The ptc10Proxy class is used to connect to the control server and send commands to
the SRS PTC10 device remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol [default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address)
[default is taken from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ptc10Proxy(Proxy, ptc10Interface):
    &#34;&#34;&#34;The ptc10Proxy class is used to connect to the control server and send commands to
    the SRS PTC10 device remotely.&#34;&#34;&#34;
    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
        timeout=CTRL_SETTINGS.TIMEOUT * 1000 # timeout in ms
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status">alarm_status</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.connect" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all">disable_all</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater">disable_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error">disable_heater_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID">get_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_names" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_names">get_names</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error">heater_sensor_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.info" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable">is_outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit">output_limit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit">output_unit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable">outputs_disable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable">outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater">read_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature">read_temperature</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reset" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID">set_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto">set_auto</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom">set_custom</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input">set_heater_input</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual">set_manual</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_name" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_name">set_name</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable">set_stable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival">set_survival</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint">setpoint</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.standby" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.standby">standby</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.stop" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tempcontrol.srs.ptc10.ptc10Simulator"><code class="flex name class">
<span>class <span class="ident">ptc10Simulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The ptc10 Simulator class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ptc10Simulator(ptc10Interface):
    &#34;&#34;&#34;
    The ptc10 Simulator class.
    &#34;&#34;&#34;

    def __init__(self):
        self._is_connected = True
        self.temp_operation = False

    def is_connected(self):
        return self._is_connected

    def is_simulator(self):
        return True

    def connect(self):
        self._is_connected = True

    def disconnect(self):
        self._is_connected = False

    def reconnect(self):
        self.connect()

    def info(self):
        pass

    def read_temperature(self):
        pass

    def read_heater(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status">alarm_status</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.connect" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all">disable_all</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater">disable_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error">disable_heater_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID">get_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_names" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_names">get_names</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error">heater_sensor_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.info" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable">is_outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit">output_limit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit">output_unit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable">outputs_disable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable">outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater">read_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature">read_temperature</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reset" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID">set_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto">set_auto</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom">set_custom</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input">set_heater_input</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual">set_manual</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_name" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_name">set_name</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable">set_stable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival">set_survival</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint">setpoint</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.standby" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.standby">standby</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.stop" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tempcontrol.srs" href="index.html">egse.tempcontrol.srs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.tempcontrol.srs.ptc10.load_setup_from_configuration_manager" href="#egse.tempcontrol.srs.ptc10.load_setup_from_configuration_manager">load_setup_from_configuration_manager</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tempcontrol.srs.ptc10.ptc10Controller" href="#egse.tempcontrol.srs.ptc10.ptc10Controller">ptc10Controller</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Controller.autotune_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Controller.autotune_PID">autotune_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Controller.get_time" href="#egse.tempcontrol.srs.ptc10.ptc10Controller.get_time">get_time</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Controller.read_temperature" href="#egse.tempcontrol.srs.ptc10.ptc10Controller.read_temperature">read_temperature</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Controller.update_time" href="#egse.tempcontrol.srs.ptc10.ptc10Controller.update_time">update_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface" href="#egse.tempcontrol.srs.ptc10.ptc10Interface">ptc10Interface</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.alarm_status">alarm_status</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.autotune_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.autotune_PID">autotune_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.connect" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.connect">connect</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_all">disable_all</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater">disable_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.disable_heater_error">disable_heater_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_PID">get_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.get_names" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.get_names">get_names</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.heater_sensor_error">heater_sensor_error</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.info" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.info">info</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.is_outputs_enable">is_outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_limit">output_limit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.output_unit">output_unit</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_disable">outputs_disable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.outputs_enable">outputs_enable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_heater">read_heater</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.read_temperature">read_temperature</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.reset" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.reset">reset</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_PID">set_PID</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_auto">set_auto</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_custom">set_custom</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_heater_input">set_heater_input</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_manual">set_manual</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_name" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_name">set_name</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_stable">set_stable</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.set_survival">set_survival</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.setpoint">setpoint</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.standby" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.standby">standby</a></code></li>
<li><code><a title="egse.tempcontrol.srs.ptc10.ptc10Interface.stop" href="#egse.tempcontrol.srs.ptc10.ptc10Interface.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.srs.ptc10.ptc10Proxy" href="#egse.tempcontrol.srs.ptc10.ptc10Proxy">ptc10Proxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.srs.ptc10.ptc10Simulator" href="#egse.tempcontrol.srs.ptc10.ptc10Simulator">ptc10Simulator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
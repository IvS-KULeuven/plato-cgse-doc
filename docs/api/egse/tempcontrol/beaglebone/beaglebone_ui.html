<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tempcontrol.beaglebone.beaglebone_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tempcontrol.beaglebone.beaglebone_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
import logging
import pickle
import sys
import zmq
from zmq import ZMQError
from PyQt5.QtCore import QThread, QObject, pyqtSignal, pyqtSlot, QTimer, QEvent

from PyQt5.QtGui import QCloseEvent, QPixmap, QIcon, QIntValidator
from PyQt5.QtWidgets import QMainWindow, QApplication, QLabel, QFrame, QHBoxLayout, QVBoxLayout, QGroupBox, QGridLayout, \
    QAction, QWidget, QLineEdit,  QPushButton


from egse.tempcontrol.beaglebone.beaglebone import BeagleboneProxy, BeagleboneSimulator
from egse.tempcontrol.beaglebone.beaglebone import CTRL_SETTINGS as HEATER_CTRL_SETTINGS
from egse.tempcontrol.spid.spid import PidProxy, PidSimulator
from egse.tempcontrol.spid.spid import CTRL_SETTINGS as PID_CTRL_SETTINGS

from egse.setup import get_setup
from egse.gui.buttons import ToggleButton
from egse.gui.led import Led, Indic as LedIndic
from egse.observer import Observer, Observable
from egse.settings import Settings
from egse.setup import Setup
from egse.zmq_ser import connect_address
from egse.resource import get_resource

MODULE_LOGGER = logging.getLogger(&#34;HEATER GUI&#34;)

class HeaterMonitoringWorker(QObject):
    &#34;&#34;&#34;Worker for monitoring the state and duty cycle of the Beaglebone Black Heaters

    The worker will send a signal when a heater state changes or 
        when the duty cycle changes

    &#34;&#34;&#34;

    heater_enabled_status_signal        = pyqtSignal(list)
    heater_duty_cycle_status_signal                   = pyqtSignal(list)
    
    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker.
        
        This worker keeps an eye on the monitoring port of the Beaglebone Heater. When a change in
            Relevant information occurs, a signalw ill be emitted. These signals will be used to update the GUI
        &#34;&#34;&#34;
        
        
        super(HeaterMonitoringWorker, self).__init__()
        
        self.active = False
        self.just_reconnected = True
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        # Keep track of the heater status, so we only have to send a signal when the state has changed
        
        self.previous_heater_status_signal = {}
        self.previous_heater_duty_cycle    = {}
        
    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;
        

        try:
            transport   = HEATER_CTRL_SETTINGS.PROTOCOL
            hostname    = HEATER_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = HEATER_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        
        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;
        
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
        self.run()
        
    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
        
        If the beaglebone status has changed, update it in the GUI

        Raises:
            Exception: ZMQ Error
        &#34;&#34;&#34;
        
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                if self.monitoring_socket in socket_list:
                    try:
                        pickle_string = self.monitoring_socket.recv()
                    except Exception:
                        raise Exception

                    monitoring_info = pickle.loads(pickle_string)
                    
                    heater_enabled      = monitoring_info[&#39;Enabled&#39;]
                    heater_duty_cycle   = monitoring_info[&#39;duty_cycle&#39;]

                    self.heater_enabled_status_signal.emit(heater_enabled)
                    
                    if heater_duty_cycle != self.previous_heater_duty_cycle:
                        self.heater_duty_cycle_status_signal.emit(heater_duty_cycle)
                    
                    self.previous_heater_duty_cycle = heater_duty_cycle
                    
                    
            except ZMQError as exc:
                raise exc
 
class PidMonitoringWorker(QObject):
    &#34;&#34;&#34;Worker for monitoring the state of the individual PID channels

   The worker will send a signal when the state of a PID channel has changed

    &#34;&#34;&#34;
    
    pid_control_server_status_signal = pyqtSignal(bool)
    pid_enabled_status_signal        = pyqtSignal(dict)
    
    def __init__(self):
        super(PidMonitoringWorker, self).__init__()
        
        self.active = False
        self.just_reconnected = True
        
        self.enabled = False
        self.pid_enabled = []
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        self.previous_control_server_status_signal = ()
        self.previous_pid_enabled_status_signal = {}


    def connect_socket(self):
        try:
            transport   = PID_CTRL_SETTINGS.PROTOCOL
            hostname    = PID_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        self.run()
        
    @pyqtSlot()
    def run(self):
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)
                if self.monitoring_socket in socket_list:
                    self.enabled = True
                    pickle_string = self.monitoring_socket.recv()

                    monitoring_info = pickle.loads(pickle_string)
                    
                    self.pid_enabled      = monitoring_info[&#39;Enabled&#39;]
                    
                    if self.previous_pid_enabled_status_signal != self.pid_enabled:
                        self.pid_enabled_status_signal.emit(self.pid_enabled)
                    
                if self.previous_control_server_status_signal != self.enabled:
                    self.pid_control_server_status_signal.emit(self.enabled)
                    
                self.previous_control_server_status_signal = self.enabled
                self.previous_pid_enabled_status_signal = self.pid_enabled
            except ZMQError as exc:
                raise exc


class ChannelWidget(QGroupBox):

    def __init__(self, heater, channel):
        
        super().__init__()
        
        self.heater = heater
        self.channel = channel
        
        name=f&#34;Channel {chr(ord(&#39;@&#39;)+self.channel + 1)}&#34;
        self.setMinimumHeight(100)
        
        self.duty_cycle = None
            
        label = QLabel(name)
        
        self.switch = ToggleButton(
            name=&#34;Turn On\Off Heater Channel&#34;,
            status_tip=f&#34;Heater {self.heater} Channel {self.channel} On\Off&#34;,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        self.switch.setObjectName(f&#34;Heater {self.heater} Channel {self.channel} Switch&#34;)
      
        self.textbox = QLineEdit(self)
        self.textbox.setObjectName(f&#34;Heater {self.heater} Channel {self.channel} Textbox&#34;)
        self.textbox.setValidator(QIntValidator(0, 100))
        self.textbox.setMaximumWidth(150)
        
        self.pid_button = QPushButton(&#34;stop PID&#34;, self)
        self.pid_button.setObjectName(f&#34;Heater {self.heater} Channel {self.channel} Button&#34;)
        
        self.layout = QGridLayout()
        
        power_layout = QHBoxLayout()
        power_layout.addWidget(QLabel(&#34;P (%)&#34;))
        power_layout.addWidget(self.textbox)
        
        self.layout.addWidget(label, 0, 0)
        self.layout.addWidget(self.pid_button, 0, 2)
        self.pid_button.hide()
        self.layout.addWidget(self.switch, 1, 0)
        self.layout.addLayout(power_layout, 1, 2)
        
        self.setLayout(self.layout)
        
class HeaterWidget(QGroupBox):
 
    def __init__(self, heater):
        super().__init__()
        self._heater = heater
        self.channel = [None] * 4
        
        name=f&#34;Heater {self._heater + 1}&#34;
        
        hbox = QHBoxLayout() 
          
        label = QLabel(name) 
        self.led = Led(self)
         
        hbox.addWidget(label)
        hbox.addWidget(self.led)
        
        layout = QVBoxLayout()
        
        layout.addLayout(hbox)

        for idx, ch in enumerate(range(0, 4)):
            self.channel[idx] = ChannelWidget(heater=self._heater, channel=ch)
            self.channel[idx].setObjectName(f&#34;{self._heater}_{ch}&#34;)
            layout.addWidget(self.channel[idx])
            
        self.setLayout(layout)
        

class HeaterUIView(QMainWindow, Observable):
    def __init__(self):
        super().__init__()
        self.setGeometry(300, 300, 1200, 300)
        self.setWindowTitle(&#34;Beaglebone Heaters&#34;)
        
        self.heaters = {}
        self.enabled_pid = []
        
        setup = get_setup()
        self.heater_availability = [True for available in setup.gse.beaglebone_heater.availability if available] 
        self.pids                = setup.gse.spid
        heaters      = self.pids.configuration.heaters

        self.channels = [channel for heater in heaters.values() for channel in heater]

        self.initUI()
        
        self.heater_monitoring_thread = QThread(self)
        self.heater_monitoring_worker = HeaterMonitoringWorker()
        self.heater_monitoring_worker.moveToThread(self.heater_monitoring_thread)
        
        self.pid_monitoring_thread = QThread(self)
        self.pid_monitoring_worker = PidMonitoringWorker()
        self.pid_monitoring_worker.moveToThread(self.pid_monitoring_thread)

        self.heater_monitoring_worker.heater_enabled_status_signal.connect(self.on_heater_enabled_status_signal)
        self.heater_monitoring_worker.heater_duty_cycle_status_signal.connect(self.on_heater_duty_cycle_status_signal)
        
        self.pid_monitoring_worker.pid_enabled_status_signal.connect(self.on_pid_enabled_status_signal)

        self.heater_monitoring_thread.started.connect(self.heater_monitoring_worker.start_process)
        self.heater_monitoring_thread.start()
        
        self.pid_monitoring_thread.started.connect(self.pid_monitoring_worker.start_process)
        self.pid_monitoring_thread.start()
                
    
    def on_pid_enabled_status_signal(self, monitoring_info: dict):
        for heater_channel, enabled in monitoring_info.items():
            command = heater_channel.split(&#34;_&#34;)
            htr = int(command[0])
            ch = int(command[1])
            if enabled:

                self.heaters[htr].channel[ch].pid_button.show()
                self.heaters[htr].channel[ch].textbox.setReadOnly(True)
                self.heaters[htr].channel[ch].setStyleSheet(&#34;&#34;&#34;QGroupBox {border: 1px solid red;}&#34;&#34;&#34;)
            
            else:
                self.heaters[htr].channel[ch].pid_button.hide()
                self.heaters[htr].channel[ch].textbox.setReadOnly(False)
                self.heaters[htr].channel[ch].setStyleSheet(&#39;fusion&#39;) 

    def on_heater_enabled_status_signal(self, monitoring_info: dict):
        for htr in range(len(self.heater_availability)):
            for ch in range(0, 4):
                self.heaters[htr].channel[ch].switch.set_selected(monitoring_info[htr][ch])
        
    def on_heater_duty_cycle_status_signal(self, monitoring_info: dict):
        for htr in range(len(self.heater_availability)):
            for ch in range(0, 4):
                self.heaters[htr].channel[ch].textbox.setText(str(int(monitoring_info[htr][ch] / 100)))
                
    def initUI(self):
        
        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)
        
        layout = QHBoxLayout()
    
        for htr in range(len(self.heater_availability)):
            avail = self.heater_availability[htr] 
            
            self.heaters[htr] = HeaterWidget(heater=htr)
            self.heaters[htr].led.set_color(1 if avail else 0)
            
            layout.addWidget(self.heaters[htr])
            
            for ch_idx, channel in enumerate(range(0, 4)):
                self.heaters[htr].channel[ch_idx].textbox.returnPressed.connect(self.set_duty_cycle)
                self.heaters[htr].channel[ch_idx].switch.clicked.connect(self.set_enable)
                self.heaters[htr].channel[ch_idx].pid_button.clicked.connect(self.turn_off_pid)
       
        app_frame.setLayout(layout)
        self.setCentralWidget(app_frame)   
        
    def set_duty_cycle(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        _htr_idx = int(command[1])
        _ch_idx  = int(command[3])
        _channelUI = self.heaters[_htr_idx].channel[_ch_idx]
        _duty_cycle = _channelUI.textbox.text()
        _duty_cycle = (float(_duty_cycle) / 100) * 10000
        MODULE_LOGGER.info(f&#34;Heater {_htr_idx+1} Channel {_ch_idx+1} Duty_Cycle {_duty_cycle}&#34;)
        self.actionObservers({&#34;set_duty_cycle&#34;: [_htr_idx, _ch_idx, _duty_cycle]})
    
    def turn_off_pid(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        htr = int(command[1])
        ch = int(command[3])
        for idx, pid in enumerate(self.channels):
            if (pid[3] is htr) and (pid[4] is ch):
                self.actionObservers({&#34;set_pid_disable&#34;: [idx]}) if (pid[3] is htr and pid[4] is ch) else None

    def set_enable(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        state = sender.is_selected()
        new_state = state
        sender.set_selected(on=new_state)
        _htr_idx = int(command[1])
        _ch_idx  = int(command[3])
        MODULE_LOGGER.info(f&#34;Heater {_htr_idx + 1} Channel {_ch_idx + 1} now has state { new_state}&#34;)
        self.actionObservers({&#34;set_enable&#34; : [_htr_idx, _ch_idx, new_state]})
            
    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        self.heater_monitoring_worker.stop()
        self.heater_monitoring_thread.quit()
        self.pid_monitoring_thread.quit()
        self.pid_monitoring_worker.stop()
                

class HeaterUIModel:
    def __init__(self, mode):
            self.mode = mode

            if self.mode == &#39;proxy&#39;:
                try:
                    self.heater = BeagleboneProxy()
                except Exception as exc:
                    raise exc

            elif self.mode == &#39;simulator&#39;:
                self.heater = BeagleboneSimulator()
            else:
                raise ValueError(f&#39;Unknown type of Heater implementation passed into the model&#39;)
            
            if self.heater is not None:
                MODULE_LOGGER.debug(f&#39;Heater Controller initialized as {self.heater.__class__.__name__}&#39;)


    def set_enable(self, htr_idx, ch_idx, enable):
        with BeagleboneProxy() as heater:
            heater.set_enable(htr_idx, ch_idx, enable)
        
    def set_duty_cycle(self, htr_idx, ch_idx, duty_cycle):
        with BeagleboneProxy() as heater:
            heater.set_duty_cycle(htr_idx, ch_idx, duty_cycle)

    def set_pid_enable(self, ch):
        try:
            with PidProxy() as pid:
                pid.enable(ch)
        except:
            MODULE_LOGGER.info(&#34;PID Control Server could not be found&#34;)
        
    def set_pid_disable(self, ch):
        MODULE_LOGGER.info(f&#34;PID channel {ch} has been disabled&#34;)
        try:
            with PidProxy() as pid:
                pid.disable(ch)
        except:
            MODULE_LOGGER.info(&#34;PID Control Server could not be found&#34;)
    
    def has_commands(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:
                return heater.has_commands()

        return True

    def load_commands(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:
                with PidProxy() as pid:
                    pid.load_commands()
                    heater.load_commands()

    def is_simulator(self):
        with BeagleboneProxy() as heater:
            return heater.is_simulator()

    def is_connected(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:
                return heater.is_cs_connected()

        else:

            return self.heater.is_connected()

    def reconnect(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:

                heater.reconnect_cs()

                return heater.is_cs_connected()

        else:

            self.heater.reconnect()

            return self.heater.is_connected()

        return False

    def disconnect(self):
        if self.mode == &#34;proxy&#34;:

            self.mode.disconnect_cs()

class HeaterUIController(Observer):
    def __init__(self, model: HeaterUIModel, view: HeaterUIView):
        self.model  = model
        self.view   = view
        self.view.addObserver(self)
 
    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                MODULE_LOGGER.debug(&#34;Reconnecting the Heater model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                MODULE_LOGGER.debug(&#34;Disconnecting the Heater model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return
 
    
    def do(self, actions):
        for action, value in actions.items():
            MODULE_LOGGER.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_duty_cycle&#34;:
                htr_idx     = value[0]
                ch_idx      = value[1]
                duty_cycle  = value[2]
                MODULE_LOGGER.debug(f&#34;do: set_duty_cycle({htr_idx}, {ch_idx}, {duty_cycle})&#34;)
                self.model.set_duty_cycle(htr_idx, ch_idx, duty_cycle)

                
            if action == &#34;set_enable&#34;:
                htr_idx     = value[0]
                ch_idx      = value[1]
                state  = value[2]
                MODULE_LOGGER.debug(f&#34;do: set_enable({htr_idx}, {ch_idx}, {state})&#34;)
                self.model.set_enable(htr_idx, ch_idx, state)
                
            if action == &#34;set_pid_enable&#34;:
                ch          = value[0]
                MODULE_LOGGER.debug(f&#34;do: set_pid_enable({ch}&#34;)
                self.model.set_pid_enable(ch)
                
            if action == &#34;set_pid_disable&#34;:
                ch          = value[0]
                MODULE_LOGGER.info(f&#34;do: set_pid_disable({ch})&#34;)
                self.model.set_pid_disable(ch)
 

    
def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;, &#34;crio&#34;},
        help=&#34;Specify AEU cRIO implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )    
    args = parser.parse_args()
    return args

def main():
    args = list(sys.argv)
    app = QApplication(args)

    args = parse_arguments()
    
    if args.type == &#39;proxy&#39;:
        try:
            proxy = BeagleboneProxy()
        except Exception:
            raise Exception
        
        # try:
        #     pid_proxy = PidProxy()
        # except:
        #     MODULE_LOGGER.info(&#34;PID Control Server is not running&#34;)
    
    view        = HeaterUIView()
    model       = HeaterUIModel(args.type)
    controller  = HeaterUIController(model, view)
    
    view.show()
    sys.exit(app.exec_())
    
if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    args = list(sys.argv)
    app = QApplication(args)

    args = parse_arguments()
    
    if args.type == &#39;proxy&#39;:
        try:
            proxy = BeagleboneProxy()
        except Exception:
            raise Exception
        
        # try:
        #     pid_proxy = PidProxy()
        # except:
        #     MODULE_LOGGER.info(&#34;PID Control Server is not running&#34;)
    
    view        = HeaterUIView()
    model       = HeaterUIModel(args.type)
    controller  = HeaterUIController(model, view)
    
    view.show()
    sys.exit(app.exec_())</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.parse_arguments"><code class="name flex">
<span>def <span class="ident">parse_arguments</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the arguments that are specific for this application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;, &#34;crio&#34;},
        help=&#34;Specify AEU cRIO implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )    
    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.ChannelWidget"><code class="flex name class">
<span>class <span class="ident">ChannelWidget</span></span>
<span>(</span><span>heater, channel)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelWidget(QGroupBox):

    def __init__(self, heater, channel):
        
        super().__init__()
        
        self.heater = heater
        self.channel = channel
        
        name=f&#34;Channel {chr(ord(&#39;@&#39;)+self.channel + 1)}&#34;
        self.setMinimumHeight(100)
        
        self.duty_cycle = None
            
        label = QLabel(name)
        
        self.switch = ToggleButton(
            name=&#34;Turn On\Off Heater Channel&#34;,
            status_tip=f&#34;Heater {self.heater} Channel {self.channel} On\Off&#34;,
            selected=get_resource(&#34;:/icons/switch-on.svg&#34;),
            not_selected=get_resource(&#34;:/icons/switch-off.svg&#34;),
        )
        self.switch.setObjectName(f&#34;Heater {self.heater} Channel {self.channel} Switch&#34;)
      
        self.textbox = QLineEdit(self)
        self.textbox.setObjectName(f&#34;Heater {self.heater} Channel {self.channel} Textbox&#34;)
        self.textbox.setValidator(QIntValidator(0, 100))
        self.textbox.setMaximumWidth(150)
        
        self.pid_button = QPushButton(&#34;stop PID&#34;, self)
        self.pid_button.setObjectName(f&#34;Heater {self.heater} Channel {self.channel} Button&#34;)
        
        self.layout = QGridLayout()
        
        power_layout = QHBoxLayout()
        power_layout.addWidget(QLabel(&#34;P (%)&#34;))
        power_layout.addWidget(self.textbox)
        
        self.layout.addWidget(label, 0, 0)
        self.layout.addWidget(self.pid_button, 0, 2)
        self.pid_button.hide()
        self.layout.addWidget(self.switch, 1, 0)
        self.layout.addLayout(power_layout, 1, 2)
        
        self.setLayout(self.layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">HeaterMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the state and duty cycle of the Beaglebone Black Heaters</p>
<p>The worker will send a signal when a heater state changes or
when the duty cycle changes</p>
<p>Initialisation of a monitoring worker.</p>
<p>This worker keeps an eye on the monitoring port of the Beaglebone Heater. When a change in
Relevant information occurs, a signalw ill be emitted. These signals will be used to update the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaterMonitoringWorker(QObject):
    &#34;&#34;&#34;Worker for monitoring the state and duty cycle of the Beaglebone Black Heaters

    The worker will send a signal when a heater state changes or 
        when the duty cycle changes

    &#34;&#34;&#34;

    heater_enabled_status_signal        = pyqtSignal(list)
    heater_duty_cycle_status_signal                   = pyqtSignal(list)
    
    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker.
        
        This worker keeps an eye on the monitoring port of the Beaglebone Heater. When a change in
            Relevant information occurs, a signalw ill be emitted. These signals will be used to update the GUI
        &#34;&#34;&#34;
        
        
        super(HeaterMonitoringWorker, self).__init__()
        
        self.active = False
        self.just_reconnected = True
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        # Keep track of the heater status, so we only have to send a signal when the state has changed
        
        self.previous_heater_status_signal = {}
        self.previous_heater_duty_cycle    = {}
        
    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;
        

        try:
            transport   = HEATER_CTRL_SETTINGS.PROTOCOL
            hostname    = HEATER_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = HEATER_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        
        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;
        
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
        self.run()
        
    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
        
        If the beaglebone status has changed, update it in the GUI

        Raises:
            Exception: ZMQ Error
        &#34;&#34;&#34;
        
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                if self.monitoring_socket in socket_list:
                    try:
                        pickle_string = self.monitoring_socket.recv()
                    except Exception:
                        raise Exception

                    monitoring_info = pickle.loads(pickle_string)
                    
                    heater_enabled      = monitoring_info[&#39;Enabled&#39;]
                    heater_duty_cycle   = monitoring_info[&#39;duty_cycle&#39;]

                    self.heater_enabled_status_signal.emit(heater_enabled)
                    
                    if heater_duty_cycle != self.previous_heater_duty_cycle:
                        self.heater_duty_cycle_status_signal.emit(heater_duty_cycle)
                    
                    self.previous_heater_duty_cycle = heater_duty_cycle
                    
                    
            except ZMQError as exc:
                raise exc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.
    &#34;&#34;&#34;
    

    try:
        transport   = HEATER_CTRL_SETTINGS.PROTOCOL
        hostname    = HEATER_CTRL_SETTINGS.HOSTNAME
        
        monitoring_port = HEATER_CTRL_SETTINGS.MONITORING_PORT
        monitoring_address = connect_address(transport, hostname, monitoring_port)
        
        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
        
        self.monitoring_timeout = 0.5
        
        self.is_socket_connected = True
        
    except:
        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.heater_duty_cycle_status_signal"><code class="name flex">
<span>def <span class="ident">heater_duty_cycle_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.heater_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">heater_enabled_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on checkin whether the Beaglebone state has changed</p>
<p>If the beaglebone status has changed, update it in the GUI</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>ZMQ Error</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34;Keep on checkin whether the Beaglebone state has changed
    
    If the beaglebone status has changed, update it in the GUI

    Raises:
        Exception: ZMQ Error
    &#34;&#34;&#34;
    
    self.active = True
    while self.is_socket_connected and self.active:
        
        try:
            socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            if self.monitoring_socket in socket_list:
                try:
                    pickle_string = self.monitoring_socket.recv()
                except Exception:
                    raise Exception

                monitoring_info = pickle.loads(pickle_string)
                
                heater_enabled      = monitoring_info[&#39;Enabled&#39;]
                heater_duty_cycle   = monitoring_info[&#39;duty_cycle&#39;]

                self.heater_enabled_status_signal.emit(heater_enabled)
                
                if heater_duty_cycle != self.previous_heater_duty_cycle:
                    self.heater_duty_cycle_status_signal.emit(heater_duty_cycle)
                
                self.previous_heater_duty_cycle = heater_duty_cycle
                
                
        except ZMQError as exc:
            raise exc</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start updated the Beaglebone status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34;Start updated the Beaglebone status&#34;&#34;&#34;
    self.run()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the monitoring worker.</p>
<p>The monitoring socket is disconnected from the monitoring port and is then closed immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    
    &#34;&#34;&#34; Stop the monitoring worker.

    The monitoring socket is disconnected from the monitoring port and is then closed immediately.
    &#34;&#34;&#34;
    
    self.monitoring_socket.close()
    self.is_socket_connected = False
    
    self.active = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController"><code class="flex name class">
<span>class <span class="ident">HeaterUIController</span></span>
<span>(</span><span>model: <a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel">HeaterUIModel</a>, view: <a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView">HeaterUIView</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaterUIController(Observer):
    def __init__(self, model: HeaterUIModel, view: HeaterUIView):
        self.model  = model
        self.view   = view
        self.view.addObserver(self)
 
    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                MODULE_LOGGER.debug(&#34;Reconnecting the Heater model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                MODULE_LOGGER.debug(&#34;Disconnecting the Heater model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return
 
    
    def do(self, actions):
        for action, value in actions.items():
            MODULE_LOGGER.debug(f&#34;do {action} with {value}&#34;)
            if action == &#34;set_duty_cycle&#34;:
                htr_idx     = value[0]
                ch_idx      = value[1]
                duty_cycle  = value[2]
                MODULE_LOGGER.debug(f&#34;do: set_duty_cycle({htr_idx}, {ch_idx}, {duty_cycle})&#34;)
                self.model.set_duty_cycle(htr_idx, ch_idx, duty_cycle)

                
            if action == &#34;set_enable&#34;:
                htr_idx     = value[0]
                ch_idx      = value[1]
                state  = value[2]
                MODULE_LOGGER.debug(f&#34;do: set_enable({htr_idx}, {ch_idx}, {state})&#34;)
                self.model.set_enable(htr_idx, ch_idx, state)
                
            if action == &#34;set_pid_enable&#34;:
                ch          = value[0]
                MODULE_LOGGER.debug(f&#34;do: set_pid_enable({ch}&#34;)
                self.model.set_pid_enable(ch)
                
            if action == &#34;set_pid_disable&#34;:
                ch          = value[0]
                MODULE_LOGGER.info(f&#34;do: set_pid_disable({ch})&#34;)
                self.model.set_pid_disable(ch)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.observer.Observer" href="../../observer.html#egse.observer.Observer">Observer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, actions)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, actions):
    for action, value in actions.items():
        MODULE_LOGGER.debug(f&#34;do {action} with {value}&#34;)
        if action == &#34;set_duty_cycle&#34;:
            htr_idx     = value[0]
            ch_idx      = value[1]
            duty_cycle  = value[2]
            MODULE_LOGGER.debug(f&#34;do: set_duty_cycle({htr_idx}, {ch_idx}, {duty_cycle})&#34;)
            self.model.set_duty_cycle(htr_idx, ch_idx, duty_cycle)

            
        if action == &#34;set_enable&#34;:
            htr_idx     = value[0]
            ch_idx      = value[1]
            state  = value[2]
            MODULE_LOGGER.debug(f&#34;do: set_enable({htr_idx}, {ch_idx}, {state})&#34;)
            self.model.set_enable(htr_idx, ch_idx, state)
            
        if action == &#34;set_pid_enable&#34;:
            ch          = value[0]
            MODULE_LOGGER.debug(f&#34;do: set_pid_enable({ch}&#34;)
            self.model.set_pid_enable(ch)
            
        if action == &#34;set_pid_disable&#34;:
            ch          = value[0]
            MODULE_LOGGER.info(f&#34;do: set_pid_disable({ch})&#34;)
            self.model.set_pid_disable(ch)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, changed_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, changed_object):

    text = changed_object.text()

    if text == &#34;Reconnect&#34;:

        if changed_object.isChecked():

            MODULE_LOGGER.debug(&#34;Reconnecting the Heater model.&#34;)

            if self.model.reconnect():

                self.view.set_connection_state(True)

                if not self.model.has_commands():

                    self.model.load_commands()

            else:
                self.view.reconnect_action.setChecked(False)
        else:

            MODULE_LOGGER.debug(&#34;Disconnecting the Heater model.&#34;)
            self.model.disconnect()
            self.view.set_connection_state(False)

        return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel"><code class="flex name class">
<span>class <span class="ident">HeaterUIModel</span></span>
<span>(</span><span>mode)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaterUIModel:
    def __init__(self, mode):
            self.mode = mode

            if self.mode == &#39;proxy&#39;:
                try:
                    self.heater = BeagleboneProxy()
                except Exception as exc:
                    raise exc

            elif self.mode == &#39;simulator&#39;:
                self.heater = BeagleboneSimulator()
            else:
                raise ValueError(f&#39;Unknown type of Heater implementation passed into the model&#39;)
            
            if self.heater is not None:
                MODULE_LOGGER.debug(f&#39;Heater Controller initialized as {self.heater.__class__.__name__}&#39;)


    def set_enable(self, htr_idx, ch_idx, enable):
        with BeagleboneProxy() as heater:
            heater.set_enable(htr_idx, ch_idx, enable)
        
    def set_duty_cycle(self, htr_idx, ch_idx, duty_cycle):
        with BeagleboneProxy() as heater:
            heater.set_duty_cycle(htr_idx, ch_idx, duty_cycle)

    def set_pid_enable(self, ch):
        try:
            with PidProxy() as pid:
                pid.enable(ch)
        except:
            MODULE_LOGGER.info(&#34;PID Control Server could not be found&#34;)
        
    def set_pid_disable(self, ch):
        MODULE_LOGGER.info(f&#34;PID channel {ch} has been disabled&#34;)
        try:
            with PidProxy() as pid:
                pid.disable(ch)
        except:
            MODULE_LOGGER.info(&#34;PID Control Server could not be found&#34;)
    
    def has_commands(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:
                return heater.has_commands()

        return True

    def load_commands(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:
                with PidProxy() as pid:
                    pid.load_commands()
                    heater.load_commands()

    def is_simulator(self):
        with BeagleboneProxy() as heater:
            return heater.is_simulator()

    def is_connected(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:
                return heater.is_cs_connected()

        else:

            return self.heater.is_connected()

    def reconnect(self):
        if self.mode == &#34;proxy&#34;:
            with BeagleboneProxy() as heater:

                heater.reconnect_cs()

                return heater.is_cs_connected()

        else:

            self.heater.reconnect()

            return self.heater.is_connected()

        return False

    def disconnect(self):
        if self.mode == &#34;proxy&#34;:

            self.mode.disconnect_cs()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    if self.mode == &#34;proxy&#34;:

        self.mode.disconnect_cs()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.has_commands"><code class="name flex">
<span>def <span class="ident">has_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_commands(self):
    if self.mode == &#34;proxy&#34;:
        with BeagleboneProxy() as heater:
            return heater.has_commands()

    return True</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    if self.mode == &#34;proxy&#34;:
        with BeagleboneProxy() as heater:
            return heater.is_cs_connected()

    else:

        return self.heater.is_connected()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.is_simulator"><code class="name flex">
<span>def <span class="ident">is_simulator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulator(self):
    with BeagleboneProxy() as heater:
        return heater.is_simulator()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(self):
    if self.mode == &#34;proxy&#34;:
        with BeagleboneProxy() as heater:
            with PidProxy() as pid:
                pid.load_commands()
                heater.load_commands()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    if self.mode == &#34;proxy&#34;:
        with BeagleboneProxy() as heater:

            heater.reconnect_cs()

            return heater.is_cs_connected()

    else:

        self.heater.reconnect()

        return self.heater.is_connected()

    return False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_duty_cycle"><code class="name flex">
<span>def <span class="ident">set_duty_cycle</span></span>(<span>self, htr_idx, ch_idx, duty_cycle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_cycle(self, htr_idx, ch_idx, duty_cycle):
    with BeagleboneProxy() as heater:
        heater.set_duty_cycle(htr_idx, ch_idx, duty_cycle)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_enable"><code class="name flex">
<span>def <span class="ident">set_enable</span></span>(<span>self, htr_idx, ch_idx, enable)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable(self, htr_idx, ch_idx, enable):
    with BeagleboneProxy() as heater:
        heater.set_enable(htr_idx, ch_idx, enable)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_pid_disable"><code class="name flex">
<span>def <span class="ident">set_pid_disable</span></span>(<span>self, ch)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_disable(self, ch):
    MODULE_LOGGER.info(f&#34;PID channel {ch} has been disabled&#34;)
    try:
        with PidProxy() as pid:
            pid.disable(ch)
    except:
        MODULE_LOGGER.info(&#34;PID Control Server could not be found&#34;)</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_pid_enable"><code class="name flex">
<span>def <span class="ident">set_pid_enable</span></span>(<span>self, ch)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pid_enable(self, ch):
    try:
        with PidProxy() as pid:
            pid.enable(ch)
    except:
        MODULE_LOGGER.info(&#34;PID Control Server could not be found&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView"><code class="flex name class">
<span>class <span class="ident">HeaterUIView</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaterUIView(QMainWindow, Observable):
    def __init__(self):
        super().__init__()
        self.setGeometry(300, 300, 1200, 300)
        self.setWindowTitle(&#34;Beaglebone Heaters&#34;)
        
        self.heaters = {}
        self.enabled_pid = []
        
        setup = get_setup()
        self.heater_availability = [True for available in setup.gse.beaglebone_heater.availability if available] 
        self.pids                = setup.gse.spid
        heaters      = self.pids.configuration.heaters

        self.channels = [channel for heater in heaters.values() for channel in heater]

        self.initUI()
        
        self.heater_monitoring_thread = QThread(self)
        self.heater_monitoring_worker = HeaterMonitoringWorker()
        self.heater_monitoring_worker.moveToThread(self.heater_monitoring_thread)
        
        self.pid_monitoring_thread = QThread(self)
        self.pid_monitoring_worker = PidMonitoringWorker()
        self.pid_monitoring_worker.moveToThread(self.pid_monitoring_thread)

        self.heater_monitoring_worker.heater_enabled_status_signal.connect(self.on_heater_enabled_status_signal)
        self.heater_monitoring_worker.heater_duty_cycle_status_signal.connect(self.on_heater_duty_cycle_status_signal)
        
        self.pid_monitoring_worker.pid_enabled_status_signal.connect(self.on_pid_enabled_status_signal)

        self.heater_monitoring_thread.started.connect(self.heater_monitoring_worker.start_process)
        self.heater_monitoring_thread.start()
        
        self.pid_monitoring_thread.started.connect(self.pid_monitoring_worker.start_process)
        self.pid_monitoring_thread.start()
                
    
    def on_pid_enabled_status_signal(self, monitoring_info: dict):
        for heater_channel, enabled in monitoring_info.items():
            command = heater_channel.split(&#34;_&#34;)
            htr = int(command[0])
            ch = int(command[1])
            if enabled:

                self.heaters[htr].channel[ch].pid_button.show()
                self.heaters[htr].channel[ch].textbox.setReadOnly(True)
                self.heaters[htr].channel[ch].setStyleSheet(&#34;&#34;&#34;QGroupBox {border: 1px solid red;}&#34;&#34;&#34;)
            
            else:
                self.heaters[htr].channel[ch].pid_button.hide()
                self.heaters[htr].channel[ch].textbox.setReadOnly(False)
                self.heaters[htr].channel[ch].setStyleSheet(&#39;fusion&#39;) 

    def on_heater_enabled_status_signal(self, monitoring_info: dict):
        for htr in range(len(self.heater_availability)):
            for ch in range(0, 4):
                self.heaters[htr].channel[ch].switch.set_selected(monitoring_info[htr][ch])
        
    def on_heater_duty_cycle_status_signal(self, monitoring_info: dict):
        for htr in range(len(self.heater_availability)):
            for ch in range(0, 4):
                self.heaters[htr].channel[ch].textbox.setText(str(int(monitoring_info[htr][ch] / 100)))
                
    def initUI(self):
        
        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)
        
        layout = QHBoxLayout()
    
        for htr in range(len(self.heater_availability)):
            avail = self.heater_availability[htr] 
            
            self.heaters[htr] = HeaterWidget(heater=htr)
            self.heaters[htr].led.set_color(1 if avail else 0)
            
            layout.addWidget(self.heaters[htr])
            
            for ch_idx, channel in enumerate(range(0, 4)):
                self.heaters[htr].channel[ch_idx].textbox.returnPressed.connect(self.set_duty_cycle)
                self.heaters[htr].channel[ch_idx].switch.clicked.connect(self.set_enable)
                self.heaters[htr].channel[ch_idx].pid_button.clicked.connect(self.turn_off_pid)
       
        app_frame.setLayout(layout)
        self.setCentralWidget(app_frame)   
        
    def set_duty_cycle(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        _htr_idx = int(command[1])
        _ch_idx  = int(command[3])
        _channelUI = self.heaters[_htr_idx].channel[_ch_idx]
        _duty_cycle = _channelUI.textbox.text()
        _duty_cycle = (float(_duty_cycle) / 100) * 10000
        MODULE_LOGGER.info(f&#34;Heater {_htr_idx+1} Channel {_ch_idx+1} Duty_Cycle {_duty_cycle}&#34;)
        self.actionObservers({&#34;set_duty_cycle&#34;: [_htr_idx, _ch_idx, _duty_cycle]})
    
    def turn_off_pid(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        htr = int(command[1])
        ch = int(command[3])
        for idx, pid in enumerate(self.channels):
            if (pid[3] is htr) and (pid[4] is ch):
                self.actionObservers({&#34;set_pid_disable&#34;: [idx]}) if (pid[3] is htr and pid[4] is ch) else None

    def set_enable(self):
        sender = self.sender()
        command = sender.objectName().split(&#34; &#34;)
        state = sender.is_selected()
        new_state = state
        sender.set_selected(on=new_state)
        _htr_idx = int(command[1])
        _ch_idx  = int(command[3])
        MODULE_LOGGER.info(f&#34;Heater {_htr_idx + 1} Channel {_ch_idx + 1} now has state { new_state}&#34;)
        self.actionObservers({&#34;set_enable&#34; : [_htr_idx, _ch_idx, new_state]})
            
    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        self.heater_monitoring_worker.stop()
        self.heater_monitoring_thread.quit()
        self.pid_monitoring_thread.quit()
        self.pid_monitoring_worker.stop()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li><a title="egse.observer.Observable" href="../../observer.html#egse.observer.Observable">Observable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, close_event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>closeEvent(self, QCloseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, close_event: QCloseEvent) -&gt; None:
    self.heater_monitoring_worker.stop()
    self.heater_monitoring_thread.quit()
    self.pid_monitoring_thread.quit()
    self.pid_monitoring_worker.stop()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    
    app_frame = QFrame()
    app_frame.setObjectName(&#34;AppFrame&#34;)
    
    layout = QHBoxLayout()

    for htr in range(len(self.heater_availability)):
        avail = self.heater_availability[htr] 
        
        self.heaters[htr] = HeaterWidget(heater=htr)
        self.heaters[htr].led.set_color(1 if avail else 0)
        
        layout.addWidget(self.heaters[htr])
        
        for ch_idx, channel in enumerate(range(0, 4)):
            self.heaters[htr].channel[ch_idx].textbox.returnPressed.connect(self.set_duty_cycle)
            self.heaters[htr].channel[ch_idx].switch.clicked.connect(self.set_enable)
            self.heaters[htr].channel[ch_idx].pid_button.clicked.connect(self.turn_off_pid)
   
    app_frame.setLayout(layout)
    self.setCentralWidget(app_frame)   </code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_heater_duty_cycle_status_signal"><code class="name flex">
<span>def <span class="ident">on_heater_duty_cycle_status_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_heater_duty_cycle_status_signal(self, monitoring_info: dict):
    for htr in range(len(self.heater_availability)):
        for ch in range(0, 4):
            self.heaters[htr].channel[ch].textbox.setText(str(int(monitoring_info[htr][ch] / 100)))</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_heater_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">on_heater_enabled_status_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_heater_enabled_status_signal(self, monitoring_info: dict):
    for htr in range(len(self.heater_availability)):
        for ch in range(0, 4):
            self.heaters[htr].channel[ch].switch.set_selected(monitoring_info[htr][ch])</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_pid_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">on_pid_enabled_status_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pid_enabled_status_signal(self, monitoring_info: dict):
    for heater_channel, enabled in monitoring_info.items():
        command = heater_channel.split(&#34;_&#34;)
        htr = int(command[0])
        ch = int(command[1])
        if enabled:

            self.heaters[htr].channel[ch].pid_button.show()
            self.heaters[htr].channel[ch].textbox.setReadOnly(True)
            self.heaters[htr].channel[ch].setStyleSheet(&#34;&#34;&#34;QGroupBox {border: 1px solid red;}&#34;&#34;&#34;)
        
        else:
            self.heaters[htr].channel[ch].pid_button.hide()
            self.heaters[htr].channel[ch].textbox.setReadOnly(False)
            self.heaters[htr].channel[ch].setStyleSheet(&#39;fusion&#39;) </code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.set_duty_cycle"><code class="name flex">
<span>def <span class="ident">set_duty_cycle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_cycle(self):
    sender = self.sender()
    command = sender.objectName().split(&#34; &#34;)
    _htr_idx = int(command[1])
    _ch_idx  = int(command[3])
    _channelUI = self.heaters[_htr_idx].channel[_ch_idx]
    _duty_cycle = _channelUI.textbox.text()
    _duty_cycle = (float(_duty_cycle) / 100) * 10000
    MODULE_LOGGER.info(f&#34;Heater {_htr_idx+1} Channel {_ch_idx+1} Duty_Cycle {_duty_cycle}&#34;)
    self.actionObservers({&#34;set_duty_cycle&#34;: [_htr_idx, _ch_idx, _duty_cycle]})</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.set_enable"><code class="name flex">
<span>def <span class="ident">set_enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable(self):
    sender = self.sender()
    command = sender.objectName().split(&#34; &#34;)
    state = sender.is_selected()
    new_state = state
    sender.set_selected(on=new_state)
    _htr_idx = int(command[1])
    _ch_idx  = int(command[3])
    MODULE_LOGGER.info(f&#34;Heater {_htr_idx + 1} Channel {_ch_idx + 1} now has state { new_state}&#34;)
    self.actionObservers({&#34;set_enable&#34; : [_htr_idx, _ch_idx, new_state]})</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.turn_off_pid"><code class="name flex">
<span>def <span class="ident">turn_off_pid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def turn_off_pid(self):
    sender = self.sender()
    command = sender.objectName().split(&#34; &#34;)
    htr = int(command[1])
    ch = int(command[3])
    for idx, pid in enumerate(self.channels):
        if (pid[3] is htr) and (pid[4] is ch):
            self.actionObservers({&#34;set_pid_disable&#34;: [idx]}) if (pid[3] is htr and pid[4] is ch) else None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterWidget"><code class="flex name class">
<span>class <span class="ident">HeaterWidget</span></span>
<span>(</span><span>heater)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaterWidget(QGroupBox):
 
    def __init__(self, heater):
        super().__init__()
        self._heater = heater
        self.channel = [None] * 4
        
        name=f&#34;Heater {self._heater + 1}&#34;
        
        hbox = QHBoxLayout() 
          
        label = QLabel(name) 
        self.led = Led(self)
         
        hbox.addWidget(label)
        hbox.addWidget(self.led)
        
        layout = QVBoxLayout()
        
        layout.addLayout(hbox)

        for idx, ch in enumerate(range(0, 4)):
            self.channel[idx] = ChannelWidget(heater=self._heater, channel=ch)
            self.channel[idx].setObjectName(f&#34;{self._heater}_{ch}&#34;)
            layout.addWidget(self.channel[idx])
            
        self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker"><code class="flex name class">
<span>class <span class="ident">PidMonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the state of the individual PID channels</p>
<p>The worker will send a signal when the state of a PID channel has changed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PidMonitoringWorker(QObject):
    &#34;&#34;&#34;Worker for monitoring the state of the individual PID channels

   The worker will send a signal when the state of a PID channel has changed

    &#34;&#34;&#34;
    
    pid_control_server_status_signal = pyqtSignal(bool)
    pid_enabled_status_signal        = pyqtSignal(dict)
    
    def __init__(self):
        super(PidMonitoringWorker, self).__init__()
        
        self.active = False
        self.just_reconnected = True
        
        self.enabled = False
        self.pid_enabled = []
        
        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5
        
        self.connect_socket()
        
        self.previous_control_server_status_signal = ()
        self.previous_pid_enabled_status_signal = {}


    def connect_socket(self):
        try:
            transport   = PID_CTRL_SETTINGS.PROTOCOL
            hostname    = PID_CTRL_SETTINGS.HOSTNAME
            
            monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
            monitoring_address = connect_address(transport, hostname, monitoring_port)
            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
            
            
            self.monitoring_timeout = 0.5
            
            self.is_socket_connected = True
            
        except:
            self.is_socket_connected = False
            
    def stop(self):
        self.monitoring_socket.close()
        self.is_socket_connected = False
        
        self.active = False
        
    def start_process(self):
        self.run()
        
    @pyqtSlot()
    def run(self):
        self.active = True
        while self.is_socket_connected and self.active:
            
            try:
                socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)
                if self.monitoring_socket in socket_list:
                    self.enabled = True
                    pickle_string = self.monitoring_socket.recv()

                    monitoring_info = pickle.loads(pickle_string)
                    
                    self.pid_enabled      = monitoring_info[&#39;Enabled&#39;]
                    
                    if self.previous_pid_enabled_status_signal != self.pid_enabled:
                        self.pid_enabled_status_signal.emit(self.pid_enabled)
                    
                if self.previous_control_server_status_signal != self.enabled:
                    self.pid_control_server_status_signal.emit(self.enabled)
                    
                self.previous_control_server_status_signal = self.enabled
                self.previous_pid_enabled_status_signal = self.pid_enabled
            except ZMQError as exc:
                raise exc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    try:
        transport   = PID_CTRL_SETTINGS.PROTOCOL
        hostname    = PID_CTRL_SETTINGS.HOSTNAME
        
        monitoring_port = PID_CTRL_SETTINGS.MONITORING_PORT
        monitoring_address = connect_address(transport, hostname, monitoring_port)
        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)
        
        
        self.monitoring_timeout = 0.5
        
        self.is_socket_connected = True
        
    except:
        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.pid_control_server_status_signal"><code class="name flex">
<span>def <span class="ident">pid_control_server_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.pid_enabled_status_signal"><code class="name flex">
<span>def <span class="ident">pid_enabled_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    self.active = True
    while self.is_socket_connected and self.active:
        
        try:
            socket_list, _, exc_list = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)
            if self.monitoring_socket in socket_list:
                self.enabled = True
                pickle_string = self.monitoring_socket.recv()

                monitoring_info = pickle.loads(pickle_string)
                
                self.pid_enabled      = monitoring_info[&#39;Enabled&#39;]
                
                if self.previous_pid_enabled_status_signal != self.pid_enabled:
                    self.pid_enabled_status_signal.emit(self.pid_enabled)
                
            if self.previous_control_server_status_signal != self.enabled:
                self.pid_control_server_status_signal.emit(self.enabled)
                
            self.previous_control_server_status_signal = self.enabled
            self.previous_pid_enabled_status_signal = self.pid_enabled
        except ZMQError as exc:
            raise exc</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    self.run()</code></pre>
</details>
</dd>
<dt id="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.monitoring_socket.close()
    self.is_socket_connected = False
    
    self.active = False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tempcontrol.beaglebone" href="index.html">egse.tempcontrol.beaglebone</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.main" href="#egse.tempcontrol.beaglebone.beaglebone_ui.main">main</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.parse_arguments" href="#egse.tempcontrol.beaglebone.beaglebone_ui.parse_arguments">parse_arguments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.ChannelWidget" href="#egse.tempcontrol.beaglebone.beaglebone_ui.ChannelWidget">ChannelWidget</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker">HeaterMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.connect_socket" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.heater_duty_cycle_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.heater_duty_cycle_status_signal">heater_duty_cycle_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.heater_enabled_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.heater_enabled_status_signal">heater_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.run" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.start_process" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.stop" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterMonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController">HeaterUIController</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController.do" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController.do">do</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController.update" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIController.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel">HeaterUIModel</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.disconnect" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.disconnect">disconnect</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.has_commands" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.has_commands">has_commands</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.is_connected" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.is_connected">is_connected</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.is_simulator" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.load_commands" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.load_commands">load_commands</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.reconnect" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.reconnect">reconnect</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_duty_cycle" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_duty_cycle">set_duty_cycle</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_enable" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_enable">set_enable</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_pid_disable" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_pid_disable">set_pid_disable</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_pid_enable" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIModel.set_pid_enable">set_pid_enable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView">HeaterUIView</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.closeEvent" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.closeEvent">closeEvent</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.initUI" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.initUI">initUI</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_heater_duty_cycle_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_heater_duty_cycle_status_signal">on_heater_duty_cycle_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_heater_enabled_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_heater_enabled_status_signal">on_heater_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_pid_enabled_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.on_pid_enabled_status_signal">on_pid_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.set_duty_cycle" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.set_duty_cycle">set_duty_cycle</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.set_enable" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.set_enable">set_enable</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.turn_off_pid" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterUIView.turn_off_pid">turn_off_pid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.HeaterWidget" href="#egse.tempcontrol.beaglebone.beaglebone_ui.HeaterWidget">HeaterWidget</a></code></h4>
</li>
<li>
<h4><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker">PidMonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.connect_socket" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.pid_control_server_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.pid_control_server_status_signal">pid_control_server_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.pid_enabled_status_signal" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.pid_enabled_status_signal">pid_enabled_status_signal</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.run" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.start_process" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.stop" href="#egse.tempcontrol.beaglebone.beaglebone_ui.PidMonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.control API documentation</title>
<meta name="description" content="This module defines the abstract class for any control server and some convenience functions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.control</code></h1>
</header>
<section id="section-intro">
<p>This module defines the abstract class for any control server and some convenience functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the abstract class for any control server and some convenience functions.
&#34;&#34;&#34;
import abc
import logging
import pickle
import threading
import time
from typing import Any

import zmq

from egse.logger import close_all_zmq_handlers
from egse.process import ProcessStatus
from egse.settings import Settings
from egse.system import do_every
from egse.system import get_full_classname
from egse.system import get_host_ip

MODULE_LOGGER = logging.getLogger(__name__)
PROCESS_SETTINGS = Settings.load(&#34;PROCESS&#34;)


def time_in_ms():
    &#34;&#34;&#34;Returns the current time in milliseconds since the Epoch.&#34;&#34;&#34;
    return int(round(time.time() * 1000))


def time_in_s():
    &#34;&#34;&#34;Returns the current time in seconds since the Epoch.&#34;&#34;&#34;
    return time.time()


def is_control_server_active(endpoint: str = None, timeout: float = 0.5) -&gt; bool:
    &#34;&#34;&#34;
    Check if the control server is running. This function sends a *Ping* message to the
    control server and expects a *Pong* answer back within the timeout period.

    Args:
        endpoint (str): the endpoint to connect to, i.e. &lt;protocol&gt;://&lt;address&gt;:&lt;port&gt;
        timeout (float): timeout when waiting for a reply [seconds, default=0.5]
    Returns:
        True if the Control Server is running and replied with the expected answer.
    &#34;&#34;&#34;
    ctx = zmq.Context.instance()

    return_code = False

    try:
        socket = ctx.socket(zmq.REQ)
        socket.connect(endpoint)
        data = pickle.dumps(&#34;Ping&#34;)
        socket.send(data)
        rlist, _, _ = zmq.select([socket], [], [], timeout=timeout)
        if socket in rlist:
            data = socket.recv()
            response = pickle.loads(data)
            return_code = response == &#34;Pong&#34;
        socket.close(linger=0)
    except Exception as exc:
        MODULE_LOGGER.warning(f&#34;Caught an exception while pinging a control server at {endpoint}: {exc}.&#34;)

    return return_code


class Response:
    &#34;&#34;&#34;Base class for any reply or response between client-server communication.

    The idea is that the response is encapsulated in one of the subclasses depending
    on the type of response.
    &#34;&#34;&#34;

    def __init__(self, message: str):
        self.message = message

    def __str__(self):
        return self.message

    @property
    def successful(self):
        &#34;&#34;&#34;Returns True if the Response is not an Exception.&#34;&#34;&#34;
        return not isinstance(self, Exception)


class Failure(Response, Exception):
    &#34;&#34;&#34;A failure response indicating something went wrong at the other side.

    This class is used to encapsulate an Exception that was caught and needs to be
    passed to the client. So, the intended use is like this:
    ```
    try:
        # perform some useful action that might raise an Exception
    except SomeException as exc:
        return Failure(&#34;Our action failed&#34;, exc)
    ```
    The client can inspect the Exception that was originally raised, in this case `SomeException`
    with the `cause` variable.

    Since a Failure is also an Exception, the property `successful` will return False.
    So, the calling method can test for this easily.

    ```
    rc: Response = function_that_returns_a_response()

    if not rc.successful:
        # handle the failure
    else:
        # handle success
    ```

    &#34;&#34;&#34;

    def __init__(self, message: str, cause: Exception = None):
        msg = f&#34;{message}: {cause}&#34; if cause is not None else message
        super().__init__(msg)
        self.cause = cause


class Success(Response):
    &#34;&#34;&#34;A success response for the client.

    The return code from any action or function that needs to be returned to the
    client shall be added.

    Since `Success` doesn&#39;t inherit from `Exception`, the property `successful` will return True.
    &#34;&#34;&#34;

    def __init__(self, message: str, return_code: Any = None):
        msg = f&#34;{message}: {return_code}&#34; if return_code is not None else message
        super().__init__(msg)
        self.return_code = return_code


class Message(Response):
    &#34;&#34;&#34;A message response from the client.

    Send a Message when there is no Failure, but also no return code. This is the alternative of
    returning a None.

    Message returns True for the property successful since it doesn&#39;t inherit from Exception.
    &#34;&#34;&#34;

    pass


class ControlServer(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    The base class for all device control servers and for the Storage Manager and Configuration
    Manager. A Control Server reads commands from a ZeroMQ socket and executes these commands by
    calling the `execute()` method of the commanding protocol class.

    The sub-class shall define the following:

    * Define the device protocol class -&gt; `self.device_protocol`
    * Bind the command socket to the device protocol -&gt; `self.dev_ctrl_cmd_sock`
    * Register the command socket in the poll set -&gt; `self.poller`

    &#34;&#34;&#34;

    def __init__(self):
        from egse.monitoring import MonitoringProtocol
        from egse.services import ServiceProtocol

        self._process_status = ProcessStatus()

        self._timer_thread = threading.Thread(
            target=do_every, args=(PROCESS_SETTINGS.METRICS_INTERVAL, self._process_status.update))
        self._timer_thread.daemon = True
        self._timer_thread.start()

        # The logger will be overwritten by the sub-class, if not, then we use this logger
        # with the name of the sub-class. That will help us to identify which sub-class did not
        # overwrite the logger attribute.

        self.logger = logging.getLogger(get_full_classname(self))

        self.interrupted = False
        self.delay = 1000  # delay between publish status information [milliseconds]
        self.hk_delay = 1000  # delay between saving housekeeping information [milliseconds]

        self.zcontext = zmq.Context.instance()
        self.poller = zmq.Poller()

        self.device_protocol = None  # This will be set in the sub-class
        self.service_protocol = ServiceProtocol(self)
        self.monitoring_protocol = MonitoringProtocol(self)

        # Setup the control server waiting for service requests

        self.dev_ctrl_service_sock = self.zcontext.socket(zmq.REP)
        self.service_protocol.bind(self.dev_ctrl_service_sock)

        # Setup the control server for sending monitoring info

        self.dev_ctrl_mon_sock = self.zcontext.socket(zmq.PUB)
        self.monitoring_protocol.bind(self.dev_ctrl_mon_sock)

        # Setup the control server waiting for device commands.
        # The device protocol shall bind the socket in the sub-class

        self.dev_ctrl_cmd_sock = self.zcontext.socket(zmq.REP)

        # Initialize the poll set

        self.poller.register(self.dev_ctrl_service_sock, zmq.POLLIN)
        self.poller.register(self.dev_ctrl_mon_sock, zmq.POLLIN)

    @abc.abstractmethod
    def get_communication_protocol(self):
        pass

    @abc.abstractmethod
    def get_commanding_port(self):
        pass

    @abc.abstractmethod
    def get_service_port(self):
        pass

    @abc.abstractmethod
    def get_monitoring_port(self):
        pass

    def get_ip_address(self):
        return get_host_ip()

    def get_storage_mnemonic(self):
        return self.__class__.__name__

    def get_process_status(self):
        return self._process_status.as_dict()

    def set_delay(self, seconds):
        self.delay = seconds * 1000

    def set_hk_delay(self, seconds):
        self.hk_delay = seconds * 1000

    def set_logging_level(self, level):
        self.logger.setLevel(level=level)

    def quit(self):
        self.interrupted = True

    def before_serve(self):
        pass

    def after_serve(self):
        pass

    def serve(self):

        self.before_serve()

        # check if Storage Manager is available

        from egse.storage import is_storage_manager_active

        storage_manager = is_storage_manager_active(timeout=0.1)

        storage_manager and self.register_to_storage_manager()

        # This approach is very simplistic and not time efficient
        # We probably want to use a Timer that executes the monitoring and saving actions at
        # dedicated times in the background.

        last_time = time_in_ms()
        last_time_hk = time_in_ms()

        while True:
            try:
                socks = dict(self.poller.poll(50))  # timeout in milliseconds, do not block
            except KeyboardInterrupt:
                self.logger.warning(&#34;Keyboard interrupt caught!&#34;)
                self.logger.warning(
                    &#34;The ControlServer can not be interrupted with CTRL-C, &#34;
                    &#34;send a quit command to the server.&#34;
                )
                continue

            if self.dev_ctrl_cmd_sock in socks:
                self.device_protocol.execute()

            if self.dev_ctrl_service_sock in socks:
                self.service_protocol.execute()

            # Now handle the periodic sending out of status information. A dictionary with the
            # status or HK info is sent out periodically based on the DELAY time that is in the
            # YAML config file.

            if time_in_ms() - last_time &gt;= self.delay:
                last_time = time_in_ms()
                self.logger.log(5, &#34;Sending status to monitoring processes.&#34;)
                self.monitoring_protocol.send_status(self.device_protocol.get_status())

            if time_in_ms() - last_time_hk &gt;= self.hk_delay:
                last_time_hk = time_in_ms()
                if storage_manager:
                    self.logger.log(5, &#34;Sending housekeeping information to Storage.&#34;)
                    self.store_housekeeping_information(self.device_protocol.get_housekeeping())

            if self.interrupted:
                self.logger.info(
                    f&#34;Quit command received, closing down the {self.__class__.__name__}.&#34;
                )
                break

            # Some device protocol sub-classes might start a number of threads or processes to
            # support the commanding. Check if these threads/processes are still alive and
            # terminate gracefully if they are not.

            if not self.device_protocol.is_alive():
                self.logger.error(
                    &#34;Some Thread or sub-process that was started by Protocol has &#34;
                    &#34;died, terminating...&#34;
                )
                break

        storage_manager and self.unregister_from_storage_manager()

        self.after_serve()

        self.device_protocol.quit()

        self.dev_ctrl_mon_sock.close()
        self.dev_ctrl_service_sock.close()
        self.dev_ctrl_cmd_sock.close()

        close_all_zmq_handlers()

        self.zcontext.term()

    def store_housekeeping_information(self, data):
        &#34;&#34;&#34;Send housekeeping information to the Storage manager.&#34;&#34;&#34;

        from egse.storage.storage_cs import StorageControlServer
        from egse.storage import StorageProxy

        if isinstance(self, StorageControlServer):
            self.logger.log(0, f&#34;{self.__class__.__name__} doesn&#39;t store housekeeping information.&#34;)
            return

        self.logger.log(0, &#34;Sending housekeeping to storage manager.&#34;)

        try:
            with StorageProxy() as proxy:
                rc = proxy.save({&#34;origin&#34;: self.get_storage_mnemonic(), &#34;data&#34;: data})
                if not rc.successful:
                    self.logger.warning(
                        f&#34;Couldn&#39;t save data to the Storage manager: {data}, cause: {rc}&#34;
                    )
        except ConnectionError as exc:
            self.logger.warning(
                f&#34;Couldn&#39;t connect to the Storage manager to store housekeeping: {exc}&#34;
            )

    def register_to_storage_manager(self):
        &#34;&#34;&#34;Register this ControlServer to the Storage manager.&#34;&#34;&#34;

        from egse.storage.storage_cs import StorageControlServer
        from egse.storage import StorageProxy
        from egse.storage.persistence import CSV

        if isinstance(self, StorageControlServer):
            return

        try:
            with StorageProxy() as proxy:
                rc = proxy.register(
                    {
                        &#34;origin&#34;: self.get_storage_mnemonic(),
                        &#34;persistence_class&#34;: CSV,
                        &#34;prep&#34;: {
                            &#34;column_names&#34;: list(self.device_protocol.get_housekeeping().keys()),
                            &#34;mode&#34;: &#34;a&#34;,
                        },
                    }
                )
                if not rc.successful:
                    self.logger.warning(f&#34;Couldn&#39;t register to the Storage manager: {rc}&#34;)
        except ConnectionError as exc:
            self.logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for registration: {exc}&#34;)

    def unregister_from_storage_manager(self):
        &#34;&#34;&#34;Unregister this ControlServer from the Storage manager.&#34;&#34;&#34;

        from egse.storage.storage_cs import StorageControlServer
        from egse.storage import StorageProxy

        if isinstance(self, StorageControlServer):
            return

        try:
            with StorageProxy() as proxy:
                rc = proxy.unregister({&#34;origin&#34;: self.get_storage_mnemonic()})
                if not rc.successful:
                    self.logger.warning(f&#34;Couldn&#39;t unregister from the Storage manager: {rc}&#34;)

        except ConnectionError as exc:
            self.logger.warning(
                f&#34;Couldn&#39;t connect to the Storage manager for de-registration: {exc}&#34;
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.control.is_control_server_active"><code class="name flex">
<span>def <span class="ident">is_control_server_active</span></span>(<span>endpoint: str = None, timeout: float = 0.5) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the control server is running. This function sends a <em>Ping</em> message to the
control server and expects a <em>Pong</em> answer back within the timeout period.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>endpoint</code></strong> :&ensp;<code>str</code></dt>
<dd>the endpoint to connect to, i.e. <protocol>://<address>:<port></dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>timeout when waiting for a reply [seconds, default=0.5]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the Control Server is running and replied with the expected answer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_control_server_active(endpoint: str = None, timeout: float = 0.5) -&gt; bool:
    &#34;&#34;&#34;
    Check if the control server is running. This function sends a *Ping* message to the
    control server and expects a *Pong* answer back within the timeout period.

    Args:
        endpoint (str): the endpoint to connect to, i.e. &lt;protocol&gt;://&lt;address&gt;:&lt;port&gt;
        timeout (float): timeout when waiting for a reply [seconds, default=0.5]
    Returns:
        True if the Control Server is running and replied with the expected answer.
    &#34;&#34;&#34;
    ctx = zmq.Context.instance()

    return_code = False

    try:
        socket = ctx.socket(zmq.REQ)
        socket.connect(endpoint)
        data = pickle.dumps(&#34;Ping&#34;)
        socket.send(data)
        rlist, _, _ = zmq.select([socket], [], [], timeout=timeout)
        if socket in rlist:
            data = socket.recv()
            response = pickle.loads(data)
            return_code = response == &#34;Pong&#34;
        socket.close(linger=0)
    except Exception as exc:
        MODULE_LOGGER.warning(f&#34;Caught an exception while pinging a control server at {endpoint}: {exc}.&#34;)

    return return_code</code></pre>
</details>
</dd>
<dt id="egse.control.time_in_ms"><code class="name flex">
<span>def <span class="ident">time_in_ms</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current time in milliseconds since the Epoch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_in_ms():
    &#34;&#34;&#34;Returns the current time in milliseconds since the Epoch.&#34;&#34;&#34;
    return int(round(time.time() * 1000))</code></pre>
</details>
</dd>
<dt id="egse.control.time_in_s"><code class="name flex">
<span>def <span class="ident">time_in_s</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current time in seconds since the Epoch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_in_s():
    &#34;&#34;&#34;Returns the current time in seconds since the Epoch.&#34;&#34;&#34;
    return time.time()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.control.ControlServer"><code class="flex name class">
<span>class <span class="ident">ControlServer</span></span>
</code></dt>
<dd>
<div class="desc"><p>The base class for all device control servers and for the Storage Manager and Configuration
Manager. A Control Server reads commands from a ZeroMQ socket and executes these commands by
calling the <code>execute()</code> method of the commanding protocol class.</p>
<p>The sub-class shall define the following:</p>
<ul>
<li>Define the device protocol class -&gt; <code>self.device_protocol</code></li>
<li>Bind the command socket to the device protocol -&gt; <code>self.dev_ctrl_cmd_sock</code></li>
<li>Register the command socket in the poll set -&gt; <code>self.poller</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControlServer(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    The base class for all device control servers and for the Storage Manager and Configuration
    Manager. A Control Server reads commands from a ZeroMQ socket and executes these commands by
    calling the `execute()` method of the commanding protocol class.

    The sub-class shall define the following:

    * Define the device protocol class -&gt; `self.device_protocol`
    * Bind the command socket to the device protocol -&gt; `self.dev_ctrl_cmd_sock`
    * Register the command socket in the poll set -&gt; `self.poller`

    &#34;&#34;&#34;

    def __init__(self):
        from egse.monitoring import MonitoringProtocol
        from egse.services import ServiceProtocol

        self._process_status = ProcessStatus()

        self._timer_thread = threading.Thread(
            target=do_every, args=(PROCESS_SETTINGS.METRICS_INTERVAL, self._process_status.update))
        self._timer_thread.daemon = True
        self._timer_thread.start()

        # The logger will be overwritten by the sub-class, if not, then we use this logger
        # with the name of the sub-class. That will help us to identify which sub-class did not
        # overwrite the logger attribute.

        self.logger = logging.getLogger(get_full_classname(self))

        self.interrupted = False
        self.delay = 1000  # delay between publish status information [milliseconds]
        self.hk_delay = 1000  # delay between saving housekeeping information [milliseconds]

        self.zcontext = zmq.Context.instance()
        self.poller = zmq.Poller()

        self.device_protocol = None  # This will be set in the sub-class
        self.service_protocol = ServiceProtocol(self)
        self.monitoring_protocol = MonitoringProtocol(self)

        # Setup the control server waiting for service requests

        self.dev_ctrl_service_sock = self.zcontext.socket(zmq.REP)
        self.service_protocol.bind(self.dev_ctrl_service_sock)

        # Setup the control server for sending monitoring info

        self.dev_ctrl_mon_sock = self.zcontext.socket(zmq.PUB)
        self.monitoring_protocol.bind(self.dev_ctrl_mon_sock)

        # Setup the control server waiting for device commands.
        # The device protocol shall bind the socket in the sub-class

        self.dev_ctrl_cmd_sock = self.zcontext.socket(zmq.REP)

        # Initialize the poll set

        self.poller.register(self.dev_ctrl_service_sock, zmq.POLLIN)
        self.poller.register(self.dev_ctrl_mon_sock, zmq.POLLIN)

    @abc.abstractmethod
    def get_communication_protocol(self):
        pass

    @abc.abstractmethod
    def get_commanding_port(self):
        pass

    @abc.abstractmethod
    def get_service_port(self):
        pass

    @abc.abstractmethod
    def get_monitoring_port(self):
        pass

    def get_ip_address(self):
        return get_host_ip()

    def get_storage_mnemonic(self):
        return self.__class__.__name__

    def get_process_status(self):
        return self._process_status.as_dict()

    def set_delay(self, seconds):
        self.delay = seconds * 1000

    def set_hk_delay(self, seconds):
        self.hk_delay = seconds * 1000

    def set_logging_level(self, level):
        self.logger.setLevel(level=level)

    def quit(self):
        self.interrupted = True

    def before_serve(self):
        pass

    def after_serve(self):
        pass

    def serve(self):

        self.before_serve()

        # check if Storage Manager is available

        from egse.storage import is_storage_manager_active

        storage_manager = is_storage_manager_active(timeout=0.1)

        storage_manager and self.register_to_storage_manager()

        # This approach is very simplistic and not time efficient
        # We probably want to use a Timer that executes the monitoring and saving actions at
        # dedicated times in the background.

        last_time = time_in_ms()
        last_time_hk = time_in_ms()

        while True:
            try:
                socks = dict(self.poller.poll(50))  # timeout in milliseconds, do not block
            except KeyboardInterrupt:
                self.logger.warning(&#34;Keyboard interrupt caught!&#34;)
                self.logger.warning(
                    &#34;The ControlServer can not be interrupted with CTRL-C, &#34;
                    &#34;send a quit command to the server.&#34;
                )
                continue

            if self.dev_ctrl_cmd_sock in socks:
                self.device_protocol.execute()

            if self.dev_ctrl_service_sock in socks:
                self.service_protocol.execute()

            # Now handle the periodic sending out of status information. A dictionary with the
            # status or HK info is sent out periodically based on the DELAY time that is in the
            # YAML config file.

            if time_in_ms() - last_time &gt;= self.delay:
                last_time = time_in_ms()
                self.logger.log(5, &#34;Sending status to monitoring processes.&#34;)
                self.monitoring_protocol.send_status(self.device_protocol.get_status())

            if time_in_ms() - last_time_hk &gt;= self.hk_delay:
                last_time_hk = time_in_ms()
                if storage_manager:
                    self.logger.log(5, &#34;Sending housekeeping information to Storage.&#34;)
                    self.store_housekeeping_information(self.device_protocol.get_housekeeping())

            if self.interrupted:
                self.logger.info(
                    f&#34;Quit command received, closing down the {self.__class__.__name__}.&#34;
                )
                break

            # Some device protocol sub-classes might start a number of threads or processes to
            # support the commanding. Check if these threads/processes are still alive and
            # terminate gracefully if they are not.

            if not self.device_protocol.is_alive():
                self.logger.error(
                    &#34;Some Thread or sub-process that was started by Protocol has &#34;
                    &#34;died, terminating...&#34;
                )
                break

        storage_manager and self.unregister_from_storage_manager()

        self.after_serve()

        self.device_protocol.quit()

        self.dev_ctrl_mon_sock.close()
        self.dev_ctrl_service_sock.close()
        self.dev_ctrl_cmd_sock.close()

        close_all_zmq_handlers()

        self.zcontext.term()

    def store_housekeeping_information(self, data):
        &#34;&#34;&#34;Send housekeeping information to the Storage manager.&#34;&#34;&#34;

        from egse.storage.storage_cs import StorageControlServer
        from egse.storage import StorageProxy

        if isinstance(self, StorageControlServer):
            self.logger.log(0, f&#34;{self.__class__.__name__} doesn&#39;t store housekeeping information.&#34;)
            return

        self.logger.log(0, &#34;Sending housekeeping to storage manager.&#34;)

        try:
            with StorageProxy() as proxy:
                rc = proxy.save({&#34;origin&#34;: self.get_storage_mnemonic(), &#34;data&#34;: data})
                if not rc.successful:
                    self.logger.warning(
                        f&#34;Couldn&#39;t save data to the Storage manager: {data}, cause: {rc}&#34;
                    )
        except ConnectionError as exc:
            self.logger.warning(
                f&#34;Couldn&#39;t connect to the Storage manager to store housekeeping: {exc}&#34;
            )

    def register_to_storage_manager(self):
        &#34;&#34;&#34;Register this ControlServer to the Storage manager.&#34;&#34;&#34;

        from egse.storage.storage_cs import StorageControlServer
        from egse.storage import StorageProxy
        from egse.storage.persistence import CSV

        if isinstance(self, StorageControlServer):
            return

        try:
            with StorageProxy() as proxy:
                rc = proxy.register(
                    {
                        &#34;origin&#34;: self.get_storage_mnemonic(),
                        &#34;persistence_class&#34;: CSV,
                        &#34;prep&#34;: {
                            &#34;column_names&#34;: list(self.device_protocol.get_housekeeping().keys()),
                            &#34;mode&#34;: &#34;a&#34;,
                        },
                    }
                )
                if not rc.successful:
                    self.logger.warning(f&#34;Couldn&#39;t register to the Storage manager: {rc}&#34;)
        except ConnectionError as exc:
            self.logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for registration: {exc}&#34;)

    def unregister_from_storage_manager(self):
        &#34;&#34;&#34;Unregister this ControlServer from the Storage manager.&#34;&#34;&#34;

        from egse.storage.storage_cs import StorageControlServer
        from egse.storage import StorageProxy

        if isinstance(self, StorageControlServer):
            return

        try:
            with StorageProxy() as proxy:
                rc = proxy.unregister({&#34;origin&#34;: self.get_storage_mnemonic()})
                if not rc.successful:
                    self.logger.warning(f&#34;Couldn&#39;t unregister from the Storage manager: {rc}&#34;)

        except ConnectionError as exc:
            self.logger.warning(
                f&#34;Couldn&#39;t connect to the Storage manager for de-registration: {exc}&#34;
            )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu_cs.AEUControlServer" href="aeu/aeu_cs.html#egse.aeu.aeu_cs.AEUControlServer">AEUControlServer</a></li>
<li><a title="egse.collimator.fcul.ogse_cs.OGSEControlServer" href="collimator/fcul/ogse_cs.html#egse.collimator.fcul.ogse_cs.OGSEControlServer">OGSEControlServer</a></li>
<li><a title="egse.confman.confman_cs.ConfigurationManagerControlServer" href="confman/confman_cs.html#egse.confman.confman_cs.ConfigurationManagerControlServer">ConfigurationManagerControlServer</a></li>
<li><a title="egse.dpu.dpu_cs.DPUControlServer" href="dpu/dpu_cs.html#egse.dpu.dpu_cs.DPUControlServer">DPUControlServer</a></li>
<li><a title="egse.dummy.DummyControlServer" href="dummy.html#egse.dummy.DummyControlServer">DummyControlServer</a></li>
<li><a title="egse.fdir.fdir_manager_cs.FdirManagerControlServer" href="fdir/fdir_manager_cs.html#egse.fdir.fdir_manager_cs.FdirManagerControlServer">FdirManagerControlServer</a></li>
<li><a title="egse.fdir.fdir_remote_cs.FdirRemoteControlServer" href="fdir/fdir_remote_cs.html#egse.fdir.fdir_remote_cs.FdirRemoteControlServer">FdirRemoteControlServer</a></li>
<li><a title="egse.fdir.gsm.beaglebone_cs.BeagleBoneControlServer" href="fdir/gsm/beaglebone_cs.html#egse.fdir.gsm.beaglebone_cs.BeagleBoneControlServer">BeagleBoneControlServer</a></li>
<li><a title="egse.filterwheel.eksma.fw8smc4_cs.FilterWheelControlServer" href="filterwheel/eksma/fw8smc4_cs.html#egse.filterwheel.eksma.fw8smc4_cs.FilterWheelControlServer">FilterWheelControlServer</a></li>
<li><a title="egse.filterwheel.eksma.fw8smc5_cs.Fw8Smc5ControlServer" href="filterwheel/eksma/fw8smc5_cs.html#egse.filterwheel.eksma.fw8smc5_cs.Fw8Smc5ControlServer">Fw8Smc5ControlServer</a></li>
<li><a title="egse.hexapod.symetrie.puna_cs.PunaControlServer" href="hexapod/symetrie/puna_cs.html#egse.hexapod.symetrie.puna_cs.PunaControlServer">PunaControlServer</a></li>
<li><a title="egse.hexapod.symetrie.zonda_cs.ZondaControlServer" href="hexapod/symetrie/zonda_cs.html#egse.hexapod.symetrie.zonda_cs.ZondaControlServer">ZondaControlServer</a></li>
<li><a title="egse.lampcontrol.beaglebone.beaglebone_cs.BeagleBoneControlServer" href="lampcontrol/beaglebone/beaglebone_cs.html#egse.lampcontrol.beaglebone.beaglebone_cs.BeagleBoneControlServer">BeagleBoneControlServer</a></li>
<li><a title="egse.lampcontrol.energetiq.lampEQ99_cs.LampControlServer" href="lampcontrol/energetiq/lampEQ99_cs.html#egse.lampcontrol.energetiq.lampEQ99_cs.LampControlServer">LampControlServer</a></li>
<li><a title="egse.powermeter.ni.cdaq9184_cs.cdaq9184ControlServer" href="powermeter/ni/cdaq9184_cs.html#egse.powermeter.ni.cdaq9184_cs.cdaq9184ControlServer">cdaq9184ControlServer</a></li>
<li><a title="egse.powermeter.thorlabs.pm100a_cs.ThorlabsPM100ControlServer" href="powermeter/thorlabs/pm100a_cs.html#egse.powermeter.thorlabs.pm100a_cs.ThorlabsPM100ControlServer">ThorlabsPM100ControlServer</a></li>
<li><a title="egse.procman.procman_cs.ProcessManagerControlServer" href="procman/procman_cs.html#egse.procman.procman_cs.ProcessManagerControlServer">ProcessManagerControlServer</a></li>
<li><a title="egse.shutter.thorlabs.ksc101_cs.ShutterKSC101ControlServer" href="shutter/thorlabs/ksc101_cs.html#egse.shutter.thorlabs.ksc101_cs.ShutterKSC101ControlServer">ShutterKSC101ControlServer</a></li>
<li><a title="egse.shutter.thorlabs.sc10_cs.Sc10ControlServer" href="shutter/thorlabs/sc10_cs.html#egse.shutter.thorlabs.sc10_cs.Sc10ControlServer">Sc10ControlServer</a></li>
<li><a title="egse.stages.aerotech.ensemble_cs.EnsembleControlServer" href="stages/aerotech/ensemble_cs.html#egse.stages.aerotech.ensemble_cs.EnsembleControlServer">EnsembleControlServer</a></li>
<li><a title="egse.stages.arun.smd3_cs.Smd3ControlServer" href="stages/arun/smd3_cs.html#egse.stages.arun.smd3_cs.Smd3ControlServer">Smd3ControlServer</a></li>
<li><a title="egse.stages.huber.smc9300_cs.HuberSMC9300ControlServer" href="stages/huber/smc9300_cs.html#egse.stages.huber.smc9300_cs.HuberSMC9300ControlServer">HuberSMC9300ControlServer</a></li>
<li><a title="egse.storage.storage_cs.StorageControlServer" href="storage/storage_cs.html#egse.storage.storage_cs.StorageControlServer">StorageControlServer</a></li>
<li><a title="egse.synoptics.syn_cs.SynopticsManager" href="synoptics/syn_cs.html#egse.synoptics.syn_cs.SynopticsManager">SynopticsManager</a></li>
<li><a title="egse.tcs.tcs_cs.TCSControlServer" href="tcs/tcs_cs.html#egse.tcs.tcs_cs.TCSControlServer">TCSControlServer</a></li>
<li><a title="egse.tempcontrol.agilent.agilent34970_cs.Agilent34970ControlServer" href="tempcontrol/agilent/agilent34970_cs.html#egse.tempcontrol.agilent.agilent34970_cs.Agilent34970ControlServer">Agilent34970ControlServer</a></li>
<li><a title="egse.tempcontrol.agilent.agilent34972_cs.Agilent34972ControlServer" href="tempcontrol/agilent/agilent34972_cs.html#egse.tempcontrol.agilent.agilent34972_cs.Agilent34972ControlServer">Agilent34972ControlServer</a></li>
<li><a title="egse.tempcontrol.beaglebone.beaglebone_cs.BeagleBoneControlServer" href="tempcontrol/beaglebone/beaglebone_cs.html#egse.tempcontrol.beaglebone.beaglebone_cs.BeagleBoneControlServer">BeagleBoneControlServer</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510_cs.DAQ6510ControlServer" href="tempcontrol/keithley/daq6510_cs.html#egse.tempcontrol.keithley.daq6510_cs.DAQ6510ControlServer">DAQ6510ControlServer</a></li>
<li><a title="egse.tempcontrol.lakeshore.lsci336_cs.LakeShore336ControlServer" href="tempcontrol/lakeshore/lsci336_cs.html#egse.tempcontrol.lakeshore.lsci336_cs.LakeShore336ControlServer">LakeShore336ControlServer</a></li>
<li><a title="egse.tempcontrol.spid.spid_cs.PidControlServer" href="tempcontrol/spid/spid_cs.html#egse.tempcontrol.spid.spid_cs.PidControlServer">PidControlServer</a></li>
<li><a title="egse.tempcontrol.srs.ptc10_cs.ptc10ControlServer" href="tempcontrol/srs/ptc10_cs.html#egse.tempcontrol.srs.ptc10_cs.ptc10ControlServer">ptc10ControlServer</a></li>
<li><a title="egse.ups.apc.apc_cs.APCControlServer" href="ups/apc/apc_cs.html#egse.ups.apc.apc_cs.APCControlServer">APCControlServer</a></li>
<li><a title="egse.vacuum.beaglebone.beaglebone_cs.BeagleBoneControlServer" href="vacuum/beaglebone/beaglebone_cs.html#egse.vacuum.beaglebone.beaglebone_cs.BeagleBoneControlServer">BeagleBoneControlServer</a></li>
<li><a title="egse.vacuum.instrutech.igm402_cs.Igm402ControlServer" href="vacuum/instrutech/igm402_cs.html#egse.vacuum.instrutech.igm402_cs.Igm402ControlServer">Igm402ControlServer</a></li>
<li><a title="egse.vacuum.mks.vacscan_cs.VacscanControlServer" href="vacuum/mks/vacscan_cs.html#egse.vacuum.mks.vacscan_cs.VacscanControlServer">VacscanControlServer</a></li>
<li><a title="egse.vacuum.pfeiffer.acp40_cs.Acp40ControlServer" href="vacuum/pfeiffer/acp40_cs.html#egse.vacuum.pfeiffer.acp40_cs.Acp40ControlServer">Acp40ControlServer</a></li>
<li><a title="egse.vacuum.pfeiffer.tc400_cs.Tc400ControlServer" href="vacuum/pfeiffer/tc400_cs.html#egse.vacuum.pfeiffer.tc400_cs.Tc400ControlServer">Tc400ControlServer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.control.ControlServer.after_serve"><code class="name flex">
<span>def <span class="ident">after_serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def after_serve(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.before_serve"><code class="name flex">
<span>def <span class="ident">before_serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_serve(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_commanding_port"><code class="name flex">
<span>def <span class="ident">get_commanding_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_commanding_port(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_communication_protocol"><code class="name flex">
<span>def <span class="ident">get_communication_protocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_communication_protocol(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_ip_address"><code class="name flex">
<span>def <span class="ident">get_ip_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_address(self):
    return get_host_ip()</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_monitoring_port"><code class="name flex">
<span>def <span class="ident">get_monitoring_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_monitoring_port(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_process_status"><code class="name flex">
<span>def <span class="ident">get_process_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_process_status(self):
    return self._process_status.as_dict()</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_service_port"><code class="name flex">
<span>def <span class="ident">get_service_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_service_port(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.get_storage_mnemonic"><code class="name flex">
<span>def <span class="ident">get_storage_mnemonic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storage_mnemonic(self):
    return self.__class__.__name__</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    self.interrupted = True</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.register_to_storage_manager"><code class="name flex">
<span>def <span class="ident">register_to_storage_manager</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Register this ControlServer to the Storage manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_to_storage_manager(self):
    &#34;&#34;&#34;Register this ControlServer to the Storage manager.&#34;&#34;&#34;

    from egse.storage.storage_cs import StorageControlServer
    from egse.storage import StorageProxy
    from egse.storage.persistence import CSV

    if isinstance(self, StorageControlServer):
        return

    try:
        with StorageProxy() as proxy:
            rc = proxy.register(
                {
                    &#34;origin&#34;: self.get_storage_mnemonic(),
                    &#34;persistence_class&#34;: CSV,
                    &#34;prep&#34;: {
                        &#34;column_names&#34;: list(self.device_protocol.get_housekeeping().keys()),
                        &#34;mode&#34;: &#34;a&#34;,
                    },
                }
            )
            if not rc.successful:
                self.logger.warning(f&#34;Couldn&#39;t register to the Storage manager: {rc}&#34;)
    except ConnectionError as exc:
        self.logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for registration: {exc}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.serve"><code class="name flex">
<span>def <span class="ident">serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serve(self):

    self.before_serve()

    # check if Storage Manager is available

    from egse.storage import is_storage_manager_active

    storage_manager = is_storage_manager_active(timeout=0.1)

    storage_manager and self.register_to_storage_manager()

    # This approach is very simplistic and not time efficient
    # We probably want to use a Timer that executes the monitoring and saving actions at
    # dedicated times in the background.

    last_time = time_in_ms()
    last_time_hk = time_in_ms()

    while True:
        try:
            socks = dict(self.poller.poll(50))  # timeout in milliseconds, do not block
        except KeyboardInterrupt:
            self.logger.warning(&#34;Keyboard interrupt caught!&#34;)
            self.logger.warning(
                &#34;The ControlServer can not be interrupted with CTRL-C, &#34;
                &#34;send a quit command to the server.&#34;
            )
            continue

        if self.dev_ctrl_cmd_sock in socks:
            self.device_protocol.execute()

        if self.dev_ctrl_service_sock in socks:
            self.service_protocol.execute()

        # Now handle the periodic sending out of status information. A dictionary with the
        # status or HK info is sent out periodically based on the DELAY time that is in the
        # YAML config file.

        if time_in_ms() - last_time &gt;= self.delay:
            last_time = time_in_ms()
            self.logger.log(5, &#34;Sending status to monitoring processes.&#34;)
            self.monitoring_protocol.send_status(self.device_protocol.get_status())

        if time_in_ms() - last_time_hk &gt;= self.hk_delay:
            last_time_hk = time_in_ms()
            if storage_manager:
                self.logger.log(5, &#34;Sending housekeeping information to Storage.&#34;)
                self.store_housekeeping_information(self.device_protocol.get_housekeeping())

        if self.interrupted:
            self.logger.info(
                f&#34;Quit command received, closing down the {self.__class__.__name__}.&#34;
            )
            break

        # Some device protocol sub-classes might start a number of threads or processes to
        # support the commanding. Check if these threads/processes are still alive and
        # terminate gracefully if they are not.

        if not self.device_protocol.is_alive():
            self.logger.error(
                &#34;Some Thread or sub-process that was started by Protocol has &#34;
                &#34;died, terminating...&#34;
            )
            break

    storage_manager and self.unregister_from_storage_manager()

    self.after_serve()

    self.device_protocol.quit()

    self.dev_ctrl_mon_sock.close()
    self.dev_ctrl_service_sock.close()
    self.dev_ctrl_cmd_sock.close()

    close_all_zmq_handlers()

    self.zcontext.term()</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.set_delay"><code class="name flex">
<span>def <span class="ident">set_delay</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_delay(self, seconds):
    self.delay = seconds * 1000</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.set_hk_delay"><code class="name flex">
<span>def <span class="ident">set_hk_delay</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_hk_delay(self, seconds):
    self.hk_delay = seconds * 1000</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.set_logging_level"><code class="name flex">
<span>def <span class="ident">set_logging_level</span></span>(<span>self, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_logging_level(self, level):
    self.logger.setLevel(level=level)</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.store_housekeeping_information"><code class="name flex">
<span>def <span class="ident">store_housekeeping_information</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Send housekeeping information to the Storage manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_housekeeping_information(self, data):
    &#34;&#34;&#34;Send housekeeping information to the Storage manager.&#34;&#34;&#34;

    from egse.storage.storage_cs import StorageControlServer
    from egse.storage import StorageProxy

    if isinstance(self, StorageControlServer):
        self.logger.log(0, f&#34;{self.__class__.__name__} doesn&#39;t store housekeeping information.&#34;)
        return

    self.logger.log(0, &#34;Sending housekeeping to storage manager.&#34;)

    try:
        with StorageProxy() as proxy:
            rc = proxy.save({&#34;origin&#34;: self.get_storage_mnemonic(), &#34;data&#34;: data})
            if not rc.successful:
                self.logger.warning(
                    f&#34;Couldn&#39;t save data to the Storage manager: {data}, cause: {rc}&#34;
                )
    except ConnectionError as exc:
        self.logger.warning(
            f&#34;Couldn&#39;t connect to the Storage manager to store housekeeping: {exc}&#34;
        )</code></pre>
</details>
</dd>
<dt id="egse.control.ControlServer.unregister_from_storage_manager"><code class="name flex">
<span>def <span class="ident">unregister_from_storage_manager</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister this ControlServer from the Storage manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_from_storage_manager(self):
    &#34;&#34;&#34;Unregister this ControlServer from the Storage manager.&#34;&#34;&#34;

    from egse.storage.storage_cs import StorageControlServer
    from egse.storage import StorageProxy

    if isinstance(self, StorageControlServer):
        return

    try:
        with StorageProxy() as proxy:
            rc = proxy.unregister({&#34;origin&#34;: self.get_storage_mnemonic()})
            if not rc.successful:
                self.logger.warning(f&#34;Couldn&#39;t unregister from the Storage manager: {rc}&#34;)

    except ConnectionError as exc:
        self.logger.warning(
            f&#34;Couldn&#39;t connect to the Storage manager for de-registration: {exc}&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.control.Failure"><code class="flex name class">
<span>class <span class="ident">Failure</span></span>
<span>(</span><span>message: str, cause: Exception = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A failure response indicating something went wrong at the other side.</p>
<p>This class is used to encapsulate an Exception that was caught and needs to be
passed to the client. So, the intended use is like this:</p>
<pre><code>try:
    # perform some useful action that might raise an Exception
except SomeException as exc:
    return Failure(&quot;Our action failed&quot;, exc)
</code></pre>
<p>The client can inspect the Exception that was originally raised, in this case <code>SomeException</code>
with the <code>cause</code> variable.</p>
<p>Since a Failure is also an Exception, the property <code>successful</code> will return False.
So, the calling method can test for this easily.</p>
<pre><code>rc: Response = function_that_returns_a_response()

if not rc.successful:
    # handle the failure
else:
    # handle success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Failure(Response, Exception):
    &#34;&#34;&#34;A failure response indicating something went wrong at the other side.

    This class is used to encapsulate an Exception that was caught and needs to be
    passed to the client. So, the intended use is like this:
    ```
    try:
        # perform some useful action that might raise an Exception
    except SomeException as exc:
        return Failure(&#34;Our action failed&#34;, exc)
    ```
    The client can inspect the Exception that was originally raised, in this case `SomeException`
    with the `cause` variable.

    Since a Failure is also an Exception, the property `successful` will return False.
    So, the calling method can test for this easily.

    ```
    rc: Response = function_that_returns_a_response()

    if not rc.successful:
        # handle the failure
    else:
        # handle success
    ```

    &#34;&#34;&#34;

    def __init__(self, message: str, cause: Exception = None):
        msg = f&#34;{message}: {cause}&#34; if cause is not None else message
        super().__init__(msg)
        self.cause = cause</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.control.Response" href="#egse.control.Response">Response</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.control.Response" href="#egse.control.Response">Response</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.control.Response.successful" href="#egse.control.Response.successful">successful</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.control.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A message response from the client.</p>
<p>Send a Message when there is no Failure, but also no return code. This is the alternative of
returning a None.</p>
<p>Message returns True for the property successful since it doesn't inherit from Exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message(Response):
    &#34;&#34;&#34;A message response from the client.

    Send a Message when there is no Failure, but also no return code. This is the alternative of
    returning a None.

    Message returns True for the property successful since it doesn&#39;t inherit from Exception.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.control.Response" href="#egse.control.Response">Response</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.control.Response" href="#egse.control.Response">Response</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.control.Response.successful" href="#egse.control.Response.successful">successful</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.control.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for any reply or response between client-server communication.</p>
<p>The idea is that the response is encapsulated in one of the subclasses depending
on the type of response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Response:
    &#34;&#34;&#34;Base class for any reply or response between client-server communication.

    The idea is that the response is encapsulated in one of the subclasses depending
    on the type of response.
    &#34;&#34;&#34;

    def __init__(self, message: str):
        self.message = message

    def __str__(self):
        return self.message

    @property
    def successful(self):
        &#34;&#34;&#34;Returns True if the Response is not an Exception.&#34;&#34;&#34;
        return not isinstance(self, Exception)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.control.Failure" href="#egse.control.Failure">Failure</a></li>
<li><a title="egse.control.Message" href="#egse.control.Message">Message</a></li>
<li><a title="egse.control.Success" href="#egse.control.Success">Success</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="egse.control.Response.successful"><code class="name">var <span class="ident">successful</span></code></dt>
<dd>
<div class="desc"><p>Returns True if the Response is not an Exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def successful(self):
    &#34;&#34;&#34;Returns True if the Response is not an Exception.&#34;&#34;&#34;
    return not isinstance(self, Exception)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.control.Success"><code class="flex name class">
<span>class <span class="ident">Success</span></span>
<span>(</span><span>message: str, return_code: Any = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A success response for the client.</p>
<p>The return code from any action or function that needs to be returned to the
client shall be added.</p>
<p>Since <code><a title="egse.control.Success" href="#egse.control.Success">Success</a></code> doesn't inherit from <code>Exception</code>, the property <code>successful</code> will return True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Success(Response):
    &#34;&#34;&#34;A success response for the client.

    The return code from any action or function that needs to be returned to the
    client shall be added.

    Since `Success` doesn&#39;t inherit from `Exception`, the property `successful` will return True.
    &#34;&#34;&#34;

    def __init__(self, message: str, return_code: Any = None):
        msg = f&#34;{message}: {return_code}&#34; if return_code is not None else message
        super().__init__(msg)
        self.return_code = return_code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.control.Response" href="#egse.control.Response">Response</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.control.Response" href="#egse.control.Response">Response</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.control.Response.successful" href="#egse.control.Response.successful">successful</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.control.is_control_server_active" href="#egse.control.is_control_server_active">is_control_server_active</a></code></li>
<li><code><a title="egse.control.time_in_ms" href="#egse.control.time_in_ms">time_in_ms</a></code></li>
<li><code><a title="egse.control.time_in_s" href="#egse.control.time_in_s">time_in_s</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.control.ControlServer" href="#egse.control.ControlServer">ControlServer</a></code></h4>
<ul class="">
<li><code><a title="egse.control.ControlServer.after_serve" href="#egse.control.ControlServer.after_serve">after_serve</a></code></li>
<li><code><a title="egse.control.ControlServer.before_serve" href="#egse.control.ControlServer.before_serve">before_serve</a></code></li>
<li><code><a title="egse.control.ControlServer.get_commanding_port" href="#egse.control.ControlServer.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.control.ControlServer.get_communication_protocol" href="#egse.control.ControlServer.get_communication_protocol">get_communication_protocol</a></code></li>
<li><code><a title="egse.control.ControlServer.get_ip_address" href="#egse.control.ControlServer.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.control.ControlServer.get_monitoring_port" href="#egse.control.ControlServer.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.control.ControlServer.get_process_status" href="#egse.control.ControlServer.get_process_status">get_process_status</a></code></li>
<li><code><a title="egse.control.ControlServer.get_service_port" href="#egse.control.ControlServer.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.control.ControlServer.get_storage_mnemonic" href="#egse.control.ControlServer.get_storage_mnemonic">get_storage_mnemonic</a></code></li>
<li><code><a title="egse.control.ControlServer.quit" href="#egse.control.ControlServer.quit">quit</a></code></li>
<li><code><a title="egse.control.ControlServer.register_to_storage_manager" href="#egse.control.ControlServer.register_to_storage_manager">register_to_storage_manager</a></code></li>
<li><code><a title="egse.control.ControlServer.serve" href="#egse.control.ControlServer.serve">serve</a></code></li>
<li><code><a title="egse.control.ControlServer.set_delay" href="#egse.control.ControlServer.set_delay">set_delay</a></code></li>
<li><code><a title="egse.control.ControlServer.set_hk_delay" href="#egse.control.ControlServer.set_hk_delay">set_hk_delay</a></code></li>
<li><code><a title="egse.control.ControlServer.set_logging_level" href="#egse.control.ControlServer.set_logging_level">set_logging_level</a></code></li>
<li><code><a title="egse.control.ControlServer.store_housekeeping_information" href="#egse.control.ControlServer.store_housekeeping_information">store_housekeeping_information</a></code></li>
<li><code><a title="egse.control.ControlServer.unregister_from_storage_manager" href="#egse.control.ControlServer.unregister_from_storage_manager">unregister_from_storage_manager</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.control.Failure" href="#egse.control.Failure">Failure</a></code></h4>
</li>
<li>
<h4><code><a title="egse.control.Message" href="#egse.control.Message">Message</a></code></h4>
</li>
<li>
<h4><code><a title="egse.control.Response" href="#egse.control.Response">Response</a></code></h4>
<ul class="">
<li><code><a title="egse.control.Response.successful" href="#egse.control.Response.successful">successful</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.control.Success" href="#egse.control.Success">Success</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
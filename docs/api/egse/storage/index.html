<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.storage API documentation</title>
<meta name="description" content="This module provides storage functionality for the Common-EGSE …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.storage</code></h1>
</header>
<section id="section-intro">
<p>This module provides storage functionality for the Common-EGSE.</p>
<p><img alt="Storage Manager" src="../../../img/storage-design.png"></p>
<h3 id="introduction">Introduction</h3>
<p>All control servers and other components that need to save data through the storage manager
need to register to the storage manager first. That can be done by creating a <code><a title="egse.storage.StorageProxy" href="#egse.storage.StorageProxy">StorageProxy</a></code>
and sending a register message for the component. The name that is registered is also used by
all <code>save</code> messages to identify the component and dispatch the correct persistence function.</p>
<p>All control servers (that inherit from the ControlServer class) will automatically register to
the Storage Manager when the control server (CS) starts. When the CS quits normally (by the
<code>quit_server()</code> command of the Service proxy) the control server will automatically be
unregistered from the Storage manager.</p>
<p>By default, when the Storage is active, it will save all the information that it gets for those
components that have registered to the Storage manager.</p>
<pre><code class="language-python">storage_proxy = StorageProxy()
...
storage_proxy.register({'origin': reg_name,
                        'persistence_class': CSV,
                        'prep': {'column_names': [], 'mode': 'w'}})
...

storage_proxy.save({'origin': reg_name, 'data': data})
...
storage_proxy.unregister({'origin': reg_name})
</code></pre>
<h3 id="commands">Commands</h3>
<p>The Storage component shall understand the following commands:</p>
<ul>
<li>
<p>registration of a component</p>
<ul>
<li><code>storage_proxy.register({'origin': str, 'persistence_class'; &lt;class&gt;, 'prep': dict})</code></li>
<li><code>storage_proxy.unregister({'origin': str})</code></li>
</ul>
</li>
<li>
<p>accept the following commands from the configuration manager</p>
<ul>
<li><code>storage_proxy.start_observation(obsid: str)</code></li>
<li><code>storage_proxy.end_observation(obsid: str)</code></li>
</ul>
</li>
<li>
<p>accept housekeeping and data packets from the DPU simulator housekeeping and accept
housekeeping and status data from any control server</p>
<ul>
<li><code>storage_proxy.save({'origin': name, 'data': data})</code></li>
</ul>
</li>
</ul>
<p>When an observation is started, the Storage Manager will 'fork' the data stream and save the
control server information in a separate set of files. The filenames will carry the <code>obsid</code>
(see below).</p>
<h3 id="what-data-is-saved">What data is saved?</h3>
<ul>
<li>Housekeeping data from other control servers, e.g. device CS or the configuration manager</li>
<li>Status data from other control servers</li>
<li>SpaceWire packets from the N-FEE and the F-FEE, this includes housekeeping and CCD data</li>
<li>Image data from the camera, i.e. processed Spacewire data packets</li>
</ul>
<h3 id="how-is-data-saved">How is data saved?</h3>
<ul>
<li>Different data types are stored in specific formats according to the PersistenceLayer
that was chosen</li>
<li>The following file formats are supported:<ul>
<li>CSV - for tabular data, typically housekeeping and status information</li>
<li>TXT - for logging information</li>
<li>FITS - for image data</li>
<li>HDF5 - for SpaceWire data and housekeeping packets</li>
</ul>
</li>
</ul>
<h3 id="how-are-the-files-named">How are the files named?</h3>
<p>We have two sets of files:</p>
<ol>
<li>
<p>files that contain only the data that was collected for an observation, i.e.
between the calls to <code>start_observation</code> and <code>end_observation</code>. These files are located
in the <code>obs</code> sub-folder of the main data store location. The filename is constructed from
the test id, the site id and the setup id, followed by the data source identifier and a
timestamp. An example from the PUNA Hexapod housekeeping file:
<code>00031_CSL_00008_PUNA_20200701_210711.csv</code>.</p>
</li>
<li>
<p>files that contain all the housekeeping for each of the data sources regardless of an
observation is running or not. All data that is collected during a test day will be stored in
these files. Outside of an observation context there will be no CCD image data collected.
These files are located in the <code>daily</code> sub-folder of the main data store location. The filename
is constructed from the date, the site id and the data source identifier. An example for the
same PUNA Hexapod file: <code>20200701_CSL_PUNA.csv</code>.</p>
</li>
</ol>
<p>The timestamp that is used is the time of file creation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides storage functionality for the Common-EGSE.

![Storage Manager](../../../img/storage-design.png)

### Introduction

All control servers and other components that need to save data through the storage manager
need to register to the storage manager first. That can be done by creating a `StorageProxy`
and sending a register message for the component. The name that is registered is also used by
all `save` messages to identify the component and dispatch the correct persistence function.

All control servers (that inherit from the ControlServer class) will automatically register to
the Storage Manager when the control server (CS) starts. When the CS quits normally (by the
`quit_server()` command of the Service proxy) the control server will automatically be
unregistered from the Storage manager.

By default, when the Storage is active, it will save all the information that it gets for those
components that have registered to the Storage manager.

```python
storage_proxy = StorageProxy()
...
storage_proxy.register({&#39;origin&#39;: reg_name,
                        &#39;persistence_class&#39;: CSV,
                        &#39;prep&#39;: {&#39;column_names&#39;: [], &#39;mode&#39;: &#39;w&#39;}})
...

storage_proxy.save({&#39;origin&#39;: reg_name, &#39;data&#39;: data})
...
storage_proxy.unregister({&#39;origin&#39;: reg_name})
```

### Commands

The Storage component shall understand the following commands:

* registration of a component

    * `storage_proxy.register({&#39;origin&#39;: str, &#39;persistence_class&#39;; &lt;class&gt;, &#39;prep&#39;: dict})`
    * `storage_proxy.unregister({&#39;origin&#39;: str})`

* accept the following commands from the configuration manager

    * `storage_proxy.start_observation(obsid: str)`
    * `storage_proxy.end_observation(obsid: str)`

* accept housekeeping and data packets from the DPU simulator housekeeping and accept
    housekeeping and status data from any control server

    * `storage_proxy.save({&#39;origin&#39;: name, &#39;data&#39;: data})`


When an observation is started, the Storage Manager will &#39;fork&#39; the data stream and save the
control server information in a separate set of files. The filenames will carry the `obsid`
(see below).

### What data is saved?

* Housekeeping data from other control servers, e.g. device CS or the configuration manager
* Status data from other control servers
* SpaceWire packets from the N-FEE and the F-FEE, this includes housekeeping and CCD data
* Image data from the camera, i.e. processed Spacewire data packets

### How is data saved?

* Different data types are stored in specific formats according to the PersistenceLayer
  that was chosen
* The following file formats are supported:
    * CSV - for tabular data, typically housekeeping and status information
    * TXT - for logging information
    * FITS - for image data
    * HDF5 - for SpaceWire data and housekeeping packets

### How are the files named?

We have two sets of files:

1. files that contain only the data that was collected for an observation, i.e.
   between the calls to `start_observation` and `end_observation`. These files are located
   in the `obs` sub-folder of the main data store location. The filename is constructed from
   the test id, the site id and the setup id, followed by the data source identifier and a
   timestamp. An example from the PUNA Hexapod housekeeping file:
   `00031_CSL_00008_PUNA_20200701_210711.csv`.

2. files that contain all the housekeeping for each of the data sources regardless of an
   observation is running or not. All data that is collected during a test day will be stored in
   these files. Outside of an observation context there will be no CCD image data collected.
   These files are located in the `daily` sub-folder of the main data store location. The filename
   is constructed from the date, the site id and the data source identifier. An example for the
   same PUNA Hexapod file: `20200701_CSL_PUNA.csv`.

The timestamp that is used is the time of file creation.

&#34;&#34;&#34;
import abc
import datetime
import logging
import os
import shutil
from pathlib import Path
from pathlib import PurePath
from typing import Dict
from typing import List
from typing import Tuple
from typing import Union

from egse.command import ClientServerCommand
from egse.config import find_files
from egse.control import ControlServer
from egse.control import Failure
from egse.control import Response
from egse.control import Success
from egse.control import is_control_server_active
from egse.decorators import dynamic_interface
from egse.exceptions import Error
from egse.obsid import ObservationIdentifier
from egse.obsid import TEST_LAB
from egse.protocol import CommandProtocol
from egse.proxy import Proxy
from egse.settings import Settings
from egse.storage.persistence import HDF5
from egse.storage.persistence import PersistenceLayer
from egse.system import format_datetime
from egse.system import replace_environment_variable
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

logger = logging.getLogger(__name__)

CTRL_SETTINGS = Settings.load(&#34;Storage Control Server&#34;)
SITE = Settings.load(&#34;SITE&#34;)
COMMAND_SETTINGS = Settings.load(filename=&#34;storage.yaml&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;storage.yaml&#34;)
CCD_SETTINGS = Settings.load(&#34;CCD&#34;)


def is_storage_manager_active(timeout: float = 0.5):
    &#34;&#34;&#34;Check if the Storage Manager is running.

    Returns:
        True if the Storage Manager is running and replied with the expected answer.
    &#34;&#34;&#34;

    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )

    return is_control_server_active(endpoint, timeout)


def register_to_storage_manager(origin: str, persistence_class: PersistenceLayer, prep: Dict):
    &#34;&#34;&#34;
    Register the component to the Storage manager.

    For information on what should go into the `prep` keyword argument, please check the proper
    persistence class.

    Args:
        origin (str): the name of the component, by which it will be registered
        persistence_class: a concrete class that will be used to store the  data
        prep (dict): preparation meta data for the persistence class
    &#34;&#34;&#34;

    try:
        with StorageProxy() as proxy:
            rc = proxy.register(
                {
                    &#34;origin&#34;: origin,
                    &#34;persistence_class&#34;: persistence_class,
                    &#34;prep&#34;: prep,
                }
            )
            if not rc.successful:
                logger.warning(f&#34;Couldn&#39;t register to the Storage manager: {rc}&#34;)
            else:
                logger.info(rc)
    except ConnectionError as exc:
        logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for registration: {exc}&#34;)
        raise


def unregister_from_storage_manager(origin: str):
    &#34;&#34;&#34;Unregister the component from the Storage manager.&#34;&#34;&#34;

    try:
        with StorageProxy() as proxy:
            rc = proxy.unregister({&#34;origin&#34;: origin})
            if not rc.successful:
                logger.warning(f&#34;Couldn&#39;t unregister from the Storage manager: {rc}&#34;)
            else:
                logger.info(rc)
    except ConnectionError as exc:
        logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for de-registration: {exc}&#34;)


def cycle_daily_files():
    &#34;&#34;&#34;
    Create a new daily file for each registered item when no such file exists.
    &#34;&#34;&#34;
    with StorageProxy() as storage:
        storage.cycle_daily_files()


class AlreadyRegisteredError(Error):
    &#34;&#34;&#34;This error indicates that an item is already registered and cannot be registered again.&#34;&#34;&#34;


class Registry:
    &#34;&#34;&#34;
    A registry for registration of components in the system that need to save data through
    the Storage Manager.
    &#34;&#34;&#34;

    def __init__(self):
        self._register = dict()

    def __contains__(self, name: str):
        &#34;&#34;&#34;Returns True if an item with &#39;name&#39; has been registered.&#34;&#34;&#34;
        if isinstance(name, str):
            return name in self._register.keys()

        raise ValueError(
            f&#34;You can only check if something is contained in the Registry &#34;
            f&#34;by a key of type string, item is of type &#39;{type(name)}&#39;.&#34;
        )

    def __len__(self):
        &#34;&#34;&#34;Returns the number of registrations.&#34;&#34;&#34;
        return len(self._register)

    def __iter__(self):
        return iter(self._register.keys())

    def get(self, name: str):
        &#34;&#34;&#34;Returns the registered item for the given name (identifier).&#34;&#34;&#34;
        return self._register.get(name)

    def register(self, name: str, item):
        &#34;&#34;&#34;Register the item by the given name in the register.

        Args:
            name (str): the key to identify this registration, usually the name of
                the control server or the class that registers
            item: an object that contains information about what information needs to be saved
                and how
        &#34;&#34;&#34;
        if not isinstance(name, str):
            raise ValueError(&#34;The name of the item to register must be a string.&#34;)
        if name in self:
            raise AlreadyRegisteredError(
                f&#34;An item with name &#39;{name}&#39; is already registered, please unregister first.&#34;
            )
        self._register[name] = item

    def unregister(self, name: str):
        &#34;&#34;&#34;Unregister the item with the given name from the register.

        Args:
            name (str): the key by which the registration was done.
        &#34;&#34;&#34;
        if not isinstance(name, str):
            raise ValueError(&#34;The name of the item to unregister must be a string.&#34;)
        if name not in self:
            raise KeyError(f&#34;There is no item with name &#39;{name}&#39; in this Register.&#34;)
        del self._register[name]


class StoragePacket(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base packet for all data send to Storage.&#34;&#34;&#34;

    def __init__(self, origin=None, data=None, metadata=None):
        self._timestamp = datetime.datetime.now(tz=datetime.timezone.utc)
        self._origin = origin
        self._data = data
        self._metadata = metadata

    @property
    def timestamp(self):
        return self._timestamp

    @property
    def origin(self):
        return self._origin

    @property
    def data(self):
        return self._data

    @property
    def metadata(self):
        return self._metadata


class StorageInterface:
    &#34;&#34;&#34;
    This interface is for control servers to register to the Storage Manager and for the
    configuration manager to start and stop an observation/test.

    The interface should be implemented by the StorageController and the StorageProxy (and
    possibly a StorageSimulator should we need that).
    &#34;&#34;&#34;

    @dynamic_interface
    def save(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Saves the data part from the item.
        Args:
            item (dict): a dictionary that identifies the origin and the data to be stored.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def read(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Reads data from storage defined by the `origin` in item.
        Args:
            item (dict): a dictionary that identifies the origin and an optional filter.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def register(self, item: dict, use_counter: bool = False) -&gt; Response:
        &#34;&#34;&#34;Registers the item to the storage manager.

        The item shall have the following keys:

        * origin (str): the name of the item, by which it will be registered
        * persistence_class (class):

        Args:
            item (dict): a dictionary that identifies the component to be registered

        Returns:
            Success: when the item could be registered successfully
            Failure: when the registration fails, `Failure.cause` provides cause exception
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def unregister(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Unregisters the item from the storage manager.

        Args:
            item (dict): a dictionary that identifies the component to be registered

        Returns:
            Success: when the item could be unregistered successfully
            Failure: when the de-registration fails, `Failure.cause` provides cause exception
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_registry_names(self):
        &#34;&#34;&#34;Returns the names of the registered components.

        Returns:
            a list of names/identifiers for the registered components.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def start_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        &#34;&#34;&#34; &#34;Start an observation for the given obsid.

        When a new obsevation is started the following actions will be taken:

        * Housekeeping and telemetry from registered components (mainly control servers)
          will be forked into a newly created file for that component.
        * Camera data will be saved as follows:
            * SpaceWire packets will go into an HDF5 file for this observation
            * CCD data will be assembled into image data and saved in FITS format

        Args:
            obsid: a unique observation identifier

        Returns:
            Success: when a new observation with the given obsid could be started properly.
            Failure: when the previous observation was not finished yet (no end_observation was
                send), or when a failure happened during the preparations for a new observation.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def end_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        &#34;&#34;&#34;Ends the currently running observation.

        When a running observation is ended, the following actions will be taken:

        * All files of registered components will be closed.
        * Housekeeping and telemetry will continue to be saved to the global repository

        Args:
            obsid: the observation identifier of the currently running observation

        Returns:
            Success: when the current observation could be ended successfully.
            Failure: when the given obsid doesn&#39;t match the current observation.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_obsid(self):
        &#34;&#34;&#34;Return the observation identifier.&#34;&#34;&#34;
        pass

    @dynamic_interface
    def cycle_daily_files(self):
        pass

    @dynamic_interface
    def get_storage_location(self):
        pass

    @dynamic_interface
    def get_filenames(self, item: dict) -&gt; List[Path]:
        &#34;&#34;&#34;Return the filename(s) associated with this registered item.&#34;&#34;&#34;
        pass

    @dynamic_interface
    def new_registration(self, item: dict, use_counter=False):
        &#34;&#34;&#34;
        Create a new data file for the given item. If the item was previously registered, close that
        registration and open a new registration. The use_counter parameter determines if an
        incremented counter is used to construct a unique filename.

        Args:
            - item: Dictionary that identifies the component to be registered.
            - use_counter: Indicates whether or not a counter should be used in the filename.
        &#34;&#34;&#34;

        pass

    @dynamic_interface
    def get_disk_usage(self):
        &#34;&#34;&#34; Return the total, used, and free disk space [bytes].

        Returns:
            - Total disk space [bytes].
            - Used disk space [bytes].
            - Free disk space [bytes].
        &#34;&#34;&#34;

        pass


def _disentangle_filename(filename: Union[str, Path]) -&gt; Tuple:
    &#34;&#34;&#34;Disentangle the given filename and return the test identifier, the site id and the Setup id.

    It is assumed in this function that the filename is from a test observation and contains the
    correct fields to be extracted. Only very limited checking is done if that is indeed the case.

    Args:
        filename (str, Path): the filename of a test observation

    Returns:
        A tuple containing the test_id (int), site_id (str) and setup_id (int). If the filename is
        not recognized as a valid filename, the returned tuple contains all None.

    &#34;&#34;&#34;
    filename = Path(filename).resolve()
    parts = filename.parts

    if parts[-2] != &#39;obs&#39;:
        name = parts[-1]
        if not (name.rsplit(&#39;_&#39;, 3)[0].endswith(&#39;_SPW&#39;) or name.rsplit(&#39;_&#39;, 2)[0].endswith(&#39;_SPW&#39;)):
            return None, None, None

    name = parts[-1]
    test_id, site_id, setup_id = name.split(&#39;_&#39;)[:3]
    return int(test_id), site_id, int(setup_id)


def _construct_filename(
        identifier: str, ext: str, obsid: ObservationIdentifier = None, use_counter=False
) -&gt; PurePath:
    &#34;&#34;&#34;Construct a filename for the data source.

    We construct two types of filenames:

    1. the observational files which store all the data that are collected during an observation.
       There is one file per data source. The files are located in the `obs` sub-folder of the
       storage location.
    2. the daily files which store all the data from a data source regardless the state of an
       observation. There is one file per data source. The files are located in the `daily`
       sub-folder of the storage location.

    Args:
        identifier (str): an identifier for the source of the data, this string is usually what
            is sent in the `origin` of the item dictionary.
        ext (str): the extension of the file, this depends oon the persistence class that is
            used for storing the data.
        obsid (ObservationIdentifier): a unique identifier for the observation
        use_counter: Indicates whether or not a counter should be included in the filename.
    Returns:
        The full path to the file as a `PurePath`.
    &#34;&#34;&#34;

    location = replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)

    if obsid:

        timestamp = datetime.datetime.now(tz=datetime.timezone.utc).strftime(&#34;%Y%m%d_%H%M%S&#34;)

        prefix = obsid.create_id(order=TEST_LAB)
        location = location / Path(&#34;obs&#34;) / prefix
        if not os.path.exists(location):
            os.makedirs(location)

        if use_counter:
            counter_file_path = location / f&#34;{prefix}_{identifier}.count&#34;
            if not counter_file_path.exists():
                pattern = f&#34;{prefix}_{identifier}_{timestamp}_*.{ext}&#34;
                counter = determine_counter_from_dir_list(location, pattern)
                _write_counter(counter, counter_file_path)
            else:
                counter = get_counter(counter_file_path)
            name = f&#34;{prefix}_{identifier}_{counter:05d}_{timestamp}.{ext}&#34;
        else:
            name = f&#34;{prefix}_{identifier}_{timestamp}.{ext}&#34;

    else:

        timestamp = datetime.datetime.now(tz=datetime.timezone.utc).strftime(&#34;%Y%m%d&#34;)

        location = location / Path(&#34;daily&#34;) / timestamp
        if not os.path.exists(location):
            os.makedirs(location)

        if use_counter:
            counter_file_path = location / f&#34;{timestamp}_{SITE.ID}_{identifier}.count&#34;
            if not counter_file_path.exists():
                pattern = f&#34;{timestamp}_{SITE.ID}_{identifier}_*.{ext}&#34;
                counter = determine_counter_from_dir_list(location, pattern)
                _write_counter(counter, counter_file_path)
            else:
                counter = get_counter(counter_file_path)
            name = f&#34;{timestamp}_{SITE.ID}_{identifier}_{counter:05d}.{ext}&#34;
        else:
            name = f&#34;{timestamp}_{SITE.ID}_{identifier}.{ext}&#34;

    return Path(location) / name


def _write_counter(counter: int, file_path: Path):
    &#34;&#34;&#34;
    Overwrites the given counter in the given file. The file contains nothing else then the counter.
    If the file didn&#39;t exist before, it will be created.

    Args:
        counter: the counter to save
        file_path: the file to which the counter shall be saved
    &#34;&#34;&#34;
    with file_path.open(&#39;w&#39;) as fd:
        fd.write(f&#34;{counter:d}&#34;)


def _read_counter(file_path: Path) -&gt; int:
    &#34;&#34;&#34;
    Reads a counter from the given file. The file shall only contain the counter which must
    be an integer on the first line of the file. If the given file doesn&#39;t exist, 0 is returned.

    Args:
        file_path: the full path of the file containing the counter

    Returns:
        The counter that is read from the file or 0 if file doesn&#39;t exist.
    &#34;&#34;&#34;
    try:
        with file_path.open(&#39;r&#39;) as fd:
            counter = fd.read().strip()
    except FileNotFoundError:
        counter = 0
    return int(counter or 0)


def get_counter(file_path: Path) -&gt; int:
    &#34;&#34;&#34;
    Read the counter from a dedicated file, add one and save the counter back to the file..

    Args:
        - file_path: full pathname of the file that contains the required counter

    Returns:
        The value of the next counter, 1 if no previous files were found or if an error occurred.
    &#34;&#34;&#34;

    counter = _read_counter(file_path)
    counter += 1
    _write_counter(counter, file_path)

    return counter


def determine_counter_from_dir_list(location, pattern, index: int = -1):
    &#34;&#34;&#34;
    Determine counter for a new file at the given location and with the given pattern.
    The next counter is determined from the sorted list of files that match the given pattern.

    Args:
        - location: Location where the file should be stored.
        - pattern: Pattern for the filename.
        - index: the location of the counter in the filename after it is split on &#39;_&#39; [default=-1]

    Returns:
        The value of the next counter, 1 if no previous files were found or if an error occurred.
    &#34;&#34;&#34;

    files = sorted(find_files(pattern=pattern, root=location))

    # No filenames found showing the given pattern -&gt; start counting at 1

    if len(files) == 0:
        return 1

    last_file = files[-1]

    parts = last_file.name.split(&#34;_&#34;)

    try:

        # Observation files have the following pattern:
        #  &lt;test ID&gt;_&lt;lab ID&gt;_&lt;setup ID&gt;_&lt;storage mnemonic&gt;_&lt;day YYYYmmdd&gt;_&lt;time HHMMSS&gt;[_&lt;counter&gt;]
        # Daily files:
        #  &lt;day&gt;_&lt;site ID&gt;_&lt;storage mnemonic&gt;[_&lt;counter&gt;]

        counter = int(parts[index].split(&#34;.&#34;)[0]) + 1
        logger.debug(f&#34;{counter = }&#34;)
        return counter

    except ValueError:
        logger.warning(&#34;ValueError&#34;, exc_info=True)
        return 1


class StorageController(StorageInterface):
    &#34;&#34;&#34;
    The Storage Controller handles the registration of components, the start and end of an
    observation/test and the dispatching of the persistence functions in save.
    &#34;&#34;&#34;

    def __init__(self):
        self._obsid: ObservationIdentifier = None
        self._registry = Registry()

    def start_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        if self._obsid is not None:
            return Failure(
                &#34;Can not start a new observation before the previous observation is ended.&#34;
            )

        self._obsid = obsid

        # open a dedicated file for each registered item

        for registered_name in self._registry:
            registered_item = self._registry.get(registered_name)

            if &#34;persistence_count&#34; in registered_item:
                # no need to fork any files that contain persistence_counts
                continue

            if issubclass(registered_item[&#34;persistence_class&#34;], HDF5):
                # do not duplicate HDF5 files during an observation - issue #1186
                continue

            # NOTE: The following lines of code contain tests for special treatment of HDF5 files
            # while the above check disables HDF5 files in OBS. We leave the code in for now until
            # a definite decision is taken.

            filename = _construct_filename(
                registered_item[&#34;origin&#34;],
                registered_item[&#34;persistence_class&#34;].extension,
                obsid,
                use_counter=issubclass(registered_item[&#34;persistence_class&#34;], HDF5),
            )

            # we have more than one file open for this item DAILY and OBS.... take care of that

            # Special case for HDF5 files as they need to be copied instead of created

            if issubclass(registered_item[&#34;persistence_class&#34;], HDF5):
                daily_file_object: HDF5 = registered_item[&#34;persistence_objects&#34;][0]
                daily_file_path: Path = daily_file_object.get_filepath()
                logger.debug(f&#34;Copying {daily_file_path} to {filename}&#34;)

                # Close the HDF5 file before copy, otherwise you will get
                # a &#39;bad object header version number&#39; when opening the destination.

                daily_file_object.close()
                shutil.copy(daily_file_path, filename)
                daily_file_object.open(mode=&#39;a&#39;)

            persistence_obj = registered_item[&#34;persistence_class&#34;](
                filename, prep=registered_item[&#34;prep&#34;]
            )

            mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
            persistence_obj.open(mode=mode)

            registered_item[&#34;persistence_objects&#34;].append(persistence_obj)

        return Success(&#34;Storage successfully started observation.&#34;)

    def end_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        if obsid != self._obsid:
            return Failure(f&#34;Given obsid doesn&#39;t match current obsid: {obsid} != {self._obsid}&#34;)

        # close the dedicated file for each registered item

        for registered_name in self._registry:
            registered_item = self._registry.get(registered_name)
            if &#34;persistence_count&#34; in registered_item:
                # no need to close any files that contain persistence_counts
                continue
            try:
                persistence_obj = registered_item[&#34;persistence_objects&#34;].pop()
                persistence_obj.close()
            except IndexError as exc:
                logger.warning(f&#34;Trying to close a persistent object for {registered_name}, {exc=}&#34;)

        self._obsid = None

        return Success(&#34;Storage successfully ended observation.&#34;)

    def get_obsid(self):
        return self._obsid

    def save(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Saves the data contained in this item to the right location and format.

        Args:
            item: dictionary with at least the following keywords - origin, data
        Returns:
            Success: when the data has been properly saved.
        &#34;&#34;&#34;
        # TODO:
        #  this method might become a performance problem and the reason that we might have
        #  back pressure problem. Keep an eye on this and do performance tests.

        # What needs to be done:
        # * based on item[&#39;origin&#39;], check if item component is registered
        # * get register entry for item
        # * for persistence in persistence list:
        #      persistence.create(data)

        registered_item = self._registry.get(item[&#34;origin&#34;])

        if not registered_item:
            return Failure(
                f&#34;Storage could not find a registration for {item[&#39;origin&#39;]}, no data saved.&#34;
            )

        for persistence_object in registered_item[&#34;persistence_objects&#34;]:
            persistence_object.create(item[&#34;data&#34;])

        return Success(f&#34;Storage successfully saved the data for {item[&#39;origin&#39;]}.&#34;)

    def read(self, item: dict):

        registered_item = self._registry.get(item[&#34;origin&#34;])

        if not registered_item:
            return Failure(
                f&#34;Storage could not find a registration for {item[&#39;origin&#39;]}, no data saved.&#34;
            )

        # FIXME:
        #   * wat als meerdere persistence_objects bestaan? alleen de eerste, alleen de laatste,
        #     samenvoegen? een nieuw keyword in item?

        result = None
        for persistence_object in registered_item[&#34;persistence_objects&#34;]:
            result = persistence_object.read(item[&#34;select&#34;])

        return Success(f&#34;Storage successfully read the data from {item[&#39;origin&#39;]}.&#34;, result)

    def register(self, item: dict, use_counter=False) -&gt; Response:

        if not isinstance(item, dict):
            return Failure(
                f&#34;Could not register item, item must be a dictionary (item={type(item)}).&#34;
            )

        prep = item.get(&#34;prep&#34;, {})

        # When we register an item, the file should always be &#39;created&#39;, unless this is a
        # persistence count and we just need to append to the file, always.

        # if &#34;persistence_count&#34; not in item:
        #     prep.update({&#34;mode&#34;: &#34;w&#34;})

        if &#34;origin&#34; not in item or &#34;persistence_class&#34; not in item:
            return Failure(&#34;Could not register item, missing mandatory keyword(s).&#34;)

        try:
            self._registry.register(item[&#34;origin&#34;], item)

            if &#34;filename&#34; in item:
                location = Path(replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION))
                filename = location / item[&#34;filename&#34;]
            else:
                filename = _construct_filename(item[&#34;origin&#34;], item[&#34;persistence_class&#34;].extension,
                                               use_counter=use_counter)

            persistence_obj = item[&#34;persistence_class&#34;](filename, prep=prep)
            mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
            persistence_obj.open(mode=mode)

            # add the PersistenceLayer object to the registered item

            item[&#34;persistence_objects&#34;] = [persistence_obj]

            # Special case when the components registration is done after an observation was
            # started, unless we are handling a persistence_count, in which case there is only one
            # file.

            if (
                self._obsid
                and &#34;persistence_count&#34; not in item
                and not issubclass(item[&#34;persistence_class&#34;], HDF5)
            ):
                filename = _construct_filename(
                    item[&#34;origin&#34;], item[&#34;persistence_class&#34;].extension, self._obsid, use_counter=use_counter
                )

                persistence_obj = item[&#34;persistence_class&#34;](filename, prep=prep)
                mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
                persistence_obj.open(mode=mode)

                item[&#34;persistence_objects&#34;].append(persistence_obj)

            msg = f&#34;Storage successfully registered {item[&#39;origin&#39;]}&#34;
            logger.info(msg)
            return Success(msg)
        except AlreadyRegisteredError as exc:
            msg = f&#34;Could not register {item[&#39;origin&#39;]}: {exc}&#34;
            logger.error(msg)
            return Success(f&#34;{item[&#39;origin&#39;]} is already registered.&#34;)
        except (ValueError, KeyError) as exc:
            # FIXME:
            #  Should I unregister here? and if yes, should I not call the
            #  self.unregister(item) method instead?
            self._registry.unregister(item[&#34;origin&#34;])
            msg = f&#34;Could not register {item[&#39;origin&#39;]}: {exc}&#34;
            logger.error(msg)
            return Failure(f&#34;Could not register {item[&#39;origin&#39;]}&#34;, exc)

    def unregister(self, item) -&gt; Response:
        try:
            registered_item = self._registry.get(item[&#34;origin&#34;])
            if registered_item is None:
                raise ValueError(&#34;The item is not registered.&#34;)

            # Probably also should close the file and some other things

            for persistence_obj in registered_item.get(&#34;persistence_objects&#34;, []):
                persistence_obj.close()

            self._registry.unregister(item[&#34;origin&#34;])

            msg = f&#34;Storage successfully unregistered {item[&#39;origin&#39;]}&#34;
            logger.info(msg)
            return Success(msg)
        except (ValueError, KeyError) as exc:
            return Failure(f&#34;Could not unregister {item[&#39;origin&#39;]}&#34;, exc)

    def get_registry_names(self):
        return list(self._registry)

    def cycle_daily_files(self):

        logger.info(&#34;Cycling daily files for Storage Manager&#34;)

        for reg_name in self._registry:
            item = self._registry.get(reg_name)
            if &#34;persistence_count&#34; in item:
                # no need to cycle any files that contain persistence_counts
                continue
            if &#34;persistence_objects&#34; in item:
                logger.info(f&#34;Cycling daily file for {item[&#39;origin&#39;]}.&#34;)

                # The first item in the list is always the daily persistence object, however, for
                # the N-FEE_SPW origin, sometimes when the N-FEE is not ON, there is no persistence
                # object. (see issue #1458) So, we catch this and continue.

                try:
                    daily_persist_obj = item[&#34;persistence_objects&#34;][0]
                    daily_persist_obj.close()
                except IndexError:
                    logger.info(f&#34;I&#39;m ignoring that there is no persistence_object &#34;
                                f&#34;for {item[&#39;origin&#39;]} at this time.&#34;)
                    continue

                # Create folder for the day
                filename = _construct_filename(item[&#39;origin&#39;], item[&#39;persistence_class&#39;].extension)

                persistence_obj: PersistenceLayer = item[&#34;persistence_class&#34;](
                    filename, prep=item.get(&#34;prep&#34;)
                )
                mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
                persistence_obj.open(mode=mode)

                # replace the previous daily persistence object with the current

                item[&#34;persistence_objects&#34;][0] = persistence_obj

            else:
                # We should never get here, since when an item is registered, the &#39;file&#39; is
                # opened and it should exist
                logger.error(
                    f&#34;Found a registered item {item} that has no persistence objects.&#34;,
                    stack_info=True,
                )

    def get_storage_location(self):
        return replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)

    def get_filenames(self, item: dict) -&gt; List[Path]:
        registered_item = self._registry.get(item[&#34;origin&#34;])

        if not registered_item:
            return []

        return [
            persistence_object.get_filepath()
            for persistence_object in registered_item[&#34;persistence_objects&#34;]
        ]

    def new_registration(self, item: dict, use_counter=False) -&gt; Response:
        if item[&#34;origin&#34;] in self.get_registry_names():
            _ = self.unregister(item)

        response = self.register(item, use_counter=use_counter)
        logger.info(f&#34;From register: {response=}&#34;)
        return response

    def get_disk_usage(self):

        location = Path(replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION))
        total, used, free = shutil.disk_usage(location)
        return total, used, free


class StorageCommand(ClientServerCommand):
    pass


class StorageProxy(Proxy, StorageInterface):
    &#34;&#34;&#34;The StorageProxy class is used to connect to the Storage Manager (control server) and
    send commands remotely.&#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))


class StorageProtocol(CommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__()
        self.control_server = control_server

        self.controller = StorageController()

        self.load_commands(COMMAND_SETTINGS.Commands, StorageCommand, StorageController)

        self.build_device_method_lookup_table(self.controller)

    def get_bind_address(self):
        return bind_address(
            self.control_server.get_communication_protocol(),
            self.control_server.get_commanding_port(),
        )

    def get_status(self) -&gt; dict:
        return super().get_status()

    def get_housekeeping(self) -&gt; dict:
        return {
            &#34;timestamp&#34;: format_datetime(),
        }</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="egse.storage.persistence" href="persistence.html">egse.storage.persistence</a></code></dt>
<dd>
<div class="desc"><p>This module handles the persistence storage for the Common-EGSE.</p></div>
</dd>
<dt><code class="name"><a title="egse.storage.storage_cs" href="storage_cs.html">egse.storage.storage_cs</a></code></dt>
<dd>
<div class="desc"><p>The Storage Control Server, aka Storage Manager, is the service which saves all data coming
from any component in the Common-EGSE …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.storage.cycle_daily_files"><code class="name flex">
<span>def <span class="ident">cycle_daily_files</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new daily file for each registered item when no such file exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cycle_daily_files():
    &#34;&#34;&#34;
    Create a new daily file for each registered item when no such file exists.
    &#34;&#34;&#34;
    with StorageProxy() as storage:
        storage.cycle_daily_files()</code></pre>
</details>
</dd>
<dt id="egse.storage.determine_counter_from_dir_list"><code class="name flex">
<span>def <span class="ident">determine_counter_from_dir_list</span></span>(<span>location, pattern, index: int = -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine counter for a new file at the given location and with the given pattern.
The next counter is determined from the sorted list of files that match the given pattern.</p>
<h2 id="args">Args</h2>
<ul>
<li>location: Location where the file should be stored.</li>
<li>pattern: Pattern for the filename.</li>
<li>index: the location of the counter in the filename after it is split on '_' [default=-1]</li>
</ul>
<h2 id="returns">Returns</h2>
<p>The value of the next counter, 1 if no previous files were found or if an error occurred.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_counter_from_dir_list(location, pattern, index: int = -1):
    &#34;&#34;&#34;
    Determine counter for a new file at the given location and with the given pattern.
    The next counter is determined from the sorted list of files that match the given pattern.

    Args:
        - location: Location where the file should be stored.
        - pattern: Pattern for the filename.
        - index: the location of the counter in the filename after it is split on &#39;_&#39; [default=-1]

    Returns:
        The value of the next counter, 1 if no previous files were found or if an error occurred.
    &#34;&#34;&#34;

    files = sorted(find_files(pattern=pattern, root=location))

    # No filenames found showing the given pattern -&gt; start counting at 1

    if len(files) == 0:
        return 1

    last_file = files[-1]

    parts = last_file.name.split(&#34;_&#34;)

    try:

        # Observation files have the following pattern:
        #  &lt;test ID&gt;_&lt;lab ID&gt;_&lt;setup ID&gt;_&lt;storage mnemonic&gt;_&lt;day YYYYmmdd&gt;_&lt;time HHMMSS&gt;[_&lt;counter&gt;]
        # Daily files:
        #  &lt;day&gt;_&lt;site ID&gt;_&lt;storage mnemonic&gt;[_&lt;counter&gt;]

        counter = int(parts[index].split(&#34;.&#34;)[0]) + 1
        logger.debug(f&#34;{counter = }&#34;)
        return counter

    except ValueError:
        logger.warning(&#34;ValueError&#34;, exc_info=True)
        return 1</code></pre>
</details>
</dd>
<dt id="egse.storage.get_counter"><code class="name flex">
<span>def <span class="ident">get_counter</span></span>(<span>file_path: pathlib.Path) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Read the counter from a dedicated file, add one and save the counter back to the file..</p>
<h2 id="args">Args</h2>
<ul>
<li>file_path: full pathname of the file that contains the required counter</li>
</ul>
<h2 id="returns">Returns</h2>
<p>The value of the next counter, 1 if no previous files were found or if an error occurred.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_counter(file_path: Path) -&gt; int:
    &#34;&#34;&#34;
    Read the counter from a dedicated file, add one and save the counter back to the file..

    Args:
        - file_path: full pathname of the file that contains the required counter

    Returns:
        The value of the next counter, 1 if no previous files were found or if an error occurred.
    &#34;&#34;&#34;

    counter = _read_counter(file_path)
    counter += 1
    _write_counter(counter, file_path)

    return counter</code></pre>
</details>
</dd>
<dt id="egse.storage.is_storage_manager_active"><code class="name flex">
<span>def <span class="ident">is_storage_manager_active</span></span>(<span>timeout: float = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the Storage Manager is running.</p>
<h2 id="returns">Returns</h2>
<p>True if the Storage Manager is running and replied with the expected answer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_storage_manager_active(timeout: float = 0.5):
    &#34;&#34;&#34;Check if the Storage Manager is running.

    Returns:
        True if the Storage Manager is running and replied with the expected answer.
    &#34;&#34;&#34;

    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )

    return is_control_server_active(endpoint, timeout)</code></pre>
</details>
</dd>
<dt id="egse.storage.register_to_storage_manager"><code class="name flex">
<span>def <span class="ident">register_to_storage_manager</span></span>(<span>origin: str, persistence_class: <a title="egse.storage.persistence.PersistenceLayer" href="persistence.html#egse.storage.persistence.PersistenceLayer">PersistenceLayer</a>, prep: Dict[~KT, ~VT])</span>
</code></dt>
<dd>
<div class="desc"><p>Register the component to the Storage manager.</p>
<p>For information on what should go into the <code>prep</code> keyword argument, please check the proper
persistence class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>origin</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the component, by which it will be registered</dd>
<dt><strong><code>persistence_class</code></strong></dt>
<dd>a concrete class that will be used to store the
data</dd>
<dt><strong><code>prep</code></strong> :&ensp;<code>dict</code></dt>
<dd>preparation meta data for the persistence class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_to_storage_manager(origin: str, persistence_class: PersistenceLayer, prep: Dict):
    &#34;&#34;&#34;
    Register the component to the Storage manager.

    For information on what should go into the `prep` keyword argument, please check the proper
    persistence class.

    Args:
        origin (str): the name of the component, by which it will be registered
        persistence_class: a concrete class that will be used to store the  data
        prep (dict): preparation meta data for the persistence class
    &#34;&#34;&#34;

    try:
        with StorageProxy() as proxy:
            rc = proxy.register(
                {
                    &#34;origin&#34;: origin,
                    &#34;persistence_class&#34;: persistence_class,
                    &#34;prep&#34;: prep,
                }
            )
            if not rc.successful:
                logger.warning(f&#34;Couldn&#39;t register to the Storage manager: {rc}&#34;)
            else:
                logger.info(rc)
    except ConnectionError as exc:
        logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for registration: {exc}&#34;)
        raise</code></pre>
</details>
</dd>
<dt id="egse.storage.unregister_from_storage_manager"><code class="name flex">
<span>def <span class="ident">unregister_from_storage_manager</span></span>(<span>origin: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister the component from the Storage manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_from_storage_manager(origin: str):
    &#34;&#34;&#34;Unregister the component from the Storage manager.&#34;&#34;&#34;

    try:
        with StorageProxy() as proxy:
            rc = proxy.unregister({&#34;origin&#34;: origin})
            if not rc.successful:
                logger.warning(f&#34;Couldn&#39;t unregister from the Storage manager: {rc}&#34;)
            else:
                logger.info(rc)
    except ConnectionError as exc:
        logger.warning(f&#34;Couldn&#39;t connect to the Storage manager for de-registration: {exc}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.storage.AlreadyRegisteredError"><code class="flex name class">
<span>class <span class="ident">AlreadyRegisteredError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This error indicates that an item is already registered and cannot be registered again.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlreadyRegisteredError(Error):
    &#34;&#34;&#34;This error indicates that an item is already registered and cannot be registered again.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.exceptions.Error" href="../exceptions.html#egse.exceptions.Error">Error</a></li>
<li><a title="egse.exceptions.CommonEGSEException" href="../exceptions.html#egse.exceptions.CommonEGSEException">CommonEGSEException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.storage.Registry"><code class="flex name class">
<span>class <span class="ident">Registry</span></span>
</code></dt>
<dd>
<div class="desc"><p>A registry for registration of components in the system that need to save data through
the Storage Manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Registry:
    &#34;&#34;&#34;
    A registry for registration of components in the system that need to save data through
    the Storage Manager.
    &#34;&#34;&#34;

    def __init__(self):
        self._register = dict()

    def __contains__(self, name: str):
        &#34;&#34;&#34;Returns True if an item with &#39;name&#39; has been registered.&#34;&#34;&#34;
        if isinstance(name, str):
            return name in self._register.keys()

        raise ValueError(
            f&#34;You can only check if something is contained in the Registry &#34;
            f&#34;by a key of type string, item is of type &#39;{type(name)}&#39;.&#34;
        )

    def __len__(self):
        &#34;&#34;&#34;Returns the number of registrations.&#34;&#34;&#34;
        return len(self._register)

    def __iter__(self):
        return iter(self._register.keys())

    def get(self, name: str):
        &#34;&#34;&#34;Returns the registered item for the given name (identifier).&#34;&#34;&#34;
        return self._register.get(name)

    def register(self, name: str, item):
        &#34;&#34;&#34;Register the item by the given name in the register.

        Args:
            name (str): the key to identify this registration, usually the name of
                the control server or the class that registers
            item: an object that contains information about what information needs to be saved
                and how
        &#34;&#34;&#34;
        if not isinstance(name, str):
            raise ValueError(&#34;The name of the item to register must be a string.&#34;)
        if name in self:
            raise AlreadyRegisteredError(
                f&#34;An item with name &#39;{name}&#39; is already registered, please unregister first.&#34;
            )
        self._register[name] = item

    def unregister(self, name: str):
        &#34;&#34;&#34;Unregister the item with the given name from the register.

        Args:
            name (str): the key by which the registration was done.
        &#34;&#34;&#34;
        if not isinstance(name, str):
            raise ValueError(&#34;The name of the item to unregister must be a string.&#34;)
        if name not in self:
            raise KeyError(f&#34;There is no item with name &#39;{name}&#39; in this Register.&#34;)
        del self._register[name]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.storage.Registry.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the registered item for the given name (identifier).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name: str):
    &#34;&#34;&#34;Returns the registered item for the given name (identifier).&#34;&#34;&#34;
    return self._register.get(name)</code></pre>
</details>
</dd>
<dt id="egse.storage.Registry.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, name: str, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Register the item by the given name in the register.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the key to identify this registration, usually the name of
the control server or the class that registers</dd>
<dt><strong><code>item</code></strong></dt>
<dd>an object that contains information about what information needs to be saved
and how</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, name: str, item):
    &#34;&#34;&#34;Register the item by the given name in the register.

    Args:
        name (str): the key to identify this registration, usually the name of
            the control server or the class that registers
        item: an object that contains information about what information needs to be saved
            and how
    &#34;&#34;&#34;
    if not isinstance(name, str):
        raise ValueError(&#34;The name of the item to register must be a string.&#34;)
    if name in self:
        raise AlreadyRegisteredError(
            f&#34;An item with name &#39;{name}&#39; is already registered, please unregister first.&#34;
        )
    self._register[name] = item</code></pre>
</details>
</dd>
<dt id="egse.storage.Registry.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister the item with the given name from the register.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the key by which the registration was done.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, name: str):
    &#34;&#34;&#34;Unregister the item with the given name from the register.

    Args:
        name (str): the key by which the registration was done.
    &#34;&#34;&#34;
    if not isinstance(name, str):
        raise ValueError(&#34;The name of the item to unregister must be a string.&#34;)
    if name not in self:
        raise KeyError(f&#34;There is no item with name &#39;{name}&#39; in this Register.&#34;)
    del self._register[name]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.storage.StorageCommand"><code class="flex name class">
<span>class <span class="ident">StorageCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageCommand(ClientServerCommand):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.storage.StorageController"><code class="flex name class">
<span>class <span class="ident">StorageController</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Storage Controller handles the registration of components, the start and end of an
observation/test and the dispatching of the persistence functions in save.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageController(StorageInterface):
    &#34;&#34;&#34;
    The Storage Controller handles the registration of components, the start and end of an
    observation/test and the dispatching of the persistence functions in save.
    &#34;&#34;&#34;

    def __init__(self):
        self._obsid: ObservationIdentifier = None
        self._registry = Registry()

    def start_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        if self._obsid is not None:
            return Failure(
                &#34;Can not start a new observation before the previous observation is ended.&#34;
            )

        self._obsid = obsid

        # open a dedicated file for each registered item

        for registered_name in self._registry:
            registered_item = self._registry.get(registered_name)

            if &#34;persistence_count&#34; in registered_item:
                # no need to fork any files that contain persistence_counts
                continue

            if issubclass(registered_item[&#34;persistence_class&#34;], HDF5):
                # do not duplicate HDF5 files during an observation - issue #1186
                continue

            # NOTE: The following lines of code contain tests for special treatment of HDF5 files
            # while the above check disables HDF5 files in OBS. We leave the code in for now until
            # a definite decision is taken.

            filename = _construct_filename(
                registered_item[&#34;origin&#34;],
                registered_item[&#34;persistence_class&#34;].extension,
                obsid,
                use_counter=issubclass(registered_item[&#34;persistence_class&#34;], HDF5),
            )

            # we have more than one file open for this item DAILY and OBS.... take care of that

            # Special case for HDF5 files as they need to be copied instead of created

            if issubclass(registered_item[&#34;persistence_class&#34;], HDF5):
                daily_file_object: HDF5 = registered_item[&#34;persistence_objects&#34;][0]
                daily_file_path: Path = daily_file_object.get_filepath()
                logger.debug(f&#34;Copying {daily_file_path} to {filename}&#34;)

                # Close the HDF5 file before copy, otherwise you will get
                # a &#39;bad object header version number&#39; when opening the destination.

                daily_file_object.close()
                shutil.copy(daily_file_path, filename)
                daily_file_object.open(mode=&#39;a&#39;)

            persistence_obj = registered_item[&#34;persistence_class&#34;](
                filename, prep=registered_item[&#34;prep&#34;]
            )

            mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
            persistence_obj.open(mode=mode)

            registered_item[&#34;persistence_objects&#34;].append(persistence_obj)

        return Success(&#34;Storage successfully started observation.&#34;)

    def end_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        if obsid != self._obsid:
            return Failure(f&#34;Given obsid doesn&#39;t match current obsid: {obsid} != {self._obsid}&#34;)

        # close the dedicated file for each registered item

        for registered_name in self._registry:
            registered_item = self._registry.get(registered_name)
            if &#34;persistence_count&#34; in registered_item:
                # no need to close any files that contain persistence_counts
                continue
            try:
                persistence_obj = registered_item[&#34;persistence_objects&#34;].pop()
                persistence_obj.close()
            except IndexError as exc:
                logger.warning(f&#34;Trying to close a persistent object for {registered_name}, {exc=}&#34;)

        self._obsid = None

        return Success(&#34;Storage successfully ended observation.&#34;)

    def get_obsid(self):
        return self._obsid

    def save(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Saves the data contained in this item to the right location and format.

        Args:
            item: dictionary with at least the following keywords - origin, data
        Returns:
            Success: when the data has been properly saved.
        &#34;&#34;&#34;
        # TODO:
        #  this method might become a performance problem and the reason that we might have
        #  back pressure problem. Keep an eye on this and do performance tests.

        # What needs to be done:
        # * based on item[&#39;origin&#39;], check if item component is registered
        # * get register entry for item
        # * for persistence in persistence list:
        #      persistence.create(data)

        registered_item = self._registry.get(item[&#34;origin&#34;])

        if not registered_item:
            return Failure(
                f&#34;Storage could not find a registration for {item[&#39;origin&#39;]}, no data saved.&#34;
            )

        for persistence_object in registered_item[&#34;persistence_objects&#34;]:
            persistence_object.create(item[&#34;data&#34;])

        return Success(f&#34;Storage successfully saved the data for {item[&#39;origin&#39;]}.&#34;)

    def read(self, item: dict):

        registered_item = self._registry.get(item[&#34;origin&#34;])

        if not registered_item:
            return Failure(
                f&#34;Storage could not find a registration for {item[&#39;origin&#39;]}, no data saved.&#34;
            )

        # FIXME:
        #   * wat als meerdere persistence_objects bestaan? alleen de eerste, alleen de laatste,
        #     samenvoegen? een nieuw keyword in item?

        result = None
        for persistence_object in registered_item[&#34;persistence_objects&#34;]:
            result = persistence_object.read(item[&#34;select&#34;])

        return Success(f&#34;Storage successfully read the data from {item[&#39;origin&#39;]}.&#34;, result)

    def register(self, item: dict, use_counter=False) -&gt; Response:

        if not isinstance(item, dict):
            return Failure(
                f&#34;Could not register item, item must be a dictionary (item={type(item)}).&#34;
            )

        prep = item.get(&#34;prep&#34;, {})

        # When we register an item, the file should always be &#39;created&#39;, unless this is a
        # persistence count and we just need to append to the file, always.

        # if &#34;persistence_count&#34; not in item:
        #     prep.update({&#34;mode&#34;: &#34;w&#34;})

        if &#34;origin&#34; not in item or &#34;persistence_class&#34; not in item:
            return Failure(&#34;Could not register item, missing mandatory keyword(s).&#34;)

        try:
            self._registry.register(item[&#34;origin&#34;], item)

            if &#34;filename&#34; in item:
                location = Path(replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION))
                filename = location / item[&#34;filename&#34;]
            else:
                filename = _construct_filename(item[&#34;origin&#34;], item[&#34;persistence_class&#34;].extension,
                                               use_counter=use_counter)

            persistence_obj = item[&#34;persistence_class&#34;](filename, prep=prep)
            mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
            persistence_obj.open(mode=mode)

            # add the PersistenceLayer object to the registered item

            item[&#34;persistence_objects&#34;] = [persistence_obj]

            # Special case when the components registration is done after an observation was
            # started, unless we are handling a persistence_count, in which case there is only one
            # file.

            if (
                self._obsid
                and &#34;persistence_count&#34; not in item
                and not issubclass(item[&#34;persistence_class&#34;], HDF5)
            ):
                filename = _construct_filename(
                    item[&#34;origin&#34;], item[&#34;persistence_class&#34;].extension, self._obsid, use_counter=use_counter
                )

                persistence_obj = item[&#34;persistence_class&#34;](filename, prep=prep)
                mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
                persistence_obj.open(mode=mode)

                item[&#34;persistence_objects&#34;].append(persistence_obj)

            msg = f&#34;Storage successfully registered {item[&#39;origin&#39;]}&#34;
            logger.info(msg)
            return Success(msg)
        except AlreadyRegisteredError as exc:
            msg = f&#34;Could not register {item[&#39;origin&#39;]}: {exc}&#34;
            logger.error(msg)
            return Success(f&#34;{item[&#39;origin&#39;]} is already registered.&#34;)
        except (ValueError, KeyError) as exc:
            # FIXME:
            #  Should I unregister here? and if yes, should I not call the
            #  self.unregister(item) method instead?
            self._registry.unregister(item[&#34;origin&#34;])
            msg = f&#34;Could not register {item[&#39;origin&#39;]}: {exc}&#34;
            logger.error(msg)
            return Failure(f&#34;Could not register {item[&#39;origin&#39;]}&#34;, exc)

    def unregister(self, item) -&gt; Response:
        try:
            registered_item = self._registry.get(item[&#34;origin&#34;])
            if registered_item is None:
                raise ValueError(&#34;The item is not registered.&#34;)

            # Probably also should close the file and some other things

            for persistence_obj in registered_item.get(&#34;persistence_objects&#34;, []):
                persistence_obj.close()

            self._registry.unregister(item[&#34;origin&#34;])

            msg = f&#34;Storage successfully unregistered {item[&#39;origin&#39;]}&#34;
            logger.info(msg)
            return Success(msg)
        except (ValueError, KeyError) as exc:
            return Failure(f&#34;Could not unregister {item[&#39;origin&#39;]}&#34;, exc)

    def get_registry_names(self):
        return list(self._registry)

    def cycle_daily_files(self):

        logger.info(&#34;Cycling daily files for Storage Manager&#34;)

        for reg_name in self._registry:
            item = self._registry.get(reg_name)
            if &#34;persistence_count&#34; in item:
                # no need to cycle any files that contain persistence_counts
                continue
            if &#34;persistence_objects&#34; in item:
                logger.info(f&#34;Cycling daily file for {item[&#39;origin&#39;]}.&#34;)

                # The first item in the list is always the daily persistence object, however, for
                # the N-FEE_SPW origin, sometimes when the N-FEE is not ON, there is no persistence
                # object. (see issue #1458) So, we catch this and continue.

                try:
                    daily_persist_obj = item[&#34;persistence_objects&#34;][0]
                    daily_persist_obj.close()
                except IndexError:
                    logger.info(f&#34;I&#39;m ignoring that there is no persistence_object &#34;
                                f&#34;for {item[&#39;origin&#39;]} at this time.&#34;)
                    continue

                # Create folder for the day
                filename = _construct_filename(item[&#39;origin&#39;], item[&#39;persistence_class&#39;].extension)

                persistence_obj: PersistenceLayer = item[&#34;persistence_class&#34;](
                    filename, prep=item.get(&#34;prep&#34;)
                )
                mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
                persistence_obj.open(mode=mode)

                # replace the previous daily persistence object with the current

                item[&#34;persistence_objects&#34;][0] = persistence_obj

            else:
                # We should never get here, since when an item is registered, the &#39;file&#39; is
                # opened and it should exist
                logger.error(
                    f&#34;Found a registered item {item} that has no persistence objects.&#34;,
                    stack_info=True,
                )

    def get_storage_location(self):
        return replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)

    def get_filenames(self, item: dict) -&gt; List[Path]:
        registered_item = self._registry.get(item[&#34;origin&#34;])

        if not registered_item:
            return []

        return [
            persistence_object.get_filepath()
            for persistence_object in registered_item[&#34;persistence_objects&#34;]
        ]

    def new_registration(self, item: dict, use_counter=False) -&gt; Response:
        if item[&#34;origin&#34;] in self.get_registry_names():
            _ = self.unregister(item)

        response = self.register(item, use_counter=use_counter)
        logger.info(f&#34;From register: {response=}&#34;)
        return response

    def get_disk_usage(self):

        location = Path(replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION))
        total, used, free = shutil.disk_usage(location)
        return total, used, free</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.storage.StorageInterface" href="#egse.storage.StorageInterface">StorageInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.storage.StorageController.cycle_daily_files"><code class="name flex">
<span>def <span class="ident">cycle_daily_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cycle_daily_files(self):

    logger.info(&#34;Cycling daily files for Storage Manager&#34;)

    for reg_name in self._registry:
        item = self._registry.get(reg_name)
        if &#34;persistence_count&#34; in item:
            # no need to cycle any files that contain persistence_counts
            continue
        if &#34;persistence_objects&#34; in item:
            logger.info(f&#34;Cycling daily file for {item[&#39;origin&#39;]}.&#34;)

            # The first item in the list is always the daily persistence object, however, for
            # the N-FEE_SPW origin, sometimes when the N-FEE is not ON, there is no persistence
            # object. (see issue #1458) So, we catch this and continue.

            try:
                daily_persist_obj = item[&#34;persistence_objects&#34;][0]
                daily_persist_obj.close()
            except IndexError:
                logger.info(f&#34;I&#39;m ignoring that there is no persistence_object &#34;
                            f&#34;for {item[&#39;origin&#39;]} at this time.&#34;)
                continue

            # Create folder for the day
            filename = _construct_filename(item[&#39;origin&#39;], item[&#39;persistence_class&#39;].extension)

            persistence_obj: PersistenceLayer = item[&#34;persistence_class&#34;](
                filename, prep=item.get(&#34;prep&#34;)
            )
            mode = &#34;a&#34; if persistence_obj.exists() else &#34;w&#34;
            persistence_obj.open(mode=mode)

            # replace the previous daily persistence object with the current

            item[&#34;persistence_objects&#34;][0] = persistence_obj

        else:
            # We should never get here, since when an item is registered, the &#39;file&#39; is
            # opened and it should exist
            logger.error(
                f&#34;Found a registered item {item} that has no persistence objects.&#34;,
                stack_info=True,
            )</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageController.get_storage_location"><code class="name flex">
<span>def <span class="ident">get_storage_location</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storage_location(self):
    return replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageController.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, item: dict) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Saves the data contained in this item to the right location and format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>dictionary with at least the following keywords - origin, data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Success</code></dt>
<dd>when the data has been properly saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, item: dict) -&gt; Response:
    &#34;&#34;&#34;Saves the data contained in this item to the right location and format.

    Args:
        item: dictionary with at least the following keywords - origin, data
    Returns:
        Success: when the data has been properly saved.
    &#34;&#34;&#34;
    # TODO:
    #  this method might become a performance problem and the reason that we might have
    #  back pressure problem. Keep an eye on this and do performance tests.

    # What needs to be done:
    # * based on item[&#39;origin&#39;], check if item component is registered
    # * get register entry for item
    # * for persistence in persistence list:
    #      persistence.create(data)

    registered_item = self._registry.get(item[&#34;origin&#34;])

    if not registered_item:
        return Failure(
            f&#34;Storage could not find a registration for {item[&#39;origin&#39;]}, no data saved.&#34;
        )

    for persistence_object in registered_item[&#34;persistence_objects&#34;]:
        persistence_object.create(item[&#34;data&#34;])

    return Success(f&#34;Storage successfully saved the data for {item[&#39;origin&#39;]}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.storage.StorageInterface" href="#egse.storage.StorageInterface">StorageInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.storage.StorageInterface.end_observation" href="#egse.storage.StorageInterface.end_observation">end_observation</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_disk_usage" href="#egse.storage.StorageInterface.get_disk_usage">get_disk_usage</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_filenames" href="#egse.storage.StorageInterface.get_filenames">get_filenames</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_obsid" href="#egse.storage.StorageInterface.get_obsid">get_obsid</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_registry_names" href="#egse.storage.StorageInterface.get_registry_names">get_registry_names</a></code></li>
<li><code><a title="egse.storage.StorageInterface.new_registration" href="#egse.storage.StorageInterface.new_registration">new_registration</a></code></li>
<li><code><a title="egse.storage.StorageInterface.read" href="#egse.storage.StorageInterface.read">read</a></code></li>
<li><code><a title="egse.storage.StorageInterface.register" href="#egse.storage.StorageInterface.register">register</a></code></li>
<li><code><a title="egse.storage.StorageInterface.start_observation" href="#egse.storage.StorageInterface.start_observation">start_observation</a></code></li>
<li><code><a title="egse.storage.StorageInterface.unregister" href="#egse.storage.StorageInterface.unregister">unregister</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.storage.StorageInterface"><code class="flex name class">
<span>class <span class="ident">StorageInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>This interface is for control servers to register to the Storage Manager and for the
configuration manager to start and stop an observation/test.</p>
<p>The interface should be implemented by the StorageController and the StorageProxy (and
possibly a StorageSimulator should we need that).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageInterface:
    &#34;&#34;&#34;
    This interface is for control servers to register to the Storage Manager and for the
    configuration manager to start and stop an observation/test.

    The interface should be implemented by the StorageController and the StorageProxy (and
    possibly a StorageSimulator should we need that).
    &#34;&#34;&#34;

    @dynamic_interface
    def save(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Saves the data part from the item.
        Args:
            item (dict): a dictionary that identifies the origin and the data to be stored.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def read(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Reads data from storage defined by the `origin` in item.
        Args:
            item (dict): a dictionary that identifies the origin and an optional filter.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def register(self, item: dict, use_counter: bool = False) -&gt; Response:
        &#34;&#34;&#34;Registers the item to the storage manager.

        The item shall have the following keys:

        * origin (str): the name of the item, by which it will be registered
        * persistence_class (class):

        Args:
            item (dict): a dictionary that identifies the component to be registered

        Returns:
            Success: when the item could be registered successfully
            Failure: when the registration fails, `Failure.cause` provides cause exception
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def unregister(self, item: dict) -&gt; Response:
        &#34;&#34;&#34;Unregisters the item from the storage manager.

        Args:
            item (dict): a dictionary that identifies the component to be registered

        Returns:
            Success: when the item could be unregistered successfully
            Failure: when the de-registration fails, `Failure.cause` provides cause exception
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_registry_names(self):
        &#34;&#34;&#34;Returns the names of the registered components.

        Returns:
            a list of names/identifiers for the registered components.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def start_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        &#34;&#34;&#34; &#34;Start an observation for the given obsid.

        When a new obsevation is started the following actions will be taken:

        * Housekeeping and telemetry from registered components (mainly control servers)
          will be forked into a newly created file for that component.
        * Camera data will be saved as follows:
            * SpaceWire packets will go into an HDF5 file for this observation
            * CCD data will be assembled into image data and saved in FITS format

        Args:
            obsid: a unique observation identifier

        Returns:
            Success: when a new observation with the given obsid could be started properly.
            Failure: when the previous observation was not finished yet (no end_observation was
                send), or when a failure happened during the preparations for a new observation.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def end_observation(self, obsid: ObservationIdentifier) -&gt; Response:
        &#34;&#34;&#34;Ends the currently running observation.

        When a running observation is ended, the following actions will be taken:

        * All files of registered components will be closed.
        * Housekeeping and telemetry will continue to be saved to the global repository

        Args:
            obsid: the observation identifier of the currently running observation

        Returns:
            Success: when the current observation could be ended successfully.
            Failure: when the given obsid doesn&#39;t match the current observation.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_obsid(self):
        &#34;&#34;&#34;Return the observation identifier.&#34;&#34;&#34;
        pass

    @dynamic_interface
    def cycle_daily_files(self):
        pass

    @dynamic_interface
    def get_storage_location(self):
        pass

    @dynamic_interface
    def get_filenames(self, item: dict) -&gt; List[Path]:
        &#34;&#34;&#34;Return the filename(s) associated with this registered item.&#34;&#34;&#34;
        pass

    @dynamic_interface
    def new_registration(self, item: dict, use_counter=False):
        &#34;&#34;&#34;
        Create a new data file for the given item. If the item was previously registered, close that
        registration and open a new registration. The use_counter parameter determines if an
        incremented counter is used to construct a unique filename.

        Args:
            - item: Dictionary that identifies the component to be registered.
            - use_counter: Indicates whether or not a counter should be used in the filename.
        &#34;&#34;&#34;

        pass

    @dynamic_interface
    def get_disk_usage(self):
        &#34;&#34;&#34; Return the total, used, and free disk space [bytes].

        Returns:
            - Total disk space [bytes].
            - Used disk space [bytes].
            - Free disk space [bytes].
        &#34;&#34;&#34;

        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.storage.StorageController" href="#egse.storage.StorageController">StorageController</a></li>
<li><a title="egse.storage.StorageProxy" href="#egse.storage.StorageProxy">StorageProxy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.storage.StorageInterface.cycle_daily_files"><code class="name flex">
<span>def <span class="ident">cycle_daily_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def cycle_daily_files(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.end_observation"><code class="name flex">
<span>def <span class="ident">end_observation</span></span>(<span>self, obsid: <a title="egse.obsid.ObservationIdentifier" href="../obsid.html#egse.obsid.ObservationIdentifier">ObservationIdentifier</a>) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Ends the currently running observation.</p>
<p>When a running observation is ended, the following actions will be taken:</p>
<ul>
<li>All files of registered components will be closed.</li>
<li>Housekeeping and telemetry will continue to be saved to the global repository</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obsid</code></strong></dt>
<dd>the observation identifier of the currently running observation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Success</code></dt>
<dd>when the current observation could be ended successfully.</dd>
<dt><code>Failure</code></dt>
<dd>when the given obsid doesn't match the current observation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def end_observation(self, obsid: ObservationIdentifier) -&gt; Response:
    &#34;&#34;&#34;Ends the currently running observation.

    When a running observation is ended, the following actions will be taken:

    * All files of registered components will be closed.
    * Housekeeping and telemetry will continue to be saved to the global repository

    Args:
        obsid: the observation identifier of the currently running observation

    Returns:
        Success: when the current observation could be ended successfully.
        Failure: when the given obsid doesn&#39;t match the current observation.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.get_disk_usage"><code class="name flex">
<span>def <span class="ident">get_disk_usage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the total, used, and free disk space [bytes].</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Total disk space [bytes].</li>
<li>Used disk space [bytes].</li>
<li>Free disk space [bytes].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_disk_usage(self):
    &#34;&#34;&#34; Return the total, used, and free disk space [bytes].

    Returns:
        - Total disk space [bytes].
        - Used disk space [bytes].
        - Free disk space [bytes].
    &#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.get_filenames"><code class="name flex">
<span>def <span class="ident">get_filenames</span></span>(<span>self, item: dict) ‑> List[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the filename(s) associated with this registered item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_filenames(self, item: dict) -&gt; List[Path]:
    &#34;&#34;&#34;Return the filename(s) associated with this registered item.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.get_obsid"><code class="name flex">
<span>def <span class="ident">get_obsid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the observation identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_obsid(self):
    &#34;&#34;&#34;Return the observation identifier.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.get_registry_names"><code class="name flex">
<span>def <span class="ident">get_registry_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the names of the registered components.</p>
<h2 id="returns">Returns</h2>
<p>a list of names/identifiers for the registered components.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_registry_names(self):
    &#34;&#34;&#34;Returns the names of the registered components.

    Returns:
        a list of names/identifiers for the registered components.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.get_storage_location"><code class="name flex">
<span>def <span class="ident">get_storage_location</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_storage_location(self):
    pass</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.new_registration"><code class="name flex">
<span>def <span class="ident">new_registration</span></span>(<span>self, item: dict, use_counter=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new data file for the given item. If the item was previously registered, close that
registration and open a new registration. The use_counter parameter determines if an
incremented counter is used to construct a unique filename.</p>
<h2 id="args">Args</h2>
<ul>
<li>item: Dictionary that identifies the component to be registered.</li>
<li>use_counter: Indicates whether or not a counter should be used in the filename.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def new_registration(self, item: dict, use_counter=False):
    &#34;&#34;&#34;
    Create a new data file for the given item. If the item was previously registered, close that
    registration and open a new registration. The use_counter parameter determines if an
    incremented counter is used to construct a unique filename.

    Args:
        - item: Dictionary that identifies the component to be registered.
        - use_counter: Indicates whether or not a counter should be used in the filename.
    &#34;&#34;&#34;

    pass</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, item: dict) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Reads data from storage defined by the <code>origin</code> in item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dictionary that identifies the origin and an optional filter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def read(self, item: dict) -&gt; Response:
    &#34;&#34;&#34;Reads data from storage defined by the `origin` in item.
    Args:
        item (dict): a dictionary that identifies the origin and an optional filter.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, item: dict, use_counter: bool = False) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Registers the item to the storage manager.</p>
<p>The item shall have the following keys:</p>
<ul>
<li>origin (str): the name of the item, by which it will be registered</li>
<li>persistence_class (class):</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dictionary that identifies the component to be registered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Success</code></dt>
<dd>when the item could be registered successfully</dd>
<dt><code>Failure</code></dt>
<dd>when the registration fails, <code>Failure.cause</code> provides cause exception</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def register(self, item: dict, use_counter: bool = False) -&gt; Response:
    &#34;&#34;&#34;Registers the item to the storage manager.

    The item shall have the following keys:

    * origin (str): the name of the item, by which it will be registered
    * persistence_class (class):

    Args:
        item (dict): a dictionary that identifies the component to be registered

    Returns:
        Success: when the item could be registered successfully
        Failure: when the registration fails, `Failure.cause` provides cause exception
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, item: dict) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Saves the data part from the item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dictionary that identifies the origin and the data to be stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def save(self, item: dict) -&gt; Response:
    &#34;&#34;&#34;Saves the data part from the item.
    Args:
        item (dict): a dictionary that identifies the origin and the data to be stored.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.start_observation"><code class="name flex">
<span>def <span class="ident">start_observation</span></span>(<span>self, obsid: <a title="egse.obsid.ObservationIdentifier" href="../obsid.html#egse.obsid.ObservationIdentifier">ObservationIdentifier</a>) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>"Start an observation for the given obsid.</p>
<p>When a new obsevation is started the following actions will be taken:</p>
<ul>
<li>Housekeeping and telemetry from registered components (mainly control servers)
will be forked into a newly created file for that component.</li>
<li>Camera data will be saved as follows:<ul>
<li>SpaceWire packets will go into an HDF5 file for this observation</li>
<li>CCD data will be assembled into image data and saved in FITS format</li>
</ul>
</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obsid</code></strong></dt>
<dd>a unique observation identifier</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Success</code></dt>
<dd>when a new observation with the given obsid could be started properly.</dd>
<dt><code>Failure</code></dt>
<dd>when the previous observation was not finished yet (no end_observation was
send), or when a failure happened during the preparations for a new observation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_observation(self, obsid: ObservationIdentifier) -&gt; Response:
    &#34;&#34;&#34; &#34;Start an observation for the given obsid.

    When a new obsevation is started the following actions will be taken:

    * Housekeeping and telemetry from registered components (mainly control servers)
      will be forked into a newly created file for that component.
    * Camera data will be saved as follows:
        * SpaceWire packets will go into an HDF5 file for this observation
        * CCD data will be assembled into image data and saved in FITS format

    Args:
        obsid: a unique observation identifier

    Returns:
        Success: when a new observation with the given obsid could be started properly.
        Failure: when the previous observation was not finished yet (no end_observation was
            send), or when a failure happened during the preparations for a new observation.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.storage.StorageInterface.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, item: dict) ‑> <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Unregisters the item from the storage manager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dictionary that identifies the component to be registered</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Success</code></dt>
<dd>when the item could be unregistered successfully</dd>
<dt><code>Failure</code></dt>
<dd>when the de-registration fails, <code>Failure.cause</code> provides cause exception</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def unregister(self, item: dict) -&gt; Response:
    &#34;&#34;&#34;Unregisters the item from the storage manager.

    Args:
        item (dict): a dictionary that identifies the component to be registered

    Returns:
        Success: when the item could be unregistered successfully
        Failure: when the de-registration fails, `Failure.cause` provides cause exception
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.storage.StoragePacket"><code class="flex name class">
<span>class <span class="ident">StoragePacket</span></span>
<span>(</span><span>origin=None, data=None, metadata=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base packet for all data send to Storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoragePacket(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base packet for all data send to Storage.&#34;&#34;&#34;

    def __init__(self, origin=None, data=None, metadata=None):
        self._timestamp = datetime.datetime.now(tz=datetime.timezone.utc)
        self._origin = origin
        self._data = data
        self._metadata = metadata

    @property
    def timestamp(self):
        return self._timestamp

    @property
    def origin(self):
        return self._origin

    @property
    def data(self):
        return self._data

    @property
    def metadata(self):
        return self._metadata</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.storage.StoragePacket.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return self._data</code></pre>
</details>
</dd>
<dt id="egse.storage.StoragePacket.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self):
    return self._metadata</code></pre>
</details>
</dd>
<dt id="egse.storage.StoragePacket.origin"><code class="name">var <span class="ident">origin</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def origin(self):
    return self._origin</code></pre>
</details>
</dd>
<dt id="egse.storage.StoragePacket.timestamp"><code class="name">var <span class="ident">timestamp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timestamp(self):
    return self._timestamp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.storage.StorageProtocol"><code class="flex name class">
<span>class <span class="ident">StorageProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the glue between the control servers and the hardware
controllers on one side, and between the control server and the connected
proxy classes on the other side.</p>
<p>The connection with the hardware controllers is when the <code>execute()</code> method
calls the <code>server_call()</code> method of the command class.</p>
<p>The connection with the proxy classes is when the <code>client_call()</code> method is added to the
interface of the Proxy subclass (by the <code>_add_commands()</code> method).</p>
<p>FIXME: Protocol is not used at the client side, i.e. the Proxy class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageProtocol(CommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__()
        self.control_server = control_server

        self.controller = StorageController()

        self.load_commands(COMMAND_SETTINGS.Commands, StorageCommand, StorageController)

        self.build_device_method_lookup_table(self.controller)

    def get_bind_address(self):
        return bind_address(
            self.control_server.get_communication_protocol(),
            self.control_server.get_commanding_port(),
        )

    def get_status(self) -&gt; dict:
        return super().get_status()

    def get_housekeeping(self) -&gt; dict:
        return {
            &#34;timestamp&#34;: format_datetime(),
        }</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.protocol.CommandProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_bind_address" href="../protocol.html#egse.protocol.CommandProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_housekeeping" href="../protocol.html#egse.protocol.CommandProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_status" href="../protocol.html#egse.protocol.CommandProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.storage.StorageProxy"><code class="flex name class">
<span>class <span class="ident">StorageProxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6100)</span>
</code></dt>
<dd>
<div class="desc"><p>The StorageProxy class is used to connect to the Storage Manager (control server) and
send commands remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol [default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address)
[default is taken from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageProxy(Proxy, StorageInterface):
    &#34;&#34;&#34;The StorageProxy class is used to connect to the Storage Manager (control server) and
    send commands remotely.&#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.storage.StorageInterface" href="#egse.storage.StorageInterface">StorageInterface</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.storage.StorageInterface" href="#egse.storage.StorageInterface">StorageInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.storage.StorageInterface.end_observation" href="#egse.storage.StorageInterface.end_observation">end_observation</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_disk_usage" href="#egse.storage.StorageInterface.get_disk_usage">get_disk_usage</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_filenames" href="#egse.storage.StorageInterface.get_filenames">get_filenames</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_obsid" href="#egse.storage.StorageInterface.get_obsid">get_obsid</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_registry_names" href="#egse.storage.StorageInterface.get_registry_names">get_registry_names</a></code></li>
<li><code><a title="egse.storage.StorageInterface.new_registration" href="#egse.storage.StorageInterface.new_registration">new_registration</a></code></li>
<li><code><a title="egse.storage.StorageInterface.read" href="#egse.storage.StorageInterface.read">read</a></code></li>
<li><code><a title="egse.storage.StorageInterface.register" href="#egse.storage.StorageInterface.register">register</a></code></li>
<li><code><a title="egse.storage.StorageInterface.save" href="#egse.storage.StorageInterface.save">save</a></code></li>
<li><code><a title="egse.storage.StorageInterface.start_observation" href="#egse.storage.StorageInterface.start_observation">start_observation</a></code></li>
<li><code><a title="egse.storage.StorageInterface.unregister" href="#egse.storage.StorageInterface.unregister">unregister</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#commands">Commands</a></li>
<li><a href="#what-data-is-saved">What data is saved?</a></li>
<li><a href="#how-is-data-saved">How is data saved?</a></li>
<li><a href="#how-are-the-files-named">How are the files named?</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="../index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="egse.storage.persistence" href="persistence.html">egse.storage.persistence</a></code></li>
<li><code><a title="egse.storage.storage_cs" href="storage_cs.html">egse.storage.storage_cs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.storage.cycle_daily_files" href="#egse.storage.cycle_daily_files">cycle_daily_files</a></code></li>
<li><code><a title="egse.storage.determine_counter_from_dir_list" href="#egse.storage.determine_counter_from_dir_list">determine_counter_from_dir_list</a></code></li>
<li><code><a title="egse.storage.get_counter" href="#egse.storage.get_counter">get_counter</a></code></li>
<li><code><a title="egse.storage.is_storage_manager_active" href="#egse.storage.is_storage_manager_active">is_storage_manager_active</a></code></li>
<li><code><a title="egse.storage.register_to_storage_manager" href="#egse.storage.register_to_storage_manager">register_to_storage_manager</a></code></li>
<li><code><a title="egse.storage.unregister_from_storage_manager" href="#egse.storage.unregister_from_storage_manager">unregister_from_storage_manager</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.storage.AlreadyRegisteredError" href="#egse.storage.AlreadyRegisteredError">AlreadyRegisteredError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.storage.Registry" href="#egse.storage.Registry">Registry</a></code></h4>
<ul class="">
<li><code><a title="egse.storage.Registry.get" href="#egse.storage.Registry.get">get</a></code></li>
<li><code><a title="egse.storage.Registry.register" href="#egse.storage.Registry.register">register</a></code></li>
<li><code><a title="egse.storage.Registry.unregister" href="#egse.storage.Registry.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.storage.StorageCommand" href="#egse.storage.StorageCommand">StorageCommand</a></code></h4>
</li>
<li>
<h4><code><a title="egse.storage.StorageController" href="#egse.storage.StorageController">StorageController</a></code></h4>
<ul class="">
<li><code><a title="egse.storage.StorageController.cycle_daily_files" href="#egse.storage.StorageController.cycle_daily_files">cycle_daily_files</a></code></li>
<li><code><a title="egse.storage.StorageController.get_storage_location" href="#egse.storage.StorageController.get_storage_location">get_storage_location</a></code></li>
<li><code><a title="egse.storage.StorageController.save" href="#egse.storage.StorageController.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.storage.StorageInterface" href="#egse.storage.StorageInterface">StorageInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.storage.StorageInterface.cycle_daily_files" href="#egse.storage.StorageInterface.cycle_daily_files">cycle_daily_files</a></code></li>
<li><code><a title="egse.storage.StorageInterface.end_observation" href="#egse.storage.StorageInterface.end_observation">end_observation</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_disk_usage" href="#egse.storage.StorageInterface.get_disk_usage">get_disk_usage</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_filenames" href="#egse.storage.StorageInterface.get_filenames">get_filenames</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_obsid" href="#egse.storage.StorageInterface.get_obsid">get_obsid</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_registry_names" href="#egse.storage.StorageInterface.get_registry_names">get_registry_names</a></code></li>
<li><code><a title="egse.storage.StorageInterface.get_storage_location" href="#egse.storage.StorageInterface.get_storage_location">get_storage_location</a></code></li>
<li><code><a title="egse.storage.StorageInterface.new_registration" href="#egse.storage.StorageInterface.new_registration">new_registration</a></code></li>
<li><code><a title="egse.storage.StorageInterface.read" href="#egse.storage.StorageInterface.read">read</a></code></li>
<li><code><a title="egse.storage.StorageInterface.register" href="#egse.storage.StorageInterface.register">register</a></code></li>
<li><code><a title="egse.storage.StorageInterface.save" href="#egse.storage.StorageInterface.save">save</a></code></li>
<li><code><a title="egse.storage.StorageInterface.start_observation" href="#egse.storage.StorageInterface.start_observation">start_observation</a></code></li>
<li><code><a title="egse.storage.StorageInterface.unregister" href="#egse.storage.StorageInterface.unregister">unregister</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.storage.StoragePacket" href="#egse.storage.StoragePacket">StoragePacket</a></code></h4>
<ul class="">
<li><code><a title="egse.storage.StoragePacket.data" href="#egse.storage.StoragePacket.data">data</a></code></li>
<li><code><a title="egse.storage.StoragePacket.metadata" href="#egse.storage.StoragePacket.metadata">metadata</a></code></li>
<li><code><a title="egse.storage.StoragePacket.origin" href="#egse.storage.StoragePacket.origin">origin</a></code></li>
<li><code><a title="egse.storage.StoragePacket.timestamp" href="#egse.storage.StoragePacket.timestamp">timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.storage.StorageProtocol" href="#egse.storage.StorageProtocol">StorageProtocol</a></code></h4>
</li>
<li>
<h4><code><a title="egse.storage.StorageProxy" href="#egse.storage.StorageProxy">StorageProxy</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
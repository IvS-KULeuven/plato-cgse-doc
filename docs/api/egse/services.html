<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.services API documentation</title>
<meta name="description" content="This module provides the services to the control servers …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.services</code></h1>
</header>
<section id="section-intro">
<p>This module provides the services to the control servers.</p>
<p>Each control server has a services protocol which provides commands that will
be executed on the control server instead of the device controller. This is
typically used to access control server specific settings like monitoring frequency,
logging levels, or to quit the control server in a controlled way.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides the services to the control servers.

Each control server has a services protocol which provides commands that will
be executed on the control server instead of the device controller. This is
typically used to access control server specific settings like monitoring frequency,
logging levels, or to quit the control server in a controlled way.

&#34;&#34;&#34;

import inspect
import logging

from egse.command import ClientServerCommand
from egse.control import ControlServer
from egse.protocol import CommandProtocol
from egse.proxy import Proxy
from egse.settings import Settings
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

MODULE_LOGGER = logging.getLogger(__name__)

SERVICE_SETTINGS = Settings.load(filename=&#34;services.yaml&#34;)


class ServiceCommand(ClientServerCommand):
    pass


class ServiceProtocol(CommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__()
        self.control_server = control_server

        self.load_commands(SERVICE_SETTINGS.Commands, ServiceCommand, ServiceProtocol)

    def get_bind_address(self):
        return bind_address(self.control_server.get_communication_protocol(), self.control_server.get_service_port())

    def get_status(self):
        return super().get_status()

    def handle_monitoring_frequency(self, freq: float):
        &#34;&#34;&#34;
        Sets the monitoring frequency (Hz) to the given freq value. This is only approximate since the frequency is
        converted into a delay time and the actual execution of the status function is subject to the load on the
        server and the overhead of the timing.

        Args:
            freq: frequency of execution (Hz)

        Returns:
            Sends back the selected delay time in seconds.
        &#34;&#34;&#34;
        seconds = self.control_server.set_delay(1.0 / freq)

        MODULE_LOGGER.debug(f&#34;Set monitoring frequency to {freq}Hz, ± every {seconds} seconds.&#34;)

        self.send(seconds)

    def handle_hk_frequency(self, freq: float):
        &#34;&#34;&#34;
        Sets the housekeeping frequency (Hz) to the given freq value. This is only approximate since the frequency is
        converted into a delay time and the actual execution of the `housekeeping` function is subject to the load on
        the server and the overhead of the timing.

        Args:
            freq: frequency of execution (Hz)

        Returns:
            Sends back the selected delay time in seconds.
        &#34;&#34;&#34;
        seconds = self.control_server.set_hk_delay(1.0 / freq)

        MODULE_LOGGER.debug(f&#34;Set housekeeping frequency to {freq}Hz, ± every {seconds} seconds.&#34;)

        self.send(seconds)

    def handle_logging_level(self, *args, **kwargs):
        &#34;&#34;&#34;
        Set the logging level for the logger with the given name.

        When &#39;all&#39; is given for the name of the logger, the level of all loggers for which the name
        starts with &#39;egse&#39; will be changed to `level`.

        Args:
            name (str): the name of an existing Logger
            level (int): the logging level

        Returns:
            Sends back an info message on what level was set.
        &#34;&#34;&#34;
        if args:
            name = args[0]
            level = int(args[1])
        else:
            name = kwargs[&#39;name&#39;]
            level = kwargs[&#39;level&#39;]

        if name == &#39;all&#39;:
            for logger in [logging.getLogger(logger_name)
                           for logger_name in logging.root.manager.loggerDict
                           if logger_name.startswith(&#39;egse&#39;)]:
                logger.setLevel(level)
            msg = f&#34;Logging level set to {level} for ALL &#39;egse&#39; loggers&#34;
        elif name in logging.root.manager.loggerDict:
            logger = logging.getLogger(name)
            logger.setLevel(level)
            msg = f&#34;Logging level for {name} set to {level}.&#34;
        else:
            msg = f&#34;Logger with name &#39;{name}&#39; doesn&#39;t exist at the server side.&#34;

        # self.control_server.set_logging_level(level)
        logging.debug(msg)
        self.send(msg)

    def handle_quit(self):
        MODULE_LOGGER.info(f&#34;Sending interrupt to {self.control_server.__class__.__name__}.&#34;)
        self.control_server.quit()
        self.send(f&#34;Sent interrupt to {self.control_server.__class__.__name__}.&#34;)

    def handle_process_status(self):
        MODULE_LOGGER.debug(f&#34;Asking for process status of {self.control_server.__class__.__name__}.&#34;)
        self.send(self.get_status())

    # FIXME: This function should be renamed `handle_get_cs_module` in the same spirit as all other service commands

    def get_cs_module(self):
        &#34;&#34;&#34;
        Returns the module in which the control server has been implemented.
        &#34;&#34;&#34;
        MODULE_LOGGER.debug(&#34;Asking for module of {self.control_server.__class__.__name__}.&#34;)
        self.send(inspect.getmodule(self.control_server).__spec__.name)


class ServiceProxy(Proxy):
    &#34;&#34;&#34;
    A ServiceProxy is a simple class that forwards service commands to a control server.
    &#34;&#34;&#34;

    def __init__(self, ctrl_settings=None, *, protocol=None, hostname=None, port=None):
        &#34;&#34;&#34;
        A ServiceProxy can be configured from the specific control server settings, or additional
        arguments `protocol`, `hostname` and `port` can be passed.

        The additional arguments always overwrite the values loaded from ctrl_settings. Either ctrl_settings or
        hostname and port must be provided, protocol is optional and defaults to &#39;tcp&#39;.

        Args:
            ctrl_settings: an AttributeDict with HOSTNAME, PORT and PROTOCOL attributes
            protocol: the transport protocol [default: tcp]
            hostname: the IP addrress of the control server
            port: the port on which the control server is listening for service commands
        &#34;&#34;&#34;
        _protocol = _hostname = _port = None
        if ctrl_settings:
            _protocol = ctrl_settings.PROTOCOL
            _hostname = ctrl_settings.HOSTNAME
            _port = ctrl_settings.SERVICE_PORT

        # the protocol argument is overwriting the standard crtl_settings

        if protocol:
            _protocol = protocol

        # if still _protocol is not set, neither by ctrl_settings, nor by the protocol argument, use a default

        if _protocol is None:
            _protocol = &#39;tcp&#39;

        if hostname:
            _hostname = hostname
        if port:
            _port = port

        if _hostname is None or _port is None:
            raise ValueError(f&#34;expected ctrl-settings or hostname and port as arguments&#34;)

        super().__init__(connect_address(_protocol, _hostname, _port))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.services.ServiceCommand"><code class="flex name class">
<span>class <span class="ident">ServiceCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServiceCommand(ClientServerCommand):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.services.ServiceProtocol"><code class="flex name class">
<span>class <span class="ident">ServiceProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="control.html#egse.control.ControlServer">ControlServer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the glue between the control servers and the hardware
controllers on one side, and between the control server and the connected
proxy classes on the other side.</p>
<p>The connection with the hardware controllers is when the <code>execute()</code> method
calls the <code>server_call()</code> method of the command class.</p>
<p>The connection with the proxy classes is when the <code>client_call()</code> method is added to the
interface of the Proxy subclass (by the <code>_add_commands()</code> method).</p>
<p>FIXME: Protocol is not used at the client side, i.e. the Proxy class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServiceProtocol(CommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__()
        self.control_server = control_server

        self.load_commands(SERVICE_SETTINGS.Commands, ServiceCommand, ServiceProtocol)

    def get_bind_address(self):
        return bind_address(self.control_server.get_communication_protocol(), self.control_server.get_service_port())

    def get_status(self):
        return super().get_status()

    def handle_monitoring_frequency(self, freq: float):
        &#34;&#34;&#34;
        Sets the monitoring frequency (Hz) to the given freq value. This is only approximate since the frequency is
        converted into a delay time and the actual execution of the status function is subject to the load on the
        server and the overhead of the timing.

        Args:
            freq: frequency of execution (Hz)

        Returns:
            Sends back the selected delay time in seconds.
        &#34;&#34;&#34;
        seconds = self.control_server.set_delay(1.0 / freq)

        MODULE_LOGGER.debug(f&#34;Set monitoring frequency to {freq}Hz, ± every {seconds} seconds.&#34;)

        self.send(seconds)

    def handle_hk_frequency(self, freq: float):
        &#34;&#34;&#34;
        Sets the housekeeping frequency (Hz) to the given freq value. This is only approximate since the frequency is
        converted into a delay time and the actual execution of the `housekeeping` function is subject to the load on
        the server and the overhead of the timing.

        Args:
            freq: frequency of execution (Hz)

        Returns:
            Sends back the selected delay time in seconds.
        &#34;&#34;&#34;
        seconds = self.control_server.set_hk_delay(1.0 / freq)

        MODULE_LOGGER.debug(f&#34;Set housekeeping frequency to {freq}Hz, ± every {seconds} seconds.&#34;)

        self.send(seconds)

    def handle_logging_level(self, *args, **kwargs):
        &#34;&#34;&#34;
        Set the logging level for the logger with the given name.

        When &#39;all&#39; is given for the name of the logger, the level of all loggers for which the name
        starts with &#39;egse&#39; will be changed to `level`.

        Args:
            name (str): the name of an existing Logger
            level (int): the logging level

        Returns:
            Sends back an info message on what level was set.
        &#34;&#34;&#34;
        if args:
            name = args[0]
            level = int(args[1])
        else:
            name = kwargs[&#39;name&#39;]
            level = kwargs[&#39;level&#39;]

        if name == &#39;all&#39;:
            for logger in [logging.getLogger(logger_name)
                           for logger_name in logging.root.manager.loggerDict
                           if logger_name.startswith(&#39;egse&#39;)]:
                logger.setLevel(level)
            msg = f&#34;Logging level set to {level} for ALL &#39;egse&#39; loggers&#34;
        elif name in logging.root.manager.loggerDict:
            logger = logging.getLogger(name)
            logger.setLevel(level)
            msg = f&#34;Logging level for {name} set to {level}.&#34;
        else:
            msg = f&#34;Logger with name &#39;{name}&#39; doesn&#39;t exist at the server side.&#34;

        # self.control_server.set_logging_level(level)
        logging.debug(msg)
        self.send(msg)

    def handle_quit(self):
        MODULE_LOGGER.info(f&#34;Sending interrupt to {self.control_server.__class__.__name__}.&#34;)
        self.control_server.quit()
        self.send(f&#34;Sent interrupt to {self.control_server.__class__.__name__}.&#34;)

    def handle_process_status(self):
        MODULE_LOGGER.debug(f&#34;Asking for process status of {self.control_server.__class__.__name__}.&#34;)
        self.send(self.get_status())

    # FIXME: This function should be renamed `handle_get_cs_module` in the same spirit as all other service commands

    def get_cs_module(self):
        &#34;&#34;&#34;
        Returns the module in which the control server has been implemented.
        &#34;&#34;&#34;
        MODULE_LOGGER.debug(&#34;Asking for module of {self.control_server.__class__.__name__}.&#34;)
        self.send(inspect.getmodule(self.control_server).__spec__.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.protocol.CommandProtocol" href="protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.services.ServiceProtocol.get_cs_module"><code class="name flex">
<span>def <span class="ident">get_cs_module</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the module in which the control server has been implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cs_module(self):
    &#34;&#34;&#34;
    Returns the module in which the control server has been implemented.
    &#34;&#34;&#34;
    MODULE_LOGGER.debug(&#34;Asking for module of {self.control_server.__class__.__name__}.&#34;)
    self.send(inspect.getmodule(self.control_server).__spec__.name)</code></pre>
</details>
</dd>
<dt id="egse.services.ServiceProtocol.handle_hk_frequency"><code class="name flex">
<span>def <span class="ident">handle_hk_frequency</span></span>(<span>self, freq: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the housekeeping frequency (Hz) to the given freq value. This is only approximate since the frequency is
converted into a delay time and the actual execution of the <code>housekeeping</code> function is subject to the load on
the server and the overhead of the timing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freq</code></strong></dt>
<dd>frequency of execution (Hz)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sends back the selected delay time in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_hk_frequency(self, freq: float):
    &#34;&#34;&#34;
    Sets the housekeeping frequency (Hz) to the given freq value. This is only approximate since the frequency is
    converted into a delay time and the actual execution of the `housekeeping` function is subject to the load on
    the server and the overhead of the timing.

    Args:
        freq: frequency of execution (Hz)

    Returns:
        Sends back the selected delay time in seconds.
    &#34;&#34;&#34;
    seconds = self.control_server.set_hk_delay(1.0 / freq)

    MODULE_LOGGER.debug(f&#34;Set housekeeping frequency to {freq}Hz, ± every {seconds} seconds.&#34;)

    self.send(seconds)</code></pre>
</details>
</dd>
<dt id="egse.services.ServiceProtocol.handle_logging_level"><code class="name flex">
<span>def <span class="ident">handle_logging_level</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the logging level for the logger with the given name.</p>
<p>When 'all' is given for the name of the logger, the level of all loggers for which the name
starts with 'egse' will be changed to <code>level</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of an existing Logger</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>the logging level</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sends back an info message on what level was set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_logging_level(self, *args, **kwargs):
    &#34;&#34;&#34;
    Set the logging level for the logger with the given name.

    When &#39;all&#39; is given for the name of the logger, the level of all loggers for which the name
    starts with &#39;egse&#39; will be changed to `level`.

    Args:
        name (str): the name of an existing Logger
        level (int): the logging level

    Returns:
        Sends back an info message on what level was set.
    &#34;&#34;&#34;
    if args:
        name = args[0]
        level = int(args[1])
    else:
        name = kwargs[&#39;name&#39;]
        level = kwargs[&#39;level&#39;]

    if name == &#39;all&#39;:
        for logger in [logging.getLogger(logger_name)
                       for logger_name in logging.root.manager.loggerDict
                       if logger_name.startswith(&#39;egse&#39;)]:
            logger.setLevel(level)
        msg = f&#34;Logging level set to {level} for ALL &#39;egse&#39; loggers&#34;
    elif name in logging.root.manager.loggerDict:
        logger = logging.getLogger(name)
        logger.setLevel(level)
        msg = f&#34;Logging level for {name} set to {level}.&#34;
    else:
        msg = f&#34;Logger with name &#39;{name}&#39; doesn&#39;t exist at the server side.&#34;

    # self.control_server.set_logging_level(level)
    logging.debug(msg)
    self.send(msg)</code></pre>
</details>
</dd>
<dt id="egse.services.ServiceProtocol.handle_monitoring_frequency"><code class="name flex">
<span>def <span class="ident">handle_monitoring_frequency</span></span>(<span>self, freq: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the monitoring frequency (Hz) to the given freq value. This is only approximate since the frequency is
converted into a delay time and the actual execution of the status function is subject to the load on the
server and the overhead of the timing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freq</code></strong></dt>
<dd>frequency of execution (Hz)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Sends back the selected delay time in seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_monitoring_frequency(self, freq: float):
    &#34;&#34;&#34;
    Sets the monitoring frequency (Hz) to the given freq value. This is only approximate since the frequency is
    converted into a delay time and the actual execution of the status function is subject to the load on the
    server and the overhead of the timing.

    Args:
        freq: frequency of execution (Hz)

    Returns:
        Sends back the selected delay time in seconds.
    &#34;&#34;&#34;
    seconds = self.control_server.set_delay(1.0 / freq)

    MODULE_LOGGER.debug(f&#34;Set monitoring frequency to {freq}Hz, ± every {seconds} seconds.&#34;)

    self.send(seconds)</code></pre>
</details>
</dd>
<dt id="egse.services.ServiceProtocol.handle_process_status"><code class="name flex">
<span>def <span class="ident">handle_process_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_process_status(self):
    MODULE_LOGGER.debug(f&#34;Asking for process status of {self.control_server.__class__.__name__}.&#34;)
    self.send(self.get_status())</code></pre>
</details>
</dd>
<dt id="egse.services.ServiceProtocol.handle_quit"><code class="name flex">
<span>def <span class="ident">handle_quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_quit(self):
    MODULE_LOGGER.info(f&#34;Sending interrupt to {self.control_server.__class__.__name__}.&#34;)
    self.control_server.quit()
    self.send(f&#34;Sent interrupt to {self.control_server.__class__.__name__}.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.protocol.CommandProtocol" href="protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.protocol.CommandProtocol.bind" href="protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.build_device_method_lookup_table" href="protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_bind_address" href="protocol.html#egse.protocol.CommandProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_housekeeping" href="protocol.html#egse.protocol.CommandProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_status" href="protocol.html#egse.protocol.CommandProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.handle_device_method" href="protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.is_alive" href="protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.load_commands" href="protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.quit" href="protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.receive" href="protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send" href="protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send_commands" href="protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.state" href="device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.update_connection_state" href="device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.services.ServiceProxy"><code class="flex name class">
<span>class <span class="ident">ServiceProxy</span></span>
<span>(</span><span>ctrl_settings=None, *, protocol=None, hostname=None, port=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A ServiceProxy is a simple class that forwards service commands to a control server.</p>
<p>A ServiceProxy can be configured from the specific control server settings, or additional
arguments <code>protocol</code>, <code>hostname</code> and <code>port</code> can be passed.</p>
<p>The additional arguments always overwrite the values loaded from ctrl_settings. Either ctrl_settings or
hostname and port must be provided, protocol is optional and defaults to 'tcp'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ctrl_settings</code></strong></dt>
<dd>an AttributeDict with HOSTNAME, PORT and PROTOCOL attributes</dd>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol [default: tcp]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>the IP addrress of the control server</dd>
<dt><strong><code>port</code></strong></dt>
<dd>the port on which the control server is listening for service commands</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServiceProxy(Proxy):
    &#34;&#34;&#34;
    A ServiceProxy is a simple class that forwards service commands to a control server.
    &#34;&#34;&#34;

    def __init__(self, ctrl_settings=None, *, protocol=None, hostname=None, port=None):
        &#34;&#34;&#34;
        A ServiceProxy can be configured from the specific control server settings, or additional
        arguments `protocol`, `hostname` and `port` can be passed.

        The additional arguments always overwrite the values loaded from ctrl_settings. Either ctrl_settings or
        hostname and port must be provided, protocol is optional and defaults to &#39;tcp&#39;.

        Args:
            ctrl_settings: an AttributeDict with HOSTNAME, PORT and PROTOCOL attributes
            protocol: the transport protocol [default: tcp]
            hostname: the IP addrress of the control server
            port: the port on which the control server is listening for service commands
        &#34;&#34;&#34;
        _protocol = _hostname = _port = None
        if ctrl_settings:
            _protocol = ctrl_settings.PROTOCOL
            _hostname = ctrl_settings.HOSTNAME
            _port = ctrl_settings.SERVICE_PORT

        # the protocol argument is overwriting the standard crtl_settings

        if protocol:
            _protocol = protocol

        # if still _protocol is not set, neither by ctrl_settings, nor by the protocol argument, use a default

        if _protocol is None:
            _protocol = &#39;tcp&#39;

        if hostname:
            _hostname = hostname
        if port:
            _port = port

        if _hostname is None or _port is None:
            raise ValueError(f&#34;expected ctrl-settings or hostname and port as arguments&#34;)

        super().__init__(connect_address(_protocol, _hostname, _port))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.services.ServiceCommand" href="#egse.services.ServiceCommand">ServiceCommand</a></code></h4>
</li>
<li>
<h4><code><a title="egse.services.ServiceProtocol" href="#egse.services.ServiceProtocol">ServiceProtocol</a></code></h4>
<ul class="">
<li><code><a title="egse.services.ServiceProtocol.get_cs_module" href="#egse.services.ServiceProtocol.get_cs_module">get_cs_module</a></code></li>
<li><code><a title="egse.services.ServiceProtocol.handle_hk_frequency" href="#egse.services.ServiceProtocol.handle_hk_frequency">handle_hk_frequency</a></code></li>
<li><code><a title="egse.services.ServiceProtocol.handle_logging_level" href="#egse.services.ServiceProtocol.handle_logging_level">handle_logging_level</a></code></li>
<li><code><a title="egse.services.ServiceProtocol.handle_monitoring_frequency" href="#egse.services.ServiceProtocol.handle_monitoring_frequency">handle_monitoring_frequency</a></code></li>
<li><code><a title="egse.services.ServiceProtocol.handle_process_status" href="#egse.services.ServiceProtocol.handle_process_status">handle_process_status</a></code></li>
<li><code><a title="egse.services.ServiceProtocol.handle_quit" href="#egse.services.ServiceProtocol.handle_quit">handle_quit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.services.ServiceProxy" href="#egse.services.ServiceProxy">ServiceProxy</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
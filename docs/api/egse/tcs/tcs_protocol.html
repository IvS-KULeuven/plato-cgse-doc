<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.tcs.tcs_protocol API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.tcs.tcs_protocol</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import logging
import multiprocessing
from typing import List

from egse.command import ClientServerCommand
from egse.control import ControlServer
from egse.control import Failure
from egse.device import DeviceConnectionState
from egse.device import DeviceTimeoutError
from egse.metrics import define_metrics
from egse.protocol import DynamicCommandProtocol
from egse.settings import Settings
from egse.system import format_datetime
from egse.tcs.tcs import TCSController
from egse.tcs.tcs import TCSParameterNaming
from egse.tcs.tcs import TCSSimulator
from egse.tcs.tcs import TCSTelemetry

MODULE_LOGGER = logging.getLogger(__name__)

CTRL_SETTINGS = Settings.load(&#34;TCS Control Server&#34;)
PUNA_SETTINGS = Settings.load(filename=&#34;tcs.yaml&#34;)


class TCSCommand(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + chr(3)  # end the string with the ASCII character EOT


class TCSMetrics:
    &#34;&#34;&#34;Defines the metrics for the TCS EGSE that are maintained by the TCSProtocol class.&#34;&#34;&#34;
    def __init__(self, origin: str, dashboard: str):
        self.metrics = define_metrics(origin=origin, dashboard=dashboard)

    def __contains__(self, item):
        return self.metrics.__contains__(item)

    def names(self):
        return self.metrics.keys()

    def update_metrics(self, name: str, value: str):
        &#34;&#34;&#34;Update the TCS metric parameter with the given value.&#34;&#34;&#34;
        if name in self.metrics:
            self.metrics[name].set(float(value))


class TCSProtocol(DynamicCommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__(control_server)

        # Read the configuration metrics from the tm-dictionary

        self._metrics = TCSMetrics(origin=control_server.get_storage_mnemonic(),
                                   dashboard=&#34;TCS_CONFIGURATION_MON&#34;)

        # Device naming is different from CGSE naming, the conversion is handled in the
        # TCSParameterNaming class.

        self._hk_names = TCSParameterNaming(origin=control_server.get_storage_mnemonic())

        # Set up two queue&#39;s to communicate with the TCS Telemetry Process.
        # The command queue is joinable because the Controller needs to wait for a response in
        # the response queue.

        self.command_queue = multiprocessing.Queue()
        self.response_queue = multiprocessing.Queue()

        # Start a separate Process to handle the TCS EGSE Telemetry

        self.processor = TCSTelemetry(self.command_queue, self.response_queue)
        self.processor.name = &#34;tcs.telemetry&#34;
        self.processor.start()

        self.device = TCSSimulator() if Settings.simulation_mode() else TCSController()

        try:
            self.device.connect()
        except (ConnectionError, DeviceTimeoutError) as exc:
            MODULE_LOGGER.warning(
                f&#34;Couldn&#39;t establish a connection to the TCS EGSE ({exc}).&#34;)

        self._dt_of_last_error = datetime.datetime.now(tz=datetime.timezone.utc)

    def quit(self):
        self.processor.terminate()

    def get_device(self):
        return self.device

    def get_status(self):

        status = super().get_status()

        # TODO (rik): add status information for the monitoring service here

        if self.state == DeviceConnectionState.DEVICE_CONNECTED:
            # Collect status information here
            pass

        return status

    def get_housekeeping(self) -&gt; dict:

        self.log_new_errors()

        result = {&#34;timestamp&#34;: format_datetime()}

        # Put in NaN as a default value, this will be updated with the actual real values
        # when the TCS EGSE is in remote control mode and the configuration can be obtained.
        # This &#39;initialisation&#39; is also needed because the column names are determined when
        # the TCS EGSE is not in remote control mode.

        result.update(
            {name: float(&#39;nan&#39;) for name in self._metrics.names()}
        )

        # if self.state == DeviceConnectionState.DEVICE_CONNECTED:
        #     # Collect housekeeping information here
        #     pass

        configuration = self.device.get_configuration()

        if isinstance(configuration, Failure):
            [self._metrics.update_metrics(name, &#39;nan&#39;) for name in self._metrics.names()]
            return result

        # update the housekeeping table with the actual values for the Storage

        result.update(
            {
                self._hk_names.get_cgse_name(name): value
                for name, value in configuration.items()
                if self._hk_names.get_cgse_name(name) in self._metrics
            }
        )

        # update the recorded metrics for Prometheus/Grafana

        for name, value in configuration.items():
            self._metrics.update_metrics(self._hk_names.get_cgse_name(name), value)

        return result

    def log_new_errors(self):

        errors = new_errors = None
        try:
            errors = self.device.get_error()
            new_errors = self._extract_last_error(errors)
            for error in new_errors:
                MODULE_LOGGER.error(f&#34;TCS EGSE: {error}&#34;)
        except Exception as exc:
            MODULE_LOGGER.error(f&#34;Exception caught: {exc=}&#34;)
            MODULE_LOGGER.debug(f&#34;{errors=}&#34;)
            MODULE_LOGGER.debug(f&#34;{new_errors=}&#34;)

    def _extract_last_error(self, errors: List):

        new_errors = []

        for error_msg in errors:
            if &#39;remote_mode_not_active&#39; in error_msg:
                MODULE_LOGGER.warning(&#34;TCS EGSE: Remote mode is not active&#34;)
                break
            if &#39;no errors&#39; in error_msg:
                break
            dt_error_str, *_, msg = error_msg.split(&#39;\t&#39;)
            dt_error = datetime.datetime.strptime(dt_error_str, &#34;%Y/%m/%d %H:%M:%S.%f UTC&#34;)
            dt_error = dt_error.replace(tzinfo=datetime.timezone.utc)
            if dt_error &gt; self._dt_of_last_error:
                new_errors.append((format_datetime(dt_error), msg))

        self._dt_of_last_error = datetime.datetime.now(tz=datetime.timezone.utc)

        return new_errors</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.tcs.tcs_protocol.TCSCommand"><code class="flex name class">
<span>class <span class="ident">TCSCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TCSCommand(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + chr(3)  # end the string with the ASCII character EOT</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tcs.tcs_protocol.TCSCommand.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    out = super().get_cmd_string(*args, **kwargs)
    return out + chr(3)  # end the string with the ASCII character EOT</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.tcs.tcs_protocol.TCSMetrics"><code class="flex name class">
<span>class <span class="ident">TCSMetrics</span></span>
<span>(</span><span>origin: str, dashboard: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the metrics for the TCS EGSE that are maintained by the TCSProtocol class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TCSMetrics:
    &#34;&#34;&#34;Defines the metrics for the TCS EGSE that are maintained by the TCSProtocol class.&#34;&#34;&#34;
    def __init__(self, origin: str, dashboard: str):
        self.metrics = define_metrics(origin=origin, dashboard=dashboard)

    def __contains__(self, item):
        return self.metrics.__contains__(item)

    def names(self):
        return self.metrics.keys()

    def update_metrics(self, name: str, value: str):
        &#34;&#34;&#34;Update the TCS metric parameter with the given value.&#34;&#34;&#34;
        if name in self.metrics:
            self.metrics[name].set(float(value))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.tcs.tcs_protocol.TCSMetrics.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self):
    return self.metrics.keys()</code></pre>
</details>
</dd>
<dt id="egse.tcs.tcs_protocol.TCSMetrics.update_metrics"><code class="name flex">
<span>def <span class="ident">update_metrics</span></span>(<span>self, name: str, value: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the TCS metric parameter with the given value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_metrics(self, name: str, value: str):
    &#34;&#34;&#34;Update the TCS metric parameter with the given value.&#34;&#34;&#34;
    if name in self.metrics:
        self.metrics[name].set(float(value))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.tcs.tcs_protocol.TCSProtocol"><code class="flex name class">
<span>class <span class="ident">TCSProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An observer for the connection state of a device. Add the sub-class of this class to
the class that inherits from DeviceConnectionObservable. The observable will notify an
update of its state by calling the <code>update_connection_state()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TCSProtocol(DynamicCommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__(control_server)

        # Read the configuration metrics from the tm-dictionary

        self._metrics = TCSMetrics(origin=control_server.get_storage_mnemonic(),
                                   dashboard=&#34;TCS_CONFIGURATION_MON&#34;)

        # Device naming is different from CGSE naming, the conversion is handled in the
        # TCSParameterNaming class.

        self._hk_names = TCSParameterNaming(origin=control_server.get_storage_mnemonic())

        # Set up two queue&#39;s to communicate with the TCS Telemetry Process.
        # The command queue is joinable because the Controller needs to wait for a response in
        # the response queue.

        self.command_queue = multiprocessing.Queue()
        self.response_queue = multiprocessing.Queue()

        # Start a separate Process to handle the TCS EGSE Telemetry

        self.processor = TCSTelemetry(self.command_queue, self.response_queue)
        self.processor.name = &#34;tcs.telemetry&#34;
        self.processor.start()

        self.device = TCSSimulator() if Settings.simulation_mode() else TCSController()

        try:
            self.device.connect()
        except (ConnectionError, DeviceTimeoutError) as exc:
            MODULE_LOGGER.warning(
                f&#34;Couldn&#39;t establish a connection to the TCS EGSE ({exc}).&#34;)

        self._dt_of_last_error = datetime.datetime.now(tz=datetime.timezone.utc)

    def quit(self):
        self.processor.terminate()

    def get_device(self):
        return self.device

    def get_status(self):

        status = super().get_status()

        # TODO (rik): add status information for the monitoring service here

        if self.state == DeviceConnectionState.DEVICE_CONNECTED:
            # Collect status information here
            pass

        return status

    def get_housekeeping(self) -&gt; dict:

        self.log_new_errors()

        result = {&#34;timestamp&#34;: format_datetime()}

        # Put in NaN as a default value, this will be updated with the actual real values
        # when the TCS EGSE is in remote control mode and the configuration can be obtained.
        # This &#39;initialisation&#39; is also needed because the column names are determined when
        # the TCS EGSE is not in remote control mode.

        result.update(
            {name: float(&#39;nan&#39;) for name in self._metrics.names()}
        )

        # if self.state == DeviceConnectionState.DEVICE_CONNECTED:
        #     # Collect housekeeping information here
        #     pass

        configuration = self.device.get_configuration()

        if isinstance(configuration, Failure):
            [self._metrics.update_metrics(name, &#39;nan&#39;) for name in self._metrics.names()]
            return result

        # update the housekeeping table with the actual values for the Storage

        result.update(
            {
                self._hk_names.get_cgse_name(name): value
                for name, value in configuration.items()
                if self._hk_names.get_cgse_name(name) in self._metrics
            }
        )

        # update the recorded metrics for Prometheus/Grafana

        for name, value in configuration.items():
            self._metrics.update_metrics(self._hk_names.get_cgse_name(name), value)

        return result

    def log_new_errors(self):

        errors = new_errors = None
        try:
            errors = self.device.get_error()
            new_errors = self._extract_last_error(errors)
            for error in new_errors:
                MODULE_LOGGER.error(f&#34;TCS EGSE: {error}&#34;)
        except Exception as exc:
            MODULE_LOGGER.error(f&#34;Exception caught: {exc=}&#34;)
            MODULE_LOGGER.debug(f&#34;{errors=}&#34;)
            MODULE_LOGGER.debug(f&#34;{new_errors=}&#34;)

    def _extract_last_error(self, errors: List):

        new_errors = []

        for error_msg in errors:
            if &#39;remote_mode_not_active&#39; in error_msg:
                MODULE_LOGGER.warning(&#34;TCS EGSE: Remote mode is not active&#34;)
                break
            if &#39;no errors&#39; in error_msg:
                break
            dt_error_str, *_, msg = error_msg.split(&#39;\t&#39;)
            dt_error = datetime.datetime.strptime(dt_error_str, &#34;%Y/%m/%d %H:%M:%S.%f UTC&#34;)
            dt_error = dt_error.replace(tzinfo=datetime.timezone.utc)
            if dt_error &gt; self._dt_of_last_error:
                new_errors.append((format_datetime(dt_error), msg))

        self._dt_of_last_error = datetime.datetime.now(tz=datetime.timezone.utc)

        return new_errors</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.protocol.DynamicCommandProtocol" href="../protocol.html#egse.protocol.DynamicCommandProtocol">DynamicCommandProtocol</a></li>
<li><a title="egse.protocol.BaseCommandProtocol" href="../protocol.html#egse.protocol.BaseCommandProtocol">BaseCommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.tcs.tcs_protocol.TCSProtocol.get_device"><code class="name flex">
<span>def <span class="ident">get_device</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device(self):
    return self.device</code></pre>
</details>
</dd>
<dt id="egse.tcs.tcs_protocol.TCSProtocol.log_new_errors"><code class="name flex">
<span>def <span class="ident">log_new_errors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_new_errors(self):

    errors = new_errors = None
    try:
        errors = self.device.get_error()
        new_errors = self._extract_last_error(errors)
        for error in new_errors:
            MODULE_LOGGER.error(f&#34;TCS EGSE: {error}&#34;)
    except Exception as exc:
        MODULE_LOGGER.error(f&#34;Exception caught: {exc=}&#34;)
        MODULE_LOGGER.debug(f&#34;{errors=}&#34;)
        MODULE_LOGGER.debug(f&#34;{new_errors=}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.tcs.tcs_protocol.TCSProtocol.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    self.processor.terminate()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.protocol.DynamicCommandProtocol" href="../protocol.html#egse.protocol.DynamicCommandProtocol">DynamicCommandProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.protocol.DynamicCommandProtocol.bind" href="../protocol.html#egse.protocol.BaseCommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.get_bind_address" href="../protocol.html#egse.protocol.BaseCommandProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.get_housekeeping" href="../protocol.html#egse.protocol.BaseCommandProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.get_status" href="../protocol.html#egse.protocol.BaseCommandProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.handle_device_method" href="../protocol.html#egse.protocol.DynamicCommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.is_alive" href="../protocol.html#egse.protocol.BaseCommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.receive" href="../protocol.html#egse.protocol.BaseCommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.send" href="../protocol.html#egse.protocol.BaseCommandProtocol.send">send</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.protocol.DynamicCommandProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.tcs" href="index.html">egse.tcs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.tcs.tcs_protocol.TCSCommand" href="#egse.tcs.tcs_protocol.TCSCommand">TCSCommand</a></code></h4>
<ul class="">
<li><code><a title="egse.tcs.tcs_protocol.TCSCommand.get_cmd_string" href="#egse.tcs.tcs_protocol.TCSCommand.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tcs.tcs_protocol.TCSMetrics" href="#egse.tcs.tcs_protocol.TCSMetrics">TCSMetrics</a></code></h4>
<ul class="">
<li><code><a title="egse.tcs.tcs_protocol.TCSMetrics.names" href="#egse.tcs.tcs_protocol.TCSMetrics.names">names</a></code></li>
<li><code><a title="egse.tcs.tcs_protocol.TCSMetrics.update_metrics" href="#egse.tcs.tcs_protocol.TCSMetrics.update_metrics">update_metrics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.tcs.tcs_protocol.TCSProtocol" href="#egse.tcs.tcs_protocol.TCSProtocol">TCSProtocol</a></code></h4>
<ul class="">
<li><code><a title="egse.tcs.tcs_protocol.TCSProtocol.get_device" href="#egse.tcs.tcs_protocol.TCSProtocol.get_device">get_device</a></code></li>
<li><code><a title="egse.tcs.tcs_protocol.TCSProtocol.log_new_errors" href="#egse.tcs.tcs_protocol.TCSProtocol.log_new_errors">log_new_errors</a></code></li>
<li><code><a title="egse.tcs.tcs_protocol.TCSProtocol.quit" href="#egse.tcs.tcs_protocol.TCSProtocol.quit">quit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
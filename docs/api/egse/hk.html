<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.hk API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.hk</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import csv
import datetime
import logging
import os
from enum import Enum
from pathlib import Path
from typing import Union

import dateutil.parser as date_parser
import numpy as np
import pandas

from egse.config import find_files
from egse.obsid import ObservationIdentifier, obsid_from_storage
from egse.resource import get_resource
from egse.settings import Settings
from egse.system import read_last_line, read_last_lines, humanize_seconds, SECONDS_IN_A_DAY, str_to_datetime, \
    time_since_epoch_1958

logger = logging.getLogger(__name__)

SITE_ID = Settings.load(&#34;SITE&#34;).ID


class TmDictionaryColumns(str, Enum):
    &#34;&#34;&#34; Enumeration of the relevant columns in the TM dictionary spreadsheet.

    The relevant columns are:

        - STORAGE_MNEMONIC: Column with the storage mnemonic of the process that generated the HK;
        - CORRECT_HK_NAMES: Column with the correct HK names (that can be used in `get_housekeeping`);
        - ORIGINAL_EGSE_HK_NAMES: Column with the names that were originally used in `get_housekeeping` the device
                                  protocol;
        - SYNOPTICS_ORIGIN_SRON: Column with the SRON-specific HK names (that will also be stored as synoptics);
        - SYNOPTICS_ORIGIN_IAS: Column with the IAS-specific HK names (that will also be stored as synoptics);
        - SYNOPTICS_ORIGIN_INTA: Column with the INTA-specific HK names (that will also be stored as synoptics);
        - CAL_OFFSET_B: Column with offset b for the linear calibration curve;
        - CAL_SLOPE_A: Column with slope a for the linear calibration curve;
        - TIMESTAMP_NAMES: Column with the name of the timestamps.
        - DASHBOARD: Column with the name of the dashboard that holds the HK metric
    &#34;&#34;&#34;

    STORAGE_MNEMONIC = &#34;Storage mnemonic&#34;
    CORRECT_HK_NAMES = &#34;CAM EGSE mnemonic&#34;
    ORIGINAL_EGSE_HK_NAMES = &#34;Original name in EGSE&#34;
    SYNOPTICS_ORIGIN_CSL = &#34;Origin of synoptics at CSL&#34;
    SYNOPTICS_ORIGIN_SRON = &#34; Origin of synoptics at SRON&#34;
    SYNOPTICS_ORIGIN_IAS = &#34; Origin of synoptics at IAS&#34;
    SYNOPTICS_ORIGIN_INTA = &#34; Origin of synoptics at INTA&#34;
    CAL_OFFSET_B = &#34;offset b cal1&#34;
    CAL_SLOPE_A = &#34;slope a cal1&#34;
    TIMESTAMP_NAMES = &#34;Name of corresponding timestamp&#34;
    DESCRIPTION = &#34;Description&#34;
    DASHBOARD = &#34;MON screen&#34;


class HKError(Exception):
    &#34;&#34;&#34; An HK-specific error.&#34;&#34;&#34;

    pass


def get_housekeeping(hk_name: str, obsid: Union[ObservationIdentifier, str, int] = None, od: str = None, time_window: int = None):
    &#34;&#34;&#34; Return the timestamp(s) and housekeeping value(s) for the housekeeping parameter with the given name.

    It is possible to indicate for which obsid or which OD the housekeeping is to be returned.  If neither of them is
    specified, the latest daily files are used.

    When the time window has not been specified, the last timestamp and housekeeping value will be returned for the
    given OD. It is possible that a component stopped writing HK for some reason, and that the last housekeeping value
    is older than you would want.  It is therefore important to inspect the corresponding timestamp.

    When the time window has been specified, the relevant housekeeping will be read:
        - determine the sampling rate (compare the timestamps for the last 2 lines in the housekeeping file);
        - determine how many samples we need to read (starting at the back);
        - read the required number of line, starting at the back;
        - for each of the read lines, append the timestamp and HK value to the arrays that will be returned

    Args:
        - hk_name: Name of the housekeeping parameter.
        - obsid: Observation identifier.  This can be an ObservationIdentifier object, a string in format TEST_LAB or
                  TEST_LAB_SETUP, or an integer representing the test ID; optional.
        - od: Identifier for the OD (yyyymmdd); optional.
        - time_window: Length of the time window over which to retrieve the housekeeping [s].  The time window ends at
                       the moment this method is called.  If not given, the latest housekeeping value is returned.

    &#34;&#34;&#34;

    # Either specify the obsid or the OD (or neither of them) but not both

    if obsid is not None and od is not None:

        raise HKError(f&#34;Both the obsid ({obsid}) and the OD ({od}) were specified.&#34;)

    # Specified obsid (as integer or as string)

    if obsid:

        try:
            return _get_housekeeping_obsid(hk_name, obsid=obsid, time_window=time_window)
        except (ValueError, StopIteration, FileNotFoundError) as exc:
            raise HKError(f&#34;No HK found for {hk_name} for obsid {obsid} at {SITE_ID}&#34;) from exc

    # Specified OD

    if od:

        try:
            return _get_housekeeping_od(hk_name, od=od, time_window=time_window)
        except (ValueError, StopIteration, FileNotFoundError) as exc:
            raise HKError(f&#34;No HK found for {hk_name} for OD {od} at {SITE_ID}&#34;) from exc

    # Didn&#39;t specify neither the obsid nor the OD

    try:
        return _get_housekeeping_daily(hk_name, time_window=time_window)
    except (ValueError, StopIteration, FileNotFoundError) as exc:
        raise HKError(f&#34;No HK found for {hk_name} for today at {SITE_ID}&#34;) from exc


def _get_housekeeping(hk_name: str, timestamp_name: str, hk_dir: str, files, time_window: int = None):
    &#34;&#34;&#34; Return the timestamp(s) and HK value(s) for the HK parameter with the given name, for the given files.

    When the time window has not been specified, the last timestamp and HK value will be returned for the given OD.
    It is possible that a component stopped writing HK for some reason, and that the last HK value is older than you
    would want.  It is therefore important to inspect the corresponding timestamp.

    When the time window has been specified, the relevant HK will be read:
        - determine the sampling rate (compare the timestamps for the last 2 lines in the HK file);
        - determine how many samples we need to read (starting at the back);
        - read the required number of line, starting at the back;
        - for each of the read lines, append the timestamp and HK value to the arrays that will be returned

    Args:
        - hk_name: Name of the housekeeping parameter.
        - timestamp_name: Name of the corresponding timestamp.
        - hk_dir: Directory with the housekeeping files.
        - files: Relative filepath of the selected housekeeping files.
        - time_window: Length of the time window over which to retrieve the housekeeping [s].  The time window ends at
                       the moment this method is called.  If not given, the latest HK-value is returned.

    Returns:
        - If the time window has not been specified: the most recent timestamp and housekeeping value.
        - If the time window has been specified: an array of timestamps and an array of housekeeping values, belonging
          to the specified time window.
    &#34;&#34;&#34;

    filename = files[-1]

    # Indices of the columns we need

    timestamp_index, hk_index = get_indices(hk_dir + filename, hk_name, timestamp_name)

    # No time window specified: return the last value

    if time_window is None:

        return get_last_non_empty(hk_dir + filename, timestamp_index, hk_index)

    # Time window specified

    else:

        # We will return an array of timestamps and an array of HK values

        timestamp_array = np.array([])
        hk_array = np.array([])

        with open(hk_dir + filename) as file:

            csv_reader = csv.reader(file)
            next(csv_reader)
            first_timepoint = next(csv_reader)[0].split(&#34;,&#34;)[timestamp_index]  # Skip the header

        last_timepoint = read_last_line(hk_dir + filename).split(&#34;,&#34;)[timestamp_index]
        elapsed = (str_to_datetime(last_timepoint) - str_to_datetime(first_timepoint)).total_seconds()

        # The time window is shorter than the timespan covered by the file

        if time_window &lt; elapsed:

            sampling_rate = get_sampling_rate(hk_dir + filename, timestamp_name)  # Time between subsequent samples
            num_samples = int(round(time_window / sampling_rate))

            lines = read_last_lines(hk_dir + filename, num_samples)

            for line in lines:

                line = line.split(&#34;,&#34;)

                timestamp_array = np.append(timestamp_array, line[timestamp_index])
                hk_array = np.append(hk_array, line[hk_index])

        # The time window is longer than the timespan covered by the file: read all lines

        else:

            with open(hk_dir + filename) as file:

                csv_reader = csv.reader(file)
                next(csv_reader)  # Skip the header

                for row in csv_reader:

                    timestamp_array = np.append(timestamp_array, row[timestamp_index])
                    hk_array = np.append(hk_array, row[hk_index])

        for index in range(len(timestamp_array)):

            timestamp_array[index] = time_since_epoch_1958(timestamp_array[index])

        return timestamp_array, hk_array


def _get_housekeeping_od(hk_name: str, od: str, time_window: int = None):
    &#34;&#34;&#34; Return the timestamp(s) and HK value(s) for the HK parameter with the given name, for the given OD.

    When the time window has not been specified, the last timestamp and HK value will be returned for the given OD.
    It is possible that a component stopped writing HK for some reason, and that the last HK value is older than you
    would want.  It is therefore important to inspect the corresponding timestamp.

    When the time window has been specified, the relevant HK will be read:
        - determine the sampling rate (compare the timestamps for the last 2 lines in the HK file);
        - determine how many samples we need to read (starting at the back);
        - read the required number of line, starting at the back;
        - for each of the read lines, append the timestamp and HK value to the arrays that will be returned

    Args:
        - hk_name: Name of the housekeeping parameter.
        - od: Identifier for the OD (yyyymmdd).
        - time_window: Length of the time window over which to retrieve the housekeeping [s].  The time window ends at
                       the moment this method is called.  If not given, the latest HK-value is returned.

        Returns:
            - If the time window has not been specified: the most recent timestamp and HK value.
            - If the time window has been specified: an array of timestamps and an array of HK values, belonging to the
              specified time window.
    &#34;&#34;&#34;

    hk_dir = os.environ[&#34;PLATO_DATA_STORAGE_LOCATION&#34;] + &#34;/daily/&#34;  # Where the HK is stored

    try:

        origin, timestamp_name = get_hk_info(hk_name)

    except KeyError:

        raise HKError(f&#34;Cannot determine which EGSE component generated HK parameter {hk_name}&#34;)

    hk_dir += f&#34;{od}/&#34;
    hk_files = [f&#34;{od}_{SITE_ID}_{origin}.csv&#34;]

    return _get_housekeeping(hk_name, timestamp_name, hk_dir, hk_files, time_window=time_window)


def _get_housekeeping_obsid(hk_name: str, obsid: Union[ObservationIdentifier, str, int], time_window: int = None):
    &#34;&#34;&#34; Return the timestamp(s) and HK value(s) for the HK parameter with the given name, for the given obsid.

    When the time window has not been specified, the last timestamp and HK value will be returned for the given obsid.
    It is possible that a component stopped writing HK for some reason, and that the last HK value is older than you
    would want.  It is therefore important to inspect the corresponding timestamp.

    When the time window has been specified, the relevant HK will be read:
        - determine the sampling rate (compare the timestamps for the last 2 lines in the HK file);
        - determine how many samples we need to read (starting at the back);
        - read the required number of line, starting at the back;
        - for each of the read lines, append the timestamp and HK value to the arrays that will be returned

    Args:
        - hk_name: Name of the housekeeping parameter.
        - obsid: Observation identifier.  This can be an ObservationIdentifier object, a string in format TEST_LAB or
                 TEST_LAB_SETUP, or an integer representing the test ID.
        - time_window: Length of the time window over which to retrieve the housekeeping [s].  The time window ends at
                       the moment this method is called.  If not given, the latest HK-value is returned.

        Returns:
            - If the time window has not been specified: the most recent timestamp and HK value.
            - If the time window has been specified: an array of timestamps and an array of HK values, belonging to the
              specified time window.
        &#34;&#34;&#34;

    hk_dir = os.environ[&#34;PLATO_DATA_STORAGE_LOCATION&#34;] + &#34;/obs/&#34;  # Where the HK is stored

    try:

        origin, timestamp_name = get_hk_info(hk_name)

    except KeyError:

        raise HKError(f&#34;Cannot determine which EGSE component generated HK parameter {hk_name}&#34;)

    obsid = obsid_from_storage(obsid)     # Convert the obsid to the correct format

    hk_dir += f&#34;{obsid}/&#34;
    pattern = f&#34;{obsid:05d}_{SITE_ID}_{origin}_*.csv&#34;
    hk_files = sorted(find_files(pattern=pattern, root=hk_dir))

    if len(hk_files) == 0:

        raise HKError(f&#34;No HK found for the {origin} at {SITE_ID} for obsid {obsid}&#34;)

    hk_files = [hk_files[-1].name]

    return _get_housekeeping(hk_name, timestamp_name, hk_dir, hk_files, time_window=time_window)


def _get_housekeeping_daily(hk_name: str, time_window: int = None):
    &#34;&#34;&#34; Return the timestamp(s) and HK value(s) for the HK parameter with the given name.

    When the time window has not been specified, the last timestamp and HK value will be returned.  It is possible that
    a component stopped writing HK for some reason, and that the last HK value is older than you would want.  It is
    therefore important to inspect the corresponding timestamp.

    When the time window has been specified, it is possible that we have to fetch the HK from multiple files,
    depending on the length of the time window:

        * Oldest file (i.e. the HK file in which the first timestamp in the specified time window is held): only part
          of it will have to be read (start reading at the back):
            - determine the filename;
            - determine the sampling rate (compare the timestamps for the last 2 lines in the HK file);
            - determine how many samples we need to read (starting at the back);
            - read the required number of line, starting at the back;
            - for each of the read lines, append the timestamp and HK value to the arrays that will be returned.
        * Any other files: entire file will have to be read:
            - determine the filename;
            - read all lines;
            - for each line: append the timestamp and HK value to the arrays that will be returned.

    Args:
        - hk_name: Name of the housekeeping parameter.
        - time_window: Length of the time window over which to retrieve the housekeeping [s].  The time window ends at
          the moment this method is called.  If not given, the latest HK-value is returned.

    Returns:
        - If the time window has not been specified: the most recent timestamp and HK value.
        - If the time window has been specified: an array of timestamps and an array of HK values, belonging to the
          specified time window.
    &#34;&#34;&#34;

    hk_dir = os.environ[&#34;PLATO_DATA_STORAGE_LOCATION&#34;] + &#34;/daily/&#34;  # Where the HK is stored

    try:

        origin, timestamp_name = get_hk_info(hk_name)

    except KeyError:

        raise HKError(f&#34;Cannot determine which EGSE component generated HK parameter {hk_name}&#34;)

    # No time window specified: return the last value

    if time_window is None:

        # Look for the last file of this component

        timestamp = datetime.datetime.now(tz=datetime.timezone.utc).strftime(&#34;%Y%m%d&#34;)
        hk_dir += f&#34;{timestamp}/&#34;
        filename = f&#34;{timestamp}_{SITE_ID}_{origin}.csv&#34;

        timestamp_index, hk_index = get_indices(hk_dir + filename, hk_name, timestamp_name)
        return get_last_non_empty(hk_dir + filename, timestamp_index, hk_index)

    # Time window specified

    else:

        # We will return an array of timestamps and an array of HK values

        timestamp_array = np.array([])
        hk_array = np.array([])

        # Go back in time from this very moment and determine:
        #   - which timespan the most recent HK file covers (i.e. how much time has elapsed since midnight)
        #   - what the time is at the start of the time window

        now = datetime.datetime.utcnow()
        elapsed_since_midnight = now.microsecond * 1e-6 + now.second + 60 * (now.minute + 60 * now.hour)
        start_time = now - datetime.timedelta(seconds=time_window)
        start_od = f&#34;{start_time.year}{start_time.month:02d}{start_time.day:02d}&#34;

        # Determine which columns will be needed from which file

        filename = f&#34;{start_od}/{start_od}_{SITE_ID}_{origin}.csv&#34;

        if Path(hk_dir + filename).exists():

            timestamp_index, hk_index = get_indices(hk_dir + filename, hk_name, timestamp_name)

            # Determine how many time samples you need to read in the first relevant HK file (starting from the back)

            sampling_rate = get_sampling_rate(hk_dir + filename, timestamp_name)  # Time between subsequent samples

            if time_window &lt;= elapsed_since_midnight:

                num_samples_first_day = int(round(time_window / sampling_rate))

            else:

                time_window_first_day = (time_window - elapsed_since_midnight) % SECONDS_IN_A_DAY
                num_samples_first_day = int(round(time_window_first_day / sampling_rate))  # TODO Round or floor?

            # Read the required number of lines in the relevant HK file (starting from the back of the file)

            lines_first_day = read_last_lines(hk_dir + filename, num_samples_first_day)

            for line in lines_first_day:

                line = line.split(&#34;,&#34;)

                timestamp_array = np.append(timestamp_array, line[timestamp_index])
                hk_array = np.append(hk_array, line[hk_index])

        # In case we also need to read more recent files
        # (those will have to be read entirely)

        else:

            logger.warning(f&#34;No HK available for {origin} on &#34;
                           f&#34;{start_time.day}/{start_time.month}/{start_time.year}&#34;)

        day = (start_time + datetime.timedelta(days=1)).date()  # The day after the first day
        last_day = datetime.date(now.year, now.month, now.day)  # Today

        while day &lt;= last_day:

            od = f&#34;{day.year}{day.month:02d}{day.day:02d}&#34;
            filename = f&#34;{od}/{od}_{SITE_ID}_{origin}.csv&#34;

            if Path(hk_dir + filename).exists():

                with open(hk_dir + filename) as file:

                    csv_reader = csv.reader(file)

                    header = next(csv_reader)  # Skip the header
                    timestamp_index = header.index(&#34;timestamp&#34;)
                    try:
                        hk_index = header.index(hk_name)
                    except ValueError:
                        raise HKError(f&#34;Cannot find column {hk_name} in {filename}&#34;)

                    for row in csv_reader:

                        timestamp_array = np.append(timestamp_array, row[timestamp_index])
                        hk_array = np.append(hk_array, row[hk_index])

            else:

                logger.warning(f&#34;No HK available for {origin} on {day.day}/{day.month}/{day.year}&#34;)

            day += datetime.timedelta(days=1)

        delta = (str_to_datetime(timestamp_array[-1]) - str_to_datetime(timestamp_array[0])).total_seconds()

        logger.info(f&#34;Retrieved HK data for {hk_name} over a time range of {humanize_seconds(delta)}&#34;)

        for index in range(len(timestamp_array)):

            timestamp_array[index] = time_since_epoch_1958(timestamp_array[index])

        return timestamp_array, hk_array


def get_last_non_empty(filename: str, timestamp_index: int, hk_index: int):
    &#34;&#34;&#34;  Return the timestamp and HK value for last real value.

    Args:
         - filename: HK file in which to look for the given HK parameter.
         - timestamp_index: Index of the column with the timestamps.
         - hk_index: Index of the column with the HK parameter with the given name.

    Returns:  The timestamp and HK value with the last real value.
    &#34;&#34;&#34;

    timestamp = None
    hk_value = &#34; &#34;

    filename = Path(filename)

    if not filename.exists():
        return None

    # Declaring variable to implement exponential search

    try:

        num_lines = 1

        while hk_value == &#34; &#34; or hk_value == &#34;&#34;:

            pos = num_lines + 1

            # List to store last N lines

            lines = []

            with open(filename) as f:

                while len(lines) &lt;= num_lines:

                    try:

                        f.seek(-pos, 2)

                    except IOError:

                        f.seek(0)
                        break

                    finally:

                        lines = list(f)

                    # Increasing value of variable exponentially

                    pos *= 2

            last_line = lines[-num_lines].rstrip(&#34;\r&#34;).split(&#34;,&#34;)
            timestamp, hk_value = last_line[timestamp_index], last_line[hk_index]

            num_lines += 1

        return time_since_epoch_1958(timestamp), hk_value

    except IndexError:
        return None, None


def get_indices(filename: str, hk_name: str, timestamp_name: str):
    &#34;&#34;&#34; Return the column number of the timestamp and given HK parameter in the given HK file.

    Args:
        - filename: HK file in which to look for the given HK parameter.
        - hk_name: Name of the HK parameter.
        - timestamp_name: Name of the corresponding timestamp.

    Returns:
        - Index of the column with the timestamps.
        - Index of the column with the HK parameter with the given name.
    &#34;&#34;&#34;

    with open(filename, &#34;r&#34;) as f:

        reader = csv.reader(f)
        header = next(reader)  # Skip the header

    timestamp_index = header.index(timestamp_name)
    # timestamp_index = 0

    try:

        hk_index = header.index(hk_name)

    except ValueError:

        raise HKError(f&#34;Cannot find column {hk_name} in {filename}&#34;)

    return timestamp_index, hk_index


def get_sampling_rate(filename: str, timestamp_name: str):
    &#34;&#34;&#34; Return the sampling rate for the HK file with the given name [s].

    The sampling rate is determine as the difference between the timestamps of the last two lines of the HK file.

    Args:
        - filename: Name of the HK file.  We do not check explicitly whether this file exists.

    Returns: Sampling rate for the HK file with the given name [s].
    &#34;&#34;&#34;

    # Determine which column comprises the timestamp

    with open(filename, &#34;r&#34;) as f:

        reader = csv.reader(f)
        header = next(reader)  # Skip the header

    timestamp_index = header.index(timestamp_name)

    # Read the last 2 lines and extract the timestamps for these lines

    eof = read_last_lines(filename, 2)

    penultimate_timestamp = date_parser.parse(eof[0].split(&#34;,&#34;)[timestamp_index])
    last_timestamp = date_parser.parse(eof[1].split(&#34;,&#34;)[timestamp_index])

    # Calculate the sampling rate [s]

    return (last_timestamp - penultimate_timestamp).total_seconds()


def convert_hk_names(original_hk: dict, conversion_dict: dict) -&gt; dict:
    &#34;&#34;&#34; Converts the names of the HK parameters in the given dictionary.

    The names in the given dictionary of HK parameters are replaced by the names from the given conversion dictionary.

    Args:
        - original_hk: Original dictionary of HK parameters.
        - conversion_dict: Dictionary with the original HK names as keys and the new HK names as keys.

    Returns: Dictionary of HK parameters with the corrected HK names.
    &#34;&#34;&#34;

    old_keys = list(original_hk.keys())
    converted_hk = {}

    for old_key in old_keys:

        try:
            new_key = conversion_dict[old_key]
        except KeyError:
            new_key = old_key   # No need to convert the name of the timestamp column(s)

        converted_hk[new_key] = original_hk[old_key]

    return converted_hk


def read_conversion_dict(storage_mnemonic: str, use_site: bool = False):
    &#34;&#34;&#34; Read the HK spreadsheet and compose conversion dictionary for HK names.

    The spreadsheet contains the following information:

        - storage mnemonic of the component that generates the HK
        - original HK name (as is comes from the device itself)
        - HK name with the correct prefix
        - name of the column (in the HK file) with the corresponding timestamp

    Args:
        - storage_mnemonic: Storage mnemonic of the component for which to compose the conversion dictionary
        - use_site: Indicate whether or not the prefixes of the new HK names are TH-specific

    Returns: Dictionary with the original HK names as keys and the converted HK names as values.
    &#34;&#34;&#34;

    filename = get_resource(&#34;:/data/tm-dictionary.csv&#34;)
    hk_info_table = pandas.read_csv(filename, sep=&#34;;&#34;)

    storage_mnemonic_col = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    correct_name_col = hk_info_table[TmDictionaryColumns.CORRECT_HK_NAMES].values
    original_name_col = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values

    selection = np.where(storage_mnemonic_col == storage_mnemonic)

    conversion_dict = dict(zip(original_name_col[selection], correct_name_col[selection]))

    if use_site:

        th_prefix = f&#34;G{SITE_ID}&#34;

        th_conversion_dict = {}

        for original_name, correct_name in conversion_dict.items():

            if str.startswith(str(correct_name), th_prefix):

                th_conversion_dict[original_name] = correct_name

        return th_conversion_dict

    else:

        return conversion_dict


def get_hk_info(hk_name: str):
    &#34;&#34;&#34; Read the HK spreadsheet and extract information for the given HK parameter.

    The spreadsheet contains the following information:

        - storage mnemonic of the component that generates the HK
        - original HK name
        - HK name with the correct prefix
        - name of the column (in the HK file) with the corresponding timestamp

    Args:
        - hk_name: Name of the HK parameter.

    Returns:
        - storage mnemonic of the component that generates the given HK parameter
        - name of the column in the HK file with the corresponding timestamp
    &#34;&#34;&#34;

    filename = get_resource(f&#34;:/data/tm-dictionary.csv&#34;)
    hk_info_table = pandas.read_csv(filename, sep=&#34;;&#34;)

    storage_mnemonic = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    hk_names = hk_info_table[TmDictionaryColumns.CORRECT_HK_NAMES].values
    timestamp_col = hk_info_table[TmDictionaryColumns.TIMESTAMP_NAMES].values

    selection = np.where(hk_names == hk_name)

    try:
        return storage_mnemonic[selection][0], timestamp_col[selection][0]
    except IndexError:
        raise HKError(f&#34;HK parameter {hk_name} unknown&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.hk.convert_hk_names"><code class="name flex">
<span>def <span class="ident">convert_hk_names</span></span>(<span>original_hk: dict, conversion_dict: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the names of the HK parameters in the given dictionary.</p>
<p>The names in the given dictionary of HK parameters are replaced by the names from the given conversion dictionary.</p>
<h2 id="args">Args</h2>
<ul>
<li>original_hk: Original dictionary of HK parameters.</li>
<li>conversion_dict: Dictionary with the original HK names as keys and the new HK names as keys.
Returns: Dictionary of HK parameters with the corrected HK names.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_hk_names(original_hk: dict, conversion_dict: dict) -&gt; dict:
    &#34;&#34;&#34; Converts the names of the HK parameters in the given dictionary.

    The names in the given dictionary of HK parameters are replaced by the names from the given conversion dictionary.

    Args:
        - original_hk: Original dictionary of HK parameters.
        - conversion_dict: Dictionary with the original HK names as keys and the new HK names as keys.

    Returns: Dictionary of HK parameters with the corrected HK names.
    &#34;&#34;&#34;

    old_keys = list(original_hk.keys())
    converted_hk = {}

    for old_key in old_keys:

        try:
            new_key = conversion_dict[old_key]
        except KeyError:
            new_key = old_key   # No need to convert the name of the timestamp column(s)

        converted_hk[new_key] = original_hk[old_key]

    return converted_hk</code></pre>
</details>
</dd>
<dt id="egse.hk.get_hk_info"><code class="name flex">
<span>def <span class="ident">get_hk_info</span></span>(<span>hk_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the HK spreadsheet and extract information for the given HK parameter.</p>
<p>The spreadsheet contains the following information:</p>
<pre><code>- storage mnemonic of the component that generates the HK
- original HK name
- HK name with the correct prefix
- name of the column (in the HK file) with the corresponding timestamp
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>hk_name: Name of the HK parameter.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>storage mnemonic of the component that generates the given HK parameter</li>
<li>name of the column in the HK file with the corresponding timestamp</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hk_info(hk_name: str):
    &#34;&#34;&#34; Read the HK spreadsheet and extract information for the given HK parameter.

    The spreadsheet contains the following information:

        - storage mnemonic of the component that generates the HK
        - original HK name
        - HK name with the correct prefix
        - name of the column (in the HK file) with the corresponding timestamp

    Args:
        - hk_name: Name of the HK parameter.

    Returns:
        - storage mnemonic of the component that generates the given HK parameter
        - name of the column in the HK file with the corresponding timestamp
    &#34;&#34;&#34;

    filename = get_resource(f&#34;:/data/tm-dictionary.csv&#34;)
    hk_info_table = pandas.read_csv(filename, sep=&#34;;&#34;)

    storage_mnemonic = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    hk_names = hk_info_table[TmDictionaryColumns.CORRECT_HK_NAMES].values
    timestamp_col = hk_info_table[TmDictionaryColumns.TIMESTAMP_NAMES].values

    selection = np.where(hk_names == hk_name)

    try:
        return storage_mnemonic[selection][0], timestamp_col[selection][0]
    except IndexError:
        raise HKError(f&#34;HK parameter {hk_name} unknown&#34;)</code></pre>
</details>
</dd>
<dt id="egse.hk.get_housekeeping"><code class="name flex">
<span>def <span class="ident">get_housekeeping</span></span>(<span>hk_name: str, obsid: Union[<a title="egse.obsid.ObservationIdentifier" href="obsid.html#egse.obsid.ObservationIdentifier">ObservationIdentifier</a>, str, int] = None, od: str = None, time_window: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the timestamp(s) and housekeeping value(s) for the housekeeping parameter with the given name.</p>
<p>It is possible to indicate for which obsid or which OD the housekeeping is to be returned.
If neither of them is
specified, the latest daily files are used.</p>
<p>When the time window has not been specified, the last timestamp and housekeeping value will be returned for the
given OD. It is possible that a component stopped writing HK for some reason, and that the last housekeeping value
is older than you would want.
It is therefore important to inspect the corresponding timestamp.</p>
<p>When the time window has been specified, the relevant housekeeping will be read:
- determine the sampling rate (compare the timestamps for the last 2 lines in the housekeeping file);
- determine how many samples we need to read (starting at the back);
- read the required number of line, starting at the back;
- for each of the read lines, append the timestamp and HK value to the arrays that will be returned</p>
<h2 id="args">Args</h2>
<ul>
<li>hk_name: Name of the housekeeping parameter.</li>
<li>obsid: Observation identifier.
This can be an ObservationIdentifier object, a string in format TEST_LAB or
TEST_LAB_SETUP, or an integer representing the test ID; optional.</li>
<li>od: Identifier for the OD (yyyymmdd); optional.</li>
<li>time_window: Length of the time window over which to retrieve the housekeeping [s].
The time window ends at
the moment this method is called.
If not given, the latest housekeeping value is returned.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_housekeeping(hk_name: str, obsid: Union[ObservationIdentifier, str, int] = None, od: str = None, time_window: int = None):
    &#34;&#34;&#34; Return the timestamp(s) and housekeeping value(s) for the housekeeping parameter with the given name.

    It is possible to indicate for which obsid or which OD the housekeeping is to be returned.  If neither of them is
    specified, the latest daily files are used.

    When the time window has not been specified, the last timestamp and housekeeping value will be returned for the
    given OD. It is possible that a component stopped writing HK for some reason, and that the last housekeeping value
    is older than you would want.  It is therefore important to inspect the corresponding timestamp.

    When the time window has been specified, the relevant housekeeping will be read:
        - determine the sampling rate (compare the timestamps for the last 2 lines in the housekeeping file);
        - determine how many samples we need to read (starting at the back);
        - read the required number of line, starting at the back;
        - for each of the read lines, append the timestamp and HK value to the arrays that will be returned

    Args:
        - hk_name: Name of the housekeeping parameter.
        - obsid: Observation identifier.  This can be an ObservationIdentifier object, a string in format TEST_LAB or
                  TEST_LAB_SETUP, or an integer representing the test ID; optional.
        - od: Identifier for the OD (yyyymmdd); optional.
        - time_window: Length of the time window over which to retrieve the housekeeping [s].  The time window ends at
                       the moment this method is called.  If not given, the latest housekeeping value is returned.

    &#34;&#34;&#34;

    # Either specify the obsid or the OD (or neither of them) but not both

    if obsid is not None and od is not None:

        raise HKError(f&#34;Both the obsid ({obsid}) and the OD ({od}) were specified.&#34;)

    # Specified obsid (as integer or as string)

    if obsid:

        try:
            return _get_housekeeping_obsid(hk_name, obsid=obsid, time_window=time_window)
        except (ValueError, StopIteration, FileNotFoundError) as exc:
            raise HKError(f&#34;No HK found for {hk_name} for obsid {obsid} at {SITE_ID}&#34;) from exc

    # Specified OD

    if od:

        try:
            return _get_housekeeping_od(hk_name, od=od, time_window=time_window)
        except (ValueError, StopIteration, FileNotFoundError) as exc:
            raise HKError(f&#34;No HK found for {hk_name} for OD {od} at {SITE_ID}&#34;) from exc

    # Didn&#39;t specify neither the obsid nor the OD

    try:
        return _get_housekeeping_daily(hk_name, time_window=time_window)
    except (ValueError, StopIteration, FileNotFoundError) as exc:
        raise HKError(f&#34;No HK found for {hk_name} for today at {SITE_ID}&#34;) from exc</code></pre>
</details>
</dd>
<dt id="egse.hk.get_indices"><code class="name flex">
<span>def <span class="ident">get_indices</span></span>(<span>filename: str, hk_name: str, timestamp_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the column number of the timestamp and given HK parameter in the given HK file.</p>
<h2 id="args">Args</h2>
<ul>
<li>filename: HK file in which to look for the given HK parameter.</li>
<li>hk_name: Name of the HK parameter.</li>
<li>timestamp_name: Name of the corresponding timestamp.</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>Index of the column with the timestamps.</li>
<li>Index of the column with the HK parameter with the given name.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_indices(filename: str, hk_name: str, timestamp_name: str):
    &#34;&#34;&#34; Return the column number of the timestamp and given HK parameter in the given HK file.

    Args:
        - filename: HK file in which to look for the given HK parameter.
        - hk_name: Name of the HK parameter.
        - timestamp_name: Name of the corresponding timestamp.

    Returns:
        - Index of the column with the timestamps.
        - Index of the column with the HK parameter with the given name.
    &#34;&#34;&#34;

    with open(filename, &#34;r&#34;) as f:

        reader = csv.reader(f)
        header = next(reader)  # Skip the header

    timestamp_index = header.index(timestamp_name)
    # timestamp_index = 0

    try:

        hk_index = header.index(hk_name)

    except ValueError:

        raise HKError(f&#34;Cannot find column {hk_name} in {filename}&#34;)

    return timestamp_index, hk_index</code></pre>
</details>
</dd>
<dt id="egse.hk.get_last_non_empty"><code class="name flex">
<span>def <span class="ident">get_last_non_empty</span></span>(<span>filename: str, timestamp_index: int, hk_index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the timestamp and HK value for last real value.</p>
<h2 id="args">Args</h2>
<ul>
<li>filename: HK file in which to look for the given HK parameter.</li>
<li>timestamp_index: Index of the column with the timestamps.</li>
<li>hk_index: Index of the column with the HK parameter with the given name.
Returns:
The timestamp and HK value with the last real value.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_non_empty(filename: str, timestamp_index: int, hk_index: int):
    &#34;&#34;&#34;  Return the timestamp and HK value for last real value.

    Args:
         - filename: HK file in which to look for the given HK parameter.
         - timestamp_index: Index of the column with the timestamps.
         - hk_index: Index of the column with the HK parameter with the given name.

    Returns:  The timestamp and HK value with the last real value.
    &#34;&#34;&#34;

    timestamp = None
    hk_value = &#34; &#34;

    filename = Path(filename)

    if not filename.exists():
        return None

    # Declaring variable to implement exponential search

    try:

        num_lines = 1

        while hk_value == &#34; &#34; or hk_value == &#34;&#34;:

            pos = num_lines + 1

            # List to store last N lines

            lines = []

            with open(filename) as f:

                while len(lines) &lt;= num_lines:

                    try:

                        f.seek(-pos, 2)

                    except IOError:

                        f.seek(0)
                        break

                    finally:

                        lines = list(f)

                    # Increasing value of variable exponentially

                    pos *= 2

            last_line = lines[-num_lines].rstrip(&#34;\r&#34;).split(&#34;,&#34;)
            timestamp, hk_value = last_line[timestamp_index], last_line[hk_index]

            num_lines += 1

        return time_since_epoch_1958(timestamp), hk_value

    except IndexError:
        return None, None</code></pre>
</details>
</dd>
<dt id="egse.hk.get_sampling_rate"><code class="name flex">
<span>def <span class="ident">get_sampling_rate</span></span>(<span>filename: str, timestamp_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the sampling rate for the HK file with the given name [s].</p>
<p>The sampling rate is determine as the difference between the timestamps of the last two lines of the HK file.</p>
<h2 id="args">Args</h2>
<ul>
<li>filename: Name of the HK file.
We do not check explicitly whether this file exists.
Returns: Sampling rate for the HK file with the given name [s].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sampling_rate(filename: str, timestamp_name: str):
    &#34;&#34;&#34; Return the sampling rate for the HK file with the given name [s].

    The sampling rate is determine as the difference between the timestamps of the last two lines of the HK file.

    Args:
        - filename: Name of the HK file.  We do not check explicitly whether this file exists.

    Returns: Sampling rate for the HK file with the given name [s].
    &#34;&#34;&#34;

    # Determine which column comprises the timestamp

    with open(filename, &#34;r&#34;) as f:

        reader = csv.reader(f)
        header = next(reader)  # Skip the header

    timestamp_index = header.index(timestamp_name)

    # Read the last 2 lines and extract the timestamps for these lines

    eof = read_last_lines(filename, 2)

    penultimate_timestamp = date_parser.parse(eof[0].split(&#34;,&#34;)[timestamp_index])
    last_timestamp = date_parser.parse(eof[1].split(&#34;,&#34;)[timestamp_index])

    # Calculate the sampling rate [s]

    return (last_timestamp - penultimate_timestamp).total_seconds()</code></pre>
</details>
</dd>
<dt id="egse.hk.read_conversion_dict"><code class="name flex">
<span>def <span class="ident">read_conversion_dict</span></span>(<span>storage_mnemonic: str, use_site: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the HK spreadsheet and compose conversion dictionary for HK names.</p>
<p>The spreadsheet contains the following information:</p>
<pre><code>- storage mnemonic of the component that generates the HK
- original HK name (as is comes from the device itself)
- HK name with the correct prefix
- name of the column (in the HK file) with the corresponding timestamp
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>storage_mnemonic: Storage mnemonic of the component for which to compose the conversion dictionary</li>
<li>use_site: Indicate whether or not the prefixes of the new HK names are TH-specific
Returns: Dictionary with the original HK names as keys and the converted HK names as values.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_conversion_dict(storage_mnemonic: str, use_site: bool = False):
    &#34;&#34;&#34; Read the HK spreadsheet and compose conversion dictionary for HK names.

    The spreadsheet contains the following information:

        - storage mnemonic of the component that generates the HK
        - original HK name (as is comes from the device itself)
        - HK name with the correct prefix
        - name of the column (in the HK file) with the corresponding timestamp

    Args:
        - storage_mnemonic: Storage mnemonic of the component for which to compose the conversion dictionary
        - use_site: Indicate whether or not the prefixes of the new HK names are TH-specific

    Returns: Dictionary with the original HK names as keys and the converted HK names as values.
    &#34;&#34;&#34;

    filename = get_resource(&#34;:/data/tm-dictionary.csv&#34;)
    hk_info_table = pandas.read_csv(filename, sep=&#34;;&#34;)

    storage_mnemonic_col = hk_info_table[TmDictionaryColumns.STORAGE_MNEMONIC].values
    correct_name_col = hk_info_table[TmDictionaryColumns.CORRECT_HK_NAMES].values
    original_name_col = hk_info_table[TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES].values

    selection = np.where(storage_mnemonic_col == storage_mnemonic)

    conversion_dict = dict(zip(original_name_col[selection], correct_name_col[selection]))

    if use_site:

        th_prefix = f&#34;G{SITE_ID}&#34;

        th_conversion_dict = {}

        for original_name, correct_name in conversion_dict.items():

            if str.startswith(str(correct_name), th_prefix):

                th_conversion_dict[original_name] = correct_name

        return th_conversion_dict

    else:

        return conversion_dict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.hk.HKError"><code class="flex name class">
<span>class <span class="ident">HKError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An HK-specific error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HKError(Exception):
    &#34;&#34;&#34; An HK-specific error.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.hk.TmDictionaryColumns"><code class="flex name class">
<span>class <span class="ident">TmDictionaryColumns</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of the relevant columns in the TM dictionary spreadsheet.</p>
<p>The relevant columns are:</p>
<pre><code>- STORAGE_MNEMONIC: Column with the storage mnemonic of the process that generated the HK;
- CORRECT_HK_NAMES: Column with the correct HK names (that can be used in &lt;code&gt;&lt;a title="egse.hk.get_housekeeping" href="#egse.hk.get_housekeeping"&gt;get\_housekeeping()&lt;/a&gt;&lt;/code&gt;);
- ORIGINAL_EGSE_HK_NAMES: Column with the names that were originally used in &lt;code&gt;&lt;a title="egse.hk.get_housekeeping" href="#egse.hk.get_housekeeping"&gt;get\_housekeeping()&lt;/a&gt;&lt;/code&gt; the device
                          protocol;
- SYNOPTICS_ORIGIN_SRON: Column with the SRON-specific HK names (that will also be stored as synoptics);
- SYNOPTICS_ORIGIN_IAS: Column with the IAS-specific HK names (that will also be stored as synoptics);
- SYNOPTICS_ORIGIN_INTA: Column with the INTA-specific HK names (that will also be stored as synoptics);
- CAL_OFFSET_B: Column with offset b for the linear calibration curve;
- CAL_SLOPE_A: Column with slope a for the linear calibration curve;
- TIMESTAMP_NAMES: Column with the name of the timestamps.
- DASHBOARD: Column with the name of the dashboard that holds the HK metric
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TmDictionaryColumns(str, Enum):
    &#34;&#34;&#34; Enumeration of the relevant columns in the TM dictionary spreadsheet.

    The relevant columns are:

        - STORAGE_MNEMONIC: Column with the storage mnemonic of the process that generated the HK;
        - CORRECT_HK_NAMES: Column with the correct HK names (that can be used in `get_housekeeping`);
        - ORIGINAL_EGSE_HK_NAMES: Column with the names that were originally used in `get_housekeeping` the device
                                  protocol;
        - SYNOPTICS_ORIGIN_SRON: Column with the SRON-specific HK names (that will also be stored as synoptics);
        - SYNOPTICS_ORIGIN_IAS: Column with the IAS-specific HK names (that will also be stored as synoptics);
        - SYNOPTICS_ORIGIN_INTA: Column with the INTA-specific HK names (that will also be stored as synoptics);
        - CAL_OFFSET_B: Column with offset b for the linear calibration curve;
        - CAL_SLOPE_A: Column with slope a for the linear calibration curve;
        - TIMESTAMP_NAMES: Column with the name of the timestamps.
        - DASHBOARD: Column with the name of the dashboard that holds the HK metric
    &#34;&#34;&#34;

    STORAGE_MNEMONIC = &#34;Storage mnemonic&#34;
    CORRECT_HK_NAMES = &#34;CAM EGSE mnemonic&#34;
    ORIGINAL_EGSE_HK_NAMES = &#34;Original name in EGSE&#34;
    SYNOPTICS_ORIGIN_CSL = &#34;Origin of synoptics at CSL&#34;
    SYNOPTICS_ORIGIN_SRON = &#34; Origin of synoptics at SRON&#34;
    SYNOPTICS_ORIGIN_IAS = &#34; Origin of synoptics at IAS&#34;
    SYNOPTICS_ORIGIN_INTA = &#34; Origin of synoptics at INTA&#34;
    CAL_OFFSET_B = &#34;offset b cal1&#34;
    CAL_SLOPE_A = &#34;slope a cal1&#34;
    TIMESTAMP_NAMES = &#34;Name of corresponding timestamp&#34;
    DESCRIPTION = &#34;Description&#34;
    DASHBOARD = &#34;MON screen&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.hk.TmDictionaryColumns.CAL_OFFSET_B"><code class="name">var <span class="ident">CAL_OFFSET_B</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.CAL_SLOPE_A"><code class="name">var <span class="ident">CAL_SLOPE_A</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.CORRECT_HK_NAMES"><code class="name">var <span class="ident">CORRECT_HK_NAMES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.DASHBOARD"><code class="name">var <span class="ident">DASHBOARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.DESCRIPTION"><code class="name">var <span class="ident">DESCRIPTION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES"><code class="name">var <span class="ident">ORIGINAL_EGSE_HK_NAMES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.STORAGE_MNEMONIC"><code class="name">var <span class="ident">STORAGE_MNEMONIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_CSL"><code class="name">var <span class="ident">SYNOPTICS_ORIGIN_CSL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_IAS"><code class="name">var <span class="ident">SYNOPTICS_ORIGIN_IAS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_INTA"><code class="name">var <span class="ident">SYNOPTICS_ORIGIN_INTA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_SRON"><code class="name">var <span class="ident">SYNOPTICS_ORIGIN_SRON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.hk.TmDictionaryColumns.TIMESTAMP_NAMES"><code class="name">var <span class="ident">TIMESTAMP_NAMES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.hk.convert_hk_names" href="#egse.hk.convert_hk_names">convert_hk_names</a></code></li>
<li><code><a title="egse.hk.get_hk_info" href="#egse.hk.get_hk_info">get_hk_info</a></code></li>
<li><code><a title="egse.hk.get_housekeeping" href="#egse.hk.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.hk.get_indices" href="#egse.hk.get_indices">get_indices</a></code></li>
<li><code><a title="egse.hk.get_last_non_empty" href="#egse.hk.get_last_non_empty">get_last_non_empty</a></code></li>
<li><code><a title="egse.hk.get_sampling_rate" href="#egse.hk.get_sampling_rate">get_sampling_rate</a></code></li>
<li><code><a title="egse.hk.read_conversion_dict" href="#egse.hk.read_conversion_dict">read_conversion_dict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.hk.HKError" href="#egse.hk.HKError">HKError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.hk.TmDictionaryColumns" href="#egse.hk.TmDictionaryColumns">TmDictionaryColumns</a></code></h4>
<ul class="">
<li><code><a title="egse.hk.TmDictionaryColumns.CAL_OFFSET_B" href="#egse.hk.TmDictionaryColumns.CAL_OFFSET_B">CAL_OFFSET_B</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.CAL_SLOPE_A" href="#egse.hk.TmDictionaryColumns.CAL_SLOPE_A">CAL_SLOPE_A</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.CORRECT_HK_NAMES" href="#egse.hk.TmDictionaryColumns.CORRECT_HK_NAMES">CORRECT_HK_NAMES</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.DASHBOARD" href="#egse.hk.TmDictionaryColumns.DASHBOARD">DASHBOARD</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.DESCRIPTION" href="#egse.hk.TmDictionaryColumns.DESCRIPTION">DESCRIPTION</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES" href="#egse.hk.TmDictionaryColumns.ORIGINAL_EGSE_HK_NAMES">ORIGINAL_EGSE_HK_NAMES</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.STORAGE_MNEMONIC" href="#egse.hk.TmDictionaryColumns.STORAGE_MNEMONIC">STORAGE_MNEMONIC</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_CSL" href="#egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_CSL">SYNOPTICS_ORIGIN_CSL</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_IAS" href="#egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_IAS">SYNOPTICS_ORIGIN_IAS</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_INTA" href="#egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_INTA">SYNOPTICS_ORIGIN_INTA</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_SRON" href="#egse.hk.TmDictionaryColumns.SYNOPTICS_ORIGIN_SRON">SYNOPTICS_ORIGIN_SRON</a></code></li>
<li><code><a title="egse.hk.TmDictionaryColumns.TIMESTAMP_NAMES" href="#egse.hk.TmDictionaryColumns.TIMESTAMP_NAMES">TIMESTAMP_NAMES</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.ni.alarms.cdaq9375_devif API documentation</title>
<meta name="description" content="The device interface for the NICDAQ 9375 Controller which is used at IAS for alarms system." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.ni.alarms.cdaq9375_devif</code></h1>
</header>
<section id="section-intro">
<p>The device interface for the NICDAQ 9375 Controller which is used at IAS for alarms system.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The device interface for the NICDAQ 9375 Controller which is used at IAS for alarms system.

&#34;&#34;&#34;

import logging
import time
import socket
import struct
from typing import List

from egse.settings import Settings
from egse.exceptions import DeviceNotFoundError
from egse.device import DeviceConnectionError, DeviceError
from egse.device import DeviceConnectionInterface, DeviceTransport, DeviceTimeoutError
from egse.command import ClientServerCommand

logger = logging.getLogger(__name__)

ctrl_settings = Settings.load(&#34;NI Controller&#34;)

DEVICE_NAME = &#34;CDAQ9375&#34;

READ_TIMEOUT = 1


class cdaq9375Error(Exception):
    &#34;&#34;&#34;Base exception for all ptc10 errors.&#34;&#34;&#34;
    pass


class cdaq9375Command(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\n&#34;


class cdaq9375SocketInterface(DeviceConnectionInterface, DeviceTransport):
    &#34;&#34;&#34;Defines the low-level interface to the NI CDAQ9375 Controller.
    Connects to the Labview interface via TCP/IP socket&#34;&#34;&#34;

    def __init__(self, hostname=None, port=None):
        self.hostname = ctrl_settings.HOSTNAME if hostname is None else hostname
        self.port = ctrl_settings.CDAQ9375_PORT if port is None else port
        self.sock = None

        self.is_connection_open = False

    def connect(self, hostname: str):
        # Sanity checks
        if self.is_connection_open:
            logger.warning(f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
            return
        if self.hostname in (None, &#34;&#34;):
            raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

        if self.port in (None, 0):
            raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            _id = self.get_id()
            logger.warning(f&#34;Connected to: {_id}&#34;)

        except socket.error as e_socket:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket
            # Asking for instrument description

        # We set a timeout of 3 sec before connecting and reset to None
        # (=blocking) after the connect. The reason for this is because when no
        # device is available, e.g during testing, the timeout will take about
        # two minutes which is way too long. It needs to be evaluated if this
        # approach is acceptable and not causing problems during production.

        try:
            logger.debug(f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
            self.sock.settimeout(3)
            self.sock.connect((self.hostname, self.port))
            self.sock.settimeout(None)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
            ) from exc
        except TimeoutError as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
            ) from exc
        except socket.gaierror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
            ) from exc
        except socket.herror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
            ) from exc
        except socket.timeout as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
            ) from exc
        except OSError as exc:
            raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

        self.is_connection_open = True

        if not self.is_connected():
            raise DeviceConnectionError(
                DEVICE_NAME, &#34;Device is not connected, check logging messages for the cause.&#34;
            )

    def disconnect(self):
        &#34;&#34;&#34;
        Disconnects from the device
        Raises:
            DeviceConnectionError when the connection has not been closed correctly

        &#34;&#34;&#34;
        try:
            if self.is_connection_open:
                logger.debug(f&#34;Disconnecting from {self.hostname}&#34;)
                self.sock.close()
                self.is_connection_open = False
        except Exception as e_exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc

    def is_connected(self):
        &#34;&#34;&#34;Return True if the device is connected.&#34;&#34;&#34;
        if not self.is_connection_open:
            return False
        return True

    def get_response(self, cmd_string):
        pass

    def get_id(self):
        return DEVICE_NAME

    def write(self, command: str):
        try:
            #logger.info(f&#34;{command=}&#34;)
            self.sock.sendall(command.encode())

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as a connection error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
        except AttributeError:
            if not self.is_connection_open:
                msg = &#34;The CDAQ9375 is not connected, use the connect() method.&#34;
                raise DeviceConnectionError(DEVICE_NAME, msg)
            raise

    def read(self) -&gt; List:
        # Set a timeout of READ_TIMEOUT to the socket.recv
        saved_timeout = self.sock.gettimeout()
        self.sock.settimeout(READ_TIMEOUT)
        try:
            # Extracts the msg size from 4 bytes sent by Labview - mind the encoding. The number
            # reprensets the number of bytes of data
            size = struct.unpack(&#39;i&#39;, self.sock.recv(4))[0]
            data = self.sock.recv(size)
        except socket.timeout as e_timeout:
            logger.warning(f&#34;Socket timeout error from {e_timeout}&#34;)
            return b&#34;\r\n&#34;
        except TimeoutError as exc:
            logger.warning(f&#34;Socket timeout error: {exc}&#34;)
            return b&#34;\r\n&#34;
        finally:
            self.sock.settimeout(saved_timeout)

        #logger.info(f&#34;Total number of bytes received from the cdaq 9375 is {size}&#34;)

        data = data.decode(&#34;ascii&#34;)

        return data

    def trans(self, cmd: str) -&gt; List:
        self.write(cmd)
        time.sleep(25)
        response = self.read()
        return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375Command"><code class="flex name class">
<span>class <span class="ident">cdaq9375Command</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cdaq9375Command(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375Command.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    out = super().get_cmd_string(*args, **kwargs)
    return out + &#34;\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375Error"><code class="flex name class">
<span>class <span class="ident">cdaq9375Error</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base exception for all ptc10 errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cdaq9375Error(Exception):
    &#34;&#34;&#34;Base exception for all ptc10 errors.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface"><code class="flex name class">
<span>class <span class="ident">cdaq9375SocketInterface</span></span>
<span>(</span><span>hostname=None, port=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the low-level interface to the NI CDAQ9375 Controller.
Connects to the Labview interface via TCP/IP socket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cdaq9375SocketInterface(DeviceConnectionInterface, DeviceTransport):
    &#34;&#34;&#34;Defines the low-level interface to the NI CDAQ9375 Controller.
    Connects to the Labview interface via TCP/IP socket&#34;&#34;&#34;

    def __init__(self, hostname=None, port=None):
        self.hostname = ctrl_settings.HOSTNAME if hostname is None else hostname
        self.port = ctrl_settings.CDAQ9375_PORT if port is None else port
        self.sock = None

        self.is_connection_open = False

    def connect(self, hostname: str):
        # Sanity checks
        if self.is_connection_open:
            logger.warning(f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
            return
        if self.hostname in (None, &#34;&#34;):
            raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

        if self.port in (None, 0):
            raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            _id = self.get_id()
            logger.warning(f&#34;Connected to: {_id}&#34;)

        except socket.error as e_socket:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket
            # Asking for instrument description

        # We set a timeout of 3 sec before connecting and reset to None
        # (=blocking) after the connect. The reason for this is because when no
        # device is available, e.g during testing, the timeout will take about
        # two minutes which is way too long. It needs to be evaluated if this
        # approach is acceptable and not causing problems during production.

        try:
            logger.debug(f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
            self.sock.settimeout(3)
            self.sock.connect((self.hostname, self.port))
            self.sock.settimeout(None)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
            ) from exc
        except TimeoutError as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
            ) from exc
        except socket.gaierror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
            ) from exc
        except socket.herror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
            ) from exc
        except socket.timeout as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
            ) from exc
        except OSError as exc:
            raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

        self.is_connection_open = True

        if not self.is_connected():
            raise DeviceConnectionError(
                DEVICE_NAME, &#34;Device is not connected, check logging messages for the cause.&#34;
            )

    def disconnect(self):
        &#34;&#34;&#34;
        Disconnects from the device
        Raises:
            DeviceConnectionError when the connection has not been closed correctly

        &#34;&#34;&#34;
        try:
            if self.is_connection_open:
                logger.debug(f&#34;Disconnecting from {self.hostname}&#34;)
                self.sock.close()
                self.is_connection_open = False
        except Exception as e_exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc

    def is_connected(self):
        &#34;&#34;&#34;Return True if the device is connected.&#34;&#34;&#34;
        if not self.is_connection_open:
            return False
        return True

    def get_response(self, cmd_string):
        pass

    def get_id(self):
        return DEVICE_NAME

    def write(self, command: str):
        try:
            #logger.info(f&#34;{command=}&#34;)
            self.sock.sendall(command.encode())

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as a connection error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket
        except AttributeError:
            if not self.is_connection_open:
                msg = &#34;The CDAQ9375 is not connected, use the connect() method.&#34;
                raise DeviceConnectionError(DEVICE_NAME, msg)
            raise

    def read(self) -&gt; List:
        # Set a timeout of READ_TIMEOUT to the socket.recv
        saved_timeout = self.sock.gettimeout()
        self.sock.settimeout(READ_TIMEOUT)
        try:
            # Extracts the msg size from 4 bytes sent by Labview - mind the encoding. The number
            # reprensets the number of bytes of data
            size = struct.unpack(&#39;i&#39;, self.sock.recv(4))[0]
            data = self.sock.recv(size)
        except socket.timeout as e_timeout:
            logger.warning(f&#34;Socket timeout error from {e_timeout}&#34;)
            return b&#34;\r\n&#34;
        except TimeoutError as exc:
            logger.warning(f&#34;Socket timeout error: {exc}&#34;)
            return b&#34;\r\n&#34;
        finally:
            self.sock.settimeout(saved_timeout)

        #logger.info(f&#34;Total number of bytes received from the cdaq 9375 is {size}&#34;)

        data = data.decode(&#34;ascii&#34;)

        return data

    def trans(self, cmd: str) -&gt; List:
        self.write(cmd)
        time.sleep(25)
        response = self.read()
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
<li><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnects from the device</p>
<h2 id="raises">Raises</h2>
<p>DeviceConnectionError when the connection has not been closed correctly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;
    Disconnects from the device
    Raises:
        DeviceConnectionError when the connection has not been closed correctly

    &#34;&#34;&#34;
    try:
        if self.is_connection_open:
            logger.debug(f&#34;Disconnecting from {self.hostname}&#34;)
            self.sock.close()
            self.is_connection_open = False
    except Exception as e_exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc</code></pre>
</details>
</dd>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
    return DEVICE_NAME</code></pre>
</details>
</dd>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.get_response"><code class="name flex">
<span>def <span class="ident">get_response</span></span>(<span>self, cmd_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_response(self, cmd_string):
    pass</code></pre>
</details>
</dd>
<dt id="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the device is connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34;Return True if the device is connected.&#34;&#34;&#34;
    if not self.is_connection_open:
        return False
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.read" href="../../device.html#egse.device.DeviceTransport.read">read</a></code></li>
<li><code><a title="egse.device.DeviceTransport.trans" href="../../device.html#egse.device.DeviceTransport.trans">trans</a></code></li>
<li><code><a title="egse.device.DeviceTransport.write" href="../../device.html#egse.device.DeviceTransport.write">write</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.query" href="../../device.html#egse.device.DeviceTransport.query">query</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.ni.alarms" href="index.html">egse.ni.alarms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375Command" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375Command">cdaq9375Command</a></code></h4>
<ul class="">
<li><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375Command.get_cmd_string" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375Command.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375Error" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375Error">cdaq9375Error</a></code></h4>
</li>
<li>
<h4><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface">cdaq9375SocketInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.disconnect" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.get_id" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.get_id">get_id</a></code></li>
<li><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.get_response" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.get_response">get_response</a></code></li>
<li><code><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.is_connected" href="#egse.ni.alarms.cdaq9375_devif.cdaq9375SocketInterface.is_connected">is_connected</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
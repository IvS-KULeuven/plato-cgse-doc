<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.aeu.aeu_protocol API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.aeu.aeu_protocol</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging

from egse.aeu import aeu_metrics
from egse.aeu.aeu import SyncData
from egse.command import ClientServerCommand
from egse.control import ControlServer
from egse.device import DeviceConnectionError, DeviceConnectionState
from egse.device import DeviceTimeoutError
from egse.hk import read_conversion_dict, convert_hk_names
from egse.protocol import CommandProtocol
from egse.settings import Settings
from egse.setup import load_setup
from egse.state import GlobalState
from egse.system import format_datetime, SignalCatcher
from egse.zmq_ser import bind_address

logger = logging.getLogger(__name__)

CRIO_SETTINGS = Settings.load(filename=&#34;aeu_crio.yaml&#34;)
PSU_SETTINGS = Settings.load(filename=&#34;aeu_psu.yaml&#34;)
AWG_SETTINGS = Settings.load(filename=&#34;aeu_awg.yaml&#34;)

LINE_FEED = &#34;\x0A&#34;
CARRIAGE_RETURN = &#34;\x0D&#34;


POWERLINES = {1: &#34;CCD&#34;, 2: &#34;CLK&#34;, 3: &#34;AN1&#34;, 4: &#34;AN2&#34;, 5: &#34;AN3&#34;, 6: &#34;DIG&#34;}


########################
# Client-server commands
########################


class CRIOCommand(ClientServerCommand):
    &#34;&#34;&#34; Client-server command for the AEU cRIO.&#34;&#34;&#34;

    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34; Return the command string.

        All commands must be terminated using a valid terminator code 0x0D (Carriage Return, CR), followed by a 0x0A
        (Line Feed, LF).  See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).

        Args:
            - args: Positional arguments for the command.
            - kwargs: Keyword arguments for the command.

        Returns: Command string for the cRIO.
        &#34;&#34;&#34;

        cmd_string = super().get_cmd_string(*args, **kwargs)

        return cmd_string + CARRIAGE_RETURN + LINE_FEED


class PSUCommand(ClientServerCommand):
    &#34;&#34;&#34; Client-server command for the AEU PSU.&#34;&#34;&#34;

    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34; Return the command string.

        All commands must be terminated using a valid terminator code 0x0A (Line Feed, LF).  See
        PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).

        Args:
            - args: Positional arguments for the command.
            - kwargs: Keyword arguments fort the command.

        Returns: Command string for the PSU.
        &#34;&#34;&#34;

        cmd_string = super().get_cmd_string(*args, **kwargs)

        return cmd_string + LINE_FEED


class AWGCommand(ClientServerCommand):
    &#34;&#34;&#34; Client-server command for the AEU AWG.&#34;&#34;&#34;

    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34; Return the command string.

        All commands must be terminated with the command terminator code 0x0A (Line Feed, LF), except for ARB1, ARB2,
        ARB3, ARB4, ARB1?, ARB2?, ARB3?, and ARB4? commands.  See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC
        ICD).

        Args:
            - args: Positional arguments for the command.
            - kwargs: Keyword arguments fort the command.

        Returns: Command string for the AWG.
        &#34;&#34;&#34;

        cmd_string = super().get_cmd_string(*args, **kwargs)

        if not (cmd_string.startswith(&#34;ARB1&#34;) or cmd_string.startswith(&#34;ARB2&#34;) or cmd_string.startswith(&#34;ARB3&#34;)
                or cmd_string.startswith(&#34;ARB4&#34;)):

            cmd_string += LINE_FEED

        return cmd_string

###########
# Protocols
###########


class AEUProtocol(CommandProtocol):
    &#34;&#34;&#34; AEU protocol.&#34;&#34;&#34;

    def __init__(self, control_server: ControlServer):
        &#34;&#34;&#34; Initialisation of an AEU protocol with the given Control Server.

        Args:
            - control_server: Control Server to associate the AEU protocol with.
        &#34;&#34;&#34;

        super().__init__()

        self.control_server = control_server

    def get_bind_address(self):
        &#34;&#34;&#34; Return the address for the AEU protocol to bind to.

        Returns: Address for the AEU protocol to bind to.
        &#34;&#34;&#34;

        return bind_address(self.control_server.get_communication_protocol(), self.control_server.get_commanding_port())

    def get_status(self):
        &#34;&#34;&#34; Return the status information.

        Returns: Status information.
        &#34;&#34;&#34;

        status = super(AEUProtocol, self).get_status()

        return status

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = {&#34;timestamp&#34;: format_datetime()}

        return hk


class CRIOProtocol(AEUProtocol):

    def __init__(self, control_server: ControlServer):
        &#34;&#34;&#34; Initialisation of a cRIO protocol with the given Control Server.

        Args:
            - control_server: Control Server to associate the cRIO protocol with.
        &#34;&#34;&#34;

        super(CRIOProtocol, self).__init__(control_server)

        self.hk_conversion_table = read_conversion_dict(self.control_server.get_storage_mnemonic(), use_site=False)

        if Settings.simulation_mode():

            # Simulation mode -&gt; start the simulator

            from egse.aeu.aeu import CRIOSimulator
            self.crio = CRIOSimulator()

        else:

            # Device available -&gt; start the controller

            from egse.aeu.aeu import CRIOController
            self.crio = CRIOController()
            self.crio.add_observer(self)

        # Connect to the simulator/controller

        try:

            self.crio.connect()

        except (ConnectionError, DeviceConnectionError, DeviceTimeoutError) as exc:

            logger.warning(f&#34;Couldn&#39;t connect to cRIO: {exc}&#34;)

        # Load the commands

        from egse.aeu.aeu import CRIOInterface
        self.load_commands(CRIO_SETTINGS.Commands, CRIOCommand, CRIOInterface)

        # Build the method look-up table

        self.build_device_method_lookup_table(self.crio)

    def get_status(self):
        &#34;&#34;&#34; Return the status information.

        Returns: Status information.
        &#34;&#34;&#34;

        status_info = super().get_status()

        led_status = self.crio.get_led_status()

        status_info.update(led_status)

        if led_status[&#34;N-CAM&#34;]:

            # status_info[&#34;Camera&#34;] = &#34;N&#34;

            clk_50mhz, clk_ccdread = self.crio.get_n_cam_clock_status()

            status_info[&#34;Clk_N_50MHz&#34;] = clk_50mhz
            status_info[&#34;Clk_N_ccdread&#34;] = clk_ccdread

        elif led_status[&#34;F-CAM&#34;]:

            # status_info[&#34;Camera&#34;] = &#34;F&#34;

            clk_50mhz_nom, clk_50_mhz_red, clk_ccdread_nom, clk_ccdread_red = self.crio.get_f_cam_clock_status()

            status_info[&#34;Clk_F_50MHz_nom&#34;] = clk_50mhz_nom
            status_info[&#34;Clk_F_50MHz_red&#34;] = clk_50_mhz_red
            status_info[&#34;Clk_F_ccdread_nom&#34;] = clk_ccdread_nom
            status_info[&#34;Clk_F_ccdread_red&#34;] = clk_ccdread_red

        clk_50mhz_nom, clk_50_mhz_red, clk_heater_nom, clk_heater_red = self.crio.get_svm_clock_status()

        status_info[&#34;Clk_TCS_50MHz_nom&#34;] = clk_50mhz_nom
        status_info[&#34;Clk_TCS_50MHz_red&#34;] = clk_50_mhz_red
        status_info[&#34;Clk_heater_nom&#34;] = clk_heater_nom
        status_info[&#34;Clk_heater_red&#34;] = clk_heater_red

        return status_info

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = super().get_housekeeping()

        if self.state == DeviceConnectionState.DEVICE_CONNECTED or Settings.simulation_mode():

            crio_data = self.crio.get_data()
            crio_data = convert_hk_names(crio_data, self.hk_conversion_table)

            aeu_metrics.GAEU_I_CCD_NFEE.set(crio_data[f&#34;GAEU_I_CCD_NFEE&#34;])
            aeu_metrics.GAEU_I_CLK_NFEE.set(crio_data[f&#34;GAEU_I_CLK_NFEE&#34;])
            aeu_metrics.GAEU_I_AN1_NFEE.set(crio_data[f&#34;GAEU_I_AN1_NFEE&#34;])
            aeu_metrics.GAEU_I_AN2_NFEE.set(crio_data[f&#34;GAEU_I_AN2_NFEE&#34;])
            aeu_metrics.GAEU_I_AN3_NFEE.set(crio_data[f&#34;GAEU_I_AN3_NFEE&#34;])
            aeu_metrics.GAEU_I_DIG_NFEE.set(crio_data[f&#34;GAEU_I_DIG_NFEE&#34;])

            aeu_metrics.GAEU_V_CCD_NFEE.set(crio_data[f&#34;GAEU_V_CCD_NFEE&#34;])
            aeu_metrics.GAEU_V_CLK_NFEE.set(crio_data[f&#34;GAEU_V_CLK_NFEE&#34;])
            aeu_metrics.GAEU_V_AN1_NFEE.set(crio_data[f&#34;GAEU_V_AN1_NFEE&#34;])
            aeu_metrics.GAEU_V_AN2_NFEE.set(crio_data[f&#34;GAEU_V_AN2_NFEE&#34;])
            aeu_metrics.GAEU_V_AN3_NFEE.set(crio_data[f&#34;GAEU_V_AN3_NFEE&#34;])
            aeu_metrics.GAEU_V_DIG_NFEE.set(crio_data[f&#34;GAEU_V_DIG_NFEE&#34;])

            aeu_metrics.GAEU_I_CCD_FFEE.set(crio_data[f&#34;GAEU_I_CCD_FFEE&#34;])
            aeu_metrics.GAEU_I_CLK_FFEE.set(crio_data[f&#34;GAEU_I_CLK_FFEE&#34;])
            aeu_metrics.GAEU_I_AN1_FFEE.set(crio_data[f&#34;GAEU_I_AN1_FFEE&#34;])
            aeu_metrics.GAEU_I_AN2_FFEE.set(crio_data[f&#34;GAEU_I_AN2_FFEE&#34;])
            aeu_metrics.GAEU_I_AN3_FFEE.set(crio_data[f&#34;GAEU_I_AN3_FFEE&#34;])
            aeu_metrics.GAEU_I_DIG_FFEE.set(crio_data[f&#34;GAEU_I_DIG_FFEE&#34;])

            aeu_metrics.GAEU_V_CCD_FFEE.set(crio_data[f&#34;GAEU_V_CCD_FFEE&#34;])
            aeu_metrics.GAEU_V_CLK_FFEE.set(crio_data[f&#34;GAEU_V_CLK_FFEE&#34;])
            aeu_metrics.GAEU_V_AN1_FFEE.set(crio_data[f&#34;GAEU_V_AN1_FFEE&#34;])
            aeu_metrics.GAEU_V_AN2_FFEE.set(crio_data[f&#34;GAEU_V_AN2_FFEE&#34;])
            aeu_metrics.GAEU_V_AN3_FFEE.set(crio_data[f&#34;GAEU_V_AN3_FFEE&#34;])
            aeu_metrics.GAEU_V_DIG_FFEE.set(crio_data[f&#34;GAEU_V_DIG_FFEE&#34;])

            aeu_metrics.GAEU_STANDBY.set(int(crio_data[&#34;GAEU_STANDBY&#34;]))
            aeu_metrics.GAEU_SELFTEST.set(int(crio_data[&#34;GAEU_SELFTEST&#34;]))
            aeu_metrics.GAEU_FC_TVAC.set(int(crio_data[&#34;GAEU_FC_TVAC&#34;]))
            aeu_metrics.GAEU_ALIGNMENT.set(int(crio_data[&#34;GAEU_ALIGNMENT&#34;]))

            aeu_metrics.GAEU_PWR_NFEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_NFEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_FFEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_FFEE_STATUS&#34;]))

            aeu_metrics.GAEU_PWR_CCD_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_CCD_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_CLK_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_CLK_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_AN1_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_AN1_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_AN2_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_AN2_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_AN3_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_AN3_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_DIG_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_DIG_FEE_STATUS&#34;]))

            aeu_metrics.GAEU_S_VOLTAGE_OOR.set(int(crio_data[&#34;GAEU_S_VOLTAGE_OOR&#34;]))
            aeu_metrics.GAEU_S_CURRENT_OOR.set(int(crio_data[&#34;GAEU_S_CURRENT_OOR&#34;]))
            aeu_metrics.GAEU_SYNC_GF.set(int(crio_data[&#34;GAEU_SYNC_GF&#34;]))

            aeu_metrics.GAEU_CLK_PWR_50MHZ.set(int(crio_data[&#34;GAEU_CLK_PWR_50MHZ&#34;]))
            aeu_metrics.GAEU_CLK_PWR_CCDREAD.set(int(crio_data[&#34;GAEU_CLK_PWR_CCDREAD&#34;]))
            aeu_metrics.GAEU_CLK_PWR_SVM.set(int(crio_data[&#34;GAEU_CLK_PWR_SVM&#34;]))
            aeu_metrics.GAEU_CLK_PWR_N_FFEE.set(int(crio_data[&#34;GAEU_CLK_PWR_N_FFEE&#34;]))
            aeu_metrics.GAEU_CLK_PWR_R_FFEE.set(int(crio_data[&#34;GAEU_CLK_PWR_R_FFEE&#34;]))
            aeu_metrics.GAEU_TESTPORT.set(int(crio_data[&#34;GAEU_TESTPORT&#34;]))

            hk.update(crio_data)

        return hk


class PSUProtocol(AEUProtocol):

    def __init__(self, control_server: ControlServer, psu_index: int):
        &#34;&#34;&#34; Initialisation of a PSU protocol with the given Control Server and index.

        Args:
            - control_server: Control Server to associate the PSU protocol with.
            - psu_index: Index of the PSU (should be 1..6).
        &#34;&#34;&#34;

        super(PSUProtocol, self).__init__(control_server)

        self.psu_index = psu_index
        self.name = POWERLINES[self.psu_index]

        if Settings.simulation_mode():

            # Simulation mode -&gt; start the simulator

            from egse.aeu.aeu import PSUSimulator
            self.psu = PSUSimulator(psu_index)

        else:

            # Device available -&gt; start the controller

            from egse.aeu.aeu import PSUController
            self.psu = PSUController(psu_index)
            self.psu.add_observer(self)

        # Connect to the simulator/controller

        try:
            self.psu.connect()
        except (ConnectionError, DeviceConnectionError, DeviceTimeoutError) as exc:
            logger.warning(f&#34;Couldn&#39;t connect to cRIO: {exc}&#34;)

        # Load the commands

        from egse.aeu.aeu import PSUInterface
        self.load_commands(PSU_SETTINGS.Commands, PSUCommand, PSUInterface)

        # Build the method look-up table

        self.build_device_method_lookup_table(self.psu)

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping and update the metrics.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = super().get_housekeeping()

        current = self.psu.get_current()
        voltage = self.psu.get_voltage()

        hk[f&#34;GAEU_PSU_I_{self.name}&#34;] = current
        hk[f&#34;GAEU_PSU_V_{self.name}&#34;] = voltage

        aeu_metrics.GAEU_PSU_V.set(voltage)
        aeu_metrics.GAEU_PSU_I.set(current)

        return hk


class AWGProtocol(AEUProtocol):

    def __init__(self, control_server: ControlServer, awg_index: int):
        &#34;&#34;&#34; Initialisation of an AWG protocol with the given Control Server and index.

        Args:
            - control_server: Control Server to associate the AWG protocol with.
            - awg_index: Index of the AWG (should be 1 or 2).
        &#34;&#34;&#34;

        super(AWGProtocol, self).__init__(control_server)

        self.awg_index = awg_index

        self.killer = SignalCatcher()

        if Settings.simulation_mode():

            # Simulation mode -&gt; start the simulator

            from egse.aeu.aeu import AWGSimulator
            self.awg = AWGSimulator(awg_index)

        else:

            # Device available -&gt; start the controller

            from egse.aeu.aeu import AWGController
            self.awg = AWGController(awg_index)
            self.awg.add_observer(self)

        # Connect to the simulator/controller

        try:
            self.awg.connect()
        except (ConnectionError, DeviceConnectionError, DeviceTimeoutError) as exc:
            logger.warning(f&#34;Couldn&#39;t connect to cRIO: {exc}&#34;)

        # Load the commands

        from egse.aeu.aeu import AWGInterface
        self.load_commands(AWG_SETTINGS.Commands, AWGCommand, AWGInterface)

        # Build the method look-up table

        self.build_device_method_lookup_table(self.awg)

        self.setup = GlobalState.setup

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = super().get_housekeeping()

        # For AWG2, we use ARBDEF1 to configure Clk_ccdread.  The name of ARBDEF1 for AWG2 (CCDREAD&lt;identifier&gt;)
        # contains an identifier, which can be used to determine the image cycle time (for external sync mode).

        if self.awg_index == 2 and (self.state == DeviceConnectionState.DEVICE_CONNECTED or Settings.simulation_mode()):

            arbdef_name = self.awg.get_arb1_def()[0]    # Name of ARBDEF1

            sync_data_string = self.setup.gse.aeu.awg2.calibration.n_cam_sync_data[arbdef_name[-1]]
            image_cycle_time = SyncData(sync_data_string).image_cycle_time

            hk[&#34;GAEU_EXT_CYCLE_TIME&#34;] = image_cycle_time

            aeu_metrics.GAEU_EXT_CYCLE_TIME.set(image_cycle_time)

        return hk</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.aeu.aeu_protocol.AEUProtocol"><code class="flex name class">
<span>class <span class="ident">AEUProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>AEU protocol.</p>
<p>Initialisation of an AEU protocol with the given Control Server.</p>
<h2 id="args">Args</h2>
<ul>
<li>control_server: Control Server to associate the AEU protocol with.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AEUProtocol(CommandProtocol):
    &#34;&#34;&#34; AEU protocol.&#34;&#34;&#34;

    def __init__(self, control_server: ControlServer):
        &#34;&#34;&#34; Initialisation of an AEU protocol with the given Control Server.

        Args:
            - control_server: Control Server to associate the AEU protocol with.
        &#34;&#34;&#34;

        super().__init__()

        self.control_server = control_server

    def get_bind_address(self):
        &#34;&#34;&#34; Return the address for the AEU protocol to bind to.

        Returns: Address for the AEU protocol to bind to.
        &#34;&#34;&#34;

        return bind_address(self.control_server.get_communication_protocol(), self.control_server.get_commanding_port())

    def get_status(self):
        &#34;&#34;&#34; Return the status information.

        Returns: Status information.
        &#34;&#34;&#34;

        status = super(AEUProtocol, self).get_status()

        return status

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = {&#34;timestamp&#34;: format_datetime()}

        return hk</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu_protocol.AWGProtocol" href="#egse.aeu.aeu_protocol.AWGProtocol">AWGProtocol</a></li>
<li><a title="egse.aeu.aeu_protocol.CRIOProtocol" href="#egse.aeu.aeu_protocol.CRIOProtocol">CRIOProtocol</a></li>
<li><a title="egse.aeu.aeu_protocol.PSUProtocol" href="#egse.aeu.aeu_protocol.PSUProtocol">PSUProtocol</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_protocol.AEUProtocol.get_bind_address"><code class="name flex">
<span>def <span class="ident">get_bind_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the address for the AEU protocol to bind to.</p>
<p>Returns: Address for the AEU protocol to bind to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bind_address(self):
    &#34;&#34;&#34; Return the address for the AEU protocol to bind to.

    Returns: Address for the AEU protocol to bind to.
    &#34;&#34;&#34;

    return bind_address(self.control_server.get_communication_protocol(), self.control_server.get_commanding_port())</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping"><code class="name flex">
<span>def <span class="ident">get_housekeeping</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Return the housekeeping.</p>
<p>Returns: Dictionary with the housekeeping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_housekeeping(self) -&gt; dict:
    &#34;&#34;&#34; Return the housekeeping.

    Returns: Dictionary with the housekeeping.
    &#34;&#34;&#34;

    hk = {&#34;timestamp&#34;: format_datetime()}

    return hk</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_protocol.AEUProtocol.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the status information.</p>
<p>Returns: Status information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self):
    &#34;&#34;&#34; Return the status information.

    Returns: Status information.
    &#34;&#34;&#34;

    status = super(AEUProtocol, self).get_status()

    return status</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.protocol.CommandProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.aeu.aeu_protocol.AWGCommand"><code class="flex name class">
<span>class <span class="ident">AWGCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Client-server command for the AEU AWG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AWGCommand(ClientServerCommand):
    &#34;&#34;&#34; Client-server command for the AEU AWG.&#34;&#34;&#34;

    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34; Return the command string.

        All commands must be terminated with the command terminator code 0x0A (Line Feed, LF), except for ARB1, ARB2,
        ARB3, ARB4, ARB1?, ARB2?, ARB3?, and ARB4? commands.  See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC
        ICD).

        Args:
            - args: Positional arguments for the command.
            - kwargs: Keyword arguments fort the command.

        Returns: Command string for the AWG.
        &#34;&#34;&#34;

        cmd_string = super().get_cmd_string(*args, **kwargs)

        if not (cmd_string.startswith(&#34;ARB1&#34;) or cmd_string.startswith(&#34;ARB2&#34;) or cmd_string.startswith(&#34;ARB3&#34;)
                or cmd_string.startswith(&#34;ARB4&#34;)):

            cmd_string += LINE_FEED

        return cmd_string</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_protocol.AWGCommand.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the command string.</p>
<p>All commands must be terminated with the command terminator code 0x0A (Line Feed, LF), except for ARB1, ARB2,
ARB3, ARB4, ARB1?, ARB2?, ARB3?, and ARB4? commands.
See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC
ICD).</p>
<h2 id="args">Args</h2>
<ul>
<li>args: Positional arguments for the command.</li>
<li>kwargs: Keyword arguments fort the command.
Returns: Command string for the AWG.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34; Return the command string.

    All commands must be terminated with the command terminator code 0x0A (Line Feed, LF), except for ARB1, ARB2,
    ARB3, ARB4, ARB1?, ARB2?, ARB3?, and ARB4? commands.  See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC
    ICD).

    Args:
        - args: Positional arguments for the command.
        - kwargs: Keyword arguments fort the command.

    Returns: Command string for the AWG.
    &#34;&#34;&#34;

    cmd_string = super().get_cmd_string(*args, **kwargs)

    if not (cmd_string.startswith(&#34;ARB1&#34;) or cmd_string.startswith(&#34;ARB2&#34;) or cmd_string.startswith(&#34;ARB3&#34;)
            or cmd_string.startswith(&#34;ARB4&#34;)):

        cmd_string += LINE_FEED

    return cmd_string</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.aeu.aeu_protocol.AWGProtocol"><code class="flex name class">
<span>class <span class="ident">AWGProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>, awg_index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>AEU protocol.</p>
<p>Initialisation of an AWG protocol with the given Control Server and index.</p>
<h2 id="args">Args</h2>
<ul>
<li>control_server: Control Server to associate the AWG protocol with.</li>
<li>awg_index: Index of the AWG (should be 1 or 2).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AWGProtocol(AEUProtocol):

    def __init__(self, control_server: ControlServer, awg_index: int):
        &#34;&#34;&#34; Initialisation of an AWG protocol with the given Control Server and index.

        Args:
            - control_server: Control Server to associate the AWG protocol with.
            - awg_index: Index of the AWG (should be 1 or 2).
        &#34;&#34;&#34;

        super(AWGProtocol, self).__init__(control_server)

        self.awg_index = awg_index

        self.killer = SignalCatcher()

        if Settings.simulation_mode():

            # Simulation mode -&gt; start the simulator

            from egse.aeu.aeu import AWGSimulator
            self.awg = AWGSimulator(awg_index)

        else:

            # Device available -&gt; start the controller

            from egse.aeu.aeu import AWGController
            self.awg = AWGController(awg_index)
            self.awg.add_observer(self)

        # Connect to the simulator/controller

        try:
            self.awg.connect()
        except (ConnectionError, DeviceConnectionError, DeviceTimeoutError) as exc:
            logger.warning(f&#34;Couldn&#39;t connect to cRIO: {exc}&#34;)

        # Load the commands

        from egse.aeu.aeu import AWGInterface
        self.load_commands(AWG_SETTINGS.Commands, AWGCommand, AWGInterface)

        # Build the method look-up table

        self.build_device_method_lookup_table(self.awg)

        self.setup = GlobalState.setup

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = super().get_housekeeping()

        # For AWG2, we use ARBDEF1 to configure Clk_ccdread.  The name of ARBDEF1 for AWG2 (CCDREAD&lt;identifier&gt;)
        # contains an identifier, which can be used to determine the image cycle time (for external sync mode).

        if self.awg_index == 2 and (self.state == DeviceConnectionState.DEVICE_CONNECTED or Settings.simulation_mode()):

            arbdef_name = self.awg.get_arb1_def()[0]    # Name of ARBDEF1

            sync_data_string = self.setup.gse.aeu.awg2.calibration.n_cam_sync_data[arbdef_name[-1]]
            image_cycle_time = SyncData(sync_data_string).image_cycle_time

            hk[&#34;GAEU_EXT_CYCLE_TIME&#34;] = image_cycle_time

            aeu_metrics.GAEU_EXT_CYCLE_TIME.set(image_cycle_time)

        return hk</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></li>
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_bind_address" href="#egse.aeu.aeu_protocol.AEUProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping" href="#egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_status" href="#egse.aeu.aeu_protocol.AEUProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.aeu.aeu_protocol.CRIOCommand"><code class="flex name class">
<span>class <span class="ident">CRIOCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Client-server command for the AEU cRIO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRIOCommand(ClientServerCommand):
    &#34;&#34;&#34; Client-server command for the AEU cRIO.&#34;&#34;&#34;

    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34; Return the command string.

        All commands must be terminated using a valid terminator code 0x0D (Carriage Return, CR), followed by a 0x0A
        (Line Feed, LF).  See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).

        Args:
            - args: Positional arguments for the command.
            - kwargs: Keyword arguments for the command.

        Returns: Command string for the cRIO.
        &#34;&#34;&#34;

        cmd_string = super().get_cmd_string(*args, **kwargs)

        return cmd_string + CARRIAGE_RETURN + LINE_FEED</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_protocol.CRIOCommand.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the command string.</p>
<p>All commands must be terminated using a valid terminator code 0x0D (Carriage Return, CR), followed by a 0x0A
(Line Feed, LF).
See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).</p>
<h2 id="args">Args</h2>
<ul>
<li>args: Positional arguments for the command.</li>
<li>kwargs: Keyword arguments for the command.
Returns: Command string for the cRIO.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34; Return the command string.

    All commands must be terminated using a valid terminator code 0x0D (Carriage Return, CR), followed by a 0x0A
    (Line Feed, LF).  See PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).

    Args:
        - args: Positional arguments for the command.
        - kwargs: Keyword arguments for the command.

    Returns: Command string for the cRIO.
    &#34;&#34;&#34;

    cmd_string = super().get_cmd_string(*args, **kwargs)

    return cmd_string + CARRIAGE_RETURN + LINE_FEED</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.aeu.aeu_protocol.CRIOProtocol"><code class="flex name class">
<span>class <span class="ident">CRIOProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>AEU protocol.</p>
<p>Initialisation of a cRIO protocol with the given Control Server.</p>
<h2 id="args">Args</h2>
<ul>
<li>control_server: Control Server to associate the cRIO protocol with.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRIOProtocol(AEUProtocol):

    def __init__(self, control_server: ControlServer):
        &#34;&#34;&#34; Initialisation of a cRIO protocol with the given Control Server.

        Args:
            - control_server: Control Server to associate the cRIO protocol with.
        &#34;&#34;&#34;

        super(CRIOProtocol, self).__init__(control_server)

        self.hk_conversion_table = read_conversion_dict(self.control_server.get_storage_mnemonic(), use_site=False)

        if Settings.simulation_mode():

            # Simulation mode -&gt; start the simulator

            from egse.aeu.aeu import CRIOSimulator
            self.crio = CRIOSimulator()

        else:

            # Device available -&gt; start the controller

            from egse.aeu.aeu import CRIOController
            self.crio = CRIOController()
            self.crio.add_observer(self)

        # Connect to the simulator/controller

        try:

            self.crio.connect()

        except (ConnectionError, DeviceConnectionError, DeviceTimeoutError) as exc:

            logger.warning(f&#34;Couldn&#39;t connect to cRIO: {exc}&#34;)

        # Load the commands

        from egse.aeu.aeu import CRIOInterface
        self.load_commands(CRIO_SETTINGS.Commands, CRIOCommand, CRIOInterface)

        # Build the method look-up table

        self.build_device_method_lookup_table(self.crio)

    def get_status(self):
        &#34;&#34;&#34; Return the status information.

        Returns: Status information.
        &#34;&#34;&#34;

        status_info = super().get_status()

        led_status = self.crio.get_led_status()

        status_info.update(led_status)

        if led_status[&#34;N-CAM&#34;]:

            # status_info[&#34;Camera&#34;] = &#34;N&#34;

            clk_50mhz, clk_ccdread = self.crio.get_n_cam_clock_status()

            status_info[&#34;Clk_N_50MHz&#34;] = clk_50mhz
            status_info[&#34;Clk_N_ccdread&#34;] = clk_ccdread

        elif led_status[&#34;F-CAM&#34;]:

            # status_info[&#34;Camera&#34;] = &#34;F&#34;

            clk_50mhz_nom, clk_50_mhz_red, clk_ccdread_nom, clk_ccdread_red = self.crio.get_f_cam_clock_status()

            status_info[&#34;Clk_F_50MHz_nom&#34;] = clk_50mhz_nom
            status_info[&#34;Clk_F_50MHz_red&#34;] = clk_50_mhz_red
            status_info[&#34;Clk_F_ccdread_nom&#34;] = clk_ccdread_nom
            status_info[&#34;Clk_F_ccdread_red&#34;] = clk_ccdread_red

        clk_50mhz_nom, clk_50_mhz_red, clk_heater_nom, clk_heater_red = self.crio.get_svm_clock_status()

        status_info[&#34;Clk_TCS_50MHz_nom&#34;] = clk_50mhz_nom
        status_info[&#34;Clk_TCS_50MHz_red&#34;] = clk_50_mhz_red
        status_info[&#34;Clk_heater_nom&#34;] = clk_heater_nom
        status_info[&#34;Clk_heater_red&#34;] = clk_heater_red

        return status_info

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = super().get_housekeeping()

        if self.state == DeviceConnectionState.DEVICE_CONNECTED or Settings.simulation_mode():

            crio_data = self.crio.get_data()
            crio_data = convert_hk_names(crio_data, self.hk_conversion_table)

            aeu_metrics.GAEU_I_CCD_NFEE.set(crio_data[f&#34;GAEU_I_CCD_NFEE&#34;])
            aeu_metrics.GAEU_I_CLK_NFEE.set(crio_data[f&#34;GAEU_I_CLK_NFEE&#34;])
            aeu_metrics.GAEU_I_AN1_NFEE.set(crio_data[f&#34;GAEU_I_AN1_NFEE&#34;])
            aeu_metrics.GAEU_I_AN2_NFEE.set(crio_data[f&#34;GAEU_I_AN2_NFEE&#34;])
            aeu_metrics.GAEU_I_AN3_NFEE.set(crio_data[f&#34;GAEU_I_AN3_NFEE&#34;])
            aeu_metrics.GAEU_I_DIG_NFEE.set(crio_data[f&#34;GAEU_I_DIG_NFEE&#34;])

            aeu_metrics.GAEU_V_CCD_NFEE.set(crio_data[f&#34;GAEU_V_CCD_NFEE&#34;])
            aeu_metrics.GAEU_V_CLK_NFEE.set(crio_data[f&#34;GAEU_V_CLK_NFEE&#34;])
            aeu_metrics.GAEU_V_AN1_NFEE.set(crio_data[f&#34;GAEU_V_AN1_NFEE&#34;])
            aeu_metrics.GAEU_V_AN2_NFEE.set(crio_data[f&#34;GAEU_V_AN2_NFEE&#34;])
            aeu_metrics.GAEU_V_AN3_NFEE.set(crio_data[f&#34;GAEU_V_AN3_NFEE&#34;])
            aeu_metrics.GAEU_V_DIG_NFEE.set(crio_data[f&#34;GAEU_V_DIG_NFEE&#34;])

            aeu_metrics.GAEU_I_CCD_FFEE.set(crio_data[f&#34;GAEU_I_CCD_FFEE&#34;])
            aeu_metrics.GAEU_I_CLK_FFEE.set(crio_data[f&#34;GAEU_I_CLK_FFEE&#34;])
            aeu_metrics.GAEU_I_AN1_FFEE.set(crio_data[f&#34;GAEU_I_AN1_FFEE&#34;])
            aeu_metrics.GAEU_I_AN2_FFEE.set(crio_data[f&#34;GAEU_I_AN2_FFEE&#34;])
            aeu_metrics.GAEU_I_AN3_FFEE.set(crio_data[f&#34;GAEU_I_AN3_FFEE&#34;])
            aeu_metrics.GAEU_I_DIG_FFEE.set(crio_data[f&#34;GAEU_I_DIG_FFEE&#34;])

            aeu_metrics.GAEU_V_CCD_FFEE.set(crio_data[f&#34;GAEU_V_CCD_FFEE&#34;])
            aeu_metrics.GAEU_V_CLK_FFEE.set(crio_data[f&#34;GAEU_V_CLK_FFEE&#34;])
            aeu_metrics.GAEU_V_AN1_FFEE.set(crio_data[f&#34;GAEU_V_AN1_FFEE&#34;])
            aeu_metrics.GAEU_V_AN2_FFEE.set(crio_data[f&#34;GAEU_V_AN2_FFEE&#34;])
            aeu_metrics.GAEU_V_AN3_FFEE.set(crio_data[f&#34;GAEU_V_AN3_FFEE&#34;])
            aeu_metrics.GAEU_V_DIG_FFEE.set(crio_data[f&#34;GAEU_V_DIG_FFEE&#34;])

            aeu_metrics.GAEU_STANDBY.set(int(crio_data[&#34;GAEU_STANDBY&#34;]))
            aeu_metrics.GAEU_SELFTEST.set(int(crio_data[&#34;GAEU_SELFTEST&#34;]))
            aeu_metrics.GAEU_FC_TVAC.set(int(crio_data[&#34;GAEU_FC_TVAC&#34;]))
            aeu_metrics.GAEU_ALIGNMENT.set(int(crio_data[&#34;GAEU_ALIGNMENT&#34;]))

            aeu_metrics.GAEU_PWR_NFEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_NFEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_FFEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_FFEE_STATUS&#34;]))

            aeu_metrics.GAEU_PWR_CCD_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_CCD_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_CLK_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_CLK_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_AN1_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_AN1_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_AN2_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_AN2_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_AN3_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_AN3_FEE_STATUS&#34;]))
            aeu_metrics.GAEU_PWR_DIG_FEE_STATUS.set(int(crio_data[&#34;GAEU_PWR_DIG_FEE_STATUS&#34;]))

            aeu_metrics.GAEU_S_VOLTAGE_OOR.set(int(crio_data[&#34;GAEU_S_VOLTAGE_OOR&#34;]))
            aeu_metrics.GAEU_S_CURRENT_OOR.set(int(crio_data[&#34;GAEU_S_CURRENT_OOR&#34;]))
            aeu_metrics.GAEU_SYNC_GF.set(int(crio_data[&#34;GAEU_SYNC_GF&#34;]))

            aeu_metrics.GAEU_CLK_PWR_50MHZ.set(int(crio_data[&#34;GAEU_CLK_PWR_50MHZ&#34;]))
            aeu_metrics.GAEU_CLK_PWR_CCDREAD.set(int(crio_data[&#34;GAEU_CLK_PWR_CCDREAD&#34;]))
            aeu_metrics.GAEU_CLK_PWR_SVM.set(int(crio_data[&#34;GAEU_CLK_PWR_SVM&#34;]))
            aeu_metrics.GAEU_CLK_PWR_N_FFEE.set(int(crio_data[&#34;GAEU_CLK_PWR_N_FFEE&#34;]))
            aeu_metrics.GAEU_CLK_PWR_R_FFEE.set(int(crio_data[&#34;GAEU_CLK_PWR_R_FFEE&#34;]))
            aeu_metrics.GAEU_TESTPORT.set(int(crio_data[&#34;GAEU_TESTPORT&#34;]))

            hk.update(crio_data)

        return hk</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></li>
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_bind_address" href="#egse.aeu.aeu_protocol.AEUProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping" href="#egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_status" href="#egse.aeu.aeu_protocol.AEUProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.aeu.aeu_protocol.PSUCommand"><code class="flex name class">
<span>class <span class="ident">PSUCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Client-server command for the AEU PSU.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PSUCommand(ClientServerCommand):
    &#34;&#34;&#34; Client-server command for the AEU PSU.&#34;&#34;&#34;

    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        &#34;&#34;&#34; Return the command string.

        All commands must be terminated using a valid terminator code 0x0A (Line Feed, LF).  See
        PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).

        Args:
            - args: Positional arguments for the command.
            - kwargs: Keyword arguments fort the command.

        Returns: Command string for the PSU.
        &#34;&#34;&#34;

        cmd_string = super().get_cmd_string(*args, **kwargs)

        return cmd_string + LINE_FEED</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_protocol.PSUCommand.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the command string.</p>
<p>All commands must be terminated using a valid terminator code 0x0A (Line Feed, LF).
See
PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).</p>
<h2 id="args">Args</h2>
<ul>
<li>args: Positional arguments for the command.</li>
<li>kwargs: Keyword arguments fort the command.
Returns: Command string for the PSU.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34; Return the command string.

    All commands must be terminated using a valid terminator code 0x0A (Line Feed, LF).  See
    PTO-EVO-SYS-UCD-0188-2B (PLATO-AEU CAM TEST EGSE TMTC ICD).

    Args:
        - args: Positional arguments for the command.
        - kwargs: Keyword arguments fort the command.

    Returns: Command string for the PSU.
    &#34;&#34;&#34;

    cmd_string = super().get_cmd_string(*args, **kwargs)

    return cmd_string + LINE_FEED</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.aeu.aeu_protocol.PSUProtocol"><code class="flex name class">
<span>class <span class="ident">PSUProtocol</span></span>
<span>(</span><span>control_server: <a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a>, psu_index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>AEU protocol.</p>
<p>Initialisation of a PSU protocol with the given Control Server and index.</p>
<h2 id="args">Args</h2>
<ul>
<li>control_server: Control Server to associate the PSU protocol with.</li>
<li>psu_index: Index of the PSU (should be 1..6).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PSUProtocol(AEUProtocol):

    def __init__(self, control_server: ControlServer, psu_index: int):
        &#34;&#34;&#34; Initialisation of a PSU protocol with the given Control Server and index.

        Args:
            - control_server: Control Server to associate the PSU protocol with.
            - psu_index: Index of the PSU (should be 1..6).
        &#34;&#34;&#34;

        super(PSUProtocol, self).__init__(control_server)

        self.psu_index = psu_index
        self.name = POWERLINES[self.psu_index]

        if Settings.simulation_mode():

            # Simulation mode -&gt; start the simulator

            from egse.aeu.aeu import PSUSimulator
            self.psu = PSUSimulator(psu_index)

        else:

            # Device available -&gt; start the controller

            from egse.aeu.aeu import PSUController
            self.psu = PSUController(psu_index)
            self.psu.add_observer(self)

        # Connect to the simulator/controller

        try:
            self.psu.connect()
        except (ConnectionError, DeviceConnectionError, DeviceTimeoutError) as exc:
            logger.warning(f&#34;Couldn&#39;t connect to cRIO: {exc}&#34;)

        # Load the commands

        from egse.aeu.aeu import PSUInterface
        self.load_commands(PSU_SETTINGS.Commands, PSUCommand, PSUInterface)

        # Build the method look-up table

        self.build_device_method_lookup_table(self.psu)

    def get_housekeeping(self) -&gt; dict:
        &#34;&#34;&#34; Return the housekeeping and update the metrics.

        Returns: Dictionary with the housekeeping.
        &#34;&#34;&#34;

        hk = super().get_housekeeping()

        current = self.psu.get_current()
        voltage = self.psu.get_voltage()

        hk[f&#34;GAEU_PSU_I_{self.name}&#34;] = current
        hk[f&#34;GAEU_PSU_V_{self.name}&#34;] = voltage

        aeu_metrics.GAEU_PSU_V.set(voltage)
        aeu_metrics.GAEU_PSU_I.set(current)

        return hk</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></li>
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_protocol.PSUProtocol.get_housekeeping"><code class="name flex">
<span>def <span class="ident">get_housekeeping</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Return the housekeeping and update the metrics.</p>
<p>Returns: Dictionary with the housekeeping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_housekeeping(self) -&gt; dict:
    &#34;&#34;&#34; Return the housekeeping and update the metrics.

    Returns: Dictionary with the housekeeping.
    &#34;&#34;&#34;

    hk = super().get_housekeeping()

    current = self.psu.get_current()
    voltage = self.psu.get_voltage()

    hk[f&#34;GAEU_PSU_I_{self.name}&#34;] = current
    hk[f&#34;GAEU_PSU_V_{self.name}&#34;] = voltage

    aeu_metrics.GAEU_PSU_V.set(voltage)
    aeu_metrics.GAEU_PSU_I.set(current)

    return hk</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_bind_address" href="#egse.aeu.aeu_protocol.AEUProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_status" href="#egse.aeu.aeu_protocol.AEUProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.aeu" href="index.html">egse.aeu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.AEUProtocol" href="#egse.aeu.aeu_protocol.AEUProtocol">AEUProtocol</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_bind_address" href="#egse.aeu.aeu_protocol.AEUProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping" href="#egse.aeu.aeu_protocol.AEUProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.aeu.aeu_protocol.AEUProtocol.get_status" href="#egse.aeu.aeu_protocol.AEUProtocol.get_status">get_status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.AWGCommand" href="#egse.aeu.aeu_protocol.AWGCommand">AWGCommand</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_protocol.AWGCommand.get_cmd_string" href="#egse.aeu.aeu_protocol.AWGCommand.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.AWGProtocol" href="#egse.aeu.aeu_protocol.AWGProtocol">AWGProtocol</a></code></h4>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.CRIOCommand" href="#egse.aeu.aeu_protocol.CRIOCommand">CRIOCommand</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_protocol.CRIOCommand.get_cmd_string" href="#egse.aeu.aeu_protocol.CRIOCommand.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.CRIOProtocol" href="#egse.aeu.aeu_protocol.CRIOProtocol">CRIOProtocol</a></code></h4>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.PSUCommand" href="#egse.aeu.aeu_protocol.PSUCommand">PSUCommand</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_protocol.PSUCommand.get_cmd_string" href="#egse.aeu.aeu_protocol.PSUCommand.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_protocol.PSUProtocol" href="#egse.aeu.aeu_protocol.PSUProtocol">PSUProtocol</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_protocol.PSUProtocol.get_housekeeping" href="#egse.aeu.aeu_protocol.PSUProtocol.get_housekeeping">get_housekeeping</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.aeu.aeu_ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.aeu.aeu_ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
import logging
import pickle
import threading

import sys
import zmq
from PyQt5.QtCore import QThread, QObject, pyqtSignal, pyqtSlot
from PyQt5.QtGui import QCloseEvent, QPixmap, QIcon
from PyQt5.QtWidgets import QMainWindow, QApplication, QLabel, QFrame, QHBoxLayout, QVBoxLayout, QGroupBox, QGridLayout, \
    QAction
from deepdiff import DeepDiff
from zmq import ZMQError

from egse.aeu.aeu import CRIOProxy, CRIOController, CRIOSimulator
from egse.aeu.aeu import CTRL_SETTINGS
from egse.config import find_file
from egse.gui.led import Led, Indic
from egse.observer import Observer, Observable
from egse.process import ProcessStatus
from egse.settings import Settings
from egse.system import do_every
from egse.zmq_ser import connect_address

MODULE_LOGGER = logging.getLogger(__name__)

# Leds that always have to be shown (no matter which camera has been selected)


RELEVANT_COMMON_KEYS = {
    &#34;Standby&#34;: &#34;Stand-by&#34;, &#34;Selftest&#34;: &#34;Self-test&#34;, &#34;FC_TVAC&#34;: &#34;Functional check &amp; TVAC&#34;, &#34;Alignment&#34;: &#34;Alignment&#34;,
    &#34;N-CAM&#34;: &#34;N-CAM&#34;, &#34;F-CAM&#34;: &#34;F-CAM&#34;, &#34;V_CCD&#34;: &#34;V_CCD&#34;, &#34;V_CLK&#34;: &#34;V_CLK&#34;, &#34;V_AN1&#34;: &#34;V_AN1&#34;, &#34;V_AN2&#34;: &#34;V_AN2&#34;,
    &#34;V_AN3&#34;: &#34;V_AN3&#34;, &#34;V_DIG&#34;: &#34;V_DIG&#34;, &#34;S_voltage_oor&#34;: &#34;Secondary voltage generation out-of-range&#34;,
    &#34;S_current_oor&#34;: &#34;Secondary current generation out-of-range&#34;, &#34;Sync_gf&#34;: &#34;Synchronisation generator failure&#34;,
    &#34;Clk_TCS_50MHz_nom&#34;: &#34;Clk_TCS_50MHz_nom&#34;, &#34;Clk_TCS_50MHz_red&#34;: &#34;Clk_TCS_50MHz_red&#34;,
    &#34;Clk_heater_nom&#34;: &#34;Clk_heater_nom&#34;, &#34;Clk_heater_red&#34;: &#34;Clk_heater_red&#34;, &#34;TestPort&#34;: &#34;Test port&#34;
}

# Leds that have to be shown only if the N-CAM has been selected

RELEVANT_N_CAM_KEYS = [&#34;Clk_N_50MHz&#34;, &#34;Clk_N_ccdread&#34;]

# Leds that have to be shown only if the F-CAM has been selected

RELEVANT_F_CAM_KEYS = [&#34;Clk_F_50MHz_nom&#34;, &#34;Clk_F_50MHz_red&#34;, &#34;Clk_F_ccdread_nom&#34;, &#34;Clk_F_ccdread_red&#34;]

GUI_SETTINGS = Settings.load(&#34;AEU GUI&#34;)


class MonitoringWorker(QObject):
    &#34;&#34;&#34; Worker for monitoring the led status of the AEU cRIO. &#34;&#34;&#34;

    # The worker will send a signal with the AEU cRIO led status

    common_led_status_signal = pyqtSignal(dict)
    hide_clk_signal = pyqtSignal()
    n_cam_clk_led_status_signal = pyqtSignal(dict)
    f_cam_clk_led_status_signal = pyqtSignal(dict)

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker.

        This worker keeps on eye on the monitoring port of the AEU cRIO.  When a changed in (relevant) monitoring
        information occurs, a signal will be emitted.  These signals will be used to update the GUI.
        &#34;&#34;&#34;

        super(MonitoringWorker, self).__init__()

        self.active = False
        self.just_reconnected = True

        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5  # [s]

        self.connect_socket()

        # Keep track of the previous led status, so we only have to send a signal when the led status has changed

        self.previous_common_led_status = {}
        self.previous_n_cam_clk_led_status = {}
        self.previous_f_cam_clk_led_status = {}

    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;

        try:

            transport = CTRL_SETTINGS.PROTOCOL
            hostname = CTRL_SETTINGS.HOSTNAME
            # commanding_port = CTRL_SETTINGS.CRIO[&#34;COMMANDING_PORT&#34;]
            monitoring_port = CTRL_SETTINGS.CRIO[&#34;MONITORING_PORT&#34;]

            monitoring_address = connect_address(transport, hostname, monitoring_port)

            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

            self.monitoring_timeout = 0.5   # [s]

            # Address of the commanding port
            # This is needed when checking whether or not the CS is active
            # TODO

            self.is_socket_connected = True

        except AttributeError:

            self.is_socket_connected = False

    def stop(self):

        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;

        self.monitoring_socket.close()
        self.is_socket_connected = False

        self.active = False

    def start_process(self):
        &#34;&#34;&#34; Start updating the led status of the AEU cRIO.&#34;&#34;&#34;

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on checking whether the led status of the AEU cRIO has changed.

        If the led status of the AEU cRIO has changed, update it in the GUI.
        &#34;&#34;&#34;

        self.active = True

        while self.is_socket_connected and self.active:

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Select the monitoring information that is relevant for the GUI

                    common_led_status = {key: monitoring_info[key] for key in RELEVANT_COMMON_KEYS.keys()}

                    n_cam_clk_led_status = {}
                    f_cam_clk_led_status = {}

                    n_cam_powered = common_led_status[&#34;N-CAM&#34;]
                    f_cam_powered = common_led_status[&#34;F-CAM&#34;]

                    if n_cam_powered:
                        n_cam_clk_led_status = {key: monitoring_info[key] for key in RELEVANT_N_CAM_KEYS}
                    elif f_cam_powered:
                        f_cam_clk_led_status = {key: monitoring_info[key] for key in RELEVANT_F_CAM_KEYS}

                    diff_common = DeepDiff(common_led_status, self.previous_common_led_status)
                    diff_n_cam_clk = DeepDiff(n_cam_clk_led_status, self.previous_n_cam_clk_led_status)
                    diff_f_cam_clk = DeepDiff(f_cam_clk_led_status, self.previous_f_cam_clk_led_status)

                    error_detected = monitoring_info[&#34;S_voltage_oor&#34;] or monitoring_info[&#34;S_current_oor&#34;] \
                                     or monitoring_info[&#34;Sync_gf&#34;]

                    # Change in common led status

                    if self.just_reconnected:

                        if error_detected or not (n_cam_powered or f_cam_powered):

                            self.hide_clk_signal.emit()

                    if len(diff_common) != 0 or self.just_reconnected:

                        self.previous_common_led_status = common_led_status
                        self.common_led_status_signal.emit(common_led_status)

                    if error_detected:

                        self.hide_clk_signal.emit()

                    # Change in N-CAM led status

                    elif len(diff_n_cam_clk) != 0:

                        self.previous_n_cam_clk_led_status = n_cam_clk_led_status
                        self.n_cam_clk_led_status_signal.emit(n_cam_clk_led_status)

                    # Change in F-CAM led status

                    elif len(diff_f_cam_clk) != 0:

                        self.previous_f_cam_clk_led_status = f_cam_clk_led_status
                        self.f_cam_clk_led_status_signal.emit(f_cam_clk_led_status)

                    self.just_reconnected = False

            except ZMQError:

                pass


class LedWidget(QGroupBox):

    def __init__(self, name: str, on_color=Indic.GREEN):
        &#34;&#34;&#34; Widget with a name and led.

        Args:
            - name: Text for the label.
            - on_color: Colour the led should have if turned on.
        &#34;&#34;&#34;

        super().__init__()

        label = QLabel(name)
        self.led = Led(self)
        self.on_color = on_color
        self.set_led_color(False)

        layout = QHBoxLayout()

        layout.addWidget(label)
        layout.addWidget(self.led)

        self.setLayout(layout)

    def set_on_color(self, on_color: Indic):
        &#34;&#34;&#34; Set the colour that the led should have when turned on.

        Args:
            - on_color: Colour the led should have when turned on.
        &#34;&#34;&#34;

        self.on_color = on_color

    def set_led_color(self, status: bool):
        &#34;&#34;&#34; Change the colour of the led.

        Args:
            - status: Indicates whether the led should be turned on.
        &#34;&#34;&#34;

        if status:

            self.led.set_color(self.on_color)

        else:

            self.led.set_color(Indic.BLACK)


class AEUUIView(QMainWindow, Observable):

    def __init__(self):
        &#34;&#34;&#34; Initialisation of the AEU GUI.

        In the current implementation, the GUI reflects the front panel of the UI, showing the following status
        information:

            - EGSE (operating) mode;
            - camera selection: N-CAM vs. F-CAM;
            - output status of the the six power lines (V_CCD, V_CLK, V_AN1, V_AN2, V_AN3, and V_DIG);
            - error detection: secondary voltage/current out-of-range &amp; synchronisation generator failure;
            - Clk signals selection: Clk_N_50MHz, Clk_N_ccdread, Clk_F_50MHz_nom, Clk_F_50MHz_red, Clk_F_ccdread_nom,
              Clk_F_ccdread_red, Clk_TCS_50MHz_nom, Clk_TCS_50MHz_red, Clk_heater_nom, Clk_heater_red, and test port.
        &#34;&#34;&#34;

        super().__init__()

        self.setGeometry(300, 300, 300, 200)
        self.setWindowTitle(&#34;Ancillary Electrical Units (AEU)&#34;)

        self.widgets = {}
        self.connected_pix, self.disconnected_pix, self.connection_status_icon = None, None, None

        self.monitoring_thread = QThread(self)
        self.monitoring_worker = MonitoringWorker()
        self.monitoring_worker.moveToThread(self.monitoring_thread)

        self.monitoring_worker.common_led_status_signal.connect(self.on_common_led_status_changed_signal)
        self.monitoring_worker.hide_clk_signal.connect(self.on_hide_clk_signal)
        self.monitoring_worker.n_cam_clk_led_status_signal.connect(self.on_n_cam_clk_led_status_changed_signal)
        self.monitoring_worker.f_cam_clk_led_status_signal.connect(self.on_f_cam_clk_led_status_changed_signal)

        self.monitoring_thread.started.connect(self.monitoring_worker.start_process)
        self.monitoring_thread.start()

        self.reconnect_action = None
        self.n_cam_clk_signals_selection_widget = QGroupBox(&#34;&#34;, self)
        self.f_cam_clk_signals_selection_widget = QGroupBox(&#34;&#34;, self)
        self.tcs_clk_signals_selection_widget = QGroupBox(&#34;&#34;, self)

        self.init_ui()

    def init_ui(self):
        &#34;&#34;&#34; Put the components in the GUI window.

        The GUI comprises the following components:

            - leds representing the EGSE mode;
            - leds representing the camera selection;
            - leds representing the power lines:
            - leds representing the error detection;
            - leds representing the Clk signals selection.
        &#34;&#34;&#34;

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        self.create_toolbar()

        # self.widgets = {}

        for key, label in RELEVANT_COMMON_KEYS.items():

            self.widgets[key] = LedWidget(label)
            self.widgets[key].setFixedHeight(50)

        for key in RELEVANT_N_CAM_KEYS + RELEVANT_F_CAM_KEYS:

            self.widgets[key] = LedWidget(key)
            self.widgets[key].setFixedHeight(50)

        self.widgets[&#34;S_voltage_oor&#34;].set_on_color(Indic.RED)
        self.widgets[&#34;S_current_oor&#34;].set_on_color(Indic.RED)
        self.widgets[&#34;Sync_gf&#34;].set_on_color(Indic.RED)

        layout = QHBoxLayout()

        # EGSE mode

        egse_mode_layout = QVBoxLayout()
        egse_mode_widget = QGroupBox(&#34;EGSE mode&#34;, self)

        egse_mode_layout.addWidget(self.widgets[&#34;Standby&#34;])
        egse_mode_layout.addWidget(self.widgets[&#34;Selftest&#34;])
        egse_mode_layout.addWidget(self.widgets[&#34;FC_TVAC&#34;])
        egse_mode_layout.addWidget(self.widgets[&#34;Alignment&#34;])

        egse_mode_widget.setLayout(egse_mode_layout)

        # Camera selection

        cam_selection_layout = QVBoxLayout()
        cam_selection_widget = QGroupBox(&#34;Camera selection&#34;, self)

        cam_selection_layout.addWidget(self.widgets[&#34;N-CAM&#34;])
        cam_selection_layout.addWidget(self.widgets[&#34;F-CAM&#34;])

        cam_selection_widget.setLayout(cam_selection_layout)

        # Power lines

        power_lines_layout = QGridLayout()
        power_lines_widget = QGroupBox(&#34;Power lines&#34;, self)

        power_lines_layout.addWidget(self.widgets[&#34;V_CCD&#34;], 0, 0)
        power_lines_layout.addWidget(self.widgets[&#34;V_CLK&#34;], 1, 0)
        power_lines_layout.addWidget(self.widgets[&#34;V_AN1&#34;], 2, 0)
        power_lines_layout.addWidget(self.widgets[&#34;V_AN2&#34;], 0, 1)
        power_lines_layout.addWidget(self.widgets[&#34;V_AN3&#34;], 1, 1)
        power_lines_layout.addWidget(self.widgets[&#34;V_DIG&#34;], 2, 1)

        power_lines_widget.setLayout(power_lines_layout)

        # Error detection

        error_detection_layout = QVBoxLayout()
        error_detection_widget = QGroupBox(&#34;Error detection&#34;, self)

        error_detection_layout.addWidget(self.widgets[&#34;S_voltage_oor&#34;])
        error_detection_layout.addWidget(self.widgets[&#34;S_current_oor&#34;])
        error_detection_layout.addWidget(self.widgets[&#34;Sync_gf&#34;])

        error_detection_widget.setLayout(error_detection_layout)

        # Clk signals selection

        clk_signals_selection_layout = QVBoxLayout()
        clk_signals_selection_widget = QGroupBox(&#34;Clk signals selection&#34;, self)

        n_cam_clk_signals_selection_layout = QHBoxLayout()
        f_cam_clk_signals_selection_layout = QGridLayout()
        tcs_clk_signals_selection_layout = QGridLayout()

        n_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_N_50MHz&#34;])
        n_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_N_ccdread&#34;])

        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_50MHz_nom&#34;], 0, 0)
        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_50MHz_red&#34;], 0, 1)
        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_ccdread_nom&#34;], 1, 0)
        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_ccdread_red&#34;], 1, 1)

        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_TCS_50MHz_nom&#34;], 0, 0)
        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_TCS_50MHz_red&#34;], 0, 1)
        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_heater_nom&#34;], 1, 0)
        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_heater_red&#34;], 1, 1)

        self.n_cam_clk_signals_selection_widget.setLayout(n_cam_clk_signals_selection_layout)
        self.f_cam_clk_signals_selection_widget.setLayout(f_cam_clk_signals_selection_layout)
        self.tcs_clk_signals_selection_widget.setLayout(tcs_clk_signals_selection_layout)

        clk_signals_selection_layout.addWidget(self.n_cam_clk_signals_selection_widget)
        clk_signals_selection_layout.addWidget(self.f_cam_clk_signals_selection_widget)
        clk_signals_selection_layout.addWidget(self.tcs_clk_signals_selection_widget)

        self.n_cam_clk_signals_selection_widget.setVisible(False)
        self.f_cam_clk_signals_selection_widget.setVisible(False)
        self.tcs_clk_signals_selection_widget.setVisible(False)

        clk_signals_selection_layout.addWidget(self.widgets[&#34;TestPort&#34;])

        clk_signals_selection_widget.setLayout(clk_signals_selection_layout)

        egse_mode_layout.addStretch(True)
        cam_selection_layout.addStretch(True)
        power_lines_layout.setRowStretch(3, 2)
        error_detection_layout.addStretch(True)
        clk_signals_selection_layout.addStretch(True)

        layout.addWidget(egse_mode_widget)
        layout.addWidget(cam_selection_widget)
        layout.addWidget(power_lines_widget)
        layout.addWidget(error_detection_widget)
        layout.addWidget(clk_signals_selection_widget)

        app_frame.setLayout(layout)

        self.setCentralWidget(app_frame)

    def create_toolbar(self):
        &#34;&#34;&#34; Create toolbar showing the state of the connection with the device.&#34;&#34;&#34;

        connected_pix = QPixmap(str(find_file(&#34;connected-100.png&#34;, in_dir=&#34;images&#34;)))
        disconnected_pix = QPixmap(str(find_file(&#34;disconnected-100.png&#34;, in_dir=&#34;images&#34;)))
        reconnect_icon = QIcon()
        reconnect_icon.addPixmap(connected_pix, QIcon.Normal, QIcon.On)
        reconnect_icon.addPixmap(disconnected_pix, QIcon.Normal, QIcon.Off)

        self.reconnect_action = QAction(reconnect_icon, &#34;Reconnect&#34;, self)
        self.reconnect_action.setToolTip(&#34;Reconnect&#34;)
        self.reconnect_action.setCheckable(True)
        self.reconnect_action.triggered.connect(self.on_click)

        toolbar = self.addToolBar(&#34;MainToolbar&#34;)
        toolbar.addAction(self.reconnect_action)

    def on_common_led_status_changed_signal(self, monitoring_info: dict):
        &#34;&#34;&#34; Update the status of the leds in case the common led status has changed.

        Args:
            - monitoring_info: Monitoring information regarding the EGSE mode, camera selection, power lines, and
                               error detection.
        &#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        for name, status in monitoring_info.items():

            self.widgets[name].set_led_color(status)

        # self.set_connection_state(True)

    def on_hide_clk_signal(self):
        &#34;&#34;&#34; Hide the information about the clocks.&#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        self.n_cam_clk_signals_selection_widget.setVisible(False)
        self.f_cam_clk_signals_selection_widget.setVisible(False)
        self.tcs_clk_signals_selection_widget.setVisible(False)

        # self.set_connection_state(True)

    def on_n_cam_clk_led_status_changed_signal(self, monitoring_info: dict):
        &#34;&#34;&#34; Update the status of the leds in case the N-CAM Clk led status has changed.

        When the given monitoring information is empty, the status of the N-CAM Clk is hidden.

        Args:
            - monitoring_info: Monitoring information regarding the N-CAM Clk signal selection.  Empty when the N-CAM is
                               not selected.
        &#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        if len(monitoring_info) == 0:

            self.n_cam_clk_signals_selection_widget.setVisible(False)
            self.tcs_clk_signals_selection_widget.setVisible(False)

        else:

            self.n_cam_clk_signals_selection_widget.setVisible(True)
            self.tcs_clk_signals_selection_widget.setVisible(True)

            for name, status in monitoring_info.items():

                self.widgets[name].set_led_color(status)

        # self.set_connection_state(True)

    def on_f_cam_clk_led_status_changed_signal(self, monitoring_info: dict):
        &#34;&#34;&#34; Update the status of the leds in case the F-CAM Clk led status has changed.

        When the given monitoring information is empty, the status of the F-CAM Clk is hidden

        Args:
            - monitoring_info: Monitoring information regarding the F-CAM Clk signal selection.  Empty when the F-CAM is
                               not selected.
        &#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        if len(monitoring_info) == 0:

            self.f_cam_clk_signals_selection_widget.setVisible(False)
            self.tcs_clk_signals_selection_widget.setVisible(False)

        else:

            self.f_cam_clk_signals_selection_widget.setVisible(True)
            self.tcs_clk_signals_selection_widget.setVisible(True)

            for name, status in monitoring_info.items():

                self.widgets[name].set_led_color(status)

        # self.set_connection_state(True)

    # def on_connection_lost_signal(self):
    #     &#34;&#34;&#34; Switch off all leds when the connection to the cRIO is lost.&#34;&#34;&#34;
    #
    #     print(&#34;Connection lost&#34;)
    #
    #     self.disable_leds()
    #
    #     # self.set_connection_state(False)

    def disable_leds(self):
        &#34;&#34;&#34; Disable all the leds.&#34;&#34;&#34;

        for led in self.widgets.values():

            led.set_led_color(0)

    def on_click(self):
        &#34;&#34;&#34; Notify the observers in case of a click.&#34;&#34;&#34;
        sender = self.sender()

        MODULE_LOGGER.log(0, f&#34;sender.text() = {sender.text()}&#34;)
        MODULE_LOGGER.log(0, f&#34;sender.isChecked() = {sender.isChecked()}&#34;)

        self.notifyObservers(sender)

    def set_connection_state(self, is_connected):
        &#34;&#34;&#34; Update the connection state in the toolbar.

        Args:
            - is_connected: Connection status to show.
        &#34;&#34;&#34;
        if is_connected:

            self.reconnect_action.setChecked(True)
            self.monitoring_worker.just_reconnected = True

        elif not is_connected:

            self.reconnect_action.setChecked(False)
            self.disable_leds()

    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

        Args:
            - close_event: Close event received when the GUI is closed.
        &#34;&#34;&#34;

        self.monitoring_worker.stop()

        self.monitoring_thread.quit()
        self.monitoring_thread.wait()


class AEUUIModel:

    def __init__(self, aeu_type: str):
        &#34;&#34;&#34; Initialisation of the mode, based on the given AEU cRIO type.

        Allowed values are:

            - proxy: to use the CRIOProxy;
            - crio: to use the CRIOController;
            - simulator: to use the CRIOSimulator.

        Args:
            - aeu_type: Type of AEU cRIO to use as UI model.
        &#34;&#34;&#34;

        self.type = aeu_type

        # Proxy

        if self.type == &#34;proxy&#34;:

            self.crio = CRIOProxy()

        # Controller

        elif self.type == &#34;crio&#34;:

            self.crio = CRIOController()
            self.crio.connect()

        # Simulator

        elif self.type == &#34;simulator&#34;:

            self.crio = CRIOSimulator()

        else:

            raise ValueError(f&#34;Unknown type of AEU cRIO implementation passed into the model: {type}&#34;)

        if self.crio is not None:

            MODULE_LOGGER.debug(f&#34;AEU cRIO Controller initialized as {self.crio.__class__.__name__}&#34;)

    def has_commands(self):
        &#34;&#34;&#34; Check whether the AEU cRIO has commands.

        Returns: True if the AEU cRIO has commands; False otherwise.
        &#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            return self.crio.has_commands()

        return True

    def load_commands(self):
        &#34;&#34;&#34; Load the commands for the CRIOProxy.&#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            self.crio.load_commands()

    def is_simulator(self):
        &#34;&#34;&#34; Checks whether the AEU cRIO is a simulator.

        Returns: True if the AEU cRIO is a simulator; False otherwise.
        &#34;&#34;&#34;

        return self.crio.is_simulator()

    def is_connected(self):
        &#34;&#34;&#34; Check whether the AEU cRIO is connected.

        Returns: True if the AEU cRIO is connected; False otherwise.
        &#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            return self.crio.is_cs_connected()

        else:

            return self.crio.is_connected()

    def reconnect(self):
        &#34;&#34;&#34; Reconnect the AEU cRIO.

        Returns: True if the connection could be established; False otherwise.
        &#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            self.crio.reconnect_cs()

            return self.crio.is_cs_connected()

        else:

            self.crio.reconnect()

            return self.crio.is_connected()

        return False

    def disconnect(self):
        &#34;&#34;&#34; Disconnect the AEU cRIO Control Server.&#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            self.crio.disconnect_cs()


class AEUUIController(Observer):

    def __init__(self, model: AEUUIModel, view: AEUUIView):

        self.model = model
        self.view = view
        self.view.addObserver(self)

        # self.states_capture_timer = None
        # self.timer_interval = 200
        # self.create_timer()

        if self.model.is_connected():

            self.view.set_connection_state(True)
            # self.start_timer()

        else:

            self.view.set_connection_state(False)
            # self.stop_timer()

    # def create_timer(self):
    #
    #     print(&#34;Create timer&#34;)
    #     &#34;&#34;&#34;Create a Timer that will update the States every second.&#34;&#34;&#34;
    #
    #     self.states_capture_timer = QTimer()
    #     # This is only needed when the Timer needs to run in another Thread
    #     # self.states_capture_timer.moveToThread(self)
    #     self.states_capture_timer.timeout.connect(self.update_connection_state)
    #     self.states_capture_timer.setInterval(self.timer_interval)
    #
    # def start_timer(self):
    #     print(&#34;Start timer&#34;)
    #     self.states_capture_timer.start()
    #
    # def stop_timer(self):
    #     print(&#34;Stop timer&#34;)
    #     self.states_capture_timer.stop()
    #
    # def update_connection_state(self):
    #     &#34;&#34;&#34;Updates the common view widgets.&#34;&#34;&#34;
    #
    #     if not self.model.is_connected():
    #
    #         self.view.set_connection_state(False)

    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                MODULE_LOGGER.debug(&#34;Reconnecting the AEU model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                MODULE_LOGGER.debug(&#34;Disconnecting the AEU model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return

    def do(self):

        pass

def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;, &#34;crio&#34;},
        help=&#34;Specify AEU cRIO implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )
    parser.add_argument(
        &#34;--profile&#34;,
        default=False,
        action=&#34;store_true&#34;,
        help=&#34;Enable info logging messages with method profile information.&#34;,
    )
    args = parser.parse_args()
    return args


def main():
    &#34;&#34;&#34; Main method to launch the AEU GUI.&#34;&#34;&#34;

    args = list(sys.argv)
    app = QApplication(args)

    # process_status = ProcessStatus()
    #
    # timer_thread = threading.Thread(target=do_every, args=(10, process_status.update))
    # timer_thread.daemon = True
    # timer_thread.start()
    #
    # start_http_server(8541)

    args = parse_arguments()

    if args.profile:
        Settings.set_profiling(True)

    if args.type == &#34;proxy&#34;:
        proxy = CRIOProxy()
        # if not proxy.ping():
        #     description = &#34;Could not connect to Stages Control Server&#34;
        #     info_text = (
        #         &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
        #         &#34;Please check if the Control Server is running and start the server if needed. &#34;
        #         &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
        #         &#34;Settings.yaml &#34;
        #         &#34;configuration file.&#34;
        #     )
        #
        #     show_warning_message(description, info_text)


    view = AEUUIView()
    model = AEUUIModel(args.type)
    controller = AEUUIController(model, view)

    view.show()
    sys.exit(app.exec_())


if __name__ == &#34;__main__&#34;:

    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.aeu.aeu_ui.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main method to launch the AEU GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34; Main method to launch the AEU GUI.&#34;&#34;&#34;

    args = list(sys.argv)
    app = QApplication(args)

    # process_status = ProcessStatus()
    #
    # timer_thread = threading.Thread(target=do_every, args=(10, process_status.update))
    # timer_thread.daemon = True
    # timer_thread.start()
    #
    # start_http_server(8541)

    args = parse_arguments()

    if args.profile:
        Settings.set_profiling(True)

    if args.type == &#34;proxy&#34;:
        proxy = CRIOProxy()
        # if not proxy.ping():
        #     description = &#34;Could not connect to Stages Control Server&#34;
        #     info_text = (
        #         &#34;The GUI will start, but the connection button will show a disconnected state. &#34;
        #         &#34;Please check if the Control Server is running and start the server if needed. &#34;
        #         &#34;Otherwise, check if the correct HOSTNAME for the control server is set in the &#34;
        #         &#34;Settings.yaml &#34;
        #         &#34;configuration file.&#34;
        #     )
        #
        #     show_warning_message(description, info_text)


    view = AEUUIView()
    model = AEUUIModel(args.type)
    controller = AEUUIController(model, view)

    view.show()
    sys.exit(app.exec_())</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.parse_arguments"><code class="name flex">
<span>def <span class="ident">parse_arguments</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the arguments that are specific for this application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_arguments():
    &#34;&#34;&#34;
    Prepare the arguments that are specific for this application.
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser()
    parser.add_argument(
        &#34;--type&#34;,
        dest=&#34;type&#34;,
        action=&#34;store&#34;,
        choices={&#34;proxy&#34;, &#34;simulator&#34;, &#34;crio&#34;},
        help=&#34;Specify AEU cRIO implementation you want to connect to.&#34;,
        default=&#34;proxy&#34;,
    )
    parser.add_argument(
        &#34;--profile&#34;,
        default=False,
        action=&#34;store_true&#34;,
        help=&#34;Enable info logging messages with method profile information.&#34;,
    )
    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.aeu.aeu_ui.AEUUIController"><code class="flex name class">
<span>class <span class="ident">AEUUIController</span></span>
<span>(</span><span>model: <a title="egse.aeu.aeu_ui.AEUUIModel" href="#egse.aeu.aeu_ui.AEUUIModel">AEUUIModel</a>, view: <a title="egse.aeu.aeu_ui.AEUUIView" href="#egse.aeu.aeu_ui.AEUUIView">AEUUIView</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AEUUIController(Observer):

    def __init__(self, model: AEUUIModel, view: AEUUIView):

        self.model = model
        self.view = view
        self.view.addObserver(self)

        # self.states_capture_timer = None
        # self.timer_interval = 200
        # self.create_timer()

        if self.model.is_connected():

            self.view.set_connection_state(True)
            # self.start_timer()

        else:

            self.view.set_connection_state(False)
            # self.stop_timer()

    # def create_timer(self):
    #
    #     print(&#34;Create timer&#34;)
    #     &#34;&#34;&#34;Create a Timer that will update the States every second.&#34;&#34;&#34;
    #
    #     self.states_capture_timer = QTimer()
    #     # This is only needed when the Timer needs to run in another Thread
    #     # self.states_capture_timer.moveToThread(self)
    #     self.states_capture_timer.timeout.connect(self.update_connection_state)
    #     self.states_capture_timer.setInterval(self.timer_interval)
    #
    # def start_timer(self):
    #     print(&#34;Start timer&#34;)
    #     self.states_capture_timer.start()
    #
    # def stop_timer(self):
    #     print(&#34;Stop timer&#34;)
    #     self.states_capture_timer.stop()
    #
    # def update_connection_state(self):
    #     &#34;&#34;&#34;Updates the common view widgets.&#34;&#34;&#34;
    #
    #     if not self.model.is_connected():
    #
    #         self.view.set_connection_state(False)

    def update(self, changed_object):

        text = changed_object.text()

        if text == &#34;Reconnect&#34;:

            if changed_object.isChecked():

                MODULE_LOGGER.debug(&#34;Reconnecting the AEU model.&#34;)

                if self.model.reconnect():

                    self.view.set_connection_state(True)

                    if not self.model.has_commands():

                        self.model.load_commands()

                else:
                    self.view.reconnect_action.setChecked(False)
            else:

                MODULE_LOGGER.debug(&#34;Disconnecting the AEU model.&#34;)
                self.model.disconnect()
                self.view.set_connection_state(False)

            return

    def do(self):

        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.observer.Observer" href="../observer.html#egse.observer.Observer">Observer</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_ui.AEUUIController.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self):

    pass</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIController.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, changed_object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, changed_object):

    text = changed_object.text()

    if text == &#34;Reconnect&#34;:

        if changed_object.isChecked():

            MODULE_LOGGER.debug(&#34;Reconnecting the AEU model.&#34;)

            if self.model.reconnect():

                self.view.set_connection_state(True)

                if not self.model.has_commands():

                    self.model.load_commands()

            else:
                self.view.reconnect_action.setChecked(False)
        else:

            MODULE_LOGGER.debug(&#34;Disconnecting the AEU model.&#34;)
            self.model.disconnect()
            self.view.set_connection_state(False)

        return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIModel"><code class="flex name class">
<span>class <span class="ident">AEUUIModel</span></span>
<span>(</span><span>aeu_type: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialisation of the mode, based on the given AEU cRIO type.</p>
<p>Allowed values are:</p>
<pre><code>- proxy: to use the CRIOProxy;
- crio: to use the CRIOController;
- simulator: to use the CRIOSimulator.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>aeu_type: Type of AEU cRIO to use as UI model.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AEUUIModel:

    def __init__(self, aeu_type: str):
        &#34;&#34;&#34; Initialisation of the mode, based on the given AEU cRIO type.

        Allowed values are:

            - proxy: to use the CRIOProxy;
            - crio: to use the CRIOController;
            - simulator: to use the CRIOSimulator.

        Args:
            - aeu_type: Type of AEU cRIO to use as UI model.
        &#34;&#34;&#34;

        self.type = aeu_type

        # Proxy

        if self.type == &#34;proxy&#34;:

            self.crio = CRIOProxy()

        # Controller

        elif self.type == &#34;crio&#34;:

            self.crio = CRIOController()
            self.crio.connect()

        # Simulator

        elif self.type == &#34;simulator&#34;:

            self.crio = CRIOSimulator()

        else:

            raise ValueError(f&#34;Unknown type of AEU cRIO implementation passed into the model: {type}&#34;)

        if self.crio is not None:

            MODULE_LOGGER.debug(f&#34;AEU cRIO Controller initialized as {self.crio.__class__.__name__}&#34;)

    def has_commands(self):
        &#34;&#34;&#34; Check whether the AEU cRIO has commands.

        Returns: True if the AEU cRIO has commands; False otherwise.
        &#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            return self.crio.has_commands()

        return True

    def load_commands(self):
        &#34;&#34;&#34; Load the commands for the CRIOProxy.&#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            self.crio.load_commands()

    def is_simulator(self):
        &#34;&#34;&#34; Checks whether the AEU cRIO is a simulator.

        Returns: True if the AEU cRIO is a simulator; False otherwise.
        &#34;&#34;&#34;

        return self.crio.is_simulator()

    def is_connected(self):
        &#34;&#34;&#34; Check whether the AEU cRIO is connected.

        Returns: True if the AEU cRIO is connected; False otherwise.
        &#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            return self.crio.is_cs_connected()

        else:

            return self.crio.is_connected()

    def reconnect(self):
        &#34;&#34;&#34; Reconnect the AEU cRIO.

        Returns: True if the connection could be established; False otherwise.
        &#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            self.crio.reconnect_cs()

            return self.crio.is_cs_connected()

        else:

            self.crio.reconnect()

            return self.crio.is_connected()

        return False

    def disconnect(self):
        &#34;&#34;&#34; Disconnect the AEU cRIO Control Server.&#34;&#34;&#34;

        if self.type == &#34;proxy&#34;:

            self.crio.disconnect_cs()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_ui.AEUUIModel.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect the AEU cRIO Control Server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34; Disconnect the AEU cRIO Control Server.&#34;&#34;&#34;

    if self.type == &#34;proxy&#34;:

        self.crio.disconnect_cs()</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIModel.has_commands"><code class="name flex">
<span>def <span class="ident">has_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the AEU cRIO has commands.</p>
<p>Returns: True if the AEU cRIO has commands; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_commands(self):
    &#34;&#34;&#34; Check whether the AEU cRIO has commands.

    Returns: True if the AEU cRIO has commands; False otherwise.
    &#34;&#34;&#34;

    if self.type == &#34;proxy&#34;:

        return self.crio.has_commands()

    return True</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIModel.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the AEU cRIO is connected.</p>
<p>Returns: True if the AEU cRIO is connected; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34; Check whether the AEU cRIO is connected.

    Returns: True if the AEU cRIO is connected; False otherwise.
    &#34;&#34;&#34;

    if self.type == &#34;proxy&#34;:

        return self.crio.is_cs_connected()

    else:

        return self.crio.is_connected()</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIModel.is_simulator"><code class="name flex">
<span>def <span class="ident">is_simulator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the AEU cRIO is a simulator.</p>
<p>Returns: True if the AEU cRIO is a simulator; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulator(self):
    &#34;&#34;&#34; Checks whether the AEU cRIO is a simulator.

    Returns: True if the AEU cRIO is a simulator; False otherwise.
    &#34;&#34;&#34;

    return self.crio.is_simulator()</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIModel.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the commands for the CRIOProxy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(self):
    &#34;&#34;&#34; Load the commands for the CRIOProxy.&#34;&#34;&#34;

    if self.type == &#34;proxy&#34;:

        self.crio.load_commands()</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIModel.reconnect"><code class="name flex">
<span>def <span class="ident">reconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconnect the AEU cRIO.</p>
<p>Returns: True if the connection could be established; False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnect(self):
    &#34;&#34;&#34; Reconnect the AEU cRIO.

    Returns: True if the connection could be established; False otherwise.
    &#34;&#34;&#34;

    if self.type == &#34;proxy&#34;:

        self.crio.reconnect_cs()

        return self.crio.is_cs_connected()

    else:

        self.crio.reconnect()

        return self.crio.is_connected()

    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView"><code class="flex name class">
<span>class <span class="ident">AEUUIView</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: QWidget = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p>
<p>Initialisation of the AEU GUI.</p>
<p>In the current implementation, the GUI reflects the front panel of the UI, showing the following status
information:</p>
<pre><code>- EGSE (operating) mode;
- camera selection: N-CAM vs. F-CAM;
- output status of the the six power lines (V_CCD, V_CLK, V_AN1, V_AN2, V_AN3, and V_DIG);
- error detection: secondary voltage/current out-of-range &amp; synchronisation generator failure;
- Clk signals selection: Clk_N_50MHz, Clk_N_ccdread, Clk_F_50MHz_nom, Clk_F_50MHz_red, Clk_F_ccdread_nom,
  Clk_F_ccdread_red, Clk_TCS_50MHz_nom, Clk_TCS_50MHz_red, Clk_heater_nom, Clk_heater_red, and test port.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AEUUIView(QMainWindow, Observable):

    def __init__(self):
        &#34;&#34;&#34; Initialisation of the AEU GUI.

        In the current implementation, the GUI reflects the front panel of the UI, showing the following status
        information:

            - EGSE (operating) mode;
            - camera selection: N-CAM vs. F-CAM;
            - output status of the the six power lines (V_CCD, V_CLK, V_AN1, V_AN2, V_AN3, and V_DIG);
            - error detection: secondary voltage/current out-of-range &amp; synchronisation generator failure;
            - Clk signals selection: Clk_N_50MHz, Clk_N_ccdread, Clk_F_50MHz_nom, Clk_F_50MHz_red, Clk_F_ccdread_nom,
              Clk_F_ccdread_red, Clk_TCS_50MHz_nom, Clk_TCS_50MHz_red, Clk_heater_nom, Clk_heater_red, and test port.
        &#34;&#34;&#34;

        super().__init__()

        self.setGeometry(300, 300, 300, 200)
        self.setWindowTitle(&#34;Ancillary Electrical Units (AEU)&#34;)

        self.widgets = {}
        self.connected_pix, self.disconnected_pix, self.connection_status_icon = None, None, None

        self.monitoring_thread = QThread(self)
        self.monitoring_worker = MonitoringWorker()
        self.monitoring_worker.moveToThread(self.monitoring_thread)

        self.monitoring_worker.common_led_status_signal.connect(self.on_common_led_status_changed_signal)
        self.monitoring_worker.hide_clk_signal.connect(self.on_hide_clk_signal)
        self.monitoring_worker.n_cam_clk_led_status_signal.connect(self.on_n_cam_clk_led_status_changed_signal)
        self.monitoring_worker.f_cam_clk_led_status_signal.connect(self.on_f_cam_clk_led_status_changed_signal)

        self.monitoring_thread.started.connect(self.monitoring_worker.start_process)
        self.monitoring_thread.start()

        self.reconnect_action = None
        self.n_cam_clk_signals_selection_widget = QGroupBox(&#34;&#34;, self)
        self.f_cam_clk_signals_selection_widget = QGroupBox(&#34;&#34;, self)
        self.tcs_clk_signals_selection_widget = QGroupBox(&#34;&#34;, self)

        self.init_ui()

    def init_ui(self):
        &#34;&#34;&#34; Put the components in the GUI window.

        The GUI comprises the following components:

            - leds representing the EGSE mode;
            - leds representing the camera selection;
            - leds representing the power lines:
            - leds representing the error detection;
            - leds representing the Clk signals selection.
        &#34;&#34;&#34;

        app_frame = QFrame()
        app_frame.setObjectName(&#34;AppFrame&#34;)

        self.create_toolbar()

        # self.widgets = {}

        for key, label in RELEVANT_COMMON_KEYS.items():

            self.widgets[key] = LedWidget(label)
            self.widgets[key].setFixedHeight(50)

        for key in RELEVANT_N_CAM_KEYS + RELEVANT_F_CAM_KEYS:

            self.widgets[key] = LedWidget(key)
            self.widgets[key].setFixedHeight(50)

        self.widgets[&#34;S_voltage_oor&#34;].set_on_color(Indic.RED)
        self.widgets[&#34;S_current_oor&#34;].set_on_color(Indic.RED)
        self.widgets[&#34;Sync_gf&#34;].set_on_color(Indic.RED)

        layout = QHBoxLayout()

        # EGSE mode

        egse_mode_layout = QVBoxLayout()
        egse_mode_widget = QGroupBox(&#34;EGSE mode&#34;, self)

        egse_mode_layout.addWidget(self.widgets[&#34;Standby&#34;])
        egse_mode_layout.addWidget(self.widgets[&#34;Selftest&#34;])
        egse_mode_layout.addWidget(self.widgets[&#34;FC_TVAC&#34;])
        egse_mode_layout.addWidget(self.widgets[&#34;Alignment&#34;])

        egse_mode_widget.setLayout(egse_mode_layout)

        # Camera selection

        cam_selection_layout = QVBoxLayout()
        cam_selection_widget = QGroupBox(&#34;Camera selection&#34;, self)

        cam_selection_layout.addWidget(self.widgets[&#34;N-CAM&#34;])
        cam_selection_layout.addWidget(self.widgets[&#34;F-CAM&#34;])

        cam_selection_widget.setLayout(cam_selection_layout)

        # Power lines

        power_lines_layout = QGridLayout()
        power_lines_widget = QGroupBox(&#34;Power lines&#34;, self)

        power_lines_layout.addWidget(self.widgets[&#34;V_CCD&#34;], 0, 0)
        power_lines_layout.addWidget(self.widgets[&#34;V_CLK&#34;], 1, 0)
        power_lines_layout.addWidget(self.widgets[&#34;V_AN1&#34;], 2, 0)
        power_lines_layout.addWidget(self.widgets[&#34;V_AN2&#34;], 0, 1)
        power_lines_layout.addWidget(self.widgets[&#34;V_AN3&#34;], 1, 1)
        power_lines_layout.addWidget(self.widgets[&#34;V_DIG&#34;], 2, 1)

        power_lines_widget.setLayout(power_lines_layout)

        # Error detection

        error_detection_layout = QVBoxLayout()
        error_detection_widget = QGroupBox(&#34;Error detection&#34;, self)

        error_detection_layout.addWidget(self.widgets[&#34;S_voltage_oor&#34;])
        error_detection_layout.addWidget(self.widgets[&#34;S_current_oor&#34;])
        error_detection_layout.addWidget(self.widgets[&#34;Sync_gf&#34;])

        error_detection_widget.setLayout(error_detection_layout)

        # Clk signals selection

        clk_signals_selection_layout = QVBoxLayout()
        clk_signals_selection_widget = QGroupBox(&#34;Clk signals selection&#34;, self)

        n_cam_clk_signals_selection_layout = QHBoxLayout()
        f_cam_clk_signals_selection_layout = QGridLayout()
        tcs_clk_signals_selection_layout = QGridLayout()

        n_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_N_50MHz&#34;])
        n_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_N_ccdread&#34;])

        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_50MHz_nom&#34;], 0, 0)
        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_50MHz_red&#34;], 0, 1)
        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_ccdread_nom&#34;], 1, 0)
        f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_ccdread_red&#34;], 1, 1)

        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_TCS_50MHz_nom&#34;], 0, 0)
        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_TCS_50MHz_red&#34;], 0, 1)
        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_heater_nom&#34;], 1, 0)
        tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_heater_red&#34;], 1, 1)

        self.n_cam_clk_signals_selection_widget.setLayout(n_cam_clk_signals_selection_layout)
        self.f_cam_clk_signals_selection_widget.setLayout(f_cam_clk_signals_selection_layout)
        self.tcs_clk_signals_selection_widget.setLayout(tcs_clk_signals_selection_layout)

        clk_signals_selection_layout.addWidget(self.n_cam_clk_signals_selection_widget)
        clk_signals_selection_layout.addWidget(self.f_cam_clk_signals_selection_widget)
        clk_signals_selection_layout.addWidget(self.tcs_clk_signals_selection_widget)

        self.n_cam_clk_signals_selection_widget.setVisible(False)
        self.f_cam_clk_signals_selection_widget.setVisible(False)
        self.tcs_clk_signals_selection_widget.setVisible(False)

        clk_signals_selection_layout.addWidget(self.widgets[&#34;TestPort&#34;])

        clk_signals_selection_widget.setLayout(clk_signals_selection_layout)

        egse_mode_layout.addStretch(True)
        cam_selection_layout.addStretch(True)
        power_lines_layout.setRowStretch(3, 2)
        error_detection_layout.addStretch(True)
        clk_signals_selection_layout.addStretch(True)

        layout.addWidget(egse_mode_widget)
        layout.addWidget(cam_selection_widget)
        layout.addWidget(power_lines_widget)
        layout.addWidget(error_detection_widget)
        layout.addWidget(clk_signals_selection_widget)

        app_frame.setLayout(layout)

        self.setCentralWidget(app_frame)

    def create_toolbar(self):
        &#34;&#34;&#34; Create toolbar showing the state of the connection with the device.&#34;&#34;&#34;

        connected_pix = QPixmap(str(find_file(&#34;connected-100.png&#34;, in_dir=&#34;images&#34;)))
        disconnected_pix = QPixmap(str(find_file(&#34;disconnected-100.png&#34;, in_dir=&#34;images&#34;)))
        reconnect_icon = QIcon()
        reconnect_icon.addPixmap(connected_pix, QIcon.Normal, QIcon.On)
        reconnect_icon.addPixmap(disconnected_pix, QIcon.Normal, QIcon.Off)

        self.reconnect_action = QAction(reconnect_icon, &#34;Reconnect&#34;, self)
        self.reconnect_action.setToolTip(&#34;Reconnect&#34;)
        self.reconnect_action.setCheckable(True)
        self.reconnect_action.triggered.connect(self.on_click)

        toolbar = self.addToolBar(&#34;MainToolbar&#34;)
        toolbar.addAction(self.reconnect_action)

    def on_common_led_status_changed_signal(self, monitoring_info: dict):
        &#34;&#34;&#34; Update the status of the leds in case the common led status has changed.

        Args:
            - monitoring_info: Monitoring information regarding the EGSE mode, camera selection, power lines, and
                               error detection.
        &#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        for name, status in monitoring_info.items():

            self.widgets[name].set_led_color(status)

        # self.set_connection_state(True)

    def on_hide_clk_signal(self):
        &#34;&#34;&#34; Hide the information about the clocks.&#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        self.n_cam_clk_signals_selection_widget.setVisible(False)
        self.f_cam_clk_signals_selection_widget.setVisible(False)
        self.tcs_clk_signals_selection_widget.setVisible(False)

        # self.set_connection_state(True)

    def on_n_cam_clk_led_status_changed_signal(self, monitoring_info: dict):
        &#34;&#34;&#34; Update the status of the leds in case the N-CAM Clk led status has changed.

        When the given monitoring information is empty, the status of the N-CAM Clk is hidden.

        Args:
            - monitoring_info: Monitoring information regarding the N-CAM Clk signal selection.  Empty when the N-CAM is
                               not selected.
        &#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        if len(monitoring_info) == 0:

            self.n_cam_clk_signals_selection_widget.setVisible(False)
            self.tcs_clk_signals_selection_widget.setVisible(False)

        else:

            self.n_cam_clk_signals_selection_widget.setVisible(True)
            self.tcs_clk_signals_selection_widget.setVisible(True)

            for name, status in monitoring_info.items():

                self.widgets[name].set_led_color(status)

        # self.set_connection_state(True)

    def on_f_cam_clk_led_status_changed_signal(self, monitoring_info: dict):
        &#34;&#34;&#34; Update the status of the leds in case the F-CAM Clk led status has changed.

        When the given monitoring information is empty, the status of the F-CAM Clk is hidden

        Args:
            - monitoring_info: Monitoring information regarding the F-CAM Clk signal selection.  Empty when the F-CAM is
                               not selected.
        &#34;&#34;&#34;

        if not self.reconnect_action.isChecked():

            return

        if len(monitoring_info) == 0:

            self.f_cam_clk_signals_selection_widget.setVisible(False)
            self.tcs_clk_signals_selection_widget.setVisible(False)

        else:

            self.f_cam_clk_signals_selection_widget.setVisible(True)
            self.tcs_clk_signals_selection_widget.setVisible(True)

            for name, status in monitoring_info.items():

                self.widgets[name].set_led_color(status)

        # self.set_connection_state(True)

    # def on_connection_lost_signal(self):
    #     &#34;&#34;&#34; Switch off all leds when the connection to the cRIO is lost.&#34;&#34;&#34;
    #
    #     print(&#34;Connection lost&#34;)
    #
    #     self.disable_leds()
    #
    #     # self.set_connection_state(False)

    def disable_leds(self):
        &#34;&#34;&#34; Disable all the leds.&#34;&#34;&#34;

        for led in self.widgets.values():

            led.set_led_color(0)

    def on_click(self):
        &#34;&#34;&#34; Notify the observers in case of a click.&#34;&#34;&#34;
        sender = self.sender()

        MODULE_LOGGER.log(0, f&#34;sender.text() = {sender.text()}&#34;)
        MODULE_LOGGER.log(0, f&#34;sender.isChecked() = {sender.isChecked()}&#34;)

        self.notifyObservers(sender)

    def set_connection_state(self, is_connected):
        &#34;&#34;&#34; Update the connection state in the toolbar.

        Args:
            - is_connected: Connection status to show.
        &#34;&#34;&#34;
        if is_connected:

            self.reconnect_action.setChecked(True)
            self.monitoring_worker.just_reconnected = True

        elif not is_connected:

            self.reconnect_action.setChecked(False)
            self.disable_leds()

    def closeEvent(self, close_event: QCloseEvent) -&gt; None:
        &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

        Args:
            - close_event: Close event received when the GUI is closed.
        &#34;&#34;&#34;

        self.monitoring_worker.stop()

        self.monitoring_thread.quit()
        self.monitoring_thread.wait()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
<li><a title="egse.observer.Observable" href="../observer.html#egse.observer.Observable">Observable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_ui.AEUUIView.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, close_event: PyQt5.QtGui.QCloseEvent) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure that all threads are stopped when the GUI is closed.</p>
<h2 id="args">Args</h2>
<ul>
<li>close_event: Close event received when the GUI is closed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, close_event: QCloseEvent) -&gt; None:
    &#34;&#34;&#34; Make sure that all threads are stopped when the GUI is closed.

    Args:
        - close_event: Close event received when the GUI is closed.
    &#34;&#34;&#34;

    self.monitoring_worker.stop()

    self.monitoring_thread.quit()
    self.monitoring_thread.wait()</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.create_toolbar"><code class="name flex">
<span>def <span class="ident">create_toolbar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create toolbar showing the state of the connection with the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_toolbar(self):
    &#34;&#34;&#34; Create toolbar showing the state of the connection with the device.&#34;&#34;&#34;

    connected_pix = QPixmap(str(find_file(&#34;connected-100.png&#34;, in_dir=&#34;images&#34;)))
    disconnected_pix = QPixmap(str(find_file(&#34;disconnected-100.png&#34;, in_dir=&#34;images&#34;)))
    reconnect_icon = QIcon()
    reconnect_icon.addPixmap(connected_pix, QIcon.Normal, QIcon.On)
    reconnect_icon.addPixmap(disconnected_pix, QIcon.Normal, QIcon.Off)

    self.reconnect_action = QAction(reconnect_icon, &#34;Reconnect&#34;, self)
    self.reconnect_action.setToolTip(&#34;Reconnect&#34;)
    self.reconnect_action.setCheckable(True)
    self.reconnect_action.triggered.connect(self.on_click)

    toolbar = self.addToolBar(&#34;MainToolbar&#34;)
    toolbar.addAction(self.reconnect_action)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.disable_leds"><code class="name flex">
<span>def <span class="ident">disable_leds</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable all the leds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_leds(self):
    &#34;&#34;&#34; Disable all the leds.&#34;&#34;&#34;

    for led in self.widgets.values():

        led.set_led_color(0)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.init_ui"><code class="name flex">
<span>def <span class="ident">init_ui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Put the components in the GUI window.</p>
<p>The GUI comprises the following components:</p>
<pre><code>- leds representing the EGSE mode;
- leds representing the camera selection;
- leds representing the power lines:
- leds representing the error detection;
- leds representing the Clk signals selection.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_ui(self):
    &#34;&#34;&#34; Put the components in the GUI window.

    The GUI comprises the following components:

        - leds representing the EGSE mode;
        - leds representing the camera selection;
        - leds representing the power lines:
        - leds representing the error detection;
        - leds representing the Clk signals selection.
    &#34;&#34;&#34;

    app_frame = QFrame()
    app_frame.setObjectName(&#34;AppFrame&#34;)

    self.create_toolbar()

    # self.widgets = {}

    for key, label in RELEVANT_COMMON_KEYS.items():

        self.widgets[key] = LedWidget(label)
        self.widgets[key].setFixedHeight(50)

    for key in RELEVANT_N_CAM_KEYS + RELEVANT_F_CAM_KEYS:

        self.widgets[key] = LedWidget(key)
        self.widgets[key].setFixedHeight(50)

    self.widgets[&#34;S_voltage_oor&#34;].set_on_color(Indic.RED)
    self.widgets[&#34;S_current_oor&#34;].set_on_color(Indic.RED)
    self.widgets[&#34;Sync_gf&#34;].set_on_color(Indic.RED)

    layout = QHBoxLayout()

    # EGSE mode

    egse_mode_layout = QVBoxLayout()
    egse_mode_widget = QGroupBox(&#34;EGSE mode&#34;, self)

    egse_mode_layout.addWidget(self.widgets[&#34;Standby&#34;])
    egse_mode_layout.addWidget(self.widgets[&#34;Selftest&#34;])
    egse_mode_layout.addWidget(self.widgets[&#34;FC_TVAC&#34;])
    egse_mode_layout.addWidget(self.widgets[&#34;Alignment&#34;])

    egse_mode_widget.setLayout(egse_mode_layout)

    # Camera selection

    cam_selection_layout = QVBoxLayout()
    cam_selection_widget = QGroupBox(&#34;Camera selection&#34;, self)

    cam_selection_layout.addWidget(self.widgets[&#34;N-CAM&#34;])
    cam_selection_layout.addWidget(self.widgets[&#34;F-CAM&#34;])

    cam_selection_widget.setLayout(cam_selection_layout)

    # Power lines

    power_lines_layout = QGridLayout()
    power_lines_widget = QGroupBox(&#34;Power lines&#34;, self)

    power_lines_layout.addWidget(self.widgets[&#34;V_CCD&#34;], 0, 0)
    power_lines_layout.addWidget(self.widgets[&#34;V_CLK&#34;], 1, 0)
    power_lines_layout.addWidget(self.widgets[&#34;V_AN1&#34;], 2, 0)
    power_lines_layout.addWidget(self.widgets[&#34;V_AN2&#34;], 0, 1)
    power_lines_layout.addWidget(self.widgets[&#34;V_AN3&#34;], 1, 1)
    power_lines_layout.addWidget(self.widgets[&#34;V_DIG&#34;], 2, 1)

    power_lines_widget.setLayout(power_lines_layout)

    # Error detection

    error_detection_layout = QVBoxLayout()
    error_detection_widget = QGroupBox(&#34;Error detection&#34;, self)

    error_detection_layout.addWidget(self.widgets[&#34;S_voltage_oor&#34;])
    error_detection_layout.addWidget(self.widgets[&#34;S_current_oor&#34;])
    error_detection_layout.addWidget(self.widgets[&#34;Sync_gf&#34;])

    error_detection_widget.setLayout(error_detection_layout)

    # Clk signals selection

    clk_signals_selection_layout = QVBoxLayout()
    clk_signals_selection_widget = QGroupBox(&#34;Clk signals selection&#34;, self)

    n_cam_clk_signals_selection_layout = QHBoxLayout()
    f_cam_clk_signals_selection_layout = QGridLayout()
    tcs_clk_signals_selection_layout = QGridLayout()

    n_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_N_50MHz&#34;])
    n_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_N_ccdread&#34;])

    f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_50MHz_nom&#34;], 0, 0)
    f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_50MHz_red&#34;], 0, 1)
    f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_ccdread_nom&#34;], 1, 0)
    f_cam_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_F_ccdread_red&#34;], 1, 1)

    tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_TCS_50MHz_nom&#34;], 0, 0)
    tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_TCS_50MHz_red&#34;], 0, 1)
    tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_heater_nom&#34;], 1, 0)
    tcs_clk_signals_selection_layout.addWidget(self.widgets[&#34;Clk_heater_red&#34;], 1, 1)

    self.n_cam_clk_signals_selection_widget.setLayout(n_cam_clk_signals_selection_layout)
    self.f_cam_clk_signals_selection_widget.setLayout(f_cam_clk_signals_selection_layout)
    self.tcs_clk_signals_selection_widget.setLayout(tcs_clk_signals_selection_layout)

    clk_signals_selection_layout.addWidget(self.n_cam_clk_signals_selection_widget)
    clk_signals_selection_layout.addWidget(self.f_cam_clk_signals_selection_widget)
    clk_signals_selection_layout.addWidget(self.tcs_clk_signals_selection_widget)

    self.n_cam_clk_signals_selection_widget.setVisible(False)
    self.f_cam_clk_signals_selection_widget.setVisible(False)
    self.tcs_clk_signals_selection_widget.setVisible(False)

    clk_signals_selection_layout.addWidget(self.widgets[&#34;TestPort&#34;])

    clk_signals_selection_widget.setLayout(clk_signals_selection_layout)

    egse_mode_layout.addStretch(True)
    cam_selection_layout.addStretch(True)
    power_lines_layout.setRowStretch(3, 2)
    error_detection_layout.addStretch(True)
    clk_signals_selection_layout.addStretch(True)

    layout.addWidget(egse_mode_widget)
    layout.addWidget(cam_selection_widget)
    layout.addWidget(power_lines_widget)
    layout.addWidget(error_detection_widget)
    layout.addWidget(clk_signals_selection_widget)

    app_frame.setLayout(layout)

    self.setCentralWidget(app_frame)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.on_click"><code class="name flex">
<span>def <span class="ident">on_click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Notify the observers in case of a click.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_click(self):
    &#34;&#34;&#34; Notify the observers in case of a click.&#34;&#34;&#34;
    sender = self.sender()

    MODULE_LOGGER.log(0, f&#34;sender.text() = {sender.text()}&#34;)
    MODULE_LOGGER.log(0, f&#34;sender.isChecked() = {sender.isChecked()}&#34;)

    self.notifyObservers(sender)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.on_common_led_status_changed_signal"><code class="name flex">
<span>def <span class="ident">on_common_led_status_changed_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of the leds in case the common led status has changed.</p>
<h2 id="args">Args</h2>
<ul>
<li>monitoring_info: Monitoring information regarding the EGSE mode, camera selection, power lines, and
error detection.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_common_led_status_changed_signal(self, monitoring_info: dict):
    &#34;&#34;&#34; Update the status of the leds in case the common led status has changed.

    Args:
        - monitoring_info: Monitoring information regarding the EGSE mode, camera selection, power lines, and
                           error detection.
    &#34;&#34;&#34;

    if not self.reconnect_action.isChecked():

        return

    for name, status in monitoring_info.items():

        self.widgets[name].set_led_color(status)

    # self.set_connection_state(True)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.on_f_cam_clk_led_status_changed_signal"><code class="name flex">
<span>def <span class="ident">on_f_cam_clk_led_status_changed_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of the leds in case the F-CAM Clk led status has changed.</p>
<p>When the given monitoring information is empty, the status of the F-CAM Clk is hidden</p>
<h2 id="args">Args</h2>
<ul>
<li>monitoring_info: Monitoring information regarding the F-CAM Clk signal selection.
Empty when the F-CAM is
not selected.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_f_cam_clk_led_status_changed_signal(self, monitoring_info: dict):
    &#34;&#34;&#34; Update the status of the leds in case the F-CAM Clk led status has changed.

    When the given monitoring information is empty, the status of the F-CAM Clk is hidden

    Args:
        - monitoring_info: Monitoring information regarding the F-CAM Clk signal selection.  Empty when the F-CAM is
                           not selected.
    &#34;&#34;&#34;

    if not self.reconnect_action.isChecked():

        return

    if len(monitoring_info) == 0:

        self.f_cam_clk_signals_selection_widget.setVisible(False)
        self.tcs_clk_signals_selection_widget.setVisible(False)

    else:

        self.f_cam_clk_signals_selection_widget.setVisible(True)
        self.tcs_clk_signals_selection_widget.setVisible(True)

        for name, status in monitoring_info.items():

            self.widgets[name].set_led_color(status)

    # self.set_connection_state(True)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.on_hide_clk_signal"><code class="name flex">
<span>def <span class="ident">on_hide_clk_signal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide the information about the clocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_hide_clk_signal(self):
    &#34;&#34;&#34; Hide the information about the clocks.&#34;&#34;&#34;

    if not self.reconnect_action.isChecked():

        return

    self.n_cam_clk_signals_selection_widget.setVisible(False)
    self.f_cam_clk_signals_selection_widget.setVisible(False)
    self.tcs_clk_signals_selection_widget.setVisible(False)

    # self.set_connection_state(True)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.on_n_cam_clk_led_status_changed_signal"><code class="name flex">
<span>def <span class="ident">on_n_cam_clk_led_status_changed_signal</span></span>(<span>self, monitoring_info: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of the leds in case the N-CAM Clk led status has changed.</p>
<p>When the given monitoring information is empty, the status of the N-CAM Clk is hidden.</p>
<h2 id="args">Args</h2>
<ul>
<li>monitoring_info: Monitoring information regarding the N-CAM Clk signal selection.
Empty when the N-CAM is
not selected.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_n_cam_clk_led_status_changed_signal(self, monitoring_info: dict):
    &#34;&#34;&#34; Update the status of the leds in case the N-CAM Clk led status has changed.

    When the given monitoring information is empty, the status of the N-CAM Clk is hidden.

    Args:
        - monitoring_info: Monitoring information regarding the N-CAM Clk signal selection.  Empty when the N-CAM is
                           not selected.
    &#34;&#34;&#34;

    if not self.reconnect_action.isChecked():

        return

    if len(monitoring_info) == 0:

        self.n_cam_clk_signals_selection_widget.setVisible(False)
        self.tcs_clk_signals_selection_widget.setVisible(False)

    else:

        self.n_cam_clk_signals_selection_widget.setVisible(True)
        self.tcs_clk_signals_selection_widget.setVisible(True)

        for name, status in monitoring_info.items():

            self.widgets[name].set_led_color(status)

    # self.set_connection_state(True)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.AEUUIView.set_connection_state"><code class="name flex">
<span>def <span class="ident">set_connection_state</span></span>(<span>self, is_connected)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the connection state in the toolbar.</p>
<h2 id="args">Args</h2>
<ul>
<li>is_connected: Connection status to show.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_connection_state(self, is_connected):
    &#34;&#34;&#34; Update the connection state in the toolbar.

    Args:
        - is_connected: Connection status to show.
    &#34;&#34;&#34;
    if is_connected:

        self.reconnect_action.setChecked(True)
        self.monitoring_worker.just_reconnected = True

    elif not is_connected:

        self.reconnect_action.setChecked(False)
        self.disable_leds()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.aeu.aeu_ui.LedWidget"><code class="flex name class">
<span>class <span class="ident">LedWidget</span></span>
<span>(</span><span>name: str, on_color=1)</span>
</code></dt>
<dd>
<div class="desc"><p>QGroupBox(parent: QWidget = None)
QGroupBox(str, parent: QWidget = None)</p>
<p>Widget with a name and led.</p>
<h2 id="args">Args</h2>
<ul>
<li>name: Text for the label.</li>
<li>on_color: Colour the led should have if turned on.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LedWidget(QGroupBox):

    def __init__(self, name: str, on_color=Indic.GREEN):
        &#34;&#34;&#34; Widget with a name and led.

        Args:
            - name: Text for the label.
            - on_color: Colour the led should have if turned on.
        &#34;&#34;&#34;

        super().__init__()

        label = QLabel(name)
        self.led = Led(self)
        self.on_color = on_color
        self.set_led_color(False)

        layout = QHBoxLayout()

        layout.addWidget(label)
        layout.addWidget(self.led)

        self.setLayout(layout)

    def set_on_color(self, on_color: Indic):
        &#34;&#34;&#34; Set the colour that the led should have when turned on.

        Args:
            - on_color: Colour the led should have when turned on.
        &#34;&#34;&#34;

        self.on_color = on_color

    def set_led_color(self, status: bool):
        &#34;&#34;&#34; Change the colour of the led.

        Args:
            - status: Indicates whether the led should be turned on.
        &#34;&#34;&#34;

        if status:

            self.led.set_color(self.on_color)

        else:

            self.led.set_color(Indic.BLACK)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_ui.LedWidget.set_led_color"><code class="name flex">
<span>def <span class="ident">set_led_color</span></span>(<span>self, status: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the colour of the led.</p>
<h2 id="args">Args</h2>
<ul>
<li>status: Indicates whether the led should be turned on.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_led_color(self, status: bool):
    &#34;&#34;&#34; Change the colour of the led.

    Args:
        - status: Indicates whether the led should be turned on.
    &#34;&#34;&#34;

    if status:

        self.led.set_color(self.on_color)

    else:

        self.led.set_color(Indic.BLACK)</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.LedWidget.set_on_color"><code class="name flex">
<span>def <span class="ident">set_on_color</span></span>(<span>self, on_color: <a title="egse.gui.led.Indic" href="../gui/led.html#egse.gui.led.Indic">Indic</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the colour that the led should have when turned on.</p>
<h2 id="args">Args</h2>
<ul>
<li>on_color: Colour the led should have when turned on.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_on_color(self, on_color: Indic):
    &#34;&#34;&#34; Set the colour that the led should have when turned on.

    Args:
        - on_color: Colour the led should have when turned on.
    &#34;&#34;&#34;

    self.on_color = on_color</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker"><code class="flex name class">
<span>class <span class="ident">MonitoringWorker</span></span>
</code></dt>
<dd>
<div class="desc"><p>Worker for monitoring the led status of the AEU cRIO. </p>
<p>Initialisation of a monitoring worker.</p>
<p>This worker keeps on eye on the monitoring port of the AEU cRIO.
When a changed in (relevant) monitoring
information occurs, a signal will be emitted.
These signals will be used to update the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MonitoringWorker(QObject):
    &#34;&#34;&#34; Worker for monitoring the led status of the AEU cRIO. &#34;&#34;&#34;

    # The worker will send a signal with the AEU cRIO led status

    common_led_status_signal = pyqtSignal(dict)
    hide_clk_signal = pyqtSignal()
    n_cam_clk_led_status_signal = pyqtSignal(dict)
    f_cam_clk_led_status_signal = pyqtSignal(dict)

    def __init__(self):
        &#34;&#34;&#34; Initialisation of a monitoring worker.

        This worker keeps on eye on the monitoring port of the AEU cRIO.  When a changed in (relevant) monitoring
        information occurs, a signal will be emitted.  These signals will be used to update the GUI.
        &#34;&#34;&#34;

        super(MonitoringWorker, self).__init__()

        self.active = False
        self.just_reconnected = True

        self.monitoring_socket = None
        self.is_socket_connected = True
        self.monitoring_timeout = 0.5  # [s]

        self.connect_socket()

        # Keep track of the previous led status, so we only have to send a signal when the led status has changed

        self.previous_common_led_status = {}
        self.previous_n_cam_clk_led_status = {}
        self.previous_f_cam_clk_led_status = {}

    def connect_socket(self):
        &#34;&#34;&#34; Create a socket and connect to the monitoring port.
        &#34;&#34;&#34;

        try:

            transport = CTRL_SETTINGS.PROTOCOL
            hostname = CTRL_SETTINGS.HOSTNAME
            # commanding_port = CTRL_SETTINGS.CRIO[&#34;COMMANDING_PORT&#34;]
            monitoring_port = CTRL_SETTINGS.CRIO[&#34;MONITORING_PORT&#34;]

            monitoring_address = connect_address(transport, hostname, monitoring_port)

            self.monitoring_socket = zmq.Context().socket(zmq.SUB)
            self.monitoring_socket.connect(monitoring_address)
            self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

            self.monitoring_timeout = 0.5   # [s]

            # Address of the commanding port
            # This is needed when checking whether or not the CS is active
            # TODO

            self.is_socket_connected = True

        except AttributeError:

            self.is_socket_connected = False

    def stop(self):

        &#34;&#34;&#34; Stop the monitoring worker.

        The monitoring socket is disconnected from the monitoring port and is then closed immediately.
        &#34;&#34;&#34;

        self.monitoring_socket.close()
        self.is_socket_connected = False

        self.active = False

    def start_process(self):
        &#34;&#34;&#34; Start updating the led status of the AEU cRIO.&#34;&#34;&#34;

        self.run()

    @pyqtSlot()
    def run(self):
        &#34;&#34;&#34; Keep on checking whether the led status of the AEU cRIO has changed.

        If the led status of the AEU cRIO has changed, update it in the GUI.
        &#34;&#34;&#34;

        self.active = True

        while self.is_socket_connected and self.active:

            try:

                socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

                # Monitoring information was received (before timeout)

                if self.monitoring_socket in socket_list:

                    pickle_string = self.monitoring_socket.recv()
                    monitoring_info = pickle.loads(pickle_string)

                    # Select the monitoring information that is relevant for the GUI

                    common_led_status = {key: monitoring_info[key] for key in RELEVANT_COMMON_KEYS.keys()}

                    n_cam_clk_led_status = {}
                    f_cam_clk_led_status = {}

                    n_cam_powered = common_led_status[&#34;N-CAM&#34;]
                    f_cam_powered = common_led_status[&#34;F-CAM&#34;]

                    if n_cam_powered:
                        n_cam_clk_led_status = {key: monitoring_info[key] for key in RELEVANT_N_CAM_KEYS}
                    elif f_cam_powered:
                        f_cam_clk_led_status = {key: monitoring_info[key] for key in RELEVANT_F_CAM_KEYS}

                    diff_common = DeepDiff(common_led_status, self.previous_common_led_status)
                    diff_n_cam_clk = DeepDiff(n_cam_clk_led_status, self.previous_n_cam_clk_led_status)
                    diff_f_cam_clk = DeepDiff(f_cam_clk_led_status, self.previous_f_cam_clk_led_status)

                    error_detected = monitoring_info[&#34;S_voltage_oor&#34;] or monitoring_info[&#34;S_current_oor&#34;] \
                                     or monitoring_info[&#34;Sync_gf&#34;]

                    # Change in common led status

                    if self.just_reconnected:

                        if error_detected or not (n_cam_powered or f_cam_powered):

                            self.hide_clk_signal.emit()

                    if len(diff_common) != 0 or self.just_reconnected:

                        self.previous_common_led_status = common_led_status
                        self.common_led_status_signal.emit(common_led_status)

                    if error_detected:

                        self.hide_clk_signal.emit()

                    # Change in N-CAM led status

                    elif len(diff_n_cam_clk) != 0:

                        self.previous_n_cam_clk_led_status = n_cam_clk_led_status
                        self.n_cam_clk_led_status_signal.emit(n_cam_clk_led_status)

                    # Change in F-CAM led status

                    elif len(diff_f_cam_clk) != 0:

                        self.previous_f_cam_clk_led_status = f_cam_clk_led_status
                        self.f_cam_clk_led_status_signal.emit(f_cam_clk_led_status)

                    self.just_reconnected = False

            except ZMQError:

                pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.common_led_status_signal"><code class="name flex">
<span>def <span class="ident">common_led_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.connect_socket"><code class="name flex">
<span>def <span class="ident">connect_socket</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a socket and connect to the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_socket(self):
    &#34;&#34;&#34; Create a socket and connect to the monitoring port.
    &#34;&#34;&#34;

    try:

        transport = CTRL_SETTINGS.PROTOCOL
        hostname = CTRL_SETTINGS.HOSTNAME
        # commanding_port = CTRL_SETTINGS.CRIO[&#34;COMMANDING_PORT&#34;]
        monitoring_port = CTRL_SETTINGS.CRIO[&#34;MONITORING_PORT&#34;]

        monitoring_address = connect_address(transport, hostname, monitoring_port)

        self.monitoring_socket = zmq.Context().socket(zmq.SUB)
        self.monitoring_socket.connect(monitoring_address)
        self.monitoring_socket.setsockopt_string(zmq.SUBSCRIBE, &#34;&#34;)

        self.monitoring_timeout = 0.5   # [s]

        # Address of the commanding port
        # This is needed when checking whether or not the CS is active
        # TODO

        self.is_socket_connected = True

    except AttributeError:

        self.is_socket_connected = False</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.f_cam_clk_led_status_signal"><code class="name flex">
<span>def <span class="ident">f_cam_clk_led_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.hide_clk_signal"><code class="name flex">
<span>def <span class="ident">hide_clk_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.n_cam_clk_led_status_signal"><code class="name flex">
<span>def <span class="ident">n_cam_clk_led_status_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep on checking whether the led status of the AEU cRIO has changed.</p>
<p>If the led status of the AEU cRIO has changed, update it in the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot()
def run(self):
    &#34;&#34;&#34; Keep on checking whether the led status of the AEU cRIO has changed.

    If the led status of the AEU cRIO has changed, update it in the GUI.
    &#34;&#34;&#34;

    self.active = True

    while self.is_socket_connected and self.active:

        try:

            socket_list, _, _ = zmq.select([self.monitoring_socket], [], [], timeout=self.monitoring_timeout)

            # Monitoring information was received (before timeout)

            if self.monitoring_socket in socket_list:

                pickle_string = self.monitoring_socket.recv()
                monitoring_info = pickle.loads(pickle_string)

                # Select the monitoring information that is relevant for the GUI

                common_led_status = {key: monitoring_info[key] for key in RELEVANT_COMMON_KEYS.keys()}

                n_cam_clk_led_status = {}
                f_cam_clk_led_status = {}

                n_cam_powered = common_led_status[&#34;N-CAM&#34;]
                f_cam_powered = common_led_status[&#34;F-CAM&#34;]

                if n_cam_powered:
                    n_cam_clk_led_status = {key: monitoring_info[key] for key in RELEVANT_N_CAM_KEYS}
                elif f_cam_powered:
                    f_cam_clk_led_status = {key: monitoring_info[key] for key in RELEVANT_F_CAM_KEYS}

                diff_common = DeepDiff(common_led_status, self.previous_common_led_status)
                diff_n_cam_clk = DeepDiff(n_cam_clk_led_status, self.previous_n_cam_clk_led_status)
                diff_f_cam_clk = DeepDiff(f_cam_clk_led_status, self.previous_f_cam_clk_led_status)

                error_detected = monitoring_info[&#34;S_voltage_oor&#34;] or monitoring_info[&#34;S_current_oor&#34;] \
                                 or monitoring_info[&#34;Sync_gf&#34;]

                # Change in common led status

                if self.just_reconnected:

                    if error_detected or not (n_cam_powered or f_cam_powered):

                        self.hide_clk_signal.emit()

                if len(diff_common) != 0 or self.just_reconnected:

                    self.previous_common_led_status = common_led_status
                    self.common_led_status_signal.emit(common_led_status)

                if error_detected:

                    self.hide_clk_signal.emit()

                # Change in N-CAM led status

                elif len(diff_n_cam_clk) != 0:

                    self.previous_n_cam_clk_led_status = n_cam_clk_led_status
                    self.n_cam_clk_led_status_signal.emit(n_cam_clk_led_status)

                # Change in F-CAM led status

                elif len(diff_f_cam_clk) != 0:

                    self.previous_f_cam_clk_led_status = f_cam_clk_led_status
                    self.f_cam_clk_led_status_signal.emit(f_cam_clk_led_status)

                self.just_reconnected = False

        except ZMQError:

            pass</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.start_process"><code class="name flex">
<span>def <span class="ident">start_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start updating the led status of the AEU cRIO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_process(self):
    &#34;&#34;&#34; Start updating the led status of the AEU cRIO.&#34;&#34;&#34;

    self.run()</code></pre>
</details>
</dd>
<dt id="egse.aeu.aeu_ui.MonitoringWorker.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the monitoring worker.</p>
<p>The monitoring socket is disconnected from the monitoring port and is then closed immediately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):

    &#34;&#34;&#34; Stop the monitoring worker.

    The monitoring socket is disconnected from the monitoring port and is then closed immediately.
    &#34;&#34;&#34;

    self.monitoring_socket.close()
    self.is_socket_connected = False

    self.active = False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.aeu" href="index.html">egse.aeu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.aeu.aeu_ui.main" href="#egse.aeu.aeu_ui.main">main</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.parse_arguments" href="#egse.aeu.aeu_ui.parse_arguments">parse_arguments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.aeu.aeu_ui.AEUUIController" href="#egse.aeu.aeu_ui.AEUUIController">AEUUIController</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_ui.AEUUIController.do" href="#egse.aeu.aeu_ui.AEUUIController.do">do</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIController.update" href="#egse.aeu.aeu_ui.AEUUIController.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_ui.AEUUIModel" href="#egse.aeu.aeu_ui.AEUUIModel">AEUUIModel</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.aeu.aeu_ui.AEUUIModel.disconnect" href="#egse.aeu.aeu_ui.AEUUIModel.disconnect">disconnect</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIModel.has_commands" href="#egse.aeu.aeu_ui.AEUUIModel.has_commands">has_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIModel.is_connected" href="#egse.aeu.aeu_ui.AEUUIModel.is_connected">is_connected</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIModel.is_simulator" href="#egse.aeu.aeu_ui.AEUUIModel.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIModel.load_commands" href="#egse.aeu.aeu_ui.AEUUIModel.load_commands">load_commands</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIModel.reconnect" href="#egse.aeu.aeu_ui.AEUUIModel.reconnect">reconnect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_ui.AEUUIView" href="#egse.aeu.aeu_ui.AEUUIView">AEUUIView</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.closeEvent" href="#egse.aeu.aeu_ui.AEUUIView.closeEvent">closeEvent</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.create_toolbar" href="#egse.aeu.aeu_ui.AEUUIView.create_toolbar">create_toolbar</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.disable_leds" href="#egse.aeu.aeu_ui.AEUUIView.disable_leds">disable_leds</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.init_ui" href="#egse.aeu.aeu_ui.AEUUIView.init_ui">init_ui</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.on_click" href="#egse.aeu.aeu_ui.AEUUIView.on_click">on_click</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.on_common_led_status_changed_signal" href="#egse.aeu.aeu_ui.AEUUIView.on_common_led_status_changed_signal">on_common_led_status_changed_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.on_f_cam_clk_led_status_changed_signal" href="#egse.aeu.aeu_ui.AEUUIView.on_f_cam_clk_led_status_changed_signal">on_f_cam_clk_led_status_changed_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.on_hide_clk_signal" href="#egse.aeu.aeu_ui.AEUUIView.on_hide_clk_signal">on_hide_clk_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.on_n_cam_clk_led_status_changed_signal" href="#egse.aeu.aeu_ui.AEUUIView.on_n_cam_clk_led_status_changed_signal">on_n_cam_clk_led_status_changed_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.AEUUIView.set_connection_state" href="#egse.aeu.aeu_ui.AEUUIView.set_connection_state">set_connection_state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_ui.LedWidget" href="#egse.aeu.aeu_ui.LedWidget">LedWidget</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_ui.LedWidget.set_led_color" href="#egse.aeu.aeu_ui.LedWidget.set_led_color">set_led_color</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.LedWidget.set_on_color" href="#egse.aeu.aeu_ui.LedWidget.set_on_color">set_on_color</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.aeu.aeu_ui.MonitoringWorker" href="#egse.aeu.aeu_ui.MonitoringWorker">MonitoringWorker</a></code></h4>
<ul class="">
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.common_led_status_signal" href="#egse.aeu.aeu_ui.MonitoringWorker.common_led_status_signal">common_led_status_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.connect_socket" href="#egse.aeu.aeu_ui.MonitoringWorker.connect_socket">connect_socket</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.f_cam_clk_led_status_signal" href="#egse.aeu.aeu_ui.MonitoringWorker.f_cam_clk_led_status_signal">f_cam_clk_led_status_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.hide_clk_signal" href="#egse.aeu.aeu_ui.MonitoringWorker.hide_clk_signal">hide_clk_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.n_cam_clk_led_status_signal" href="#egse.aeu.aeu_ui.MonitoringWorker.n_cam_clk_led_status_signal">n_cam_clk_led_status_signal</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.run" href="#egse.aeu.aeu_ui.MonitoringWorker.run">run</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.start_process" href="#egse.aeu.aeu_ui.MonitoringWorker.start_process">start_process</a></code></li>
<li><code><a title="egse.aeu.aeu_ui.MonitoringWorker.stop" href="#egse.aeu.aeu_ui.MonitoringWorker.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
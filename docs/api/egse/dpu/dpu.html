<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.dpu.dpu API documentation</title>
<meta name="description" content="This module contains commanding functions that are used by the DPU Controller / Processor …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.dpu.dpu</code></h1>
</header>
<section id="section-intro">
<p>This module contains commanding functions that are used by the DPU Controller / Processor.</p>
<p>The commanding functions (starting with <code>command_</code>) are put on the command_queue by the
DPUController when a user executes a DPU command. The DPU processor picks up the command from the
queue and executes the command in the RMAP commanding window, i.e. when the N-FEE is ready to
accept RMAP commands. All these commands shall start with <code>command_</code>.</p>
<p>There are also priority commands which are treated different by the DPU processor. The DPU
processor executes the priority commands also outside of the RMAP window. Priority commands can
either act only within the context of the DPU processor, i.e. return a register value without
consulting the N-FEE, or special RMAP commands can also be sent to the N-FEE outside the normal
RMAP window. An example of the latter is the <em>Immediate ON</em> mode. These commands shall all start
with <code>prio_command_</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains commanding functions that are used by the DPU Controller / Processor.

The commanding functions (starting with `command_`) are put on the command_queue by the
DPUController when a user executes a DPU command. The DPU processor picks up the command from the
queue and executes the command in the RMAP commanding window, i.e. when the N-FEE is ready to
accept RMAP commands. All these commands shall start with `command_`.

There are also priority commands which are treated different by the DPU processor. The DPU
processor executes the priority commands also outside of the RMAP window. Priority commands can
either act only within the context of the DPU processor, i.e. return a register value without
consulting the N-FEE, or special RMAP commands can also be sent to the N-FEE outside the normal
RMAP window. An example of the latter is the _Immediate ON_ mode. These commands shall all start
with `prio_command_`.

&#34;&#34;&#34;
import logging
from collections import namedtuple
from typing import Optional

from egse.fee import DEFAULT_CCD_READOUT_ORDER
from egse.fee import n_fee_mode
from egse.fee import sensor_sel
from egse.reg import Register
from egse.reg import RegisterMap
from egse.spw import SpaceWireInterface
from egse.system import Timer

MODULE_LOGGER = logging.getLogger(__name__)


class NFEEState:
    &#34;&#34;&#34;
    This class represents the state of the N-FEE FPGA as close as possible in terms of register
    values during the different stages of a readout cycle. The difference between this class and
    the register map is that the register map is updated on RMAP write requests (commands on the
    DPU Processor Queue), while this class is updated on sync pulses from the content of the
    register map. Therefore, the N-FEE Internals represent the actual state, while the register
    map represents the commanded state.

    The following parameters are tracked by this class:

    Every long pulse (400ms):

        * v_start, v_end, h_end, n_final_dump, ccd_mode_config, ccd_readout_order,
          sync_sel, digitise_en, DG_en, int_sync_period
        * sensor_sel, ccd_read_en

    Every short pulse (200ms):

        * sensor_sel, ccd_read_en
    &#34;&#34;&#34;

    FIELDS = (
        &#34;v_start&#34;,
        &#34;v_end&#34;,
        &#34;h_end&#34;,
        &#34;n_final_dump&#34;,
        &#34;ccd_mode_config&#34;,
        &#34;ccd_readout_order&#34;,
        &#34;sync_sel&#34;,
        &#34;digitise_en&#34;,
        &#34;DG_en&#34;,
        &#34;int_sync_period&#34;,
        &#34;sensor_sel&#34;,  # also updated on 200ms pulse
        &#34;ccd_read_en&#34;,  # also updated on 200ms pulse
    )

    StateTuple = namedtuple(&#34;StateTuple&#34;, FIELDS)

    def __init__(self):

        self._internals = {k: 0 for k in NFEEState.FIELDS}

    @property
    def v_start(self):
        return self._internals[&#34;v_start&#34;]

    @property
    def v_end(self):
        return self._internals[&#34;v_end&#34;]

    @property
    def h_end(self):
        return self._internals[&#34;h_end&#34;]

    @property
    def n_final_dump(self):
        return self._internals[&#34;n_final_dump&#34;]

    @property
    def ccd_mode_config(self):
        return self._internals[&#34;ccd_mode_config&#34;]

    @property
    def ccd_readout_order(self):
        return self._internals[&#34;ccd_readout_order&#34;]

    @property
    def sync_sel(self):
        return self._internals[&#34;sync_sel&#34;]

    @property
    def digitise_en(self):
        return self._internals[&#34;digitise_en&#34;]

    @property
    def dg_en(self):
        return self._internals[&#34;DG_en&#34;]

    @property
    def int_sync_period(self):
        return self._internals[&#34;int_sync_period&#34;]

    @property
    def sensor_sel(self):
        return self._internals[&#34;sensor_sel&#34;]

    @property
    def ccd_read_en(self):
        return self._internals[&#34;ccd_read_en&#34;]

    def get_value(self, name: str):
        return self._internals[name]

    def get_parameter_names(self):
        return self._internals.keys()

    def update_at_400ms(self, reg_map: RegisterMap):
        &#34;&#34;&#34;
        Update the state from all the relevant values of the Register Map. In principle, triggered
        by the 400ms pulse, the N-FEE will update it&#39;s internal state from all the values in the
        Register Map. For the purpose of the DPU Processor, we only need a sub-set of these values.
        Since the DPU Processor doesn&#39;t know about pulses, it decides if a 400ms pulse was received
        from the content of the HK packet header. A 400ms pulse was received when the
        frame number is the housekeeping packet is zero, frame_number==0.

        Args:
            reg_map (RegisterMap): the DPU Processor register map

        &#34;&#34;&#34;

        MODULE_LOGGER.debug(&#34;Updating N-FEE State at 400ms..&#34;)

        for par_name in self._internals:
            self._internals[par_name] = reg_map[par_name]

    def update_at_200ms(self, reg_map: RegisterMap):
        &#34;&#34;&#34;
        Update the state from selected values of the Register Map. Only the following parameters
        are updated at a 200ms pulse. We only have 200ms pulses when in external sync mode. The
        update shall be done on frame_number == 1, 2, or 3.

        * sensor_sel: the CCD side &#39;E=0b10&#39; or &#39;F=0b01&#39; or BOTH=0b11. This is a 2-bit number.
        * ccd_read_en: flag to enable/disable CCD readout

        Args:
            reg_map (RegisterMap): the DPU Processor register map

        &#34;&#34;&#34;

        MODULE_LOGGER.debug(&#34;Updating N-FEE State at 200ms..&#34;)

        for par_name in &#34;sensor_sel&#34;, &#34;ccd_read_en&#34;:
            self._internals[par_name] = reg_map[par_name]

    def get_state(self):
        return NFEEState.StateTuple(**self._internals)


def read_register_from_n_fee(
        transport: SpaceWireInterface, register_map: RegisterMap, reg_name: str
) -&gt; bytes:
    &#34;&#34;&#34;
    Reads the data for the given register from the N-FEE memory map.

    This function sends an RMAP read request for the register to the N-FEE.
    The returned data is then compared to the data read from the local copy
    of the register map. If the data is different, the local data is replaced
    with the retrieved data and a warning message is issued. The function
    finally returns the retrieved data as a bytes object of length 4.

    Args:
        transport (SpaceWireInterface): the transport method
        register_map (RegisterMap): a local copy of the register map
        reg_name (str): the name of the register to fetch from the N-FEE

    Returns:
        data: the 32-bit data that was read from the N-FEE.

    &#34;&#34;&#34;

    reg: Register = register_map.get_register(reg_name)
    address = reg.address

    rx_data = transport.read_register(address)
    data = register_map.get_register_data(reg_name)

    if rx_data != data:
        MODULE_LOGGER.warning(
            f&#34;Data received for {reg.name} is different from local copy: {rx_data} != {data}&#34;
        )

        # update the local copy of the registry
        register_map.set_register_data(reg_name, rx_data)

    return rx_data


def write_register_on_n_fee(
        transport: SpaceWireInterface, register_map: RegisterMap, reg_name: str
):
    &#34;&#34;&#34;
    Writes the data from the given register to the N-FEE memory map.

    The function reads the data for the registry from the local register map
    and then sends an RMAP write request for the register to the N-FEE.

    .. note:: it is assumed that the local register map is up-to-date.

    Args:
        transport (SpaceWireInterface): the transport method
        register_map (RegisterMap): a local copy of the register map
        reg_name (str): the name of the register to fetch from the N-FEE

    Raises:
        RMAPError: when data can not be written on the target, i.e. the N-FEE.
    &#34;&#34;&#34;

    reg: Register = register_map.get_register(reg_name)
    address = reg.address

    data = register_map.get_register_data(reg_name)

    # Prepare and send the RMAP write request command
    # This function can generate an RMAPError, but we let it pass so that it
    # can be caught at a higher level.

    _ = transport.write_register(address, data)


def command_noop(*args, **kwargs):
    MODULE_LOGGER.debug(&#34;No commanding during this sync period.&#34;)


def command_get_full_register(transport: SpaceWireInterface, register_map: RegisterMap):
    &#34;&#34;&#34;
    Reads the full register from the N-FEE and initializes the local register map with
    the returned data.

    Args:
        transport (SpaceWireInterface): interface to use for SpaceWire communication
        register_map (RegisterMap): the N-FEE register map
    &#34;&#34;&#34;

    # In principle we should request each register separately, but the N-FEE allows even in
    # critical memory to read the full register at once. I leave the original code here should
    # the behaviour of the N-FEE become more restrictive again.
    #
    # for reg_name in register_map:
    #     read_register_from_n_fee(transport, register_map, reg_name)

    with Timer(&#34;Request full register from N-FEE&#34;):
        data = transport.read_register(0x0000_0000, 0x800, strict=False)
        register_map.set_data(0x0000_0000, data, 0x800)

    return register_map


def command_get_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    MODULE_LOGGER.info(&#34;Request mode from N-FEE.&#34;)

    reg: Register = register_map.get_register(&#34;reg_21_config&#34;)

    read_register_from_n_fee(transport, register_map, reg.name)

    return register_map.get_value(&#34;reg_21_config&#34;, &#34;ccd_mode_config&#34;)


def prio_command_is_dump_mode(n_fee_state: NFEEState.StateTuple) -&gt; bool:
    MODULE_LOGGER.info(&#34;Request N-FEE if in DUMP mode (prio).&#34;)

    # This is a prio command which means it will be executed as soon as possible and return quickly.
    # Mode change in the N-FEE happens only on long (400ms) pulses, therefore prio commands act on
    # the N-FEE State instead of the RegisterMap.

    return (
        not n_fee_state.digitise_en and n_fee_state.DG_en and
        n_fee_state.ccd_mode_config == n_fee_mode.FULL_IMAGE_MODE
    )


def prio_command_get_mode(n_fee_state: NFEEState.StateTuple):
    MODULE_LOGGER.info(&#34;Request mode from N-FEE (prio).&#34;)

    # This is a prio command which means it will be executed as soon as possible and return quickly.
    # Mode change in the N-FEE happens only on long (400ms) pulses, therefore prio commands act on
    # the N-FEE State instead of the RegisterMap.

    return n_fee_state.ccd_mode_config


def command_set_immediate_on_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    # TODO (Rik): this command shall become a prio_command
    #     Check what the N-FEE does and what is returned as a response, especially since in the
    #     mean time other packets can be returned. This method I think will return a
    #     WriteRequestReply, but it is probably asynchronously!
    MODULE_LOGGER.info(&#34;Commanding N-FEE into IMMEDIATE ON mode.&#34;)

    reg: Register = register_map.get_register(&#34;reg_21_config&#34;)

    read_register_from_n_fee(transport, register_map, reg.name)

    register_map.set_value(reg.name, &#34;ccd_mode_config&#34;, n_fee_mode.IMMEDIATE_ON_MODE)

    MODULE_LOGGER.debug(&#34;Sending write request to N-FEE for IMMEDIATE ON mode.&#34;)

    write_register_on_n_fee(transport, register_map, reg.name)

    return n_fee_mode.IMMEDIATE_ON_MODE.value


def command_set_high_precision_hk_mode(transport: SpaceWireInterface, register_map: RegisterMap,
                                       flag: bool):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into HIGH PRECISION HK mode.&#34;)

    reg: Register = register_map.get_register(&#34;reg_5_config&#34;)

    read_register_from_n_fee(transport, register_map, reg.name)

    register_map.set_value(reg.name, &#34;High_precision_HK_en&#34;, flag)

    MODULE_LOGGER.debug(&#34;Sending write request to N-FEE for High Precision HK mode.&#34;)

    write_register_on_n_fee(transport, register_map, reg.name)

    return flag


def command_set_on_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into ON mode.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.ON_MODE)

    return register_map[&#34;ccd_mode_config&#34;]


def command_set_standby_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into StandBy mode.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.STAND_BY_MODE)

    return register_map[&#34;ccd_mode_config&#34;]


def command_set_dump_mode(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order: int = DEFAULT_CCD_READOUT_ORDER, n_final_dump: int = 0, sync_sel: int = 0
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into dump mode.&#34;)

    MODULE_LOGGER.info(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;,
                  n_final_dump=n_final_dump, charge_injection_en=0, img_clk_dir=0, reg_clk_dir=0)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_.value, digitise_en=0b00, DG_en=0b01, sync_sel=sync_sel)
    _set_register(transport, register_map, &#34;reg_21_config&#34;,
                  ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    # Set (back) the default values for VGD as they might have been changed by charge injection

    # _set_register(transport, register_map, &#34;reg_19_config&#34;, ccd_vgd_config=0xE)
    # _set_register(transport, register_map, &#34;reg_20_config&#34;, ccd_vgd_config=0xCF)

    return register_map[&#34;ccd_mode_config&#34;]


def command_set_dump_mode_int_sync(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 10, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order: int = DEFAULT_CCD_READOUT_ORDER, n_final_dump: int = 4509,
        int_sync_period: int = 2500, sync_sel: int = 1
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into internal sync dump mode.&#34;)

    MODULE_LOGGER.info(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}, {n_final_dump=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;,
                  n_final_dump=n_final_dump, charge_injection_en=0, img_clk_dir=0, reg_clk_dir=0)
    _set_register(transport, register_map, &#34;reg_4_config&#34;, int_sync_period=int_sync_period)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_.value, digitise_en=0b00, DG_en=0b01, sync_sel=sync_sel)
    _set_register(transport, register_map, &#34;reg_21_config&#34;,
                  ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return register_map[&#34;ccd_mode_config&#34;]


def _set_register(transport: SpaceWireInterface, register_map: RegisterMap, reg_name: str, **kwarg: int):
    &#34;&#34;&#34;
    Set a register from it&#39;s individual parameters and sends the register to the N-FEE. This
    function first reads the register from the N-FEE and updates the local register if there is a
    mismatch.

    Args:
        transport: the transport layer for SpaceWire communication
        register_map (RegisterMap): a local copy of the register map (maintained by the DPU
            Processor)
        reg_name (str): the name of the register
        kwarg (dict): a dictionary with the parameter names and their values

    Returns:
        None.

    &#34;&#34;&#34;
    reg: Register = register_map.get_register(reg_name)

    read_register_from_n_fee(transport, register_map, reg.name)

    for k, v in kwarg.items():
        register_map.set_value(reg.name, k, v)

    write_register_on_n_fee(transport, register_map, reg.name)
    read_register_from_n_fee(transport, register_map, reg.name)


def command_set_full_image_mode(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER, n_final_dump=0
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into Full Image mode.&#34;)

    MODULE_LOGGER.debug(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;, n_final_dump=n_final_dump)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00, sync_sel=0)
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return n_fee_mode.FULL_IMAGE_MODE.value


def command_set_full_image_mode_int_sync(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER, n_final_dump=0, int_sync_period=6250
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into Full Image mode and internal sync.&#34;)

    MODULE_LOGGER.debug(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}, &#34;
        f&#34;{ccd_readout_order=}, {int_sync_period=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;, n_final_dump=n_final_dump)
    _set_register(transport, register_map, &#34;reg_4_config&#34;, int_sync_period=int_sync_period)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00, sync_sel=1)
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return n_fee_mode.FULL_IMAGE_MODE.value


def command_set_register_value(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        reg_name: str, field_name: str, field_value: int
):
    MODULE_LOGGER.info(f&#34;Commanding N-FEE to set register value {field_name=} to {field_value=}.&#34;)

    _set_register(transport, register_map, reg_name, **{field_name: field_value})

    return True


def command_reset(transport: SpaceWireInterface, register_map: RegisterMap):

    MODULE_LOGGER.info(&#34;Commanding N-FEE to reset to default settings.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=0x07)

    return True


def command_internal_clock(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        int_sync_period: int
):
    MODULE_LOGGER.info(f&#34;Commanding N-FEE the internal clock to {int_sync_period=}ms and select it.&#34;)

    _set_register(transport, register_map, &#34;reg_4_config&#34;, int_sync_period=int_sync_period)
    _set_register(transport, register_map, &#34;reg_5_config&#34;, sync_sel=1)


def command_external_clock(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
):
    MODULE_LOGGER.debug(&#34;Commanding N-FEE to use the external clock.&#34;)

    _set_register(transport, register_map, &#34;reg_5_config&#34;, sync_sel=0)


def command_set_full_image_pattern_mode(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0,
        v_end: int = 4509,
        sensor_sel_=sensor_sel.BOTH_SIDES,
):
    &#34;&#34;&#34;
    Command the N-FEE into Full Image Pattern mode. This mode can only be reached from the ON_MODE,
    but this is not checked by this function (it is an assumption that the caller has checked this).

    .. note:: this function is currently N-FEE specific.

    Args:
        transport: the transport layer for SpaceWire communication
        register_map (RegisterMap): a local copy of the register map
        v_start (int): the start line for the readout
        v_end (int): the last line for the readout
        sensor_sel_ (int): the side of the CCD that needs to be transferred

    Returns:
        None.
    &#34;&#34;&#34;
    MODULE_LOGGER.info(&#34;Commanding N-FEE into Full Image Pattern mode.&#34;)

    MODULE_LOGGER.debug(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    # _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_5_config&#34;, sensor_sel=sensor_sel_)
    _set_register(transport, register_map, &#34;reg_5_config&#34;, digitise_en=0b01)  # send data to DPU
    _set_register(transport, register_map, &#34;reg_5_config&#34;, DG_en=0b00)  # dump gate low
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_PATTERN_MODE)

    return n_fee_mode.FULL_IMAGE_PATTERN_MODE.value


def command_set_clear_error_flags(transport: SpaceWireInterface, register_map: RegisterMap):
    &#34;&#34;&#34;
    Clear all error flags generated by the N-FEE FPGA for non RMAP/SpW related functions immediately.

    The `clear_error_flag` bit in the register map is set to 1, meaning that all error flags that
    are generated by the N-FEE FPGA for non RMAP-SpW related functions are cleared immediately.
    This bit is cleared automatically, so that any future error flags can be latched again.  If
    the error conditions persist and no corrective measures are taken, then  error flags would be
    set again.
    &#34;&#34;&#34;
    MODULE_LOGGER.debug(&#34;Commanding N-FEE to clear error flag.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, clear_error_flag=1)

    return register_map[&#34;clear_error_flag&#34;]


def command_set_reverse_clocking(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0,
        v_end: int = 4509,
        sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER,
        n_final_dump=0,
        img_clk_dir=0,
        reg_clk_dir=0,
):
    &#34;&#34;&#34;
    Command the N-FEE into full image reverse clocking mode.
    &#34;&#34;&#34;
    MODULE_LOGGER.info(&#34;Commanding N-FEE to reverse clocking.&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;,
                  n_final_dump=n_final_dump, img_clk_dir=img_clk_dir, reg_clk_dir=reg_clk_dir)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00, sync_sel=0)
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return True


def command_set_charge_injection(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0,
        v_end: int = 4509,
        n_final_dump=0,
        sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER,
        charge_injection_width=0,
        charge_injection_gap=0,
):
    &#34;&#34;&#34;
    TBW
    &#34;&#34;&#34;
    MODULE_LOGGER.info(&#34;Commanding N-FEE to configure charge injection.&#34;)

    _set_register(
        transport, register_map, &#34;reg_0_config&#34;,
        v_start=v_start, v_end=v_end)
    _set_register(
        transport, register_map, &#34;reg_1_config&#34;,
        charge_injection_width=charge_injection_width,
        charge_injection_gap=charge_injection_gap)
    _set_register(
        transport, register_map, &#34;reg_2_config&#34;,
        ccd_readout_order=ccd_readout_order)
    _set_register(
        transport, register_map, &#34;reg_3_config&#34;,
        n_final_dump=n_final_dump, charge_injection_en=1)
    _set_register(
        transport, register_map, &#34;reg_5_config&#34;,
        sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00)
    _set_register(
        transport, register_map, &#34;reg_21_config&#34;,
        ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return True


def command_set_vgd(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        ccd_vgd_config: Optional[float] = None,
):
    &#34;&#34;&#34;
    Set the ccd_vgd_config register value.

    Note that the N-FEE shall be in ON mode for this to take effect!
    &#34;&#34;&#34;

    MODULE_LOGGER.info(f&#34;{ccd_vgd_config=}&#34;)

    if ccd_vgd_config is not None:

        # HARDCODED STUFF HERE
        # FIXME: these numbers should go into the Setup camera.fee section
        #     5.983 -&gt; what is that value? where does it come from? see email Dave Walton
        # Explanation by Dave Walton in MSSL provided test script:
        #     V_GD control is 5.983V per bit (12bit DAC). So 17V=2842d, =0xB1A.
        #     DAC LS Nibble (0xA in this case) is programmed into MSNibble of reg_4C.
        #     DAC MSByte (0xB1 in this case) is programmed into LSByte of reg_50.

        converted_vgd = int(ccd_vgd_config/5.983*1000)

        value_reg_19 = converted_vgd &amp; 0b1111
        value_reg_20 = (converted_vgd &gt;&gt; 4) &amp; 0b11111111

        _set_register(transport, register_map, &#34;reg_19_config&#34;, ccd_vgd_config=value_reg_19)
        _set_register(transport, register_map, &#34;reg_20_config&#34;, ccd_vgd_config=value_reg_20)

        return True

    return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.dpu.dpu.command_external_clock"><code class="name flex">
<span>def <span class="ident">command_external_clock</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_external_clock(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
):
    MODULE_LOGGER.debug(&#34;Commanding N-FEE to use the external clock.&#34;)

    _set_register(transport, register_map, &#34;reg_5_config&#34;, sync_sel=0)</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_get_full_register"><code class="name flex">
<span>def <span class="ident">command_get_full_register</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the full register from the N-FEE and initializes the local register map with
the returned data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong> :&ensp;<code>SpaceWireInterface</code></dt>
<dd>interface to use for SpaceWire communication</dd>
<dt><strong><code>register_map</code></strong> :&ensp;<code>RegisterMap</code></dt>
<dd>the N-FEE register map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_get_full_register(transport: SpaceWireInterface, register_map: RegisterMap):
    &#34;&#34;&#34;
    Reads the full register from the N-FEE and initializes the local register map with
    the returned data.

    Args:
        transport (SpaceWireInterface): interface to use for SpaceWire communication
        register_map (RegisterMap): the N-FEE register map
    &#34;&#34;&#34;

    # In principle we should request each register separately, but the N-FEE allows even in
    # critical memory to read the full register at once. I leave the original code here should
    # the behaviour of the N-FEE become more restrictive again.
    #
    # for reg_name in register_map:
    #     read_register_from_n_fee(transport, register_map, reg_name)

    with Timer(&#34;Request full register from N-FEE&#34;):
        data = transport.read_register(0x0000_0000, 0x800, strict=False)
        register_map.set_data(0x0000_0000, data, 0x800)

    return register_map</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_get_mode"><code class="name flex">
<span>def <span class="ident">command_get_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_get_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    MODULE_LOGGER.info(&#34;Request mode from N-FEE.&#34;)

    reg: Register = register_map.get_register(&#34;reg_21_config&#34;)

    read_register_from_n_fee(transport, register_map, reg.name)

    return register_map.get_value(&#34;reg_21_config&#34;, &#34;ccd_mode_config&#34;)</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_internal_clock"><code class="name flex">
<span>def <span class="ident">command_internal_clock</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, int_sync_period: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_internal_clock(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        int_sync_period: int
):
    MODULE_LOGGER.info(f&#34;Commanding N-FEE the internal clock to {int_sync_period=}ms and select it.&#34;)

    _set_register(transport, register_map, &#34;reg_4_config&#34;, int_sync_period=int_sync_period)
    _set_register(transport, register_map, &#34;reg_5_config&#34;, sync_sel=1)</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_noop"><code class="name flex">
<span>def <span class="ident">command_noop</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_noop(*args, **kwargs):
    MODULE_LOGGER.debug(&#34;No commanding during this sync period.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_reset"><code class="name flex">
<span>def <span class="ident">command_reset</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_reset(transport: SpaceWireInterface, register_map: RegisterMap):

    MODULE_LOGGER.info(&#34;Commanding N-FEE to reset to default settings.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=0x07)

    return True</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_charge_injection"><code class="name flex">
<span>def <span class="ident">command_set_charge_injection</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 4509, n_final_dump=0, sensor_sel_=sensor_sel.BOTH_SIDES, ccd_readout_order=78, charge_injection_width=0, charge_injection_gap=0)</span>
</code></dt>
<dd>
<div class="desc"><p>TBW</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_charge_injection(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0,
        v_end: int = 4509,
        n_final_dump=0,
        sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER,
        charge_injection_width=0,
        charge_injection_gap=0,
):
    &#34;&#34;&#34;
    TBW
    &#34;&#34;&#34;
    MODULE_LOGGER.info(&#34;Commanding N-FEE to configure charge injection.&#34;)

    _set_register(
        transport, register_map, &#34;reg_0_config&#34;,
        v_start=v_start, v_end=v_end)
    _set_register(
        transport, register_map, &#34;reg_1_config&#34;,
        charge_injection_width=charge_injection_width,
        charge_injection_gap=charge_injection_gap)
    _set_register(
        transport, register_map, &#34;reg_2_config&#34;,
        ccd_readout_order=ccd_readout_order)
    _set_register(
        transport, register_map, &#34;reg_3_config&#34;,
        n_final_dump=n_final_dump, charge_injection_en=1)
    _set_register(
        transport, register_map, &#34;reg_5_config&#34;,
        sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00)
    _set_register(
        transport, register_map, &#34;reg_21_config&#34;,
        ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return True</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_clear_error_flags"><code class="name flex">
<span>def <span class="ident">command_set_clear_error_flags</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all error flags generated by the N-FEE FPGA for non RMAP/SpW related functions immediately.</p>
<p>The <code>clear_error_flag</code> bit in the register map is set to 1, meaning that all error flags that
are generated by the N-FEE FPGA for non RMAP-SpW related functions are cleared immediately.
This bit is cleared automatically, so that any future error flags can be latched again.
If
the error conditions persist and no corrective measures are taken, then
error flags would be
set again.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_clear_error_flags(transport: SpaceWireInterface, register_map: RegisterMap):
    &#34;&#34;&#34;
    Clear all error flags generated by the N-FEE FPGA for non RMAP/SpW related functions immediately.

    The `clear_error_flag` bit in the register map is set to 1, meaning that all error flags that
    are generated by the N-FEE FPGA for non RMAP-SpW related functions are cleared immediately.
    This bit is cleared automatically, so that any future error flags can be latched again.  If
    the error conditions persist and no corrective measures are taken, then  error flags would be
    set again.
    &#34;&#34;&#34;
    MODULE_LOGGER.debug(&#34;Commanding N-FEE to clear error flag.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, clear_error_flag=1)

    return register_map[&#34;clear_error_flag&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_dump_mode"><code class="name flex">
<span>def <span class="ident">command_set_dump_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES, ccd_readout_order: int = 78, n_final_dump: int = 0, sync_sel: int = 0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_dump_mode(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order: int = DEFAULT_CCD_READOUT_ORDER, n_final_dump: int = 0, sync_sel: int = 0
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into dump mode.&#34;)

    MODULE_LOGGER.info(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;,
                  n_final_dump=n_final_dump, charge_injection_en=0, img_clk_dir=0, reg_clk_dir=0)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_.value, digitise_en=0b00, DG_en=0b01, sync_sel=sync_sel)
    _set_register(transport, register_map, &#34;reg_21_config&#34;,
                  ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    # Set (back) the default values for VGD as they might have been changed by charge injection

    # _set_register(transport, register_map, &#34;reg_19_config&#34;, ccd_vgd_config=0xE)
    # _set_register(transport, register_map, &#34;reg_20_config&#34;, ccd_vgd_config=0xCF)

    return register_map[&#34;ccd_mode_config&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_dump_mode_int_sync"><code class="name flex">
<span>def <span class="ident">command_set_dump_mode_int_sync</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 10, sensor_sel_=sensor_sel.BOTH_SIDES, ccd_readout_order: int = 78, n_final_dump: int = 4509, int_sync_period: int = 2500, sync_sel: int = 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_dump_mode_int_sync(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 10, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order: int = DEFAULT_CCD_READOUT_ORDER, n_final_dump: int = 4509,
        int_sync_period: int = 2500, sync_sel: int = 1
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into internal sync dump mode.&#34;)

    MODULE_LOGGER.info(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}, {n_final_dump=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;,
                  n_final_dump=n_final_dump, charge_injection_en=0, img_clk_dir=0, reg_clk_dir=0)
    _set_register(transport, register_map, &#34;reg_4_config&#34;, int_sync_period=int_sync_period)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_.value, digitise_en=0b00, DG_en=0b01, sync_sel=sync_sel)
    _set_register(transport, register_map, &#34;reg_21_config&#34;,
                  ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return register_map[&#34;ccd_mode_config&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_full_image_mode"><code class="name flex">
<span>def <span class="ident">command_set_full_image_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES, ccd_readout_order=78, n_final_dump=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_full_image_mode(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER, n_final_dump=0
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into Full Image mode.&#34;)

    MODULE_LOGGER.debug(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;, n_final_dump=n_final_dump)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00, sync_sel=0)
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return n_fee_mode.FULL_IMAGE_MODE.value</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_full_image_mode_int_sync"><code class="name flex">
<span>def <span class="ident">command_set_full_image_mode_int_sync</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES, ccd_readout_order=78, n_final_dump=0, int_sync_period=6250)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_full_image_mode_int_sync(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER, n_final_dump=0, int_sync_period=6250
):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into Full Image mode and internal sync.&#34;)

    MODULE_LOGGER.debug(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}, &#34;
        f&#34;{ccd_readout_order=}, {int_sync_period=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;, n_final_dump=n_final_dump)
    _set_register(transport, register_map, &#34;reg_4_config&#34;, int_sync_period=int_sync_period)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00, sync_sel=1)
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return n_fee_mode.FULL_IMAGE_MODE.value</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_full_image_pattern_mode"><code class="name flex">
<span>def <span class="ident">command_set_full_image_pattern_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES)</span>
</code></dt>
<dd>
<div class="desc"><p>Command the N-FEE into Full Image Pattern mode. This mode can only be reached from the ON_MODE,
but this is not checked by this function (it is an assumption that the caller has checked this).</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;this function is currently N-FEE specific.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>the transport layer for SpaceWire communication</dd>
<dt><strong><code>register_map</code></strong> :&ensp;<code>RegisterMap</code></dt>
<dd>a local copy of the register map</dd>
<dt><strong><code>v_start</code></strong> :&ensp;<code>int</code></dt>
<dd>the start line for the readout</dd>
<dt><strong><code>v_end</code></strong> :&ensp;<code>int</code></dt>
<dd>the last line for the readout</dd>
<dt><strong><code>sensor_sel_</code></strong> :&ensp;<code>int</code></dt>
<dd>the side of the CCD that needs to be transferred</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_full_image_pattern_mode(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0,
        v_end: int = 4509,
        sensor_sel_=sensor_sel.BOTH_SIDES,
):
    &#34;&#34;&#34;
    Command the N-FEE into Full Image Pattern mode. This mode can only be reached from the ON_MODE,
    but this is not checked by this function (it is an assumption that the caller has checked this).

    .. note:: this function is currently N-FEE specific.

    Args:
        transport: the transport layer for SpaceWire communication
        register_map (RegisterMap): a local copy of the register map
        v_start (int): the start line for the readout
        v_end (int): the last line for the readout
        sensor_sel_ (int): the side of the CCD that needs to be transferred

    Returns:
        None.
    &#34;&#34;&#34;
    MODULE_LOGGER.info(&#34;Commanding N-FEE into Full Image Pattern mode.&#34;)

    MODULE_LOGGER.debug(
        f&#34;Setting {v_start=} and {v_end=}, {v_end - v_start + 1} lines, {sensor_sel_=}&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    # _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_5_config&#34;, sensor_sel=sensor_sel_)
    _set_register(transport, register_map, &#34;reg_5_config&#34;, digitise_en=0b01)  # send data to DPU
    _set_register(transport, register_map, &#34;reg_5_config&#34;, DG_en=0b00)  # dump gate low
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_PATTERN_MODE)

    return n_fee_mode.FULL_IMAGE_PATTERN_MODE.value</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_high_precision_hk_mode"><code class="name flex">
<span>def <span class="ident">command_set_high_precision_hk_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, flag: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_high_precision_hk_mode(transport: SpaceWireInterface, register_map: RegisterMap,
                                       flag: bool):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into HIGH PRECISION HK mode.&#34;)

    reg: Register = register_map.get_register(&#34;reg_5_config&#34;)

    read_register_from_n_fee(transport, register_map, reg.name)

    register_map.set_value(reg.name, &#34;High_precision_HK_en&#34;, flag)

    MODULE_LOGGER.debug(&#34;Sending write request to N-FEE for High Precision HK mode.&#34;)

    write_register_on_n_fee(transport, register_map, reg.name)

    return flag</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_immediate_on_mode"><code class="name flex">
<span>def <span class="ident">command_set_immediate_on_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_immediate_on_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    # TODO (Rik): this command shall become a prio_command
    #     Check what the N-FEE does and what is returned as a response, especially since in the
    #     mean time other packets can be returned. This method I think will return a
    #     WriteRequestReply, but it is probably asynchronously!
    MODULE_LOGGER.info(&#34;Commanding N-FEE into IMMEDIATE ON mode.&#34;)

    reg: Register = register_map.get_register(&#34;reg_21_config&#34;)

    read_register_from_n_fee(transport, register_map, reg.name)

    register_map.set_value(reg.name, &#34;ccd_mode_config&#34;, n_fee_mode.IMMEDIATE_ON_MODE)

    MODULE_LOGGER.debug(&#34;Sending write request to N-FEE for IMMEDIATE ON mode.&#34;)

    write_register_on_n_fee(transport, register_map, reg.name)

    return n_fee_mode.IMMEDIATE_ON_MODE.value</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_on_mode"><code class="name flex">
<span>def <span class="ident">command_set_on_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_on_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into ON mode.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.ON_MODE)

    return register_map[&#34;ccd_mode_config&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_register_value"><code class="name flex">
<span>def <span class="ident">command_set_register_value</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, reg_name: str, field_name: str, field_value: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_register_value(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        reg_name: str, field_name: str, field_value: int
):
    MODULE_LOGGER.info(f&#34;Commanding N-FEE to set register value {field_name=} to {field_value=}.&#34;)

    _set_register(transport, register_map, reg_name, **{field_name: field_value})

    return True</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_reverse_clocking"><code class="name flex">
<span>def <span class="ident">command_set_reverse_clocking</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, v_start: int = 0, v_end: int = 4509, sensor_sel_=sensor_sel.BOTH_SIDES, ccd_readout_order=78, n_final_dump=0, img_clk_dir=0, reg_clk_dir=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Command the N-FEE into full image reverse clocking mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_reverse_clocking(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        v_start: int = 0,
        v_end: int = 4509,
        sensor_sel_=sensor_sel.BOTH_SIDES,
        ccd_readout_order=DEFAULT_CCD_READOUT_ORDER,
        n_final_dump=0,
        img_clk_dir=0,
        reg_clk_dir=0,
):
    &#34;&#34;&#34;
    Command the N-FEE into full image reverse clocking mode.
    &#34;&#34;&#34;
    MODULE_LOGGER.info(&#34;Commanding N-FEE to reverse clocking.&#34;)

    _set_register(transport, register_map, &#34;reg_0_config&#34;, v_start=v_start, v_end=v_end)
    _set_register(transport, register_map, &#34;reg_2_config&#34;, ccd_readout_order=ccd_readout_order)
    _set_register(transport, register_map, &#34;reg_3_config&#34;,
                  n_final_dump=n_final_dump, img_clk_dir=img_clk_dir, reg_clk_dir=reg_clk_dir)
    _set_register(transport, register_map, &#34;reg_5_config&#34;,
                  sensor_sel=sensor_sel_, digitise_en=0b01, DG_en=0b00, sync_sel=0)
    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.FULL_IMAGE_MODE)

    return True</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_standby_mode"><code class="name flex">
<span>def <span class="ident">command_set_standby_mode</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_standby_mode(transport: SpaceWireInterface, register_map: RegisterMap):
    MODULE_LOGGER.info(&#34;Commanding N-FEE into StandBy mode.&#34;)

    _set_register(transport, register_map, &#34;reg_21_config&#34;, ccd_mode_config=n_fee_mode.STAND_BY_MODE)

    return register_map[&#34;ccd_mode_config&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.command_set_vgd"><code class="name flex">
<span>def <span class="ident">command_set_vgd</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, ccd_vgd_config: Optional[float] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the ccd_vgd_config register value.</p>
<p>Note that the N-FEE shall be in ON mode for this to take effect!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_set_vgd(
        transport: SpaceWireInterface,
        register_map: RegisterMap,
        ccd_vgd_config: Optional[float] = None,
):
    &#34;&#34;&#34;
    Set the ccd_vgd_config register value.

    Note that the N-FEE shall be in ON mode for this to take effect!
    &#34;&#34;&#34;

    MODULE_LOGGER.info(f&#34;{ccd_vgd_config=}&#34;)

    if ccd_vgd_config is not None:

        # HARDCODED STUFF HERE
        # FIXME: these numbers should go into the Setup camera.fee section
        #     5.983 -&gt; what is that value? where does it come from? see email Dave Walton
        # Explanation by Dave Walton in MSSL provided test script:
        #     V_GD control is 5.983V per bit (12bit DAC). So 17V=2842d, =0xB1A.
        #     DAC LS Nibble (0xA in this case) is programmed into MSNibble of reg_4C.
        #     DAC MSByte (0xB1 in this case) is programmed into LSByte of reg_50.

        converted_vgd = int(ccd_vgd_config/5.983*1000)

        value_reg_19 = converted_vgd &amp; 0b1111
        value_reg_20 = (converted_vgd &gt;&gt; 4) &amp; 0b11111111

        _set_register(transport, register_map, &#34;reg_19_config&#34;, ccd_vgd_config=value_reg_19)
        _set_register(transport, register_map, &#34;reg_20_config&#34;, ccd_vgd_config=value_reg_20)

        return True

    return False</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.prio_command_get_mode"><code class="name flex">
<span>def <span class="ident">prio_command_get_mode</span></span>(<span>n_fee_state: egse.dpu.dpu.StateTuple)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prio_command_get_mode(n_fee_state: NFEEState.StateTuple):
    MODULE_LOGGER.info(&#34;Request mode from N-FEE (prio).&#34;)

    # This is a prio command which means it will be executed as soon as possible and return quickly.
    # Mode change in the N-FEE happens only on long (400ms) pulses, therefore prio commands act on
    # the N-FEE State instead of the RegisterMap.

    return n_fee_state.ccd_mode_config</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.prio_command_is_dump_mode"><code class="name flex">
<span>def <span class="ident">prio_command_is_dump_mode</span></span>(<span>n_fee_state: egse.dpu.dpu.StateTuple) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prio_command_is_dump_mode(n_fee_state: NFEEState.StateTuple) -&gt; bool:
    MODULE_LOGGER.info(&#34;Request N-FEE if in DUMP mode (prio).&#34;)

    # This is a prio command which means it will be executed as soon as possible and return quickly.
    # Mode change in the N-FEE happens only on long (400ms) pulses, therefore prio commands act on
    # the N-FEE State instead of the RegisterMap.

    return (
        not n_fee_state.digitise_en and n_fee_state.DG_en and
        n_fee_state.ccd_mode_config == n_fee_mode.FULL_IMAGE_MODE
    )</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.read_register_from_n_fee"><code class="name flex">
<span>def <span class="ident">read_register_from_n_fee</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, reg_name: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the data for the given register from the N-FEE memory map.</p>
<p>This function sends an RMAP read request for the register to the N-FEE.
The returned data is then compared to the data read from the local copy
of the register map. If the data is different, the local data is replaced
with the retrieved data and a warning message is issued. The function
finally returns the retrieved data as a bytes object of length 4.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong> :&ensp;<code>SpaceWireInterface</code></dt>
<dd>the transport method</dd>
<dt><strong><code>register_map</code></strong> :&ensp;<code>RegisterMap</code></dt>
<dd>a local copy of the register map</dd>
<dt><strong><code>reg_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the register to fetch from the N-FEE</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>the 32-bit data that was read from the N-FEE.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_register_from_n_fee(
        transport: SpaceWireInterface, register_map: RegisterMap, reg_name: str
) -&gt; bytes:
    &#34;&#34;&#34;
    Reads the data for the given register from the N-FEE memory map.

    This function sends an RMAP read request for the register to the N-FEE.
    The returned data is then compared to the data read from the local copy
    of the register map. If the data is different, the local data is replaced
    with the retrieved data and a warning message is issued. The function
    finally returns the retrieved data as a bytes object of length 4.

    Args:
        transport (SpaceWireInterface): the transport method
        register_map (RegisterMap): a local copy of the register map
        reg_name (str): the name of the register to fetch from the N-FEE

    Returns:
        data: the 32-bit data that was read from the N-FEE.

    &#34;&#34;&#34;

    reg: Register = register_map.get_register(reg_name)
    address = reg.address

    rx_data = transport.read_register(address)
    data = register_map.get_register_data(reg_name)

    if rx_data != data:
        MODULE_LOGGER.warning(
            f&#34;Data received for {reg.name} is different from local copy: {rx_data} != {data}&#34;
        )

        # update the local copy of the registry
        register_map.set_register_data(reg_name, rx_data)

    return rx_data</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.write_register_on_n_fee"><code class="name flex">
<span>def <span class="ident">write_register_on_n_fee</span></span>(<span>transport: <a title="egse.spw.SpaceWireInterface" href="../spw.html#egse.spw.SpaceWireInterface">SpaceWireInterface</a>, register_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>, reg_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the data from the given register to the N-FEE memory map.</p>
<p>The function reads the data for the registry from the local register map
and then sends an RMAP write request for the register to the N-FEE.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;it is assumed that the local register map is up-to-date.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong> :&ensp;<code>SpaceWireInterface</code></dt>
<dd>the transport method</dd>
<dt><strong><code>register_map</code></strong> :&ensp;<code>RegisterMap</code></dt>
<dd>a local copy of the register map</dd>
<dt><strong><code>reg_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the register to fetch from the N-FEE</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RMAPError</code></dt>
<dd>when data can not be written on the target, i.e. the N-FEE.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_register_on_n_fee(
        transport: SpaceWireInterface, register_map: RegisterMap, reg_name: str
):
    &#34;&#34;&#34;
    Writes the data from the given register to the N-FEE memory map.

    The function reads the data for the registry from the local register map
    and then sends an RMAP write request for the register to the N-FEE.

    .. note:: it is assumed that the local register map is up-to-date.

    Args:
        transport (SpaceWireInterface): the transport method
        register_map (RegisterMap): a local copy of the register map
        reg_name (str): the name of the register to fetch from the N-FEE

    Raises:
        RMAPError: when data can not be written on the target, i.e. the N-FEE.
    &#34;&#34;&#34;

    reg: Register = register_map.get_register(reg_name)
    address = reg.address

    data = register_map.get_register_data(reg_name)

    # Prepare and send the RMAP write request command
    # This function can generate an RMAPError, but we let it pass so that it
    # can be caught at a higher level.

    _ = transport.write_register(address, data)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.dpu.dpu.NFEEState"><code class="flex name class">
<span>class <span class="ident">NFEEState</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the state of the N-FEE FPGA as close as possible in terms of register
values during the different stages of a readout cycle. The difference between this class and
the register map is that the register map is updated on RMAP write requests (commands on the
DPU Processor Queue), while this class is updated on sync pulses from the content of the
register map. Therefore, the N-FEE Internals represent the actual state, while the register
map represents the commanded state.</p>
<p>The following parameters are tracked by this class:</p>
<p>Every long pulse (400ms):</p>
<pre><code>* v_start, v_end, h_end, n_final_dump, ccd_mode_config, ccd_readout_order,
  sync_sel, digitise_en, DG_en, int_sync_period
* sensor_sel, ccd_read_en
</code></pre>
<p>Every short pulse (200ms):</p>
<pre><code>* sensor_sel, ccd_read_en
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NFEEState:
    &#34;&#34;&#34;
    This class represents the state of the N-FEE FPGA as close as possible in terms of register
    values during the different stages of a readout cycle. The difference between this class and
    the register map is that the register map is updated on RMAP write requests (commands on the
    DPU Processor Queue), while this class is updated on sync pulses from the content of the
    register map. Therefore, the N-FEE Internals represent the actual state, while the register
    map represents the commanded state.

    The following parameters are tracked by this class:

    Every long pulse (400ms):

        * v_start, v_end, h_end, n_final_dump, ccd_mode_config, ccd_readout_order,
          sync_sel, digitise_en, DG_en, int_sync_period
        * sensor_sel, ccd_read_en

    Every short pulse (200ms):

        * sensor_sel, ccd_read_en
    &#34;&#34;&#34;

    FIELDS = (
        &#34;v_start&#34;,
        &#34;v_end&#34;,
        &#34;h_end&#34;,
        &#34;n_final_dump&#34;,
        &#34;ccd_mode_config&#34;,
        &#34;ccd_readout_order&#34;,
        &#34;sync_sel&#34;,
        &#34;digitise_en&#34;,
        &#34;DG_en&#34;,
        &#34;int_sync_period&#34;,
        &#34;sensor_sel&#34;,  # also updated on 200ms pulse
        &#34;ccd_read_en&#34;,  # also updated on 200ms pulse
    )

    StateTuple = namedtuple(&#34;StateTuple&#34;, FIELDS)

    def __init__(self):

        self._internals = {k: 0 for k in NFEEState.FIELDS}

    @property
    def v_start(self):
        return self._internals[&#34;v_start&#34;]

    @property
    def v_end(self):
        return self._internals[&#34;v_end&#34;]

    @property
    def h_end(self):
        return self._internals[&#34;h_end&#34;]

    @property
    def n_final_dump(self):
        return self._internals[&#34;n_final_dump&#34;]

    @property
    def ccd_mode_config(self):
        return self._internals[&#34;ccd_mode_config&#34;]

    @property
    def ccd_readout_order(self):
        return self._internals[&#34;ccd_readout_order&#34;]

    @property
    def sync_sel(self):
        return self._internals[&#34;sync_sel&#34;]

    @property
    def digitise_en(self):
        return self._internals[&#34;digitise_en&#34;]

    @property
    def dg_en(self):
        return self._internals[&#34;DG_en&#34;]

    @property
    def int_sync_period(self):
        return self._internals[&#34;int_sync_period&#34;]

    @property
    def sensor_sel(self):
        return self._internals[&#34;sensor_sel&#34;]

    @property
    def ccd_read_en(self):
        return self._internals[&#34;ccd_read_en&#34;]

    def get_value(self, name: str):
        return self._internals[name]

    def get_parameter_names(self):
        return self._internals.keys()

    def update_at_400ms(self, reg_map: RegisterMap):
        &#34;&#34;&#34;
        Update the state from all the relevant values of the Register Map. In principle, triggered
        by the 400ms pulse, the N-FEE will update it&#39;s internal state from all the values in the
        Register Map. For the purpose of the DPU Processor, we only need a sub-set of these values.
        Since the DPU Processor doesn&#39;t know about pulses, it decides if a 400ms pulse was received
        from the content of the HK packet header. A 400ms pulse was received when the
        frame number is the housekeeping packet is zero, frame_number==0.

        Args:
            reg_map (RegisterMap): the DPU Processor register map

        &#34;&#34;&#34;

        MODULE_LOGGER.debug(&#34;Updating N-FEE State at 400ms..&#34;)

        for par_name in self._internals:
            self._internals[par_name] = reg_map[par_name]

    def update_at_200ms(self, reg_map: RegisterMap):
        &#34;&#34;&#34;
        Update the state from selected values of the Register Map. Only the following parameters
        are updated at a 200ms pulse. We only have 200ms pulses when in external sync mode. The
        update shall be done on frame_number == 1, 2, or 3.

        * sensor_sel: the CCD side &#39;E=0b10&#39; or &#39;F=0b01&#39; or BOTH=0b11. This is a 2-bit number.
        * ccd_read_en: flag to enable/disable CCD readout

        Args:
            reg_map (RegisterMap): the DPU Processor register map

        &#34;&#34;&#34;

        MODULE_LOGGER.debug(&#34;Updating N-FEE State at 200ms..&#34;)

        for par_name in &#34;sensor_sel&#34;, &#34;ccd_read_en&#34;:
            self._internals[par_name] = reg_map[par_name]

    def get_state(self):
        return NFEEState.StateTuple(**self._internals)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="egse.dpu.dpu.NFEEState.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.dpu.dpu.NFEEState.StateTuple"><code class="name">var <span class="ident">StateTuple</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="egse.dpu.dpu.NFEEState.ccd_mode_config"><code class="name">var <span class="ident">ccd_mode_config</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ccd_mode_config(self):
    return self._internals[&#34;ccd_mode_config&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.ccd_read_en"><code class="name">var <span class="ident">ccd_read_en</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ccd_read_en(self):
    return self._internals[&#34;ccd_read_en&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.ccd_readout_order"><code class="name">var <span class="ident">ccd_readout_order</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ccd_readout_order(self):
    return self._internals[&#34;ccd_readout_order&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.dg_en"><code class="name">var <span class="ident">dg_en</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dg_en(self):
    return self._internals[&#34;DG_en&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.digitise_en"><code class="name">var <span class="ident">digitise_en</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def digitise_en(self):
    return self._internals[&#34;digitise_en&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.h_end"><code class="name">var <span class="ident">h_end</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def h_end(self):
    return self._internals[&#34;h_end&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.int_sync_period"><code class="name">var <span class="ident">int_sync_period</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def int_sync_period(self):
    return self._internals[&#34;int_sync_period&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.n_final_dump"><code class="name">var <span class="ident">n_final_dump</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_final_dump(self):
    return self._internals[&#34;n_final_dump&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.sensor_sel"><code class="name">var <span class="ident">sensor_sel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_sel(self):
    return self._internals[&#34;sensor_sel&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.sync_sel"><code class="name">var <span class="ident">sync_sel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sync_sel(self):
    return self._internals[&#34;sync_sel&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.v_end"><code class="name">var <span class="ident">v_end</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_end(self):
    return self._internals[&#34;v_end&#34;]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.v_start"><code class="name">var <span class="ident">v_start</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v_start(self):
    return self._internals[&#34;v_start&#34;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.dpu.dpu.NFEEState.get_parameter_names"><code class="name flex">
<span>def <span class="ident">get_parameter_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameter_names(self):
    return self._internals.keys()</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self):
    return NFEEState.StateTuple(**self._internals)</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, name: str):
    return self._internals[name]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.update_at_200ms"><code class="name flex">
<span>def <span class="ident">update_at_200ms</span></span>(<span>self, reg_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the state from selected values of the Register Map. Only the following parameters
are updated at a 200ms pulse. We only have 200ms pulses when in external sync mode. The
update shall be done on frame_number == 1, 2, or 3.</p>
<ul>
<li>sensor_sel: the CCD side 'E=0b10' or 'F=0b01' or BOTH=0b11. This is a 2-bit number.</li>
<li>ccd_read_en: flag to enable/disable CCD readout</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reg_map</code></strong> :&ensp;<code>RegisterMap</code></dt>
<dd>the DPU Processor register map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_at_200ms(self, reg_map: RegisterMap):
    &#34;&#34;&#34;
    Update the state from selected values of the Register Map. Only the following parameters
    are updated at a 200ms pulse. We only have 200ms pulses when in external sync mode. The
    update shall be done on frame_number == 1, 2, or 3.

    * sensor_sel: the CCD side &#39;E=0b10&#39; or &#39;F=0b01&#39; or BOTH=0b11. This is a 2-bit number.
    * ccd_read_en: flag to enable/disable CCD readout

    Args:
        reg_map (RegisterMap): the DPU Processor register map

    &#34;&#34;&#34;

    MODULE_LOGGER.debug(&#34;Updating N-FEE State at 200ms..&#34;)

    for par_name in &#34;sensor_sel&#34;, &#34;ccd_read_en&#34;:
        self._internals[par_name] = reg_map[par_name]</code></pre>
</details>
</dd>
<dt id="egse.dpu.dpu.NFEEState.update_at_400ms"><code class="name flex">
<span>def <span class="ident">update_at_400ms</span></span>(<span>self, reg_map: <a title="egse.reg.RegisterMap" href="../reg.html#egse.reg.RegisterMap">RegisterMap</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the state from all the relevant values of the Register Map. In principle, triggered
by the 400ms pulse, the N-FEE will update it's internal state from all the values in the
Register Map. For the purpose of the DPU Processor, we only need a sub-set of these values.
Since the DPU Processor doesn't know about pulses, it decides if a 400ms pulse was received
from the content of the HK packet header. A 400ms pulse was received when the
frame number is the housekeeping packet is zero, frame_number==0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reg_map</code></strong> :&ensp;<code>RegisterMap</code></dt>
<dd>the DPU Processor register map</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_at_400ms(self, reg_map: RegisterMap):
    &#34;&#34;&#34;
    Update the state from all the relevant values of the Register Map. In principle, triggered
    by the 400ms pulse, the N-FEE will update it&#39;s internal state from all the values in the
    Register Map. For the purpose of the DPU Processor, we only need a sub-set of these values.
    Since the DPU Processor doesn&#39;t know about pulses, it decides if a 400ms pulse was received
    from the content of the HK packet header. A 400ms pulse was received when the
    frame number is the housekeeping packet is zero, frame_number==0.

    Args:
        reg_map (RegisterMap): the DPU Processor register map

    &#34;&#34;&#34;

    MODULE_LOGGER.debug(&#34;Updating N-FEE State at 400ms..&#34;)

    for par_name in self._internals:
        self._internals[par_name] = reg_map[par_name]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.dpu" href="index.html">egse.dpu</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.dpu.dpu.command_external_clock" href="#egse.dpu.dpu.command_external_clock">command_external_clock</a></code></li>
<li><code><a title="egse.dpu.dpu.command_get_full_register" href="#egse.dpu.dpu.command_get_full_register">command_get_full_register</a></code></li>
<li><code><a title="egse.dpu.dpu.command_get_mode" href="#egse.dpu.dpu.command_get_mode">command_get_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_internal_clock" href="#egse.dpu.dpu.command_internal_clock">command_internal_clock</a></code></li>
<li><code><a title="egse.dpu.dpu.command_noop" href="#egse.dpu.dpu.command_noop">command_noop</a></code></li>
<li><code><a title="egse.dpu.dpu.command_reset" href="#egse.dpu.dpu.command_reset">command_reset</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_charge_injection" href="#egse.dpu.dpu.command_set_charge_injection">command_set_charge_injection</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_clear_error_flags" href="#egse.dpu.dpu.command_set_clear_error_flags">command_set_clear_error_flags</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_dump_mode" href="#egse.dpu.dpu.command_set_dump_mode">command_set_dump_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_dump_mode_int_sync" href="#egse.dpu.dpu.command_set_dump_mode_int_sync">command_set_dump_mode_int_sync</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_full_image_mode" href="#egse.dpu.dpu.command_set_full_image_mode">command_set_full_image_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_full_image_mode_int_sync" href="#egse.dpu.dpu.command_set_full_image_mode_int_sync">command_set_full_image_mode_int_sync</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_full_image_pattern_mode" href="#egse.dpu.dpu.command_set_full_image_pattern_mode">command_set_full_image_pattern_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_high_precision_hk_mode" href="#egse.dpu.dpu.command_set_high_precision_hk_mode">command_set_high_precision_hk_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_immediate_on_mode" href="#egse.dpu.dpu.command_set_immediate_on_mode">command_set_immediate_on_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_on_mode" href="#egse.dpu.dpu.command_set_on_mode">command_set_on_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_register_value" href="#egse.dpu.dpu.command_set_register_value">command_set_register_value</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_reverse_clocking" href="#egse.dpu.dpu.command_set_reverse_clocking">command_set_reverse_clocking</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_standby_mode" href="#egse.dpu.dpu.command_set_standby_mode">command_set_standby_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.command_set_vgd" href="#egse.dpu.dpu.command_set_vgd">command_set_vgd</a></code></li>
<li><code><a title="egse.dpu.dpu.prio_command_get_mode" href="#egse.dpu.dpu.prio_command_get_mode">prio_command_get_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.prio_command_is_dump_mode" href="#egse.dpu.dpu.prio_command_is_dump_mode">prio_command_is_dump_mode</a></code></li>
<li><code><a title="egse.dpu.dpu.read_register_from_n_fee" href="#egse.dpu.dpu.read_register_from_n_fee">read_register_from_n_fee</a></code></li>
<li><code><a title="egse.dpu.dpu.write_register_on_n_fee" href="#egse.dpu.dpu.write_register_on_n_fee">write_register_on_n_fee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.dpu.dpu.NFEEState" href="#egse.dpu.dpu.NFEEState">NFEEState</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.dpu.dpu.NFEEState.FIELDS" href="#egse.dpu.dpu.NFEEState.FIELDS">FIELDS</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.StateTuple" href="#egse.dpu.dpu.NFEEState.StateTuple">StateTuple</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.ccd_mode_config" href="#egse.dpu.dpu.NFEEState.ccd_mode_config">ccd_mode_config</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.ccd_read_en" href="#egse.dpu.dpu.NFEEState.ccd_read_en">ccd_read_en</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.ccd_readout_order" href="#egse.dpu.dpu.NFEEState.ccd_readout_order">ccd_readout_order</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.dg_en" href="#egse.dpu.dpu.NFEEState.dg_en">dg_en</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.digitise_en" href="#egse.dpu.dpu.NFEEState.digitise_en">digitise_en</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.get_parameter_names" href="#egse.dpu.dpu.NFEEState.get_parameter_names">get_parameter_names</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.get_state" href="#egse.dpu.dpu.NFEEState.get_state">get_state</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.get_value" href="#egse.dpu.dpu.NFEEState.get_value">get_value</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.h_end" href="#egse.dpu.dpu.NFEEState.h_end">h_end</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.int_sync_period" href="#egse.dpu.dpu.NFEEState.int_sync_period">int_sync_period</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.n_final_dump" href="#egse.dpu.dpu.NFEEState.n_final_dump">n_final_dump</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.sensor_sel" href="#egse.dpu.dpu.NFEEState.sensor_sel">sensor_sel</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.sync_sel" href="#egse.dpu.dpu.NFEEState.sync_sel">sync_sel</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.update_at_200ms" href="#egse.dpu.dpu.NFEEState.update_at_200ms">update_at_200ms</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.update_at_400ms" href="#egse.dpu.dpu.NFEEState.update_at_400ms">update_at_400ms</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.v_end" href="#egse.dpu.dpu.NFEEState.v_end">v_end</a></code></li>
<li><code><a title="egse.dpu.dpu.NFEEState.v_start" href="#egse.dpu.dpu.NFEEState.v_start">v_start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.bits API documentation</title>
<meta name="description" content="This module contains a number of convenience functions to work with bits, bytes and integers." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.bits</code></h1>
</header>
<section id="section-intro">
<p>This module contains a number of convenience functions to work with bits, bytes and integers.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains a number of convenience functions to work with bits, bytes and integers.
&#34;&#34;&#34;
import ctypes
from typing import Union


def set_bit(value: int, bit) -&gt; int:
    &#34;&#34;&#34;
    Set bit to 1 for the given value.

    Args:
        value (int): the integer value that needs a bit set or unset
        bit (int): the index of the bit to set/unset, starting from 0 at the LSB

    Returns:
        the changed value.
    &#34;&#34;&#34;
    return value | (1 &lt;&lt; bit)


def set_bits(value: int, bits: tuple) -&gt; int:
    &#34;&#34;&#34;
    Set the given bits in value to 1.
    Args:
        value (int): the value where the given bits shall be changed
        bits (tuple): a tuple with start and stop bits
    Returns:
        the changed value
    &#34;&#34;&#34;
    for i in range(bits[0], bits[1]):
        value |= 1 &lt;&lt; i
    return value


def clear_bit(value: int, bit) -&gt; int:
    &#34;&#34;&#34;
    Set bit to 0 for the given value.

    Args:
        value (int): the integer value that needs a bit set or unset
        bit (int): the index of the bit to set/unset, starting from 0 at the LSB

    Returns:
        the changed value.
    &#34;&#34;&#34;
    return value &amp; ~(1 &lt;&lt; bit)


def clear_bits(value: int, bits: tuple) -&gt; int:
    &#34;&#34;&#34;
    Set the given bits in value to 0.
    Args:
        value (int): the value where the given bits shall be changed
        bits (tuple): a tuple with start and stop bits
    Returns:
        the changed value
    &#34;&#34;&#34;
    for i in range(bits[0], bits[1]):
        value &amp;= ~(1 &lt;&lt; i)
    return value


def toggle_bit(value: int, bit) -&gt; int:
    &#34;&#34;&#34;
    Toggle the bit in the given value.

    Args:
        value (int): the integer value that needs a bit toggled
        bit (int): the index of the bit to toggle, starting from 0 at the LSB

    Returns:
        the changed value.
    &#34;&#34;&#34;
    return value ^ (1 &lt;&lt; bit)


def bit_set(value: int, bit) -&gt; bool:
    &#34;&#34;&#34;
    Return True if the bit is set.

    Args:
        value (int): the value to check
        bit (int): the index of the bit to check, starting from 0 at the LSB

    Returns:
        True if the bit is set (1).
    &#34;&#34;&#34;
    bit_value = 1 &lt;&lt; bit
    return value &amp; (bit_value) == bit_value


def bits_set(value: int, *args) -&gt; bool:
    &#34;&#34;&#34;
    Return True if all the bits are set.

    Args:
        value (int): the value to check
        args: a set of indices of the bits to check, starting from 0 at the LSB
    Returns:
        True if all the bits are set (1).

    For example:
        &gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [0, 1, 3, 8, 10])
        &gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [3, 8])
        &gt;&gt;&gt; assert not bits_set(0b0101_0000_1011, [1, 2, 3])
    &#34;&#34;&#34;

    if len(args) == 1 and isinstance(args[0], list):
        args = args[0]
    return all([bit_set(value, bit) for bit in args])


def beautify_binary(value: int, sep: str = &#39; &#39;, group: int = 8, prefix: str = &#39;&#39;, size: int = 0):
    &#34;&#34;&#34;
    Returns a binary representation of the given value. The bits are presented
    in groups of 8 bits for clarity by default (can be changed with the `group` keyword).

    Args:
        value (int): the value to beautify
        sep (str): the separator character to be used, default is a space
        group (int): the number of bits to group together, default is 8
        prefix (str): a string to prefix the result, default is &#39;&#39;
        size (int): number of digits

    Returns:
        a binary string representation.

    For example:
        &gt;&gt;&gt; status = 2**14 + 2**7
        &gt;&gt;&gt; assert beautify_binary(status) == &#34;01000000 10000000&#34;
    &#34;&#34;&#34;

    if size == 0:
        size = 8
        while value &gt; 2**size - 1:
            size += 8

    b_str = f&#39;{value:0{size}b}&#39;

    return prefix + sep.join([b_str[i:i + group] for i in range(0, len(b_str), group)])


def humanize_bytes(n: int, base: Union[int, str] = 2, precision: int = 3) -&gt; str:
    &#34;&#34;&#34;
    Represents the size `n` in human readable form, i.e. as byte, KiB, MiB, GiB, ...

    Please note that, by default, I use the IEC standard (International Engineering Consortium)
    which is in `base=2` (binary), i.e. 1024 bytes = 1.0 KiB. If you need SI units (International
    System of Units), you need to specify `base=10` (decimal), i.e. 1000 bytes = 1.0 kB.

    Args:
        n (int): number of byte
        base (int, str): binary (2) or decimal (10)
        precision (int): the number of decimal places [default=3]
    Returns:
        a human readable size, like 512 byte or 2.300 TiB
    Raises:
        ValueError when base is different from 2 (binary) or 10 (decimal).

    Examples:
        &gt;&gt;&gt; assert humanize_bytes(55) == &#34;55 bytes&#34;
        &gt;&gt;&gt; assert humanize_bytes(1024) == &#34;1.000 KiB&#34;
        &gt;&gt;&gt; assert humanize_bytes(1000, base=10) == &#34;1.000 kB&#34;
        &gt;&gt;&gt; assert humanize_bytes(1000000000) == &#39;953.674 MiB&#39;
        &gt;&gt;&gt; assert humanize_bytes(1000000000, base=10) == &#39;1.000 GB&#39;
        &gt;&gt;&gt; assert humanize_bytes(1073741824) == &#39;1.000 GiB&#39;
        &gt;&gt;&gt; assert humanize_bytes(1024**5 - 1, precision=0) == &#39;1024 TiB&#39;
    &#34;&#34;&#34;

    if base not in [2, 10, &#34;binary&#34;, &#34;decimal&#34;]:
        raise ValueError(f&#34;Only base 2 (binary) and 10 (decimal) are supported, got {base}.&#34;)

    # By default we assume base == 2 or base == &#34;binary&#34;

    one_kilo = 1024
    units = [&#39;KiB&#39;, &#39;MiB&#39;, &#39;GiB&#39;, &#39;TiB&#39;, &#39;PiB&#39;, &#39;EiB&#39;, &#39;ZiB&#39;, &#39;YiB&#39;]

    if base == 10 or base == &#39;decimal&#39;:
        one_kilo = 1000
        units = [&#39;kB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;]

    _n = n
    if _n &lt; one_kilo:
        return f&#34;{_n} byte{&#39;&#39; if n == 1 else &#39;s&#39;}&#34;

    for dim in units:
        _n /= one_kilo
        if _n &lt; one_kilo:
            return f&#34;{_n:.{precision}f} {dim}&#34;

    return f&#34;{n} byte{&#39;&#39; if n == 1 else &#39;s&#39;}&#34;


CRC_TABLE = [
    0x00, 0x91, 0xe3, 0x72, 0x07, 0x96, 0xe4, 0x75,
    0x0e, 0x9f, 0xed, 0x7c, 0x09, 0x98, 0xea, 0x7b,
    0x1c, 0x8d, 0xff, 0x6e, 0x1b, 0x8a, 0xf8, 0x69,
    0x12, 0x83, 0xf1, 0x60, 0x15, 0x84, 0xf6, 0x67,
    0x38, 0xa9, 0xdb, 0x4a, 0x3f, 0xae, 0xdc, 0x4d,
    0x36, 0xa7, 0xd5, 0x44, 0x31, 0xa0, 0xd2, 0x43,
    0x24, 0xb5, 0xc7, 0x56, 0x23, 0xb2, 0xc0, 0x51,
    0x2a, 0xbb, 0xc9, 0x58, 0x2d, 0xbc, 0xce, 0x5f,
    0x70, 0xe1, 0x93, 0x02, 0x77, 0xe6, 0x94, 0x05,
    0x7e, 0xef, 0x9d, 0x0c, 0x79, 0xe8, 0x9a, 0x0b,
    0x6c, 0xfd, 0x8f, 0x1e, 0x6b, 0xfa, 0x88, 0x19,
    0x62, 0xf3, 0x81, 0x10, 0x65, 0xf4, 0x86, 0x17,
    0x48, 0xd9, 0xab, 0x3a, 0x4f, 0xde, 0xac, 0x3d,
    0x46, 0xd7, 0xa5, 0x34, 0x41, 0xd0, 0xa2, 0x33,
    0x54, 0xc5, 0xb7, 0x26, 0x53, 0xc2, 0xb0, 0x21,
    0x5a, 0xcb, 0xb9, 0x28, 0x5d, 0xcc, 0xbe, 0x2f,
    0xe0, 0x71, 0x03, 0x92, 0xe7, 0x76, 0x04, 0x95,
    0xee, 0x7f, 0x0d, 0x9c, 0xe9, 0x78, 0x0a, 0x9b,
    0xfc, 0x6d, 0x1f, 0x8e, 0xfb, 0x6a, 0x18, 0x89,
    0xf2, 0x63, 0x11, 0x80, 0xf5, 0x64, 0x16, 0x87,
    0xd8, 0x49, 0x3b, 0xaa, 0xdf, 0x4e, 0x3c, 0xad,
    0xd6, 0x47, 0x35, 0xa4, 0xd1, 0x40, 0x32, 0xa3,
    0xc4, 0x55, 0x27, 0xb6, 0xc3, 0x52, 0x20, 0xb1,
    0xca, 0x5b, 0x29, 0xb8, 0xcd, 0x5c, 0x2e, 0xbf,
    0x90, 0x01, 0x73, 0xe2, 0x97, 0x06, 0x74, 0xe5,
    0x9e, 0x0f, 0x7d, 0xec, 0x99, 0x08, 0x7a, 0xeb,
    0x8c, 0x1d, 0x6f, 0xfe, 0x8b, 0x1a, 0x68, 0xf9,
    0x82, 0x13, 0x61, 0xf0, 0x85, 0x14, 0x66, 0xf7,
    0xa8, 0x39, 0x4b, 0xda, 0xaf, 0x3e, 0x4c, 0xdd,
    0xa6, 0x37, 0x45, 0xd4, 0xa1, 0x30, 0x42, 0xd3,
    0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22, 0x50, 0xc1,
    0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf,
]


def crc_calc(data, start: int, len: int) -&gt; int:
    &#34;&#34;&#34;
    Calculate the checksum for (part of) the data.

    Reference:
        The description of the CRC calculation for RMAP is given in the ECSS document
        _Space Engineering: SpaceWire - Remote Memory Access Protocol_, section A.3
        on page 80 [ECSS‐E‐ST‐50‐52C].

    Args:
        data: the data for which the checksum needs to be calculated
        start: offset into the data array [byte]
        len: number of bytes to incorporate into the calculation

    Returns:
        the calculated checksum.
    &#34;&#34;&#34;
    crc: int = 0

    # The check below is needed because we can pass data that is of type ctypes.c_char_Array
    # and the individual elements have then type &#39;bytes&#39;.

    if isinstance(data[0], bytes):
        for idx in range(start, start+len):
            crc = CRC_TABLE[crc ^ (int.from_bytes(data[idx], byteorder=&#39;big&#39;) &amp; 0xFF)]
    elif isinstance(data[0], int):
        for idx in range(start, start+len):
            crc = CRC_TABLE[crc ^ (data[idx] &amp; 0xFF)]

    return crc


def s16(value: int):
    &#34;&#34;&#34;
    Return the signed equivalent of a hex or binary number.

    Since integers in Python are objects and stored in a variable number of bits, Python doesn&#39;t
    know the concept of twos-complement for negative integers. For example, this 16-bit number

        &gt;&gt;&gt; 0b1000_0000_0001_0001
        32785

    which in twos-complement is actually a negative value:

        &gt;&gt;&gt; s16(0b1000_0000_0001_0001)
        -32751

    The &#39;bin()&#39; fuction will return a strange representation of this number:

        &gt;&gt;&gt; bin(-32751)
        &#39;-0b111111111101111&#39;

    when we however mask the value we get:

        &gt;&gt;&gt; bin(-32751 &amp; 0b1111_1111_1111_1111)
        &#39;0b1000000000010001&#39;

    See:
        https://stackoverflow.com/questions/1604464/twos-complement-in-python and
        https://stackoverflow.com/questions/46993519/python-representation-of-negative-integers and
        https://stackoverflow.com/questions/25096755/signed-equivalent-of-a-2s-complement-hex-value
        and https://stackoverflow.com/a/32262478/4609203

    Returns:
        The negative equivalent of a twos-complement binary number.
    &#34;&#34;&#34;
    return ctypes.c_int16(value).value


def s32(value: int):
    &#34;&#34;&#34;
    Return the signed equivalent of a hex or binary number.

    Since integers in Python are objects and stored in a variable number of bits, Python doesn&#39;t
    know the concept of twos-complement for negative integers. For example, this 32-bit number

        &gt;&gt;&gt; 0b1000_0000_0000_0000_0000_0000_0001_0001
        2147483665

    which in twos-complement is actually a negative value:

        &gt;&gt;&gt; s32(0b1000_0000_0000_0000_0000_0000_0001_0001)
        -2147483631

    Returns:
        The negative equivalent of a twos-complement binary number.
    &#34;&#34;&#34;
    return ctypes.c_int32(value).value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.bits.beautify_binary"><code class="name flex">
<span>def <span class="ident">beautify_binary</span></span>(<span>value: int, sep: str = ' ', group: int = 8, prefix: str = '', size: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a binary representation of the given value. The bits are presented
in groups of 8 bits for clarity by default (can be changed with the <code>group</code> keyword).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the value to beautify</dd>
<dt><strong><code>sep</code></strong> :&ensp;<code>str</code></dt>
<dd>the separator character to be used, default is a space</dd>
<dt><strong><code>group</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of bits to group together, default is 8</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>a string to prefix the result, default is ''</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>number of digits</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a binary string representation.
For example:
&gt;&gt;&gt; status = 2<strong>14 + 2</strong>7
&gt;&gt;&gt; assert beautify_binary(status) == "01000000 10000000"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beautify_binary(value: int, sep: str = &#39; &#39;, group: int = 8, prefix: str = &#39;&#39;, size: int = 0):
    &#34;&#34;&#34;
    Returns a binary representation of the given value. The bits are presented
    in groups of 8 bits for clarity by default (can be changed with the `group` keyword).

    Args:
        value (int): the value to beautify
        sep (str): the separator character to be used, default is a space
        group (int): the number of bits to group together, default is 8
        prefix (str): a string to prefix the result, default is &#39;&#39;
        size (int): number of digits

    Returns:
        a binary string representation.

    For example:
        &gt;&gt;&gt; status = 2**14 + 2**7
        &gt;&gt;&gt; assert beautify_binary(status) == &#34;01000000 10000000&#34;
    &#34;&#34;&#34;

    if size == 0:
        size = 8
        while value &gt; 2**size - 1:
            size += 8

    b_str = f&#39;{value:0{size}b}&#39;

    return prefix + sep.join([b_str[i:i + group] for i in range(0, len(b_str), group)])</code></pre>
</details>
</dd>
<dt id="egse.bits.bit_set"><code class="name flex">
<span>def <span class="ident">bit_set</span></span>(<span>value: int, bit) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the bit is set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the value to check</dd>
<dt><strong><code>bit</code></strong> :&ensp;<code>int</code></dt>
<dd>the index of the bit to check, starting from 0 at the LSB</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the bit is set (1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bit_set(value: int, bit) -&gt; bool:
    &#34;&#34;&#34;
    Return True if the bit is set.

    Args:
        value (int): the value to check
        bit (int): the index of the bit to check, starting from 0 at the LSB

    Returns:
        True if the bit is set (1).
    &#34;&#34;&#34;
    bit_value = 1 &lt;&lt; bit
    return value &amp; (bit_value) == bit_value</code></pre>
</details>
</dd>
<dt id="egse.bits.bits_set"><code class="name flex">
<span>def <span class="ident">bits_set</span></span>(<span>value: int, *args) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if all the bits are set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the value to check</dd>
<dt><strong><code>args</code></strong></dt>
<dd>a set of indices of the bits to check, starting from 0 at the LSB</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if all the bits are set (1).
For example:
&gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [0, 1, 3, 8, 10])
&gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [3, 8])
&gt;&gt;&gt; assert not bits_set(0b0101_0000_1011, [1, 2, 3])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bits_set(value: int, *args) -&gt; bool:
    &#34;&#34;&#34;
    Return True if all the bits are set.

    Args:
        value (int): the value to check
        args: a set of indices of the bits to check, starting from 0 at the LSB
    Returns:
        True if all the bits are set (1).

    For example:
        &gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [0, 1, 3, 8, 10])
        &gt;&gt;&gt; assert bits_set(0b0101_0000_1011, [3, 8])
        &gt;&gt;&gt; assert not bits_set(0b0101_0000_1011, [1, 2, 3])
    &#34;&#34;&#34;

    if len(args) == 1 and isinstance(args[0], list):
        args = args[0]
    return all([bit_set(value, bit) for bit in args])</code></pre>
</details>
</dd>
<dt id="egse.bits.clear_bit"><code class="name flex">
<span>def <span class="ident">clear_bit</span></span>(<span>value: int, bit) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Set bit to 0 for the given value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the integer value that needs a bit set or unset</dd>
<dt><strong><code>bit</code></strong> :&ensp;<code>int</code></dt>
<dd>the index of the bit to set/unset, starting from 0 at the LSB</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the changed value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_bit(value: int, bit) -&gt; int:
    &#34;&#34;&#34;
    Set bit to 0 for the given value.

    Args:
        value (int): the integer value that needs a bit set or unset
        bit (int): the index of the bit to set/unset, starting from 0 at the LSB

    Returns:
        the changed value.
    &#34;&#34;&#34;
    return value &amp; ~(1 &lt;&lt; bit)</code></pre>
</details>
</dd>
<dt id="egse.bits.clear_bits"><code class="name flex">
<span>def <span class="ident">clear_bits</span></span>(<span>value: int, bits: tuple) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Set the given bits in value to 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the value where the given bits shall be changed</dd>
<dt><strong><code>bits</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with start and stop bits</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the changed value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_bits(value: int, bits: tuple) -&gt; int:
    &#34;&#34;&#34;
    Set the given bits in value to 0.
    Args:
        value (int): the value where the given bits shall be changed
        bits (tuple): a tuple with start and stop bits
    Returns:
        the changed value
    &#34;&#34;&#34;
    for i in range(bits[0], bits[1]):
        value &amp;= ~(1 &lt;&lt; i)
    return value</code></pre>
</details>
</dd>
<dt id="egse.bits.crc_calc"><code class="name flex">
<span>def <span class="ident">crc_calc</span></span>(<span>data, start: int, len: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the checksum for (part of) the data.</p>
<h2 id="reference">Reference</h2>
<p>The description of the CRC calculation for RMAP is given in the ECSS document
<em>Space Engineering: SpaceWire - Remote Memory Access Protocol</em>, section A.3
on page 80 [ECSS‐E‐ST‐50‐52C].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>the data for which the checksum needs to be calculated</dd>
<dt><strong><code>start</code></strong></dt>
<dd>offset into the data array [byte]</dd>
<dt><strong><code>len</code></strong></dt>
<dd>number of bytes to incorporate into the calculation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the calculated checksum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crc_calc(data, start: int, len: int) -&gt; int:
    &#34;&#34;&#34;
    Calculate the checksum for (part of) the data.

    Reference:
        The description of the CRC calculation for RMAP is given in the ECSS document
        _Space Engineering: SpaceWire - Remote Memory Access Protocol_, section A.3
        on page 80 [ECSS‐E‐ST‐50‐52C].

    Args:
        data: the data for which the checksum needs to be calculated
        start: offset into the data array [byte]
        len: number of bytes to incorporate into the calculation

    Returns:
        the calculated checksum.
    &#34;&#34;&#34;
    crc: int = 0

    # The check below is needed because we can pass data that is of type ctypes.c_char_Array
    # and the individual elements have then type &#39;bytes&#39;.

    if isinstance(data[0], bytes):
        for idx in range(start, start+len):
            crc = CRC_TABLE[crc ^ (int.from_bytes(data[idx], byteorder=&#39;big&#39;) &amp; 0xFF)]
    elif isinstance(data[0], int):
        for idx in range(start, start+len):
            crc = CRC_TABLE[crc ^ (data[idx] &amp; 0xFF)]

    return crc</code></pre>
</details>
</dd>
<dt id="egse.bits.humanize_bytes"><code class="name flex">
<span>def <span class="ident">humanize_bytes</span></span>(<span>n: int, base: Union[int, str] = 2, precision: int = 3) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the size <code>n</code> in human readable form, i.e. as byte, KiB, MiB, GiB, &hellip;</p>
<p>Please note that, by default, I use the IEC standard (International Engineering Consortium)
which is in <code>base=2</code> (binary), i.e. 1024 bytes = 1.0 KiB. If you need SI units (International
System of Units), you need to specify <code>base=10</code> (decimal), i.e. 1000 bytes = 1.0 kB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of byte</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>int, str</code></dt>
<dd>binary (2) or decimal (10)</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of decimal places [default=3]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a human readable size, like 512 byte or 2.300 TiB</p>
<h2 id="raises">Raises</h2>
<p>ValueError when base is different from 2 (binary) or 10 (decimal).</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; assert humanize_bytes(55) == &quot;55 bytes&quot;
&gt;&gt;&gt; assert humanize_bytes(1024) == &quot;1.000 KiB&quot;
&gt;&gt;&gt; assert humanize_bytes(1000, base=10) == &quot;1.000 kB&quot;
&gt;&gt;&gt; assert humanize_bytes(1000000000) == '953.674 MiB'
&gt;&gt;&gt; assert humanize_bytes(1000000000, base=10) == '1.000 GB'
&gt;&gt;&gt; assert humanize_bytes(1073741824) == '1.000 GiB'
&gt;&gt;&gt; assert humanize_bytes(1024**5 - 1, precision=0) == '1024 TiB'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def humanize_bytes(n: int, base: Union[int, str] = 2, precision: int = 3) -&gt; str:
    &#34;&#34;&#34;
    Represents the size `n` in human readable form, i.e. as byte, KiB, MiB, GiB, ...

    Please note that, by default, I use the IEC standard (International Engineering Consortium)
    which is in `base=2` (binary), i.e. 1024 bytes = 1.0 KiB. If you need SI units (International
    System of Units), you need to specify `base=10` (decimal), i.e. 1000 bytes = 1.0 kB.

    Args:
        n (int): number of byte
        base (int, str): binary (2) or decimal (10)
        precision (int): the number of decimal places [default=3]
    Returns:
        a human readable size, like 512 byte or 2.300 TiB
    Raises:
        ValueError when base is different from 2 (binary) or 10 (decimal).

    Examples:
        &gt;&gt;&gt; assert humanize_bytes(55) == &#34;55 bytes&#34;
        &gt;&gt;&gt; assert humanize_bytes(1024) == &#34;1.000 KiB&#34;
        &gt;&gt;&gt; assert humanize_bytes(1000, base=10) == &#34;1.000 kB&#34;
        &gt;&gt;&gt; assert humanize_bytes(1000000000) == &#39;953.674 MiB&#39;
        &gt;&gt;&gt; assert humanize_bytes(1000000000, base=10) == &#39;1.000 GB&#39;
        &gt;&gt;&gt; assert humanize_bytes(1073741824) == &#39;1.000 GiB&#39;
        &gt;&gt;&gt; assert humanize_bytes(1024**5 - 1, precision=0) == &#39;1024 TiB&#39;
    &#34;&#34;&#34;

    if base not in [2, 10, &#34;binary&#34;, &#34;decimal&#34;]:
        raise ValueError(f&#34;Only base 2 (binary) and 10 (decimal) are supported, got {base}.&#34;)

    # By default we assume base == 2 or base == &#34;binary&#34;

    one_kilo = 1024
    units = [&#39;KiB&#39;, &#39;MiB&#39;, &#39;GiB&#39;, &#39;TiB&#39;, &#39;PiB&#39;, &#39;EiB&#39;, &#39;ZiB&#39;, &#39;YiB&#39;]

    if base == 10 or base == &#39;decimal&#39;:
        one_kilo = 1000
        units = [&#39;kB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;]

    _n = n
    if _n &lt; one_kilo:
        return f&#34;{_n} byte{&#39;&#39; if n == 1 else &#39;s&#39;}&#34;

    for dim in units:
        _n /= one_kilo
        if _n &lt; one_kilo:
            return f&#34;{_n:.{precision}f} {dim}&#34;

    return f&#34;{n} byte{&#39;&#39; if n == 1 else &#39;s&#39;}&#34;</code></pre>
</details>
</dd>
<dt id="egse.bits.s16"><code class="name flex">
<span>def <span class="ident">s16</span></span>(<span>value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the signed equivalent of a hex or binary number.</p>
<p>Since integers in Python are objects and stored in a variable number of bits, Python doesn't
know the concept of twos-complement for negative integers. For example, this 16-bit number</p>
<pre><code>&gt;&gt;&gt; 0b1000_0000_0001_0001
32785
</code></pre>
<p>which in twos-complement is actually a negative value:</p>
<pre><code>&gt;&gt;&gt; s16(0b1000_0000_0001_0001)
-32751
</code></pre>
<p>The 'bin()' fuction will return a strange representation of this number:</p>
<pre><code>&gt;&gt;&gt; bin(-32751)
'-0b111111111101111'
</code></pre>
<p>when we however mask the value we get:</p>
<pre><code>&gt;&gt;&gt; bin(-32751 &amp; 0b1111_1111_1111_1111)
'0b1000000000010001'
</code></pre>
<h2 id="see">See</h2>
<p><a href="https://stackoverflow.com/questions/1604464/twos-complement-in-python">https://stackoverflow.com/questions/1604464/twos-complement-in-python</a> and
<a href="https://stackoverflow.com/questions/46993519/python-representation-of-negative-integers">https://stackoverflow.com/questions/46993519/python-representation-of-negative-integers</a> and
<a href="https://stackoverflow.com/questions/25096755/signed-equivalent-of-a-2s-complement-hex-value">https://stackoverflow.com/questions/25096755/signed-equivalent-of-a-2s-complement-hex-value</a>
and <a href="https://stackoverflow.com/a/32262478/4609203">https://stackoverflow.com/a/32262478/4609203</a></p>
<h2 id="returns">Returns</h2>
<p>The negative equivalent of a twos-complement binary number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def s16(value: int):
    &#34;&#34;&#34;
    Return the signed equivalent of a hex or binary number.

    Since integers in Python are objects and stored in a variable number of bits, Python doesn&#39;t
    know the concept of twos-complement for negative integers. For example, this 16-bit number

        &gt;&gt;&gt; 0b1000_0000_0001_0001
        32785

    which in twos-complement is actually a negative value:

        &gt;&gt;&gt; s16(0b1000_0000_0001_0001)
        -32751

    The &#39;bin()&#39; fuction will return a strange representation of this number:

        &gt;&gt;&gt; bin(-32751)
        &#39;-0b111111111101111&#39;

    when we however mask the value we get:

        &gt;&gt;&gt; bin(-32751 &amp; 0b1111_1111_1111_1111)
        &#39;0b1000000000010001&#39;

    See:
        https://stackoverflow.com/questions/1604464/twos-complement-in-python and
        https://stackoverflow.com/questions/46993519/python-representation-of-negative-integers and
        https://stackoverflow.com/questions/25096755/signed-equivalent-of-a-2s-complement-hex-value
        and https://stackoverflow.com/a/32262478/4609203

    Returns:
        The negative equivalent of a twos-complement binary number.
    &#34;&#34;&#34;
    return ctypes.c_int16(value).value</code></pre>
</details>
</dd>
<dt id="egse.bits.s32"><code class="name flex">
<span>def <span class="ident">s32</span></span>(<span>value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the signed equivalent of a hex or binary number.</p>
<p>Since integers in Python are objects and stored in a variable number of bits, Python doesn't
know the concept of twos-complement for negative integers. For example, this 32-bit number</p>
<pre><code>&gt;&gt;&gt; 0b1000_0000_0000_0000_0000_0000_0001_0001
2147483665
</code></pre>
<p>which in twos-complement is actually a negative value:</p>
<pre><code>&gt;&gt;&gt; s32(0b1000_0000_0000_0000_0000_0000_0001_0001)
-2147483631
</code></pre>
<h2 id="returns">Returns</h2>
<p>The negative equivalent of a twos-complement binary number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def s32(value: int):
    &#34;&#34;&#34;
    Return the signed equivalent of a hex or binary number.

    Since integers in Python are objects and stored in a variable number of bits, Python doesn&#39;t
    know the concept of twos-complement for negative integers. For example, this 32-bit number

        &gt;&gt;&gt; 0b1000_0000_0000_0000_0000_0000_0001_0001
        2147483665

    which in twos-complement is actually a negative value:

        &gt;&gt;&gt; s32(0b1000_0000_0000_0000_0000_0000_0001_0001)
        -2147483631

    Returns:
        The negative equivalent of a twos-complement binary number.
    &#34;&#34;&#34;
    return ctypes.c_int32(value).value</code></pre>
</details>
</dd>
<dt id="egse.bits.set_bit"><code class="name flex">
<span>def <span class="ident">set_bit</span></span>(<span>value: int, bit) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Set bit to 1 for the given value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the integer value that needs a bit set or unset</dd>
<dt><strong><code>bit</code></strong> :&ensp;<code>int</code></dt>
<dd>the index of the bit to set/unset, starting from 0 at the LSB</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the changed value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bit(value: int, bit) -&gt; int:
    &#34;&#34;&#34;
    Set bit to 1 for the given value.

    Args:
        value (int): the integer value that needs a bit set or unset
        bit (int): the index of the bit to set/unset, starting from 0 at the LSB

    Returns:
        the changed value.
    &#34;&#34;&#34;
    return value | (1 &lt;&lt; bit)</code></pre>
</details>
</dd>
<dt id="egse.bits.set_bits"><code class="name flex">
<span>def <span class="ident">set_bits</span></span>(<span>value: int, bits: tuple) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Set the given bits in value to 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the value where the given bits shall be changed</dd>
<dt><strong><code>bits</code></strong> :&ensp;<code>tuple</code></dt>
<dd>a tuple with start and stop bits</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the changed value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bits(value: int, bits: tuple) -&gt; int:
    &#34;&#34;&#34;
    Set the given bits in value to 1.
    Args:
        value (int): the value where the given bits shall be changed
        bits (tuple): a tuple with start and stop bits
    Returns:
        the changed value
    &#34;&#34;&#34;
    for i in range(bits[0], bits[1]):
        value |= 1 &lt;&lt; i
    return value</code></pre>
</details>
</dd>
<dt id="egse.bits.toggle_bit"><code class="name flex">
<span>def <span class="ident">toggle_bit</span></span>(<span>value: int, bit) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle the bit in the given value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>the integer value that needs a bit toggled</dd>
<dt><strong><code>bit</code></strong> :&ensp;<code>int</code></dt>
<dd>the index of the bit to toggle, starting from 0 at the LSB</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the changed value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_bit(value: int, bit) -&gt; int:
    &#34;&#34;&#34;
    Toggle the bit in the given value.

    Args:
        value (int): the integer value that needs a bit toggled
        bit (int): the index of the bit to toggle, starting from 0 at the LSB

    Returns:
        the changed value.
    &#34;&#34;&#34;
    return value ^ (1 &lt;&lt; bit)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="egse.bits.beautify_binary" href="#egse.bits.beautify_binary">beautify_binary</a></code></li>
<li><code><a title="egse.bits.bit_set" href="#egse.bits.bit_set">bit_set</a></code></li>
<li><code><a title="egse.bits.bits_set" href="#egse.bits.bits_set">bits_set</a></code></li>
<li><code><a title="egse.bits.clear_bit" href="#egse.bits.clear_bit">clear_bit</a></code></li>
<li><code><a title="egse.bits.clear_bits" href="#egse.bits.clear_bits">clear_bits</a></code></li>
<li><code><a title="egse.bits.crc_calc" href="#egse.bits.crc_calc">crc_calc</a></code></li>
<li><code><a title="egse.bits.humanize_bytes" href="#egse.bits.humanize_bytes">humanize_bytes</a></code></li>
<li><code><a title="egse.bits.s16" href="#egse.bits.s16">s16</a></code></li>
<li><code><a title="egse.bits.s32" href="#egse.bits.s32">s32</a></code></li>
<li><code><a title="egse.bits.set_bit" href="#egse.bits.set_bit">set_bit</a></code></li>
<li><code><a title="egse.bits.set_bits" href="#egse.bits.set_bits">set_bits</a></code></li>
<li><code><a title="egse.bits.toggle_bit" href="#egse.bits.toggle_bit">toggle_bit</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.alert.alertman_cs API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.alert.alertman_cs</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import multiprocessing

import click
import sys
import zmq
from prometheus_client import start_http_server

from egse.alert import AlertManagerProtocol, AlertManagerProxy
from egse.control import ControlServer, is_control_server_active
from egse.settings import Settings
from egse.system import replace_environment_variable
from egse.zmq_ser import connect_address

logger = logging.getLogger(__name__)

CTRL_SETTINGS = Settings.load(&#34;Alert Manager Control Server&#34;)

class AlertManagerControlServer(ControlServer):
    &#34;&#34;&#34;
    The Alert Manager Control Server handles all Common-EGSE Alerts and notification.
    &#34;&#34;&#34;
    def __init__(self, phase):
        &#34;&#34;&#34; Initialisation of a new Control Server for Alert Management

        The initialisation of this Control Server consists of the following
        steps:

            - Define the device protocol;
            - Bind the command socket to the device protocol (to listen for
              commands);
            - Add the device protocol to the poller, to be able to listen for
              commands on different sockets in one thread.
        &#34;&#34;&#34;
        
        super().__init__()

        # Protocol used for commanding
        
        self.device_protocol = AlertManagerProtocol(self, phase)
        
        # Bind to a socket to listen for commands
        
        self.logger.debug(f&#34;Binding ZeroMQ socket to {self.device_protocol.get_bind_address()}&#34;)
        self.device_protocol.bind(self.dev_ctrl_cmd_sock)

        # Listen on different sockets in the same threads -&gt; poller
        
        self.poller.register(self.dev_ctrl_cmd_sock, zmq.POLLIN)


    def get_communication_protocol(self):
        &#34;&#34;&#34;Returns the communication protocol, as defined in the settings.

        Returns:
            - Communication protocol, as defined in the settings.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.PROTOCOL

    def get_commanding_port(self):
        &#34;&#34;&#34;Returns the commanding port number.

        The commanding port is the port on which the Controller listens for
        commands, using the REQ-REP (ZeroMQ) socket pattern.  Its number is
        read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for commands.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.COMMANDING_PORT

    def get_service_port(self):
        &#34;&#34;&#34;Returns the service port number.

        The service port is the port on which the Controller listens for
        configuration and administration, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for
              configuration and administration.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.SERVICE_PORT

    def get_monitoring_port(self):
        &#34;&#34;&#34;Returns the monitoring port number.

        The monitoring port is the port on which the Controller sends periodic
        information on the device, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller sends periodic status
              information on the device.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.MONITORING_PORT

    def get_storage_mnemonic(self):
        &#34;&#34;&#34;Returns the storage mnemonic for the Controller.

        The storage mnemonic is used in the filename of the housekeeping of
        the Controller (as using by the Storage).  If this is not defined in
        the settings file, &#34;PM&#34; will be used instead.

        Returns:
            - Storage mnemonic for the Controller.
        &#34;&#34;&#34;
        try:
            
            # As defined in the settings file
            
            return CTRL_SETTINGS.STORAGE_MNEMONIC
        except AttributeError:
            
            # Default
            
            return &#34;AM&#34;

    def before_serve(self):
        &#34;&#34;&#34; Start the Prometheus server &#34;&#34;&#34;
        start_http_server(CTRL_SETTINGS.METRICS_PORT)
        
    def after_serve(self):
        &#34;&#34;&#34; Stop all running alert threads &#34;&#34;&#34;
        self.device_protocol.controller.stop_all_alerts()
        self.device_protocol.controller.stop_all_cs_monitors()


@click.group()
def cli():
    pass

@cli.command()
@click.argument(&#39;phase&#39;, type=click.Choice([&#39;none&#39;, &#39;warm&#39;, &#39;transition&#39;, &#39;cold&#39;], case_sensitive=False), default=&#39;none&#39;)
def start(phase):
    &#34;&#34;&#34; Start the Alert Manager &#34;&#34;&#34;
    multiprocessing.current_process().name = &#34;alertman_cs&#34;

    # Check if prerequisites are fulfilled
    try:
        check_prerequisites()
    except RuntimeError as exc:
        print(exc)
        logger.error(exc)
        return 0

    try:
        control_server = AlertManagerControlServer(phase)
        control_server.serve()
    except KeyboardInterrupt:
        print(&#34;Shutdown requested...exiting&#34;)
    except SystemExit as exit_code:
        print(&#34;System Exit with code {}.&#34;.format(exit_code))
        sys.exit(exit_code)
    except Exception:
        import traceback

        traceback.print_exc(file=sys.stdout)

    return 0

@cli.command()
def stop():
    &#34;&#34;&#34;Sends a &#39;quit_server&#39; command to the Alert Manager&#34;&#34;&#34;
    with AlertManagerProxy() as am:
        sp = am.get_service_proxy()
        sp.quit_server()

@cli.command()    
def status():
    &#34;&#34;&#34; Print the status of the Alert Manager Control Server&#34;&#34;&#34;
    import rich
    
    rich.print(&#34;Alert Manager&#34;)
    
    protocol = CTRL_SETTINGS.PROTOCOL
    hostname = CTRL_SETTINGS.HOSTNAME
    port     = CTRL_SETTINGS.COMMANDING_PORT
    
    endpoint = connect_address(protocol, hostname, port)
    
    if is_control_server_active(endpoint):
        rich.print(f&#34;   Status: [green]active&#34;)
        
        with AlertManagerProxy() as am:
            rich.print(f&#34;   Hostname: {am.get_ip_address()}&#34;)
            rich.print(f&#34;   Monitoring port: {am.get_monitoring_port()}&#34;)
            rich.print(f&#34;   Commanding port: {am.get_commanding_port()}&#34;)
            rich.print(f&#34;   Service port: {am.get_service_port()}&#34;)
            phase = am.current_phase()
            alerts = am.alert_status(None)
            if alerts:
                num = len(alerts)
                active = 0
                triggered = 0
                for alert in alerts.values():
                    if alert[&#39;active&#39;]:
                        active += 1
                    if alert[&#39;triggered&#39;]:
                        triggered += 1
                rich.print(f&#34;   Phase: [bright_cyan]{phase.upper()}&#34;)
                rich.print(f&#34;   Running (Active/Total): [red]{active}[white]/[green]{num}&#34;)
                rich.print(f&#34;   Triggered:  [red]{triggered}[white]/[green]{num}&#34;)
            rich.print(f&#34;   Email server: {replace_environment_variable(CTRL_SETTINGS.EMAIL_SERVER)}&#34;)
            rich.print(f&#34;   Bot address: {replace_environment_variable(CTRL_SETTINGS.EMAIL_SENDER)}&#34;)
            rich.print(f&#34;   CS recipients: {replace_environment_variable(CTRL_SETTINGS.EMAIL_CS_RECIPIENTS)}&#34;)
            rich.print(f&#34;   Warning recipients: {replace_environment_variable(CTRL_SETTINGS.EMAIL_WARNING_RECIPIENTS)}&#34;)
    else:
        rich.print(f&#34;   Status: [red]Inactive&#34;)
    

def check_prerequisites():
    &#34;&#34;&#34; Checks whether the required environment variables have been set. &#34;&#34;&#34;
    sender = replace_environment_variable(CTRL_SETTINGS.EMAIL_SENDER)
    server = replace_environment_variable(CTRL_SETTINGS.EMAIL_SERVER)
    warning_recip = replace_environment_variable(CTRL_SETTINGS.EMAIL_WARNING_RECIPIENTS)
    cs_recip = replace_environment_variable(CTRL_SETTINGS.EMAIL_CS_RECIPIENTS)
    
    if not (sender and server and warning_recip and cs_recip):
        raise RuntimeError(
            &#34;The environment variables referenced in the Settings.yaml file for the &#34;
            &#34;&#39;EMAIL_SENDER&#39;, &#39;EMAIL_SERVER&#39;, &#39;EMAIL_WARNING_RECIPIENTS&#39;, &#39;EMAIL_CS_RECIPIENTS&#39;&#34;
            &#34;of the Alert Manager control server does not exist, please set the &#34;
            &#34;Environment variables.&#34;
        )

    logger.debug(f&#34;Alert sender: {sender}&#34;)
    logger.debug(f&#34;Alert server: {server}&#34;)
    logger.debug(f&#34;Warning recipients: {warning_recip}&#34;)
    logger.debug(f&#34;Cs recipients: {cs_recip}&#34;)

if __name__ == &#34;__main__&#34;:
    sys.exit(cli())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.alert.alertman_cs.check_prerequisites"><code class="name flex">
<span>def <span class="ident">check_prerequisites</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the required environment variables have been set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_prerequisites():
    &#34;&#34;&#34; Checks whether the required environment variables have been set. &#34;&#34;&#34;
    sender = replace_environment_variable(CTRL_SETTINGS.EMAIL_SENDER)
    server = replace_environment_variable(CTRL_SETTINGS.EMAIL_SERVER)
    warning_recip = replace_environment_variable(CTRL_SETTINGS.EMAIL_WARNING_RECIPIENTS)
    cs_recip = replace_environment_variable(CTRL_SETTINGS.EMAIL_CS_RECIPIENTS)
    
    if not (sender and server and warning_recip and cs_recip):
        raise RuntimeError(
            &#34;The environment variables referenced in the Settings.yaml file for the &#34;
            &#34;&#39;EMAIL_SENDER&#39;, &#39;EMAIL_SERVER&#39;, &#39;EMAIL_WARNING_RECIPIENTS&#39;, &#39;EMAIL_CS_RECIPIENTS&#39;&#34;
            &#34;of the Alert Manager control server does not exist, please set the &#34;
            &#34;Environment variables.&#34;
        )

    logger.debug(f&#34;Alert sender: {sender}&#34;)
    logger.debug(f&#34;Alert server: {server}&#34;)
    logger.debug(f&#34;Warning recipients: {warning_recip}&#34;)
    logger.debug(f&#34;Cs recipients: {cs_recip}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer"><code class="flex name class">
<span>class <span class="ident">AlertManagerControlServer</span></span>
<span>(</span><span>phase)</span>
</code></dt>
<dd>
<div class="desc"><p>The Alert Manager Control Server handles all Common-EGSE Alerts and notification.</p>
<p>Initialisation of a new Control Server for Alert Management</p>
<p>The initialisation of this Control Server consists of the following
steps:</p>
<pre><code>- Define the device protocol;
- Bind the command socket to the device protocol (to listen for
  commands);
- Add the device protocol to the poller, to be able to listen for
  commands on different sockets in one thread.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlertManagerControlServer(ControlServer):
    &#34;&#34;&#34;
    The Alert Manager Control Server handles all Common-EGSE Alerts and notification.
    &#34;&#34;&#34;
    def __init__(self, phase):
        &#34;&#34;&#34; Initialisation of a new Control Server for Alert Management

        The initialisation of this Control Server consists of the following
        steps:

            - Define the device protocol;
            - Bind the command socket to the device protocol (to listen for
              commands);
            - Add the device protocol to the poller, to be able to listen for
              commands on different sockets in one thread.
        &#34;&#34;&#34;
        
        super().__init__()

        # Protocol used for commanding
        
        self.device_protocol = AlertManagerProtocol(self, phase)
        
        # Bind to a socket to listen for commands
        
        self.logger.debug(f&#34;Binding ZeroMQ socket to {self.device_protocol.get_bind_address()}&#34;)
        self.device_protocol.bind(self.dev_ctrl_cmd_sock)

        # Listen on different sockets in the same threads -&gt; poller
        
        self.poller.register(self.dev_ctrl_cmd_sock, zmq.POLLIN)


    def get_communication_protocol(self):
        &#34;&#34;&#34;Returns the communication protocol, as defined in the settings.

        Returns:
            - Communication protocol, as defined in the settings.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.PROTOCOL

    def get_commanding_port(self):
        &#34;&#34;&#34;Returns the commanding port number.

        The commanding port is the port on which the Controller listens for
        commands, using the REQ-REP (ZeroMQ) socket pattern.  Its number is
        read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for commands.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.COMMANDING_PORT

    def get_service_port(self):
        &#34;&#34;&#34;Returns the service port number.

        The service port is the port on which the Controller listens for
        configuration and administration, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller listens for
              configuration and administration.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.SERVICE_PORT

    def get_monitoring_port(self):
        &#34;&#34;&#34;Returns the monitoring port number.

        The monitoring port is the port on which the Controller sends periodic
        information on the device, using the PUB-SUB (ZeroMQ) socket
        pattern.  Its number is read from the settings file.

        Returns:
            - Number of the port on which the Controller sends periodic status
              information on the device.
        &#34;&#34;&#34;
        return CTRL_SETTINGS.MONITORING_PORT

    def get_storage_mnemonic(self):
        &#34;&#34;&#34;Returns the storage mnemonic for the Controller.

        The storage mnemonic is used in the filename of the housekeeping of
        the Controller (as using by the Storage).  If this is not defined in
        the settings file, &#34;PM&#34; will be used instead.

        Returns:
            - Storage mnemonic for the Controller.
        &#34;&#34;&#34;
        try:
            
            # As defined in the settings file
            
            return CTRL_SETTINGS.STORAGE_MNEMONIC
        except AttributeError:
            
            # Default
            
            return &#34;AM&#34;

    def before_serve(self):
        &#34;&#34;&#34; Start the Prometheus server &#34;&#34;&#34;
        start_http_server(CTRL_SETTINGS.METRICS_PORT)
        
    def after_serve(self):
        &#34;&#34;&#34; Stop all running alert threads &#34;&#34;&#34;
        self.device_protocol.controller.stop_all_alerts()
        self.device_protocol.controller.stop_all_cs_monitors()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.after_serve"><code class="name flex">
<span>def <span class="ident">after_serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop all running alert threads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def after_serve(self):
    &#34;&#34;&#34; Stop all running alert threads &#34;&#34;&#34;
    self.device_protocol.controller.stop_all_alerts()
    self.device_protocol.controller.stop_all_cs_monitors()</code></pre>
</details>
</dd>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.before_serve"><code class="name flex">
<span>def <span class="ident">before_serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the Prometheus server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def before_serve(self):
    &#34;&#34;&#34; Start the Prometheus server &#34;&#34;&#34;
    start_http_server(CTRL_SETTINGS.METRICS_PORT)</code></pre>
</details>
</dd>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.get_commanding_port"><code class="name flex">
<span>def <span class="ident">get_commanding_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the commanding port number.</p>
<p>The commanding port is the port on which the Controller listens for
commands, using the REQ-REP (ZeroMQ) socket pattern.
Its number is
read from the settings file.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Number of the port on which the Controller listens for commands.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_commanding_port(self):
    &#34;&#34;&#34;Returns the commanding port number.

    The commanding port is the port on which the Controller listens for
    commands, using the REQ-REP (ZeroMQ) socket pattern.  Its number is
    read from the settings file.

    Returns:
        - Number of the port on which the Controller listens for commands.
    &#34;&#34;&#34;
    return CTRL_SETTINGS.COMMANDING_PORT</code></pre>
</details>
</dd>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.get_communication_protocol"><code class="name flex">
<span>def <span class="ident">get_communication_protocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the communication protocol, as defined in the settings.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Communication protocol, as defined in the settings.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_communication_protocol(self):
    &#34;&#34;&#34;Returns the communication protocol, as defined in the settings.

    Returns:
        - Communication protocol, as defined in the settings.
    &#34;&#34;&#34;
    return CTRL_SETTINGS.PROTOCOL</code></pre>
</details>
</dd>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.get_monitoring_port"><code class="name flex">
<span>def <span class="ident">get_monitoring_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the monitoring port number.</p>
<p>The monitoring port is the port on which the Controller sends periodic
information on the device, using the PUB-SUB (ZeroMQ) socket
pattern.
Its number is read from the settings file.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Number of the port on which the Controller sends periodic status
information on the device.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_monitoring_port(self):
    &#34;&#34;&#34;Returns the monitoring port number.

    The monitoring port is the port on which the Controller sends periodic
    information on the device, using the PUB-SUB (ZeroMQ) socket
    pattern.  Its number is read from the settings file.

    Returns:
        - Number of the port on which the Controller sends periodic status
          information on the device.
    &#34;&#34;&#34;
    return CTRL_SETTINGS.MONITORING_PORT</code></pre>
</details>
</dd>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.get_service_port"><code class="name flex">
<span>def <span class="ident">get_service_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the service port number.</p>
<p>The service port is the port on which the Controller listens for
configuration and administration, using the PUB-SUB (ZeroMQ) socket
pattern.
Its number is read from the settings file.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Number of the port on which the Controller listens for
configuration and administration.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_service_port(self):
    &#34;&#34;&#34;Returns the service port number.

    The service port is the port on which the Controller listens for
    configuration and administration, using the PUB-SUB (ZeroMQ) socket
    pattern.  Its number is read from the settings file.

    Returns:
        - Number of the port on which the Controller listens for
          configuration and administration.
    &#34;&#34;&#34;
    return CTRL_SETTINGS.SERVICE_PORT</code></pre>
</details>
</dd>
<dt id="egse.alert.alertman_cs.AlertManagerControlServer.get_storage_mnemonic"><code class="name flex">
<span>def <span class="ident">get_storage_mnemonic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the storage mnemonic for the Controller.</p>
<p>The storage mnemonic is used in the filename of the housekeeping of
the Controller (as using by the Storage).
If this is not defined in
the settings file, "PM" will be used instead.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Storage mnemonic for the Controller.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_storage_mnemonic(self):
    &#34;&#34;&#34;Returns the storage mnemonic for the Controller.

    The storage mnemonic is used in the filename of the housekeeping of
    the Controller (as using by the Storage).  If this is not defined in
    the settings file, &#34;PM&#34; will be used instead.

    Returns:
        - Storage mnemonic for the Controller.
    &#34;&#34;&#34;
    try:
        
        # As defined in the settings file
        
        return CTRL_SETTINGS.STORAGE_MNEMONIC
    except AttributeError:
        
        # Default
        
        return &#34;AM&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.control.ControlServer" href="../control.html#egse.control.ControlServer">ControlServer</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.control.ControlServer.handle_scheduled_tasks" href="../control.html#egse.control.ControlServer.handle_scheduled_tasks">handle_scheduled_tasks</a></code></li>
<li><code><a title="egse.control.ControlServer.notify_listeners" href="../control.html#egse.control.ControlServer.notify_listeners">notify_listeners</a></code></li>
<li><code><a title="egse.control.ControlServer.register_as_listener" href="../control.html#egse.control.ControlServer.register_as_listener">register_as_listener</a></code></li>
<li><code><a title="egse.control.ControlServer.register_to_storage_manager" href="../control.html#egse.control.ControlServer.register_to_storage_manager">register_to_storage_manager</a></code></li>
<li><code><a title="egse.control.ControlServer.schedule_task" href="../control.html#egse.control.ControlServer.schedule_task">schedule_task</a></code></li>
<li><code><a title="egse.control.ControlServer.set_delay" href="../control.html#egse.control.ControlServer.set_delay">set_delay</a></code></li>
<li><code><a title="egse.control.ControlServer.set_hk_delay" href="../control.html#egse.control.ControlServer.set_hk_delay">set_hk_delay</a></code></li>
<li><code><a title="egse.control.ControlServer.store_housekeeping_information" href="../control.html#egse.control.ControlServer.store_housekeeping_information">store_housekeeping_information</a></code></li>
<li><code><a title="egse.control.ControlServer.unregister_as_listener" href="../control.html#egse.control.ControlServer.unregister_as_listener">unregister_as_listener</a></code></li>
<li><code><a title="egse.control.ControlServer.unregister_from_storage_manager" href="../control.html#egse.control.ControlServer.unregister_from_storage_manager">unregister_from_storage_manager</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.alert" href="index.html">egse.alert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.alert.alertman_cs.check_prerequisites" href="#egse.alert.alertman_cs.check_prerequisites">check_prerequisites</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.alert.alertman_cs.AlertManagerControlServer" href="#egse.alert.alertman_cs.AlertManagerControlServer">AlertManagerControlServer</a></code></h4>
<ul class="">
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.after_serve" href="#egse.alert.alertman_cs.AlertManagerControlServer.after_serve">after_serve</a></code></li>
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.before_serve" href="#egse.alert.alertman_cs.AlertManagerControlServer.before_serve">before_serve</a></code></li>
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.get_commanding_port" href="#egse.alert.alertman_cs.AlertManagerControlServer.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.get_communication_protocol" href="#egse.alert.alertman_cs.AlertManagerControlServer.get_communication_protocol">get_communication_protocol</a></code></li>
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.get_monitoring_port" href="#egse.alert.alertman_cs.AlertManagerControlServer.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.get_service_port" href="#egse.alert.alertman_cs.AlertManagerControlServer.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.alert.alertman_cs.AlertManagerControlServer.get_storage_mnemonic" href="#egse.alert.alertman_cs.AlertManagerControlServer.get_storage_mnemonic">get_storage_mnemonic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
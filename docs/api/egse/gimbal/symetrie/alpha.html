<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.gimbal.symetrie.alpha API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.gimbal.symetrie.alpha</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from egse.decorators import dynamic_interface


class AlphaControllerInterface:
    @dynamic_interface
    def info(self):
        &#34;&#34;&#34;Returns basic information about the gimbal and the controller.

        Returns:
            a multiline response message containing the device info.
        Raises:
            GimbalError: when information can not be retrieved.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def reset(self, wait=True):
        &#34;&#34;&#34;Completely resets the Gimbal hardware controller with the standard boot cycle.

        Args:
            wait (bool): after the reset command has been sent to the controller, wait
                for 30 seconds which should complete the cycle, i.e. this command will
                only return after 30 seconds.

        .. Note::
           This command is equivalent to power cycling the controller manually.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def homing(self):
        &#34;&#34;&#34;Start the homing cycle for the Gimbal.

        Homing is required before performing a control movement. Without absolute encoders,
        the homing is performed with a gimbal movement until detecting the reference sensor
        on each of the actuators. The Gimbal will go to a position were the sensors are
        reached that signal a known calibrated position and then returns to the zero position.

        Whenever a homing is performed, the method will return before the actual movement
        is finished.

        The homing cycle takes about two minutes to complete, but the ``homing()`` method
        returns almost immediately. Therefore, to check if the homing is finished, use
        the is_homing_done() method.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    #
    # Gimbal does not support virtual homing
    #
    # @dynamic_interface
    # def set_virtual_homing(self, tx, ty, tz, rx, ry, rz):


    @dynamic_interface
    def stop(self):
        &#34;&#34;&#34;Stop the current motion. This command can be send during a motion of the Gimbal.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def clear_error(self):
        &#34;&#34;&#34;Clear all errors in the controller software.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is Time-Out or when there is a communication error with the
            gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def activate_control_loop(self):
        &#34;&#34;&#34;Activates the control loop on motors.

        Returns:
            0 on success, -1 when ignored, -2 on error.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal
                hardware controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def deactivate_control_loop(self):
        &#34;&#34;&#34;Disables the control loop on the servo motors.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def jog(self, axis: int, inc: float) -&gt; int:
        &#34;&#34;&#34;Perform a JOG-type movement on the specified actuator.

        .. note::
            This is a maintenance feature.

        Args:
            axis (int): number of the actuator (1 to 2)
            inc (float): increment to achieve in [deg]
        Returns:
            0 on success, -1 if command was ignored due to non-compliance.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_debug_info(self):
        &#34;&#34;&#34;
        Request debug information from the Gimbal Controller.

        The method returns four values that represent the following status:

        1. ``Homing``: state of the homing
        2. ``PosRef``: state of the Position Reference command
        3. ``KinError``: error in kinematic calculation
        4. ``Panel``: Panel state

        Note many of these codes overlap PUNA&#39;s debug codes. These have been
        thoroughly reviewed before defining the interface.

        The Homing can take the following values:

            =====     ==================
            Value     Meaning
            =====     ==================
            0         Undefined
            1         Homing in progress
            2         Homing done
            3         Error
            =====     ==================

        The PosRef can take the following values:

            =======     =====================
             Value       Meaning
            =======     =====================
               0         Undefined
               1         Abort input error
               2         Movement in progress
               3         Position reached
               4         Error
            =======     =====================

        The KinError can take the following values:

            =======     ===============================================
             Value       Meaning
            =======     ===============================================
               0         none
               1         Homing not done
               2         Inverse kinematic model (MGI) – workspace
               3         Inverse kinematic model (MGI) – joint angle
               4         Forward kinematic model (MGD) – workspace
               5         Forward kinematic model (MGD) – max iteration
               6         Position calculation (PLCC) – workspace
               7         Position calculation (PLCC) – max iteration.
            =======     ===============================================

        The Panel status can take the following values:

            ======   ===============
            Index       Command
            ======   ===============
            -2       Command error
            -1       Ignored / Command not allowed
            **0**       **None**
            1        Homing
            2        Stop
            3        Control ON
            4        Control OFF
            10       Valid POS
            11       Move
            12       Sequence
            13       Specific POS
            15       Clear Error
              **Family “Set config”**
            ------------------------
            21       Config CS
            22       Config Limits_mTn
            23       Config Limits_uTo
            24       Config Limits_Enabled
            25       Config Speed
            26       Config Current
            27       Config Backlash
              **Family “Get config”**
            ------------------------
            31       Config CS
            32       Config Limits_mTn
            33       Config Limits_uTo
            34       Config Limits_Enabled
            35       Config Speed
            36       Config Current
            37       Config Backlash
              **Family “Maintenance”**
            ------------------------
            41       Jog
            50       Config Save
            51       Config Default
            52       Config Saved?
            55       Version
            ======   ===============

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def configure_offsets(self, grx, gry):
        &#34;&#34;&#34;
        Changes the definition of offsets. This is the Gimbal&#39;s equivalent of changing the
        PUNA&#39;s coordinate system.

        The parameters grx and gry are used to define axes offsets. The position with
        offset is named Position or User position. The position without offset is named
        Machine position.

        Args:
            grx (float): offset on the Rx axis [deg]
            gry (float): offset on the Ry axis [deg]

        Returns:
            0 on success and -1 when the configuration is ignored, e.g. when password protection
            is enabled.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_offsets(self):
        &#34;&#34;&#34;Retrieve the definition of the gimbal offsets.

        Returns:
            grx and gry in [deg].
        Raises:
            GimbalError: when an error occurred while trying to retrieve the information.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def move_absolute(self, grx, gry):
        &#34;&#34;&#34;Rotates the gimbal in both axes, absolute coordinates.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            return_code: 0 on success, -1 when ignored, -2 on error

        Raises:
            GimbalError: when the arguments do not match up, or when there is a time out or when
            there is a
            socket communication error.

        .. note::
           When the command was not successful, this method will query the
           POSVALID? using the checkAbsolutePosition() and print a summary
           of the error messages to the log file.

        .. todo::
           do we want to check if the movement is valid before actually performing
           the movement?

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def move_relative(self, grx, gry):
        &#34;&#34;&#34;Move the gimbal relative to its current position.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            0 on success, -1 when ignored, -2 on error.

        Raises:
            GimbalError: when the arguments do not match up, or when there is a time out or when
            there is a
            socket communication error.

        .. todo:: do we want to check if the movement is valid before actually performing
                  the movement?

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def check_absolute_movement(self, grx, gry):
        &#34;&#34;&#34;Check if the requested gimbal movement is valid.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.

        .. todo:: either provide a more user friendly return value or a method/function
                  to process the information into a human readable form. Also update
                  the documentation of this method with more information about the
                  bitfields etc.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def check_relative_movement(self, grx, gry):
        &#34;&#34;&#34;Check if the requested object movement is valid.

        The relative motion is expressed in the object coordinate system.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.

        .. todo:: either provide a more user friendly return value or a method/function
                  to process the information into a human readable form. Also update
                  the documentation of this method with more information about the
                  bitfields etc.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_user_positions(self):
        &#34;&#34;&#34;Retreive the current position of the gimbal.

        Asks the current position of the gimbal. Position returned corresponds to the
        user position (position with offsets).

        Returns:
            array: an array of two float values for grx, gry
            None: when an Exception was raised and logs the error message.

        .. note:: This is equivalent to the POSUSER? command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_machine_positions(self):
        &#34;&#34;&#34;Retreive the current position of the gimbal.

        Asks the current position of the gimbal. Position returned corresponds to the
        machine position (position without offsets).

        Returns:
            array: an array of two float values for grx, gry
            None: when a PMACError was raised and logs the error message.

        .. note:: This is equivalent to the POSMACH? command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_motor_temperatures(self):
        &#34;&#34;&#34;Retreive the current temperatures of the Gimbal motors.

        Asks the current temperatures of the motors as measured by their
        corresponding thermocouples. Results are in Celsius.

        Returns:
            array: an array of two float values for grx, gry
            None: when a PMACError was raised and logs the error message.

        .. note:: This is equivalent to the STATE#AI? command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_actuator_length(self):
        &#34;&#34;&#34;Retrieve the current length of the gimbal actuators.

        Returns:
            array: an array of 2 float values for actuator length L1 to L2 in [mm], and \
            None: when an Exception was raised and logs the error message.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_speed(self, sr):
        &#34;&#34;&#34;Set the speed of the gimbal movements.

        Args:
            sr (float): The angular speed, expressed in deg per second [deg/s].

        The argument sr is automatically limited by the controller between the
        minimum and maximum speeds allowed for the gimbal.

        Returns:
            0 on success and -1 when the configuration is ignored, e.g. when password protection
            is enabled.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_speed(self):
        &#34;&#34;&#34;Retrieve the configuration of the movement speed.

        Returns:
            sr, sr_min, sr_max

        Where:
            * ``sr`` is the angular speed of the gimbal in deg per second [deg/s]
            * ``sr_min``, ``sr_max`` are the limits for the rotation speed [deg/s]

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_general_state(self):
        &#34;&#34;&#34;Retrieve general state information of the gimbal.

        Returns:
            tuple: where the first element is an integer where the bits represent each state, and
                the second element is an array of True/False flags for each state described in
                Gimbal
                Controller API, section 2.5.6.

            None: when an Exception was raised and logs the error message.

        .. note:: This is equivalent to the STATE#GIMBAL? Command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_actuator_state(self):
        &#34;&#34;&#34;Retreive general state information of the actuators.

        For each of the two actuators, an integer value is returned that should be interpreted as a
        bit field containing status bits for that actuator.

            ======   ========================
             Bit      Function
            ======   ========================
              0       In position
              1       Control loop on servo motors active
              2       Homing done
              3       Input &#34;Home Switch&#34;
              4       Input &#34;Positive limit switch&#34;
              5       Input &#34;Negative limit switch&#34;
              6       Brake control output
              7       Following error (warning)
              8       Following error (Fatal)
              9       Actuator out of bounds error
             10       Amplifier error
             11       Encoder error
             12       Phasing error (brushless engine only)
             13-23    Reserved
            ======   ========================

        Returns:
            array: an array of two (2) dictionaries with True/False flags for each actuator state
            as described in
                Gimbal Controller API, section 2.5.5.
            None: when an Exception was raised and logs the error message.

        .. note:: This is equivalent to the STATE#ACTUATOR? Command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def goto_specific_position(self, pos):
        &#34;&#34;&#34;Ask to go to a specific position.

        * pos=0 Machine zero position (jog &amp; maintenance only!)
        * pos=1 Unused (not valid for the Gimbal)
        * pos=2 User zero position (with offsets)

        Returns:
            0 on success, -1 when ignored, -2 for an invalid movement command

        Raises:
            GimbalError: when there is Time-Out or when there is a communication error with the
            gimbal controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def goto_zero_position(self):
        &#34;&#34;&#34;Ask the gimbal to go to the user zero position.

        Returns:
            0 on success, -1 when ignored, -2 for an invalid movement command

        Raises:
            GimbalError: when there is Time-Out or when there is a socket communication error.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_homing_done(self):
        &#34;&#34;&#34;
        Check if Homing is done. This method checks the ``Q26`` variable.
        When this variable indicates &#39;Homing is done&#39; it means the command has properly been
        executed,
        but it doesn&#39;t mean the Gimbal is in position. The gimbal might still be moving to its
        zero position.

        Returns:
            True when the homing is done, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_in_position(self):
        &#34;&#34;&#34;
        Checks if the actuators are in position.

        This method queries the Q36 variable and examines the third bit which is the &#39;Is
        Position&#39; bit.
        This method does **not** query the actuator state variables Q30 till Q36.

        Returns:
            True when in position, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def perform_maintenance(self, axis):
        &#34;&#34;&#34;Perform a maintenance cycle which consists to travel the full range
        on one axis corresponding to the Gimbal machine limits. The movement is
        also in machine coordinate system.

        Undocumented. Ask Symetrie.

        Args:
            axis (int): on which axis the full range movement is executed
        Returns:
            0 on success, -1 when ignored for non-compliance.
        Raises:
            GimbalError: when there is Time-Out or when there is a socket communication error.
        &#34;&#34;&#34;
        raise NotImplementedError

    def log_positions(self):
        &#34;&#34;&#34;
        Log the current position of the gimbal (level=INFO). The positions correspond to

          * the position of the object in the User Coordinate System, and
          * the position of the gimbal in the Machine Coordinate System.

        &#34;&#34;&#34;

        pos = self.get_user_positions()
        logger.info(
            f&#34;Object [in User]     : &#34;
            f&#34;{pos[0]:2.5f}, {pos[1]:2.5f}&#34;
        )

        pos = self.get_machine_positions()
        logger.info(
            f&#34;Platform [in Machine]: &#34;
            f&#34;{pos[0]:2.5f}, {pos[1]:2.5f}&#34;
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface"><code class="flex name class">
<span>class <span class="ident">AlphaControllerInterface</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphaControllerInterface:
    @dynamic_interface
    def info(self):
        &#34;&#34;&#34;Returns basic information about the gimbal and the controller.

        Returns:
            a multiline response message containing the device info.
        Raises:
            GimbalError: when information can not be retrieved.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def reset(self, wait=True):
        &#34;&#34;&#34;Completely resets the Gimbal hardware controller with the standard boot cycle.

        Args:
            wait (bool): after the reset command has been sent to the controller, wait
                for 30 seconds which should complete the cycle, i.e. this command will
                only return after 30 seconds.

        .. Note::
           This command is equivalent to power cycling the controller manually.

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def homing(self):
        &#34;&#34;&#34;Start the homing cycle for the Gimbal.

        Homing is required before performing a control movement. Without absolute encoders,
        the homing is performed with a gimbal movement until detecting the reference sensor
        on each of the actuators. The Gimbal will go to a position were the sensors are
        reached that signal a known calibrated position and then returns to the zero position.

        Whenever a homing is performed, the method will return before the actual movement
        is finished.

        The homing cycle takes about two minutes to complete, but the ``homing()`` method
        returns almost immediately. Therefore, to check if the homing is finished, use
        the is_homing_done() method.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    #
    # Gimbal does not support virtual homing
    #
    # @dynamic_interface
    # def set_virtual_homing(self, tx, ty, tz, rx, ry, rz):


    @dynamic_interface
    def stop(self):
        &#34;&#34;&#34;Stop the current motion. This command can be send during a motion of the Gimbal.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def clear_error(self):
        &#34;&#34;&#34;Clear all errors in the controller software.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is Time-Out or when there is a communication error with the
            gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def activate_control_loop(self):
        &#34;&#34;&#34;Activates the control loop on motors.

        Returns:
            0 on success, -1 when ignored, -2 on error.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal
                hardware controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def deactivate_control_loop(self):
        &#34;&#34;&#34;Disables the control loop on the servo motors.

        Returns:
            0 on success.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def jog(self, axis: int, inc: float) -&gt; int:
        &#34;&#34;&#34;Perform a JOG-type movement on the specified actuator.

        .. note::
            This is a maintenance feature.

        Args:
            axis (int): number of the actuator (1 to 2)
            inc (float): increment to achieve in [deg]
        Returns:
            0 on success, -1 if command was ignored due to non-compliance.
        Raises:
            GimbalError: when there is a time out or when there is a communication error with
            the gimbal.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_debug_info(self):
        &#34;&#34;&#34;
        Request debug information from the Gimbal Controller.

        The method returns four values that represent the following status:

        1. ``Homing``: state of the homing
        2. ``PosRef``: state of the Position Reference command
        3. ``KinError``: error in kinematic calculation
        4. ``Panel``: Panel state

        Note many of these codes overlap PUNA&#39;s debug codes. These have been
        thoroughly reviewed before defining the interface.

        The Homing can take the following values:

            =====     ==================
            Value     Meaning
            =====     ==================
            0         Undefined
            1         Homing in progress
            2         Homing done
            3         Error
            =====     ==================

        The PosRef can take the following values:

            =======     =====================
             Value       Meaning
            =======     =====================
               0         Undefined
               1         Abort input error
               2         Movement in progress
               3         Position reached
               4         Error
            =======     =====================

        The KinError can take the following values:

            =======     ===============================================
             Value       Meaning
            =======     ===============================================
               0         none
               1         Homing not done
               2         Inverse kinematic model (MGI) – workspace
               3         Inverse kinematic model (MGI) – joint angle
               4         Forward kinematic model (MGD) – workspace
               5         Forward kinematic model (MGD) – max iteration
               6         Position calculation (PLCC) – workspace
               7         Position calculation (PLCC) – max iteration.
            =======     ===============================================

        The Panel status can take the following values:

            ======   ===============
            Index       Command
            ======   ===============
            -2       Command error
            -1       Ignored / Command not allowed
            **0**       **None**
            1        Homing
            2        Stop
            3        Control ON
            4        Control OFF
            10       Valid POS
            11       Move
            12       Sequence
            13       Specific POS
            15       Clear Error
              **Family “Set config”**
            ------------------------
            21       Config CS
            22       Config Limits_mTn
            23       Config Limits_uTo
            24       Config Limits_Enabled
            25       Config Speed
            26       Config Current
            27       Config Backlash
              **Family “Get config”**
            ------------------------
            31       Config CS
            32       Config Limits_mTn
            33       Config Limits_uTo
            34       Config Limits_Enabled
            35       Config Speed
            36       Config Current
            37       Config Backlash
              **Family “Maintenance”**
            ------------------------
            41       Jog
            50       Config Save
            51       Config Default
            52       Config Saved?
            55       Version
            ======   ===============

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def configure_offsets(self, grx, gry):
        &#34;&#34;&#34;
        Changes the definition of offsets. This is the Gimbal&#39;s equivalent of changing the
        PUNA&#39;s coordinate system.

        The parameters grx and gry are used to define axes offsets. The position with
        offset is named Position or User position. The position without offset is named
        Machine position.

        Args:
            grx (float): offset on the Rx axis [deg]
            gry (float): offset on the Ry axis [deg]

        Returns:
            0 on success and -1 when the configuration is ignored, e.g. when password protection
            is enabled.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_offsets(self):
        &#34;&#34;&#34;Retrieve the definition of the gimbal offsets.

        Returns:
            grx and gry in [deg].
        Raises:
            GimbalError: when an error occurred while trying to retrieve the information.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def move_absolute(self, grx, gry):
        &#34;&#34;&#34;Rotates the gimbal in both axes, absolute coordinates.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            return_code: 0 on success, -1 when ignored, -2 on error

        Raises:
            GimbalError: when the arguments do not match up, or when there is a time out or when
            there is a
            socket communication error.

        .. note::
           When the command was not successful, this method will query the
           POSVALID? using the checkAbsolutePosition() and print a summary
           of the error messages to the log file.

        .. todo::
           do we want to check if the movement is valid before actually performing
           the movement?

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def move_relative(self, grx, gry):
        &#34;&#34;&#34;Move the gimbal relative to its current position.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            0 on success, -1 when ignored, -2 on error.

        Raises:
            GimbalError: when the arguments do not match up, or when there is a time out or when
            there is a
            socket communication error.

        .. todo:: do we want to check if the movement is valid before actually performing
                  the movement?

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def check_absolute_movement(self, grx, gry):
        &#34;&#34;&#34;Check if the requested gimbal movement is valid.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.

        .. todo:: either provide a more user friendly return value or a method/function
                  to process the information into a human readable form. Also update
                  the documentation of this method with more information about the
                  bitfields etc.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def check_relative_movement(self, grx, gry):
        &#34;&#34;&#34;Check if the requested object movement is valid.

        The relative motion is expressed in the object coordinate system.

        Args:
            grx (float): rotation around the X-axis [deg]
            gry (float): rotation around the Y-axis [deg]

        Returns:
            tuple: where the first element is an integer that represents the
                bitfield encoding the errors. The second element is a dictionary
                with the bit numbers that were (on) and the corresponding error
                description.

        .. todo:: either provide a more user friendly return value or a method/function
                  to process the information into a human readable form. Also update
                  the documentation of this method with more information about the
                  bitfields etc.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_user_positions(self):
        &#34;&#34;&#34;Retreive the current position of the gimbal.

        Asks the current position of the gimbal. Position returned corresponds to the
        user position (position with offsets).

        Returns:
            array: an array of two float values for grx, gry
            None: when an Exception was raised and logs the error message.

        .. note:: This is equivalent to the POSUSER? command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_machine_positions(self):
        &#34;&#34;&#34;Retreive the current position of the gimbal.

        Asks the current position of the gimbal. Position returned corresponds to the
        machine position (position without offsets).

        Returns:
            array: an array of two float values for grx, gry
            None: when a PMACError was raised and logs the error message.

        .. note:: This is equivalent to the POSMACH? command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_motor_temperatures(self):
        &#34;&#34;&#34;Retreive the current temperatures of the Gimbal motors.

        Asks the current temperatures of the motors as measured by their
        corresponding thermocouples. Results are in Celsius.

        Returns:
            array: an array of two float values for grx, gry
            None: when a PMACError was raised and logs the error message.

        .. note:: This is equivalent to the STATE#AI? command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_actuator_length(self):
        &#34;&#34;&#34;Retrieve the current length of the gimbal actuators.

        Returns:
            array: an array of 2 float values for actuator length L1 to L2 in [mm], and \
            None: when an Exception was raised and logs the error message.
        &#34;&#34;&#34;

        raise NotImplementedError

    @dynamic_interface
    def set_speed(self, sr):
        &#34;&#34;&#34;Set the speed of the gimbal movements.

        Args:
            sr (float): The angular speed, expressed in deg per second [deg/s].

        The argument sr is automatically limited by the controller between the
        minimum and maximum speeds allowed for the gimbal.

        Returns:
            0 on success and -1 when the configuration is ignored, e.g. when password protection
            is enabled.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_speed(self):
        &#34;&#34;&#34;Retrieve the configuration of the movement speed.

        Returns:
            sr, sr_min, sr_max

        Where:
            * ``sr`` is the angular speed of the gimbal in deg per second [deg/s]
            * ``sr_min``, ``sr_max`` are the limits for the rotation speed [deg/s]

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_general_state(self):
        &#34;&#34;&#34;Retrieve general state information of the gimbal.

        Returns:
            tuple: where the first element is an integer where the bits represent each state, and
                the second element is an array of True/False flags for each state described in
                Gimbal
                Controller API, section 2.5.6.

            None: when an Exception was raised and logs the error message.

        .. note:: This is equivalent to the STATE#GIMBAL? Command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_actuator_state(self):
        &#34;&#34;&#34;Retreive general state information of the actuators.

        For each of the two actuators, an integer value is returned that should be interpreted as a
        bit field containing status bits for that actuator.

            ======   ========================
             Bit      Function
            ======   ========================
              0       In position
              1       Control loop on servo motors active
              2       Homing done
              3       Input &#34;Home Switch&#34;
              4       Input &#34;Positive limit switch&#34;
              5       Input &#34;Negative limit switch&#34;
              6       Brake control output
              7       Following error (warning)
              8       Following error (Fatal)
              9       Actuator out of bounds error
             10       Amplifier error
             11       Encoder error
             12       Phasing error (brushless engine only)
             13-23    Reserved
            ======   ========================

        Returns:
            array: an array of two (2) dictionaries with True/False flags for each actuator state
            as described in
                Gimbal Controller API, section 2.5.5.
            None: when an Exception was raised and logs the error message.

        .. note:: This is equivalent to the STATE#ACTUATOR? Command.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def goto_specific_position(self, pos):
        &#34;&#34;&#34;Ask to go to a specific position.

        * pos=0 Machine zero position (jog &amp; maintenance only!)
        * pos=1 Unused (not valid for the Gimbal)
        * pos=2 User zero position (with offsets)

        Returns:
            0 on success, -1 when ignored, -2 for an invalid movement command

        Raises:
            GimbalError: when there is Time-Out or when there is a communication error with the
            gimbal controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def goto_zero_position(self):
        &#34;&#34;&#34;Ask the gimbal to go to the user zero position.

        Returns:
            0 on success, -1 when ignored, -2 for an invalid movement command

        Raises:
            GimbalError: when there is Time-Out or when there is a socket communication error.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_homing_done(self):
        &#34;&#34;&#34;
        Check if Homing is done. This method checks the ``Q26`` variable.
        When this variable indicates &#39;Homing is done&#39; it means the command has properly been
        executed,
        but it doesn&#39;t mean the Gimbal is in position. The gimbal might still be moving to its
        zero position.

        Returns:
            True when the homing is done, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_in_position(self):
        &#34;&#34;&#34;
        Checks if the actuators are in position.

        This method queries the Q36 variable and examines the third bit which is the &#39;Is
        Position&#39; bit.
        This method does **not** query the actuator state variables Q30 till Q36.

        Returns:
            True when in position, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def perform_maintenance(self, axis):
        &#34;&#34;&#34;Perform a maintenance cycle which consists to travel the full range
        on one axis corresponding to the Gimbal machine limits. The movement is
        also in machine coordinate system.

        Undocumented. Ask Symetrie.

        Args:
            axis (int): on which axis the full range movement is executed
        Returns:
            0 on success, -1 when ignored for non-compliance.
        Raises:
            GimbalError: when there is Time-Out or when there is a socket communication error.
        &#34;&#34;&#34;
        raise NotImplementedError

    def log_positions(self):
        &#34;&#34;&#34;
        Log the current position of the gimbal (level=INFO). The positions correspond to

          * the position of the object in the User Coordinate System, and
          * the position of the gimbal in the Machine Coordinate System.

        &#34;&#34;&#34;

        pos = self.get_user_positions()
        logger.info(
            f&#34;Object [in User]     : &#34;
            f&#34;{pos[0]:2.5f}, {pos[1]:2.5f}&#34;
        )

        pos = self.get_machine_positions()
        logger.info(
            f&#34;Platform [in Machine]: &#34;
            f&#34;{pos[0]:2.5f}, {pos[1]:2.5f}&#34;
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.gimbal.symetrie.gimbal.GimbalInterface" href="gimbal.html#egse.gimbal.symetrie.gimbal.GimbalInterface">GimbalInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.activate_control_loop"><code class="name flex">
<span>def <span class="ident">activate_control_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Activates the control loop on motors.</p>
<h2 id="returns">Returns</h2>
<p>0 on success, -1 when ignored, -2 on error.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is a time out or when there is a communication error with</dd>
</dl>
<p>the gimbal
hardware controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def activate_control_loop(self):
    &#34;&#34;&#34;Activates the control loop on motors.

    Returns:
        0 on success, -1 when ignored, -2 on error.
    Raises:
        GimbalError: when there is a time out or when there is a communication error with
        the gimbal
            hardware controller.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.check_absolute_movement"><code class="name flex">
<span>def <span class="ident">check_absolute_movement</span></span>(<span>self, grx, gry)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the requested gimbal movement is valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>gry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>where the first element is an integer that represents the
bitfield encoding the errors. The second element is a dictionary
with the bit numbers that were (on) and the corresponding error
description.</dd>
</dl>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>either provide a more user friendly return value or a method/function
to process the information into a human readable form. Also update
the documentation of this method with more information about the
bitfields etc.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def check_absolute_movement(self, grx, gry):
    &#34;&#34;&#34;Check if the requested gimbal movement is valid.

    Args:
        grx (float): rotation around the X-axis [deg]
        gry (float): rotation around the Y-axis [deg]

    Returns:
        tuple: where the first element is an integer that represents the
            bitfield encoding the errors. The second element is a dictionary
            with the bit numbers that were (on) and the corresponding error
            description.

    .. todo:: either provide a more user friendly return value or a method/function
              to process the information into a human readable form. Also update
              the documentation of this method with more information about the
              bitfields etc.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.check_relative_movement"><code class="name flex">
<span>def <span class="ident">check_relative_movement</span></span>(<span>self, grx, gry)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the requested object movement is valid.</p>
<p>The relative motion is expressed in the object coordinate system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>gry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>where the first element is an integer that represents the
bitfield encoding the errors. The second element is a dictionary
with the bit numbers that were (on) and the corresponding error
description.</dd>
</dl>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>either provide a more user friendly return value or a method/function
to process the information into a human readable form. Also update
the documentation of this method with more information about the
bitfields etc.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def check_relative_movement(self, grx, gry):
    &#34;&#34;&#34;Check if the requested object movement is valid.

    The relative motion is expressed in the object coordinate system.

    Args:
        grx (float): rotation around the X-axis [deg]
        gry (float): rotation around the Y-axis [deg]

    Returns:
        tuple: where the first element is an integer that represents the
            bitfield encoding the errors. The second element is a dictionary
            with the bit numbers that were (on) and the corresponding error
            description.

    .. todo:: either provide a more user friendly return value or a method/function
              to process the information into a human readable form. Also update
              the documentation of this method with more information about the
              bitfields etc.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.clear_error"><code class="name flex">
<span>def <span class="ident">clear_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all errors in the controller software.</p>
<h2 id="returns">Returns</h2>
<p>0 on success.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is Time-Out or when there is a communication error with the</dd>
</dl>
<p>gimbal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def clear_error(self):
    &#34;&#34;&#34;Clear all errors in the controller software.

    Returns:
        0 on success.
    Raises:
        GimbalError: when there is Time-Out or when there is a communication error with the
        gimbal.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.configure_offsets"><code class="name flex">
<span>def <span class="ident">configure_offsets</span></span>(<span>self, grx, gry)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the definition of offsets. This is the Gimbal's equivalent of changing the
PUNA's coordinate system.</p>
<p>The parameters grx and gry are used to define axes offsets. The position with
offset is named Position or User position. The position without offset is named
Machine position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grx</code></strong> :&ensp;<code>float</code></dt>
<dd>offset on the Rx axis [deg]</dd>
<dt><strong><code>gry</code></strong> :&ensp;<code>float</code></dt>
<dd>offset on the Ry axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success and -1 when the configuration is ignored, e.g. when password protection
is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def configure_offsets(self, grx, gry):
    &#34;&#34;&#34;
    Changes the definition of offsets. This is the Gimbal&#39;s equivalent of changing the
    PUNA&#39;s coordinate system.

    The parameters grx and gry are used to define axes offsets. The position with
    offset is named Position or User position. The position without offset is named
    Machine position.

    Args:
        grx (float): offset on the Rx axis [deg]
        gry (float): offset on the Ry axis [deg]

    Returns:
        0 on success and -1 when the configuration is ignored, e.g. when password protection
        is enabled.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop"><code class="name flex">
<span>def <span class="ident">deactivate_control_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables the control loop on the servo motors.</p>
<h2 id="returns">Returns</h2>
<p>0 on success.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is a time out or when there is a communication error with</dd>
</dl>
<p>the gimbal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def deactivate_control_loop(self):
    &#34;&#34;&#34;Disables the control loop on the servo motors.

    Returns:
        0 on success.
    Raises:
        GimbalError: when there is a time out or when there is a communication error with
        the gimbal.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_actuator_length"><code class="name flex">
<span>def <span class="ident">get_actuator_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the current length of the gimbal actuators.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>an array of 2 float values for actuator length L1 to L2 in [mm], and
None: when an Exception was raised and logs the error message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_actuator_length(self):
    &#34;&#34;&#34;Retrieve the current length of the gimbal actuators.

    Returns:
        array: an array of 2 float values for actuator length L1 to L2 in [mm], and \
        None: when an Exception was raised and logs the error message.
    &#34;&#34;&#34;

    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_actuator_state"><code class="name flex">
<span>def <span class="ident">get_actuator_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retreive general state information of the actuators.</p>
<p>For each of the two actuators, an integer value is returned that should be interpreted as a
bit field containing status bits for that actuator.</p>
<pre><code>======   ========================
 Bit      Function
======   ========================
  0       In position
  1       Control loop on servo motors active
  2       Homing done
  3       Input "Home Switch"
  4       Input "Positive limit switch"
  5       Input "Negative limit switch"
  6       Brake control output
  7       Following error (warning)
  8       Following error (Fatal)
  9       Actuator out of bounds error
 10       Amplifier error
 11       Encoder error
 12       Phasing error (brushless engine only)
 13-23    Reserved
======   ========================
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>an array of two (2) dictionaries with True/False flags for each actuator state</dd>
<dt>as described in</dt>
<dt>Gimbal Controller API, section 2.5.5.</dt>
<dt><code>None</code></dt>
<dd>when an Exception was raised and logs the error message.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is equivalent to the STATE#ACTUATOR? Command.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_actuator_state(self):
    &#34;&#34;&#34;Retreive general state information of the actuators.

    For each of the two actuators, an integer value is returned that should be interpreted as a
    bit field containing status bits for that actuator.

        ======   ========================
         Bit      Function
        ======   ========================
          0       In position
          1       Control loop on servo motors active
          2       Homing done
          3       Input &#34;Home Switch&#34;
          4       Input &#34;Positive limit switch&#34;
          5       Input &#34;Negative limit switch&#34;
          6       Brake control output
          7       Following error (warning)
          8       Following error (Fatal)
          9       Actuator out of bounds error
         10       Amplifier error
         11       Encoder error
         12       Phasing error (brushless engine only)
         13-23    Reserved
        ======   ========================

    Returns:
        array: an array of two (2) dictionaries with True/False flags for each actuator state
        as described in
            Gimbal Controller API, section 2.5.5.
        None: when an Exception was raised and logs the error message.

    .. note:: This is equivalent to the STATE#ACTUATOR? Command.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_debug_info"><code class="name flex">
<span>def <span class="ident">get_debug_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Request debug information from the Gimbal Controller.</p>
<p>The method returns four values that represent the following status:</p>
<ol>
<li><code>Homing</code>: state of the homing</li>
<li><code>PosRef</code>: state of the Position Reference command</li>
<li><code>KinError</code>: error in kinematic calculation</li>
<li><code>Panel</code>: Panel state</li>
</ol>
<p>Note many of these codes overlap PUNA's debug codes. These have been
thoroughly reviewed before defining the interface.</p>
<p>The Homing can take the following values:</p>
<pre><code>=====     ==================
Value     Meaning
=====     ==================
0         Undefined
1         Homing in progress
2         Homing done
3         Error
=====     ==================
</code></pre>
<p>The PosRef can take the following values:</p>
<pre><code>=======     =====================
 Value       Meaning
=======     =====================
   0         Undefined
   1         Abort input error
   2         Movement in progress
   3         Position reached
   4         Error
=======     =====================
</code></pre>
<p>The KinError can take the following values:</p>
<pre><code>=======     ===============================================
 Value       Meaning
=======     ===============================================
   0         none
   1         Homing not done
   2         Inverse kinematic model (MGI) – workspace
   3         Inverse kinematic model (MGI) – joint angle
   4         Forward kinematic model (MGD) – workspace
   5         Forward kinematic model (MGD) – max iteration
   6         Position calculation (PLCC) – workspace
   7         Position calculation (PLCC) – max iteration.
=======     ===============================================
</code></pre>
<p>The Panel status can take the following values:</p>
<pre><code>======   ===============
Index       Command
======   ===============
-2       Command error
-1       Ignored / Command not allowed
**0**       **None**
1        Homing
2        Stop
3        Control ON
4        Control OFF
10       Valid POS
11       Move
12       Sequence
13       Specific POS
15       Clear Error
  **Family “Set config”**
------------------------
21       Config CS
22       Config Limits_mTn
23       Config Limits_uTo
24       Config Limits_Enabled
25       Config Speed
26       Config Current
27       Config Backlash
  **Family “Get config”**
------------------------
31       Config CS
32       Config Limits_mTn
33       Config Limits_uTo
34       Config Limits_Enabled
35       Config Speed
36       Config Current
37       Config Backlash
  **Family “Maintenance”**
------------------------
41       Jog
50       Config Save
51       Config Default
52       Config Saved?
55       Version
======   ===============
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_debug_info(self):
    &#34;&#34;&#34;
    Request debug information from the Gimbal Controller.

    The method returns four values that represent the following status:

    1. ``Homing``: state of the homing
    2. ``PosRef``: state of the Position Reference command
    3. ``KinError``: error in kinematic calculation
    4. ``Panel``: Panel state

    Note many of these codes overlap PUNA&#39;s debug codes. These have been
    thoroughly reviewed before defining the interface.

    The Homing can take the following values:

        =====     ==================
        Value     Meaning
        =====     ==================
        0         Undefined
        1         Homing in progress
        2         Homing done
        3         Error
        =====     ==================

    The PosRef can take the following values:

        =======     =====================
         Value       Meaning
        =======     =====================
           0         Undefined
           1         Abort input error
           2         Movement in progress
           3         Position reached
           4         Error
        =======     =====================

    The KinError can take the following values:

        =======     ===============================================
         Value       Meaning
        =======     ===============================================
           0         none
           1         Homing not done
           2         Inverse kinematic model (MGI) – workspace
           3         Inverse kinematic model (MGI) – joint angle
           4         Forward kinematic model (MGD) – workspace
           5         Forward kinematic model (MGD) – max iteration
           6         Position calculation (PLCC) – workspace
           7         Position calculation (PLCC) – max iteration.
        =======     ===============================================

    The Panel status can take the following values:

        ======   ===============
        Index       Command
        ======   ===============
        -2       Command error
        -1       Ignored / Command not allowed
        **0**       **None**
        1        Homing
        2        Stop
        3        Control ON
        4        Control OFF
        10       Valid POS
        11       Move
        12       Sequence
        13       Specific POS
        15       Clear Error
          **Family “Set config”**
        ------------------------
        21       Config CS
        22       Config Limits_mTn
        23       Config Limits_uTo
        24       Config Limits_Enabled
        25       Config Speed
        26       Config Current
        27       Config Backlash
          **Family “Get config”**
        ------------------------
        31       Config CS
        32       Config Limits_mTn
        33       Config Limits_uTo
        34       Config Limits_Enabled
        35       Config Speed
        36       Config Current
        37       Config Backlash
          **Family “Maintenance”**
        ------------------------
        41       Jog
        50       Config Save
        51       Config Default
        52       Config Saved?
        55       Version
        ======   ===============

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_general_state"><code class="name flex">
<span>def <span class="ident">get_general_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve general state information of the gimbal.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>where the first element is an integer where the bits represent each state, and
the second element is an array of True/False flags for each state described in
Gimbal
Controller API, section 2.5.6.</dd>
<dt><code>None</code></dt>
<dd>when an Exception was raised and logs the error message.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is equivalent to the STATE#GIMBAL? Command.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_general_state(self):
    &#34;&#34;&#34;Retrieve general state information of the gimbal.

    Returns:
        tuple: where the first element is an integer where the bits represent each state, and
            the second element is an array of True/False flags for each state described in
            Gimbal
            Controller API, section 2.5.6.

        None: when an Exception was raised and logs the error message.

    .. note:: This is equivalent to the STATE#GIMBAL? Command.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_machine_positions"><code class="name flex">
<span>def <span class="ident">get_machine_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retreive the current position of the gimbal.</p>
<p>Asks the current position of the gimbal. Position returned corresponds to the
machine position (position without offsets).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>an array of two float values for grx, gry</dd>
<dt><code>None</code></dt>
<dd>when a PMACError was raised and logs the error message.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is equivalent to the POSMACH? command.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_machine_positions(self):
    &#34;&#34;&#34;Retreive the current position of the gimbal.

    Asks the current position of the gimbal. Position returned corresponds to the
    machine position (position without offsets).

    Returns:
        array: an array of two float values for grx, gry
        None: when a PMACError was raised and logs the error message.

    .. note:: This is equivalent to the POSMACH? command.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_motor_temperatures"><code class="name flex">
<span>def <span class="ident">get_motor_temperatures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retreive the current temperatures of the Gimbal motors.</p>
<p>Asks the current temperatures of the motors as measured by their
corresponding thermocouples. Results are in Celsius.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>an array of two float values for grx, gry</dd>
<dt><code>None</code></dt>
<dd>when a PMACError was raised and logs the error message.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is equivalent to the STATE#AI? command.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_motor_temperatures(self):
    &#34;&#34;&#34;Retreive the current temperatures of the Gimbal motors.

    Asks the current temperatures of the motors as measured by their
    corresponding thermocouples. Results are in Celsius.

    Returns:
        array: an array of two float values for grx, gry
        None: when a PMACError was raised and logs the error message.

    .. note:: This is equivalent to the STATE#AI? command.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_offsets"><code class="name flex">
<span>def <span class="ident">get_offsets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the definition of the gimbal offsets.</p>
<h2 id="returns">Returns</h2>
<p>grx and gry in [deg].</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when an error occurred while trying to retrieve the information.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_offsets(self):
    &#34;&#34;&#34;Retrieve the definition of the gimbal offsets.

    Returns:
        grx and gry in [deg].
    Raises:
        GimbalError: when an error occurred while trying to retrieve the information.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_speed"><code class="name flex">
<span>def <span class="ident">get_speed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the configuration of the movement speed.</p>
<h2 id="returns">Returns</h2>
<p>sr, sr_min, sr_max</p>
<h2 id="where">Where</h2>
<ul>
<li><code>sr</code> is the angular speed of the gimbal in deg per second [deg/s]</li>
<li><code>sr_min</code>, <code>sr_max</code> are the limits for the rotation speed [deg/s]</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_speed(self):
    &#34;&#34;&#34;Retrieve the configuration of the movement speed.

    Returns:
        sr, sr_min, sr_max

    Where:
        * ``sr`` is the angular speed of the gimbal in deg per second [deg/s]
        * ``sr_min``, ``sr_max`` are the limits for the rotation speed [deg/s]

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_user_positions"><code class="name flex">
<span>def <span class="ident">get_user_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retreive the current position of the gimbal.</p>
<p>Asks the current position of the gimbal. Position returned corresponds to the
user position (position with offsets).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>an array of two float values for grx, gry</dd>
<dt><code>None</code></dt>
<dd>when an Exception was raised and logs the error message.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is equivalent to the POSUSER? command.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_user_positions(self):
    &#34;&#34;&#34;Retreive the current position of the gimbal.

    Asks the current position of the gimbal. Position returned corresponds to the
    user position (position with offsets).

    Returns:
        array: an array of two float values for grx, gry
        None: when an Exception was raised and logs the error message.

    .. note:: This is equivalent to the POSUSER? command.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.goto_specific_position"><code class="name flex">
<span>def <span class="ident">goto_specific_position</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask to go to a specific position.</p>
<ul>
<li>pos=0 Machine zero position (jog &amp; maintenance only!)</li>
<li>pos=1 Unused (not valid for the Gimbal)</li>
<li>pos=2 User zero position (with offsets)</li>
</ul>
<h2 id="returns">Returns</h2>
<p>0 on success, -1 when ignored, -2 for an invalid movement command</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is Time-Out or when there is a communication error with the</dd>
</dl>
<p>gimbal controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def goto_specific_position(self, pos):
    &#34;&#34;&#34;Ask to go to a specific position.

    * pos=0 Machine zero position (jog &amp; maintenance only!)
    * pos=1 Unused (not valid for the Gimbal)
    * pos=2 User zero position (with offsets)

    Returns:
        0 on success, -1 when ignored, -2 for an invalid movement command

    Raises:
        GimbalError: when there is Time-Out or when there is a communication error with the
        gimbal controller.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.goto_zero_position"><code class="name flex">
<span>def <span class="ident">goto_zero_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask the gimbal to go to the user zero position.</p>
<h2 id="returns">Returns</h2>
<p>0 on success, -1 when ignored, -2 for an invalid movement command</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is Time-Out or when there is a socket communication error.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def goto_zero_position(self):
    &#34;&#34;&#34;Ask the gimbal to go to the user zero position.

    Returns:
        0 on success, -1 when ignored, -2 for an invalid movement command

    Raises:
        GimbalError: when there is Time-Out or when there is a socket communication error.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.homing"><code class="name flex">
<span>def <span class="ident">homing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the homing cycle for the Gimbal.</p>
<p>Homing is required before performing a control movement. Without absolute encoders,
the homing is performed with a gimbal movement until detecting the reference sensor
on each of the actuators. The Gimbal will go to a position were the sensors are
reached that signal a known calibrated position and then returns to the zero position.</p>
<p>Whenever a homing is performed, the method will return before the actual movement
is finished.</p>
<p>The homing cycle takes about two minutes to complete, but the <code>homing()</code> method
returns almost immediately. Therefore, to check if the homing is finished, use
the is_homing_done() method.</p>
<h2 id="returns">Returns</h2>
<p>0 on success.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is a time out or when there is a communication error with</dd>
</dl>
<p>the gimbal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def homing(self):
    &#34;&#34;&#34;Start the homing cycle for the Gimbal.

    Homing is required before performing a control movement. Without absolute encoders,
    the homing is performed with a gimbal movement until detecting the reference sensor
    on each of the actuators. The Gimbal will go to a position were the sensors are
    reached that signal a known calibrated position and then returns to the zero position.

    Whenever a homing is performed, the method will return before the actual movement
    is finished.

    The homing cycle takes about two minutes to complete, but the ``homing()`` method
    returns almost immediately. Therefore, to check if the homing is finished, use
    the is_homing_done() method.

    Returns:
        0 on success.
    Raises:
        GimbalError: when there is a time out or when there is a communication error with
        the gimbal.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns basic information about the gimbal and the controller.</p>
<h2 id="returns">Returns</h2>
<p>a multiline response message containing the device info.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when information can not be retrieved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def info(self):
    &#34;&#34;&#34;Returns basic information about the gimbal and the controller.

    Returns:
        a multiline response message containing the device info.
    Raises:
        GimbalError: when information can not be retrieved.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.is_homing_done"><code class="name flex">
<span>def <span class="ident">is_homing_done</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if Homing is done. This method checks the <code>Q26</code> variable.
When this variable indicates 'Homing is done' it means the command has properly been
executed,
but it doesn't mean the Gimbal is in position. The gimbal might still be moving to its
zero position.</p>
<h2 id="returns">Returns</h2>
<p>True when the homing is done, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def is_homing_done(self):
    &#34;&#34;&#34;
    Check if Homing is done. This method checks the ``Q26`` variable.
    When this variable indicates &#39;Homing is done&#39; it means the command has properly been
    executed,
    but it doesn&#39;t mean the Gimbal is in position. The gimbal might still be moving to its
    zero position.

    Returns:
        True when the homing is done, False otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.is_in_position"><code class="name flex">
<span>def <span class="ident">is_in_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the actuators are in position.</p>
<p>This method queries the Q36 variable and examines the third bit which is the 'Is
Position' bit.
This method does <strong>not</strong> query the actuator state variables Q30 till Q36.</p>
<h2 id="returns">Returns</h2>
<p>True when in position, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def is_in_position(self):
    &#34;&#34;&#34;
    Checks if the actuators are in position.

    This method queries the Q36 variable and examines the third bit which is the &#39;Is
    Position&#39; bit.
    This method does **not** query the actuator state variables Q30 till Q36.

    Returns:
        True when in position, False otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.jog"><code class="name flex">
<span>def <span class="ident">jog</span></span>(<span>self, axis: int, inc: float) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a JOG-type movement on the specified actuator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a maintenance feature.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>number of the actuator (1 to 2)</dd>
<dt><strong><code>inc</code></strong> :&ensp;<code>float</code></dt>
<dd>increment to achieve in [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success, -1 if command was ignored due to non-compliance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is a time out or when there is a communication error with</dd>
</dl>
<p>the gimbal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def jog(self, axis: int, inc: float) -&gt; int:
    &#34;&#34;&#34;Perform a JOG-type movement on the specified actuator.

    .. note::
        This is a maintenance feature.

    Args:
        axis (int): number of the actuator (1 to 2)
        inc (float): increment to achieve in [deg]
    Returns:
        0 on success, -1 if command was ignored due to non-compliance.
    Raises:
        GimbalError: when there is a time out or when there is a communication error with
        the gimbal.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.log_positions"><code class="name flex">
<span>def <span class="ident">log_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Log the current position of the gimbal (level=INFO). The positions correspond to</p>
<ul>
<li>the position of the object in the User Coordinate System, and</li>
<li>the position of the gimbal in the Machine Coordinate System.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_positions(self):
    &#34;&#34;&#34;
    Log the current position of the gimbal (level=INFO). The positions correspond to

      * the position of the object in the User Coordinate System, and
      * the position of the gimbal in the Machine Coordinate System.

    &#34;&#34;&#34;

    pos = self.get_user_positions()
    logger.info(
        f&#34;Object [in User]     : &#34;
        f&#34;{pos[0]:2.5f}, {pos[1]:2.5f}&#34;
    )

    pos = self.get_machine_positions()
    logger.info(
        f&#34;Platform [in Machine]: &#34;
        f&#34;{pos[0]:2.5f}, {pos[1]:2.5f}&#34;
    )</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.move_absolute"><code class="name flex">
<span>def <span class="ident">move_absolute</span></span>(<span>self, grx, gry)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates the gimbal in both axes, absolute coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>gry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>return_code</code></dt>
<dd>0 on success, -1 when ignored, -2 on error</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when the arguments do not match up, or when there is a time out or when</dd>
</dl>
<p>there is a
socket communication error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the command was not successful, this method will query the
POSVALID? using the checkAbsolutePosition() and print a summary
of the error messages to the log file.</p>
</div>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>do we want to check if the movement is valid before actually performing
the movement?</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def move_absolute(self, grx, gry):
    &#34;&#34;&#34;Rotates the gimbal in both axes, absolute coordinates.

    Args:
        grx (float): rotation around the X-axis [deg]
        gry (float): rotation around the Y-axis [deg]

    Returns:
        return_code: 0 on success, -1 when ignored, -2 on error

    Raises:
        GimbalError: when the arguments do not match up, or when there is a time out or when
        there is a
        socket communication error.

    .. note::
       When the command was not successful, this method will query the
       POSVALID? using the checkAbsolutePosition() and print a summary
       of the error messages to the log file.

    .. todo::
       do we want to check if the movement is valid before actually performing
       the movement?

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.move_relative"><code class="name flex">
<span>def <span class="ident">move_relative</span></span>(<span>self, grx, gry)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the gimbal relative to its current position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>grx</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the X-axis [deg]</dd>
<dt><strong><code>gry</code></strong> :&ensp;<code>float</code></dt>
<dd>rotation around the Y-axis [deg]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success, -1 when ignored, -2 on error.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when the arguments do not match up, or when there is a time out or when</dd>
</dl>
<p>there is a
socket communication error.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>do we want to check if the movement is valid before actually performing
the movement?</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def move_relative(self, grx, gry):
    &#34;&#34;&#34;Move the gimbal relative to its current position.

    Args:
        grx (float): rotation around the X-axis [deg]
        gry (float): rotation around the Y-axis [deg]

    Returns:
        0 on success, -1 when ignored, -2 on error.

    Raises:
        GimbalError: when the arguments do not match up, or when there is a time out or when
        there is a
        socket communication error.

    .. todo:: do we want to check if the movement is valid before actually performing
              the movement?

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.perform_maintenance"><code class="name flex">
<span>def <span class="ident">perform_maintenance</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a maintenance cycle which consists to travel the full range
on one axis corresponding to the Gimbal machine limits. The movement is
also in machine coordinate system.</p>
<p>Undocumented. Ask Symetrie.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>on which axis the full range movement is executed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success, -1 when ignored for non-compliance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is Time-Out or when there is a socket communication error.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def perform_maintenance(self, axis):
    &#34;&#34;&#34;Perform a maintenance cycle which consists to travel the full range
    on one axis corresponding to the Gimbal machine limits. The movement is
    also in machine coordinate system.

    Undocumented. Ask Symetrie.

    Args:
        axis (int): on which axis the full range movement is executed
    Returns:
        0 on success, -1 when ignored for non-compliance.
    Raises:
        GimbalError: when there is Time-Out or when there is a socket communication error.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, wait=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely resets the Gimbal hardware controller with the standard boot cycle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>after the reset command has been sent to the controller, wait
for 30 seconds which should complete the cycle, i.e. this command will
only return after 30 seconds.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This command is equivalent to power cycling the controller manually.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def reset(self, wait=True):
    &#34;&#34;&#34;Completely resets the Gimbal hardware controller with the standard boot cycle.

    Args:
        wait (bool): after the reset command has been sent to the controller, wait
            for 30 seconds which should complete the cycle, i.e. this command will
            only return after 30 seconds.

    .. Note::
       This command is equivalent to power cycling the controller manually.

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.set_speed"><code class="name flex">
<span>def <span class="ident">set_speed</span></span>(<span>self, sr)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the speed of the gimbal movements.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sr</code></strong> :&ensp;<code>float</code></dt>
<dd>The angular speed, expressed in deg per second [deg/s].</dd>
</dl>
<p>The argument sr is automatically limited by the controller between the
minimum and maximum speeds allowed for the gimbal.</p>
<h2 id="returns">Returns</h2>
<p>0 on success and -1 when the configuration is ignored, e.g. when password protection
is enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_speed(self, sr):
    &#34;&#34;&#34;Set the speed of the gimbal movements.

    Args:
        sr (float): The angular speed, expressed in deg per second [deg/s].

    The argument sr is automatically limited by the controller between the
    minimum and maximum speeds allowed for the gimbal.

    Returns:
        0 on success and -1 when the configuration is ignored, e.g. when password protection
        is enabled.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.gimbal.symetrie.alpha.AlphaControllerInterface.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the current motion. This command can be send during a motion of the Gimbal.</p>
<h2 id="returns">Returns</h2>
<p>0 on success.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GimbalError</code></dt>
<dd>when there is a time out or when there is a communication error with</dd>
</dl>
<p>the gimbal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def stop(self):
    &#34;&#34;&#34;Stop the current motion. This command can be send during a motion of the Gimbal.

    Returns:
        0 on success.
    Raises:
        GimbalError: when there is a time out or when there is a communication error with
        the gimbal.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.gimbal.symetrie" href="index.html">egse.gimbal.symetrie</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface">AlphaControllerInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.activate_control_loop" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.activate_control_loop">activate_control_loop</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.check_absolute_movement" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.check_absolute_movement">check_absolute_movement</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.check_relative_movement" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.check_relative_movement">check_relative_movement</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.clear_error" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.configure_offsets" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.configure_offsets">configure_offsets</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.deactivate_control_loop">deactivate_control_loop</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_actuator_length" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_actuator_length">get_actuator_length</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_actuator_state" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_actuator_state">get_actuator_state</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_debug_info" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_debug_info">get_debug_info</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_general_state" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_general_state">get_general_state</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_machine_positions" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_machine_positions">get_machine_positions</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_motor_temperatures" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_motor_temperatures">get_motor_temperatures</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_offsets" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_offsets">get_offsets</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_speed" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_speed">get_speed</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_user_positions" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.get_user_positions">get_user_positions</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.goto_specific_position" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.goto_specific_position">goto_specific_position</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.goto_zero_position" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.goto_zero_position">goto_zero_position</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.homing" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.homing">homing</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.info" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.info">info</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.is_homing_done" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.is_homing_done">is_homing_done</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.is_in_position" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.jog" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.jog">jog</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.log_positions" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.log_positions">log_positions</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.move_absolute" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.move_absolute">move_absolute</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.move_relative" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.move_relative">move_relative</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.perform_maintenance" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.perform_maintenance">perform_maintenance</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.reset" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.reset">reset</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.set_speed" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.set_speed">set_speed</a></code></li>
<li><code><a title="egse.gimbal.symetrie.alpha.AlphaControllerInterface.stop" href="#egse.gimbal.symetrie.alpha.AlphaControllerInterface.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
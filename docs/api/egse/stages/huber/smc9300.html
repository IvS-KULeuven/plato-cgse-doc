<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.stages.huber.smc9300 API documentation</title>
<meta name="description" content="This module defines the device classes to be used to connect to and control the HUBER Stages." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.stages.huber.smc9300</code></h1>
</header>
<section id="section-intro">
<p>This module defines the device classes to be used to connect to and control the HUBER Stages.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the device classes to be used to connect to and control the HUBER Stages.
&#34;&#34;&#34;
import logging
import random
import time

from egse.decorators import dynamic_interface
from egse.decorators import to_be_implemented
from egse.device import DeviceConnectionState
from egse.device import DeviceInterface
from egse.proxy import Proxy
from egse.settings import Settings
from egse.setup import load_setup
from egse.stages import StagesError
from egse.stages.huber.smc9300_devif import HuberError
from egse.stages.huber.smc9300_devif import HuberSMC9300EthernetInterface
from egse.stages.huber.smc9300_devif import cmd_cerr
from egse.stages.huber.smc9300_devif import cmd_ffast
from egse.stages.huber.smc9300_devif import cmd_goto
from egse.stages.huber.smc9300_devif import cmd_move
from egse.stages.huber.smc9300_devif import cmd_q_configuration
from egse.stages.huber.smc9300_devif import cmd_q_e
from egse.stages.huber.smc9300_devif import cmd_q_ec
from egse.stages.huber.smc9300_devif import cmd_q_error
from egse.stages.huber.smc9300_devif import cmd_q_pos
from egse.stages.huber.smc9300_devif import cmd_q_state
from egse.stages.huber.smc9300_devif import cmd_q_status
from egse.stages.huber.smc9300_devif import cmd_q_system_info
from egse.stages.huber.smc9300_devif import cmd_q_version
from egse.stages.huber.smc9300_devif import cmd_quit
from egse.stages.huber.smc9300_devif import cmd_zero
from egse.zmq_ser import connect_address

logger = logging.getLogger(__name__)

HC_SETTINGS = Settings.load(&#34;Huber Controller&#34;)
CTRL_SETTINGS = Settings.load(&#34;Huber Control Server&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;smc9300.yaml&#34;)


class HuberSMC9300Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Controller, Simulator and Proxy classes for this device.
    &#34;&#34;&#34;

    @dynamic_interface
    def info(self):
        &#34;&#34;&#34;
        Retrieve basic information about the Huber Stages and the Controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_configuration(self, axis):
        &#34;&#34;&#34;
        Get description for the given axis.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_conf_value(self, axis, name):
        conf = self.get_configuration(axis)
        return conf[name] if name in conf else None

    @dynamic_interface
    def get_version(self):
        &#34;&#34;&#34;
        Get version information about the current control program.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def goto(self, axis: int, position: float, wait: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Move the stage to the given absolute position.

        A positive angle moves the rotation stage counter clockwise.

        Args:
            axis (int): the integer identifier of one of the axis controlled by the SMC
            position (float): when the given axis is a rotation stage, the position is given
                in degrees [deg], for a translation stage, the position is given
                in millimeter [mm].
            wait (bool): if True, the method only returns when the device is in position
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def move(self, axis: int, distance: float) -&gt; None:
        &#34;&#34;&#34;
        Move the stage relative to the current position in the given distance.

        A positive angle moves the rotation stage counter clockwise.

        :param int axis: the integer identifier of one of the axis controlled by the SMC
        :param float distance: when the given axis is a rotation stage, the distance is given
            in degrees [deg], for a translation stage, the distance is given
            in millimeter [mm].
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_slew_speed(self, axis, speed):
        &#34;&#34;&#34;
        Configure the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.

        Manual positioning commands are i.e. ``fast``, ``move``, ``goto``, or
        the use of the direction keys.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_slew_speed(self, axis):
        &#34;&#34;&#34;
        Returns the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_in_position(self, axis):
        &#34;&#34;&#34;
        Returns True if the mechanism is in position and not moving.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_current_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current position for this axis as a float.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_current_encoder_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current encoder position for this axis as a float.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_current_encoder_counter_value(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the current encoder counter value for this axis as an int.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_error(self, axis):
        &#34;&#34;&#34;
        Returns the last occured error and corresponding error message for the given axis.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def clear_error(self, axis):
        &#34;&#34;&#34;
        Reset the last occured error and clear the error message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def quit(self):
        &#34;&#34;&#34;
        Immediately stop any positioning process.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_state(self, axis) -&gt; int:
        raise NotImplementedError

    @dynamic_interface
    def get_status(self, axis):
        raise NotImplementedError

    @dynamic_interface
    def zero(self, axis):
        &#34;&#34;&#34;
        Set the current position of the axis to zero (0.00). If a reference position
        offset value is configured (see the configuration command ``rofs``) the current
        position is set to that reference offset value.
        &#34;&#34;&#34;
        raise NotImplementedError


class HuberSMC9300Controller(HuberSMC9300Interface):
    &#34;&#34;&#34;
    The HuberSmC9300Controller class is used to directly communicate with the HUBER SMC9300
    Controller through an Ethernet interface.
    &#34;&#34;&#34;

    def __init__(self, hostname=HC_SETTINGS.HOSTNAME, port=HC_SETTINGS.PORT):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the HUBER SMC9300 Hardware Controller.

        Args:
            hostname (str): the IP address or fully qualified hostname of the HUBER hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the `settings.yaml`
                configuration file.

        Raises:
            StagesError: when the connection could not be established for some reason.
        &#34;&#34;&#34;
        super().__init__()

        logger.debug(f&#34;Initializing HuberSMC9300Controller with hostname={hostname} on port={port}&#34;)

        try:
            self.huber = HuberSMC9300EthernetInterface()
            self.huber.setConnectionParameters(hostname, port)
        except HuberError as exc:
            logger.warning(f&#34;HuberError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise StagesError(&#34;Couldn&#39;t establish a connection with the HUBER Stage.&#34;) from exc

        self._number_of_axes = HC_SETTINGS.NUMBER_OF_AXES

    def connect(self):
        try:
            self.huber.connect()

            # set the speed of each of the stages to the default speed from the Settings.

            for stage in 1, 2, 3:
                default_speed = HC_SETTINGS.DEFAULT_SPEED[stage - 1]
                self.set_slew_speed(stage, default_speed)

        except HuberError as exc:
            logger.warning(f&#34;HuberError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the HUBER Stage.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        try:
            # Clear the error for each of the axis before disconnecting
            for axis in range(1, self._number_of_axes + 1):
                self.clear_error(axis)
            self.huber.disconnect()
        except HuberError as exc:
            raise ConnectionError(&#34;Couldn&#39;t disconnect from HUBER Controller.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the HUBER Stages Controller is connected. &#34;&#34;&#34;
        return self.huber.is_connected()

    def is_simulator(self):
        return False

    def info(self):
        try:
            cmd = cmd_q_system_info.get_cmd_string()
            msg = &#34;Info about the HUBER Controller: &#34;
            msg += self.huber.get_response(cmd)
        except HuberError as exc:
            raise StagesError(&#34;Couldn&#39;t retrieve information from HUBER Controller&#34;) from exc

        return msg

    def get_configuration(self, axis):
        cmd = cmd_q_configuration.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd)
        all_conf = retStr.split(&#34;\r\n&#34;)

        # Every item in the all_conf list has the format &#39;&lt;var&gt;&lt;axis&gt;:&lt;value&gt;&#39; where &lt;var&gt; is the
        # name of the configuration variable, &lt;axis&gt; is the axis number and &lt;value&gt; is the current
        # value for the configuration variable. A comment line starts with a &#39;#&#39; character.

        all_conf = [item.split(&#34;:&#34;) for item in all_conf if not item.startswith(&#34;#&#34;)]

        # Turn this list of lists into a dictionary and remove the &lt;axis&gt; from the variable names

        return {key[:-1]: value for key, value in all_conf}

    def get_version(self):
        cmd_string = cmd_q_version.get_cmd_string()
        retStr = self.huber.get_response(cmd_string)
        return retStr

    def goto(self, axis, position, wait=True):

        # For the big rotation stage use the workaround to avoid continuous movement in the same
        # direction, and to avoid the limit switch.

        if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
            current = self.get_current_position(axis)
            movement = calculate_relative_movement(current, position)
            return self.move(axis, movement, wait)
        else:
            out = 0
            try:
                cmd_string = cmd_goto.get_cmd_string(axis, position)
                self.huber.send_direct_command(cmd_string)
                if wait:
                    out = self.huber.wait_until_axis_ready(axis)
            except HuberError as exc:
                raise StagesError(f&#34;Couldn&#39;t goto position {position} for the Huber Stage.&#34;) from exc

            return out

    def move(self, axis, distance, wait=True):
        out = 0
        try:
            cmd_string = cmd_move.get_cmd_string(axis, distance)
            self.huber.send_direct_command(cmd_string)
            if wait:
                out = self.huber.wait_until_axis_ready(axis)
        except HuberError as exc:
            raise StagesError(
                f&#34;Couldn&#39;t move {distance} from current position for the Huber Stage.&#34;
            ) from exc

        return out

    def set_slew_speed(self, axis, speed):
        try:
            cmd_string = cmd_ffast.get_cmd_string(axis, speed)
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t set the slew speed for axis {axis} to {speed}&#34;) from exc

    def get_slew_speed(self, axis):
        return self.get_conf_value(axis, &#34;ffast&#34;)

    def is_in_position(self, axis):
        state = self.get_state(axis)

        # The sleep of 0.5s here is empirically determined because tests failed randomly because the position was
        # apparently not completely reached. We also noticed an oscilation when arriving at a certain position.
        # A daignostic test revealed that the status sometimes changes bit 0 and bit 7 indicating the axis/controller
        # ready before the mechanism actually reached the setpoont. We need about 0.2s before the actual value is
        # reached, 0.5 seconds is a safe wait time.

        time.sleep(0.5)

        return state &amp; 0b10000001 == 0b10000001

    def get_current_position(self, axis) -&gt; float:
        cmd_string = cmd_q_pos.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)

        # The response will look like &#39;&lt;axis&gt;:&lt;retPos&gt;;&#39;
        # where &lt;axis&gt; is the axis number and &lt;retPos&gt; is the current position as a float
        retPos = float(retStr[2:-1])

        return retPos

    def get_current_encoder_position(self, axis) -&gt; float:
        cmd_string = cmd_q_e.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)

        # The response will look like &#39;1:&lt;retPos&gt;;&#39; where retPos is the current position as a float
        retPos = float(retStr[2:-1])

        return retPos

    def get_current_encoder_counter_value(self, axis) -&gt; int:
        cmd_string = cmd_q_ec.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)

        # The response will look like &#39;1:&lt;retPos&gt;;&#39; where retPos is the current position as a float
        retPos = int(retStr[2:-1])

        return retPos

    def get_error(self, axis):
        cmd_string = cmd_q_error.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)
        # The response string looks like &#39;&lt;axis&gt;:&lt;errno&gt; &lt;errmsg&gt;&#39; where &lt;axis&gt; is the axis number,
        # &lt;errno&gt; is the error number and &lt;errmsg&gt; is the error message.
        retStr = retStr[2:]

        return retStr.split(maxsplit=1)

    def clear_error(self, axis):
        try:
            cmd_string = cmd_cerr.get_cmd_string(axis)
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t clear errors for axis {axis}&#34;) from exc

    def quit(self):
        try:
            cmd_string = cmd_quit.get_cmd_string()
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t stop positioning process&#34;) from exc

    def get_state(self, axis) -&gt; int:
        rc = self.huber.get_response(cmd_q_state.get_cmd_string(axis))
        # response is e.g. &#39;1:&lt;state&gt;;&#39;
        # cut &#39;1:&#39; and &#39;;&#39;
        state = int(rc[2:-1])
        # logger.debug(f&#34;{rc=}, {state=}&#34;)
        return state

    def get_status(self, axis):
        retStr = self.huber.get_response(cmd_q_status.get_cmd_string(axis))
        return retStr

    def zero(self, axis):
        try:
            cmd_string = cmd_zero.get_cmd_string(axis)
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t set reference zero position for axis {axis}&#34;) from exc


class AxisTimer:
    &#34;&#34;&#34;
    This class controls all the timings of an axis.
    &#34;&#34;&#34;

    def __init__(self):
        self._start_time = time.time()

    def start(self):
        &#34;&#34;&#34;Start the timer.&#34;&#34;&#34;
        self._start_time = time.time()

    def get_delta_time(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the delta time since the start() method was called on this
        AxisTimer.

        :returns: delta time in seconds since the start of the timer
        &#34;&#34;&#34;
        return time.time() - self._start_time


class Axis:
    &#34;&#34;&#34;
    This class controls the settings and movements of one particular axis
    for the HUBER Stages.

    Do not use this class directly, it is used from within the HuberSimulator.
    &#34;&#34;&#34;

    def __init__(self, slew_speed, encoder_conversion):
        # Translation Stage: slew_speed = 77_200, encoder_conversion = 20_000
        # Big Rotation: slew_speed = 22_943_316, encoder_conversion = 11_930_500
        self._slew_speed = slew_speed  # encoder positions per second
        self._encoder_conversion_factor = encoder_conversion  # encoder positions per mm/deg
        self._encoder_counter = 0
        self._encoder_position = 0.0
        self._current_position = 0.0
        self._start_position = 0.0
        self._commanded_position = None
        self._moving = False
        self._direction = 0
        self._timer = AxisTimer()

    def get_slew_speed(self) -&gt; int:
        return self._slew_speed

    def set_slew_speed(self, speed: int):
        self._slew_speed = speed

    def get_converted_slew_speed(self) -&gt; float:
        &#34;&#34;&#34;Returns the slew speed in mm/s or deg/s&#34;&#34;&#34;
        return self._slew_speed / self._encoder_conversion_factor

    def start(self):
        &#34;&#34;&#34;
        Start a movement. A movement is defined as the change from the current
        position to the commanded position. Therefore, the start position will
        be set to the current position and all calculations including time will
        be with respect to the starting position.
        &#34;&#34;&#34;
        if self._commanded_position is None:
            raise Exception(&#34;Can not start a movement if commanded position is not set.&#34;)

        self._timer.start()
        self._moving = True
        self._distance = self._current_position - self._commanded_position
        self._direction = 1 if self._commanded_position &gt; self._current_position else -1
        self._start_position = self._current_position

    def set_commanded_position(self, position):
        self._commanded_position = position

    def get_current_position(self) -&gt; float:
        self._calc_current_position()
        return self._current_position

    def get_encoder_position(self) -&gt; float:
        return self.get_current_position()

    def get_encode_counter_value(self) -&gt; int:
        return int(self.get_encoder_position() * self._encoder_conversion_factor)

    def is_in_position(self):
        self._calc_current_position()
        if self._moving:
            return False
        else:
            return True

    def _calc_current_position(self):
        if not self._moving:
            return

        delta_t = self._timer.get_delta_time()
        slew_speed = self.get_converted_slew_speed()
        travel = slew_speed * delta_t

        if travel &gt;= abs(self._distance):
            self._current_position = self._commanded_position
            self._moving = False
            self._distance = 0.0
        else:
            self._current_position = self._start_position + travel * self._direction


class HuberSMC9300Simulator(HuberSMC9300Interface):
    &#34;&#34;&#34;
    The class simulates the HUBER Stages.
    &#34;&#34;&#34;

    def __init__(self):
        self._controller_ready = True
        self._is_connected = False
        self._version = &#34;0.1&#34;

        # The slew_speed and the encoder_conversion factor is empirically determined from the
        # hardware measures between 0 and 100. The timings that result for these stages are
        # only approximately correct.

        self._axes = [
            None,
            Axis(22_943_316, 11_930_500),
            Axis(20_000, 20_000),
            Axis(77_200, 20_000),
        ]

    def connect(self):
        self._is_connected = True

    def disconnect(self):
        self._is_connected = False

    def reconnect(self):
        self.connect()

    def is_connected(self):
        return True

    def is_simulator(self):
        return True

    def info(self):
        msg = f&#34;Info about the HuberSMC9300Simulator {self.get_version()}\n&#34;
        msg += &#34;\n&#34;
        msg += f&#34;Number of axes: {len(self._axes) - 1}&#34;
        return msg

    def get_version(self):
        return f&#34;v{self._version}&#34;

    @to_be_implemented
    def get_configuration(self, axis):
        return f&#34;Configuration for axis {axis}&#34;

    def goto(self, axis, position, wait=True):

        # For the big rotation stage use the workaround to avoid continuous movement in the same
        # direction, and to avoid the limit switch.

        if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
            current = self.get_current_position(axis)
            # FIXME: avoidance should be in the Setup of this HUBER stage
            movement = calculate_relative_movement(current, position)
            return self.move(axis, movement, wait)
        else:
            self._axes[axis].set_commanded_position(position)
            self._axes[axis].start()
            if wait:
                while not self._axes[axis].is_in_position():
                    time.sleep(0.001)

                time.sleep(0.5)

    def move(self, axis, distance, wait=True):
        cp = self._axes[axis].get_current_position()
        self._axes[axis].set_commanded_position(cp + distance)
        self._axes[axis].start()
        if wait:
            while not self._axes[axis].is_in_position():
                time.sleep(0.001)

            time.sleep(0.5)

    def get_current_position(self, axis):
        return self._axes[axis].get_current_position()

    @to_be_implemented
    def get_current_encoder_position(self, axis) -&gt; float:
        # For now we just return the current position, but this should actually
        # lag a little behind the current position. That&#39;s why it is to_be_implemented.
        return self._axes[axis].get_encoder_position()

    @to_be_implemented
    def get_current_encoder_counter_value(self, axis) -&gt; int:
        return self._axes[axis].get_encode_counter_value()

    def is_in_position(self, axis):
        return self._axes[axis].is_in_position()

    def get_slew_speed(self, axis):
        return self._axes[axis].get_slew_speed()

    def set_slew_speed(self, axis, speed: int):
        self._axes[axis].set_slew_speed(speed)

    @to_be_implemented
    def zero(self, axis):
        # FIXME: how can we implement this in this simulator? Do we keep a reference zero position
        #        and use that in our position calculations?
        pass

    @to_be_implemented
    def clear_error(self, axis):
        pass

    @to_be_implemented
    def quit(self):
        logger.warning(&#34;Quit command not yet fully functioning for simulation mode.&#34;)

    @to_be_implemented
    def get_error(self, axis):
        pass

    def get_state(self, axis) -&gt; int:
        return random.choice([0b0000, 0b0100, 0b1000, 0b1100])

    @to_be_implemented
    def get_status(self, axis):
        pass


class HuberSMC9300Proxy(Proxy, HuberSMC9300Interface):
    &#34;&#34;&#34;
    The HuberProxy class is used to connect to the Huber SMC9300 control server and send commands
    to the HUBER Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol
                [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))


def calculate_relative_movement(current, setpoint, hardstop=None, avoidance=None):
    &#34;&#34;&#34;
    This function calculates the relative movement from the current position to the given setpoint.
    It defines the direction and the size of the movement based on the current position,
    the setpoint, the hardstop position and the avoidance angle.

    The function strives to always return the smallest possible angle in order to minimize the
    duration of the movement.

    The target position (setpoint) can not fall in the range [hardstop - avoidance,
    hardstop + avoidance]. There is no check on the current position, it is assumed not to be in
    the avoidance range.

    If hardstop or avoidance are not given, they are loaded from the setup.

    Args:
        current (float): the current position of the rotation stage
        setpoint (float): the target position of the rotation stage
        hardstop (float): the location of the hardstop
        avoidance (float): angle of avoidance
    Returns:
        The angle to move relative from current position to setpoint.
    Raises:
        A ValueError when the setpoint falls inside of the avoidance range, i.e.
        [-180 + avoidance, +180 - avoidance].
    &#34;&#34;&#34;

    setup = load_setup()

    avoidance = avoidance if avoidance is not None else setup.gse.stages.big_rotation_stage.avoidance
    hardstop = hardstop if hardstop is not None else setup.gse.stages.big_rotation_stage.hardstop

    # logger.debug(f&#34;@entry: {current=}, {setpoint=}, {hardstop=}, {avoidance=}&#34;)

    # Bring the current and the setpoint between 0 and 360 (non-inclusive)

    current %= 360
    setpoint %= 360

    # logger.debug(f&#34;After % 360: {current=}, {setpoint=}&#34;)

    # Check if the setpoint falls in the avoidance range

    if hardstop - avoidance &lt; setpoint &lt; hardstop + avoidance:
        raise ValueError(
            f&#34;setpoint argument shall NOT be between {hardstop - avoidance} and &#34;
            f&#34;{hardstop + avoidance}, given value {setpoint = }&#34;)

    # Find the smallest angle between the current and the setpoint

    movement = min(abs(current - setpoint), abs(360 + current - setpoint))
    direction = +1 if current + movement == setpoint else -1

    target = current + direction*movement

    # logger.debug(f&#34;Smallest movement: {current=}, {setpoint=}, {target=:.2f}, {movement=:.2f}, {direction=}&#34;)

    # Check if we will pass over 180º and invert direction if true.

    if (current &lt; target and current &lt; hardstop &lt; target) or \
       (current &gt; target and target &lt; hardstop &lt; current):
        movement = 360 - movement
        direction *= -1

        # target = current + direction * movement
        # logger.debug(f&#34;corrected: {current=}, {setpoint=}, {target=:.2f}, {movement=:.2f}, {direction=}&#34;)

    return direction * movement</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.stages.huber.smc9300.calculate_relative_movement"><code class="name flex">
<span>def <span class="ident">calculate_relative_movement</span></span>(<span>current, setpoint, hardstop=None, avoidance=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function calculates the relative movement from the current position to the given setpoint.
It defines the direction and the size of the movement based on the current position,
the setpoint, the hardstop position and the avoidance angle.</p>
<p>The function strives to always return the smallest possible angle in order to minimize the
duration of the movement.</p>
<p>The target position (setpoint) can not fall in the range [hardstop - avoidance,
hardstop + avoidance]. There is no check on the current position, it is assumed not to be in
the avoidance range.</p>
<p>If hardstop or avoidance are not given, they are loaded from the setup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>current</code></strong> :&ensp;<code>float</code></dt>
<dd>the current position of the rotation stage</dd>
<dt><strong><code>setpoint</code></strong> :&ensp;<code>float</code></dt>
<dd>the target position of the rotation stage</dd>
<dt><strong><code>hardstop</code></strong> :&ensp;<code>float</code></dt>
<dd>the location of the hardstop</dd>
<dt><strong><code>avoidance</code></strong> :&ensp;<code>float</code></dt>
<dd>angle of avoidance</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The angle to move relative from current position to setpoint.</p>
<h2 id="raises">Raises</h2>
<p>A ValueError when the setpoint falls inside of the avoidance range, i.e.
[-180 + avoidance, +180 - avoidance].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_relative_movement(current, setpoint, hardstop=None, avoidance=None):
    &#34;&#34;&#34;
    This function calculates the relative movement from the current position to the given setpoint.
    It defines the direction and the size of the movement based on the current position,
    the setpoint, the hardstop position and the avoidance angle.

    The function strives to always return the smallest possible angle in order to minimize the
    duration of the movement.

    The target position (setpoint) can not fall in the range [hardstop - avoidance,
    hardstop + avoidance]. There is no check on the current position, it is assumed not to be in
    the avoidance range.

    If hardstop or avoidance are not given, they are loaded from the setup.

    Args:
        current (float): the current position of the rotation stage
        setpoint (float): the target position of the rotation stage
        hardstop (float): the location of the hardstop
        avoidance (float): angle of avoidance
    Returns:
        The angle to move relative from current position to setpoint.
    Raises:
        A ValueError when the setpoint falls inside of the avoidance range, i.e.
        [-180 + avoidance, +180 - avoidance].
    &#34;&#34;&#34;

    setup = load_setup()

    avoidance = avoidance if avoidance is not None else setup.gse.stages.big_rotation_stage.avoidance
    hardstop = hardstop if hardstop is not None else setup.gse.stages.big_rotation_stage.hardstop

    # logger.debug(f&#34;@entry: {current=}, {setpoint=}, {hardstop=}, {avoidance=}&#34;)

    # Bring the current and the setpoint between 0 and 360 (non-inclusive)

    current %= 360
    setpoint %= 360

    # logger.debug(f&#34;After % 360: {current=}, {setpoint=}&#34;)

    # Check if the setpoint falls in the avoidance range

    if hardstop - avoidance &lt; setpoint &lt; hardstop + avoidance:
        raise ValueError(
            f&#34;setpoint argument shall NOT be between {hardstop - avoidance} and &#34;
            f&#34;{hardstop + avoidance}, given value {setpoint = }&#34;)

    # Find the smallest angle between the current and the setpoint

    movement = min(abs(current - setpoint), abs(360 + current - setpoint))
    direction = +1 if current + movement == setpoint else -1

    target = current + direction*movement

    # logger.debug(f&#34;Smallest movement: {current=}, {setpoint=}, {target=:.2f}, {movement=:.2f}, {direction=}&#34;)

    # Check if we will pass over 180º and invert direction if true.

    if (current &lt; target and current &lt; hardstop &lt; target) or \
       (current &gt; target and target &lt; hardstop &lt; current):
        movement = 360 - movement
        direction *= -1

        # target = current + direction * movement
        # logger.debug(f&#34;corrected: {current=}, {setpoint=}, {target=:.2f}, {movement=:.2f}, {direction=}&#34;)

    return direction * movement</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.stages.huber.smc9300.Axis"><code class="flex name class">
<span>class <span class="ident">Axis</span></span>
<span>(</span><span>slew_speed, encoder_conversion)</span>
</code></dt>
<dd>
<div class="desc"><p>This class controls the settings and movements of one particular axis
for the HUBER Stages.</p>
<p>Do not use this class directly, it is used from within the HuberSimulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axis:
    &#34;&#34;&#34;
    This class controls the settings and movements of one particular axis
    for the HUBER Stages.

    Do not use this class directly, it is used from within the HuberSimulator.
    &#34;&#34;&#34;

    def __init__(self, slew_speed, encoder_conversion):
        # Translation Stage: slew_speed = 77_200, encoder_conversion = 20_000
        # Big Rotation: slew_speed = 22_943_316, encoder_conversion = 11_930_500
        self._slew_speed = slew_speed  # encoder positions per second
        self._encoder_conversion_factor = encoder_conversion  # encoder positions per mm/deg
        self._encoder_counter = 0
        self._encoder_position = 0.0
        self._current_position = 0.0
        self._start_position = 0.0
        self._commanded_position = None
        self._moving = False
        self._direction = 0
        self._timer = AxisTimer()

    def get_slew_speed(self) -&gt; int:
        return self._slew_speed

    def set_slew_speed(self, speed: int):
        self._slew_speed = speed

    def get_converted_slew_speed(self) -&gt; float:
        &#34;&#34;&#34;Returns the slew speed in mm/s or deg/s&#34;&#34;&#34;
        return self._slew_speed / self._encoder_conversion_factor

    def start(self):
        &#34;&#34;&#34;
        Start a movement. A movement is defined as the change from the current
        position to the commanded position. Therefore, the start position will
        be set to the current position and all calculations including time will
        be with respect to the starting position.
        &#34;&#34;&#34;
        if self._commanded_position is None:
            raise Exception(&#34;Can not start a movement if commanded position is not set.&#34;)

        self._timer.start()
        self._moving = True
        self._distance = self._current_position - self._commanded_position
        self._direction = 1 if self._commanded_position &gt; self._current_position else -1
        self._start_position = self._current_position

    def set_commanded_position(self, position):
        self._commanded_position = position

    def get_current_position(self) -&gt; float:
        self._calc_current_position()
        return self._current_position

    def get_encoder_position(self) -&gt; float:
        return self.get_current_position()

    def get_encode_counter_value(self) -&gt; int:
        return int(self.get_encoder_position() * self._encoder_conversion_factor)

    def is_in_position(self):
        self._calc_current_position()
        if self._moving:
            return False
        else:
            return True

    def _calc_current_position(self):
        if not self._moving:
            return

        delta_t = self._timer.get_delta_time()
        slew_speed = self.get_converted_slew_speed()
        travel = slew_speed * delta_t

        if travel &gt;= abs(self._distance):
            self._current_position = self._commanded_position
            self._moving = False
            self._distance = 0.0
        else:
            self._current_position = self._start_position + travel * self._direction</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.Axis.get_converted_slew_speed"><code class="name flex">
<span>def <span class="ident">get_converted_slew_speed</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the slew speed in mm/s or deg/s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_converted_slew_speed(self) -&gt; float:
    &#34;&#34;&#34;Returns the slew speed in mm/s or deg/s&#34;&#34;&#34;
    return self._slew_speed / self._encoder_conversion_factor</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.get_current_position"><code class="name flex">
<span>def <span class="ident">get_current_position</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_position(self) -&gt; float:
    self._calc_current_position()
    return self._current_position</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.get_encode_counter_value"><code class="name flex">
<span>def <span class="ident">get_encode_counter_value</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_encode_counter_value(self) -&gt; int:
    return int(self.get_encoder_position() * self._encoder_conversion_factor)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.get_encoder_position"><code class="name flex">
<span>def <span class="ident">get_encoder_position</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_encoder_position(self) -&gt; float:
    return self.get_current_position()</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.get_slew_speed"><code class="name flex">
<span>def <span class="ident">get_slew_speed</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_speed(self) -&gt; int:
    return self._slew_speed</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.is_in_position"><code class="name flex">
<span>def <span class="ident">is_in_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_position(self):
    self._calc_current_position()
    if self._moving:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.set_commanded_position"><code class="name flex">
<span>def <span class="ident">set_commanded_position</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_commanded_position(self, position):
    self._commanded_position = position</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.set_slew_speed"><code class="name flex">
<span>def <span class="ident">set_slew_speed</span></span>(<span>self, speed: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_speed(self, speed: int):
    self._slew_speed = speed</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.Axis.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a movement. A movement is defined as the change from the current
position to the commanded position. Therefore, the start position will
be set to the current position and all calculations including time will
be with respect to the starting position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Start a movement. A movement is defined as the change from the current
    position to the commanded position. Therefore, the start position will
    be set to the current position and all calculations including time will
    be with respect to the starting position.
    &#34;&#34;&#34;
    if self._commanded_position is None:
        raise Exception(&#34;Can not start a movement if commanded position is not set.&#34;)

    self._timer.start()
    self._moving = True
    self._distance = self._current_position - self._commanded_position
    self._direction = 1 if self._commanded_position &gt; self._current_position else -1
    self._start_position = self._current_position</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.stages.huber.smc9300.AxisTimer"><code class="flex name class">
<span>class <span class="ident">AxisTimer</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class controls all the timings of an axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AxisTimer:
    &#34;&#34;&#34;
    This class controls all the timings of an axis.
    &#34;&#34;&#34;

    def __init__(self):
        self._start_time = time.time()

    def start(self):
        &#34;&#34;&#34;Start the timer.&#34;&#34;&#34;
        self._start_time = time.time()

    def get_delta_time(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the delta time since the start() method was called on this
        AxisTimer.

        :returns: delta time in seconds since the start of the timer
        &#34;&#34;&#34;
        return time.time() - self._start_time</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.AxisTimer.get_delta_time"><code class="name flex">
<span>def <span class="ident">get_delta_time</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the delta time since the start() method was called on this
AxisTimer.</p>
<p>:returns: delta time in seconds since the start of the timer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delta_time(self) -&gt; float:
    &#34;&#34;&#34;
    Returns the delta time since the start() method was called on this
    AxisTimer.

    :returns: delta time in seconds since the start of the timer
    &#34;&#34;&#34;
    return time.time() - self._start_time</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.AxisTimer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the timer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Start the timer.&#34;&#34;&#34;
    self._start_time = time.time()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Controller"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Controller</span></span>
<span>(</span><span>hostname='localhost', port=4243)</span>
</code></dt>
<dd>
<div class="desc"><p>The HuberSmC9300Controller class is used to directly communicate with the HUBER SMC9300
Controller through an Ethernet interface.</p>
<p>Opens a TCP/IP socket connection with the HUBER SMC9300 Hardware Controller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the HUBER hardware
controller. The default is defined in the <code>settings.yaml</code> configuration file.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to, by default set in the <code>settings.yaml</code>
configuration file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>StagesError</code></dt>
<dd>when the connection could not be established for some reason.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Controller(HuberSMC9300Interface):
    &#34;&#34;&#34;
    The HuberSmC9300Controller class is used to directly communicate with the HUBER SMC9300
    Controller through an Ethernet interface.
    &#34;&#34;&#34;

    def __init__(self, hostname=HC_SETTINGS.HOSTNAME, port=HC_SETTINGS.PORT):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the HUBER SMC9300 Hardware Controller.

        Args:
            hostname (str): the IP address or fully qualified hostname of the HUBER hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the `settings.yaml`
                configuration file.

        Raises:
            StagesError: when the connection could not be established for some reason.
        &#34;&#34;&#34;
        super().__init__()

        logger.debug(f&#34;Initializing HuberSMC9300Controller with hostname={hostname} on port={port}&#34;)

        try:
            self.huber = HuberSMC9300EthernetInterface()
            self.huber.setConnectionParameters(hostname, port)
        except HuberError as exc:
            logger.warning(f&#34;HuberError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise StagesError(&#34;Couldn&#39;t establish a connection with the HUBER Stage.&#34;) from exc

        self._number_of_axes = HC_SETTINGS.NUMBER_OF_AXES

    def connect(self):
        try:
            self.huber.connect()

            # set the speed of each of the stages to the default speed from the Settings.

            for stage in 1, 2, 3:
                default_speed = HC_SETTINGS.DEFAULT_SPEED[stage - 1]
                self.set_slew_speed(stage, default_speed)

        except HuberError as exc:
            logger.warning(f&#34;HuberError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the HUBER Stage.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        try:
            # Clear the error for each of the axis before disconnecting
            for axis in range(1, self._number_of_axes + 1):
                self.clear_error(axis)
            self.huber.disconnect()
        except HuberError as exc:
            raise ConnectionError(&#34;Couldn&#39;t disconnect from HUBER Controller.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the HUBER Stages Controller is connected. &#34;&#34;&#34;
        return self.huber.is_connected()

    def is_simulator(self):
        return False

    def info(self):
        try:
            cmd = cmd_q_system_info.get_cmd_string()
            msg = &#34;Info about the HUBER Controller: &#34;
            msg += self.huber.get_response(cmd)
        except HuberError as exc:
            raise StagesError(&#34;Couldn&#39;t retrieve information from HUBER Controller&#34;) from exc

        return msg

    def get_configuration(self, axis):
        cmd = cmd_q_configuration.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd)
        all_conf = retStr.split(&#34;\r\n&#34;)

        # Every item in the all_conf list has the format &#39;&lt;var&gt;&lt;axis&gt;:&lt;value&gt;&#39; where &lt;var&gt; is the
        # name of the configuration variable, &lt;axis&gt; is the axis number and &lt;value&gt; is the current
        # value for the configuration variable. A comment line starts with a &#39;#&#39; character.

        all_conf = [item.split(&#34;:&#34;) for item in all_conf if not item.startswith(&#34;#&#34;)]

        # Turn this list of lists into a dictionary and remove the &lt;axis&gt; from the variable names

        return {key[:-1]: value for key, value in all_conf}

    def get_version(self):
        cmd_string = cmd_q_version.get_cmd_string()
        retStr = self.huber.get_response(cmd_string)
        return retStr

    def goto(self, axis, position, wait=True):

        # For the big rotation stage use the workaround to avoid continuous movement in the same
        # direction, and to avoid the limit switch.

        if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
            current = self.get_current_position(axis)
            movement = calculate_relative_movement(current, position)
            return self.move(axis, movement, wait)
        else:
            out = 0
            try:
                cmd_string = cmd_goto.get_cmd_string(axis, position)
                self.huber.send_direct_command(cmd_string)
                if wait:
                    out = self.huber.wait_until_axis_ready(axis)
            except HuberError as exc:
                raise StagesError(f&#34;Couldn&#39;t goto position {position} for the Huber Stage.&#34;) from exc

            return out

    def move(self, axis, distance, wait=True):
        out = 0
        try:
            cmd_string = cmd_move.get_cmd_string(axis, distance)
            self.huber.send_direct_command(cmd_string)
            if wait:
                out = self.huber.wait_until_axis_ready(axis)
        except HuberError as exc:
            raise StagesError(
                f&#34;Couldn&#39;t move {distance} from current position for the Huber Stage.&#34;
            ) from exc

        return out

    def set_slew_speed(self, axis, speed):
        try:
            cmd_string = cmd_ffast.get_cmd_string(axis, speed)
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t set the slew speed for axis {axis} to {speed}&#34;) from exc

    def get_slew_speed(self, axis):
        return self.get_conf_value(axis, &#34;ffast&#34;)

    def is_in_position(self, axis):
        state = self.get_state(axis)

        # The sleep of 0.5s here is empirically determined because tests failed randomly because the position was
        # apparently not completely reached. We also noticed an oscilation when arriving at a certain position.
        # A daignostic test revealed that the status sometimes changes bit 0 and bit 7 indicating the axis/controller
        # ready before the mechanism actually reached the setpoont. We need about 0.2s before the actual value is
        # reached, 0.5 seconds is a safe wait time.

        time.sleep(0.5)

        return state &amp; 0b10000001 == 0b10000001

    def get_current_position(self, axis) -&gt; float:
        cmd_string = cmd_q_pos.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)

        # The response will look like &#39;&lt;axis&gt;:&lt;retPos&gt;;&#39;
        # where &lt;axis&gt; is the axis number and &lt;retPos&gt; is the current position as a float
        retPos = float(retStr[2:-1])

        return retPos

    def get_current_encoder_position(self, axis) -&gt; float:
        cmd_string = cmd_q_e.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)

        # The response will look like &#39;1:&lt;retPos&gt;;&#39; where retPos is the current position as a float
        retPos = float(retStr[2:-1])

        return retPos

    def get_current_encoder_counter_value(self, axis) -&gt; int:
        cmd_string = cmd_q_ec.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)

        # The response will look like &#39;1:&lt;retPos&gt;;&#39; where retPos is the current position as a float
        retPos = int(retStr[2:-1])

        return retPos

    def get_error(self, axis):
        cmd_string = cmd_q_error.get_cmd_string(axis)
        retStr = self.huber.get_response(cmd_string)
        # The response string looks like &#39;&lt;axis&gt;:&lt;errno&gt; &lt;errmsg&gt;&#39; where &lt;axis&gt; is the axis number,
        # &lt;errno&gt; is the error number and &lt;errmsg&gt; is the error message.
        retStr = retStr[2:]

        return retStr.split(maxsplit=1)

    def clear_error(self, axis):
        try:
            cmd_string = cmd_cerr.get_cmd_string(axis)
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t clear errors for axis {axis}&#34;) from exc

    def quit(self):
        try:
            cmd_string = cmd_quit.get_cmd_string()
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t stop positioning process&#34;) from exc

    def get_state(self, axis) -&gt; int:
        rc = self.huber.get_response(cmd_q_state.get_cmd_string(axis))
        # response is e.g. &#39;1:&lt;state&gt;;&#39;
        # cut &#39;1:&#39; and &#39;;&#39;
        state = int(rc[2:-1])
        # logger.debug(f&#34;{rc=}, {state=}&#34;)
        return state

    def get_status(self, axis):
        retStr = self.huber.get_response(cmd_q_status.get_cmd_string(axis))
        return retStr

    def zero(self, axis):
        try:
            cmd_string = cmd_zero.get_cmd_string(axis)
            self.huber.send_direct_command(cmd_string)
        except HuberError as exc:
            raise StagesError(f&#34;Couldn&#39;t set reference zero position for axis {axis}&#34;) from exc</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Controller.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self, axis) -&gt; int:
    rc = self.huber.get_response(cmd_q_state.get_cmd_string(axis))
    # response is e.g. &#39;1:&lt;state&gt;;&#39;
    # cut &#39;1:&#39; and &#39;;&#39;
    state = int(rc[2:-1])
    # logger.debug(f&#34;{rc=}, {state=}&#34;)
    return state</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Controller.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, axis):
    retStr = self.huber.get_response(cmd_q_status.get_cmd_string(axis))
    return retStr</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Controller.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the HUBER Stages Controller is connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34;Check if the HUBER Stages Controller is connected. &#34;&#34;&#34;
    return self.huber.is_connected()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Interface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Controller, Simulator and Proxy classes for this device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Controller, Simulator and Proxy classes for this device.
    &#34;&#34;&#34;

    @dynamic_interface
    def info(self):
        &#34;&#34;&#34;
        Retrieve basic information about the Huber Stages and the Controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_configuration(self, axis):
        &#34;&#34;&#34;
        Get description for the given axis.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_conf_value(self, axis, name):
        conf = self.get_configuration(axis)
        return conf[name] if name in conf else None

    @dynamic_interface
    def get_version(self):
        &#34;&#34;&#34;
        Get version information about the current control program.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def goto(self, axis: int, position: float, wait: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Move the stage to the given absolute position.

        A positive angle moves the rotation stage counter clockwise.

        Args:
            axis (int): the integer identifier of one of the axis controlled by the SMC
            position (float): when the given axis is a rotation stage, the position is given
                in degrees [deg], for a translation stage, the position is given
                in millimeter [mm].
            wait (bool): if True, the method only returns when the device is in position
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def move(self, axis: int, distance: float) -&gt; None:
        &#34;&#34;&#34;
        Move the stage relative to the current position in the given distance.

        A positive angle moves the rotation stage counter clockwise.

        :param int axis: the integer identifier of one of the axis controlled by the SMC
        :param float distance: when the given axis is a rotation stage, the distance is given
            in degrees [deg], for a translation stage, the distance is given
            in millimeter [mm].
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def set_slew_speed(self, axis, speed):
        &#34;&#34;&#34;
        Configure the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.

        Manual positioning commands are i.e. ``fast``, ``move``, ``goto``, or
        the use of the direction keys.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_slew_speed(self, axis):
        &#34;&#34;&#34;
        Returns the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_in_position(self, axis):
        &#34;&#34;&#34;
        Returns True if the mechanism is in position and not moving.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_current_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current position for this axis as a float.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_current_encoder_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current encoder position for this axis as a float.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_current_encoder_counter_value(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the current encoder counter value for this axis as an int.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_error(self, axis):
        &#34;&#34;&#34;
        Returns the last occured error and corresponding error message for the given axis.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def clear_error(self, axis):
        &#34;&#34;&#34;
        Reset the last occured error and clear the error message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def quit(self):
        &#34;&#34;&#34;
        Immediately stop any positioning process.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_state(self, axis) -&gt; int:
        raise NotImplementedError

    @dynamic_interface
    def get_status(self, axis):
        raise NotImplementedError

    @dynamic_interface
    def zero(self, axis):
        &#34;&#34;&#34;
        Set the current position of the axis to zero (0.00). If a reference position
        offset value is configured (see the configuration command ``rofs``) the current
        position is set to that reference offset value.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Controller" href="#egse.stages.huber.smc9300.HuberSMC9300Controller">HuberSMC9300Controller</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Proxy" href="#egse.stages.huber.smc9300.HuberSMC9300Proxy">HuberSMC9300Proxy</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Simulator" href="#egse.stages.huber.smc9300.HuberSMC9300Simulator">HuberSMC9300Simulator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error"><code class="name flex">
<span>def <span class="ident">clear_error</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the last occured error and clear the error message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def clear_error(self, axis):
    &#34;&#34;&#34;
    Reset the last occured error and clear the error message.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value"><code class="name flex">
<span>def <span class="ident">get_conf_value</span></span>(<span>self, axis, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conf_value(self, axis, name):
    conf = self.get_configuration(axis)
    return conf[name] if name in conf else None</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration"><code class="name flex">
<span>def <span class="ident">get_configuration</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Get description for the given axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_configuration(self, axis):
    &#34;&#34;&#34;
    Get description for the given axis.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value"><code class="name flex">
<span>def <span class="ident">get_current_encoder_counter_value</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current encoder counter value for this axis as an int.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_current_encoder_counter_value(self, axis) -&gt; int:
    &#34;&#34;&#34;
    Returns the current encoder counter value for this axis as an int.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position"><code class="name flex">
<span>def <span class="ident">get_current_encoder_position</span></span>(<span>self, axis) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current encoder position for this axis as a float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_current_encoder_position(self, axis) -&gt; float:
    &#34;&#34;&#34;
    Returns the current encoder position for this axis as a float.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position"><code class="name flex">
<span>def <span class="ident">get_current_position</span></span>(<span>self, axis) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current position for this axis as a float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_current_position(self, axis) -&gt; float:
    &#34;&#34;&#34;
    Returns the current position for this axis as a float.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the last occured error and corresponding error message for the given axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_error(self, axis):
    &#34;&#34;&#34;
    Returns the last occured error and corresponding error message for the given axis.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed"><code class="name flex">
<span>def <span class="ident">get_slew_speed</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum slew speed used for the execution of manual
positioning commands. The maximum speed depends on the motor type,
driver type and positioning hardware properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_slew_speed(self, axis):
    &#34;&#34;&#34;
    Returns the maximum slew speed used for the execution of manual
    positioning commands. The maximum speed depends on the motor type,
    driver type and positioning hardware properties.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_state(self, axis) -&gt; int:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_status(self, axis):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get version information about the current control program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_version(self):
    &#34;&#34;&#34;
    Get version information about the current control program.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, axis: int, position: float, wait: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Move the stage to the given absolute position.</p>
<p>A positive angle moves the rotation stage counter clockwise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>the integer identifier of one of the axis controlled by the SMC</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>float</code></dt>
<dd>when the given axis is a rotation stage, the position is given
in degrees [deg], for a translation stage, the position is given
in millimeter [mm].</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the method only returns when the device is in position</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def goto(self, axis: int, position: float, wait: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Move the stage to the given absolute position.

    A positive angle moves the rotation stage counter clockwise.

    Args:
        axis (int): the integer identifier of one of the axis controlled by the SMC
        position (float): when the given axis is a rotation stage, the position is given
            in degrees [deg], for a translation stage, the position is given
            in millimeter [mm].
        wait (bool): if True, the method only returns when the device is in position
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve basic information about the Huber Stages and the Controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def info(self):
    &#34;&#34;&#34;
    Retrieve basic information about the Huber Stages and the Controller.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position"><code class="name flex">
<span>def <span class="ident">is_in_position</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the mechanism is in position and not moving.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def is_in_position(self, axis):
    &#34;&#34;&#34;
    Returns True if the mechanism is in position and not moving.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, axis: int, distance: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Move the stage relative to the current position in the given distance.</p>
<p>A positive angle moves the rotation stage counter clockwise.</p>
<p>:param int axis: the integer identifier of one of the axis controlled by the SMC
:param float distance: when the given axis is a rotation stage, the distance is given
in degrees [deg], for a translation stage, the distance is given
in millimeter [mm].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def move(self, axis: int, distance: float) -&gt; None:
    &#34;&#34;&#34;
    Move the stage relative to the current position in the given distance.

    A positive angle moves the rotation stage counter clockwise.

    :param int axis: the integer identifier of one of the axis controlled by the SMC
    :param float distance: when the given axis is a rotation stage, the distance is given
        in degrees [deg], for a translation stage, the distance is given
        in millimeter [mm].
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Immediately stop any positioning process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def quit(self):
    &#34;&#34;&#34;
    Immediately stop any positioning process.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed"><code class="name flex">
<span>def <span class="ident">set_slew_speed</span></span>(<span>self, axis, speed)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the maximum slew speed used for the execution of manual
positioning commands. The maximum speed depends on the motor type,
driver type and positioning hardware properties.</p>
<p>Manual positioning commands are i.e. <code>fast</code>, <code>move</code>, <code>goto</code>, or
the use of the direction keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def set_slew_speed(self, axis, speed):
    &#34;&#34;&#34;
    Configure the maximum slew speed used for the execution of manual
    positioning commands. The maximum speed depends on the motor type,
    driver type and positioning hardware properties.

    Manual positioning commands are i.e. ``fast``, ``move``, ``goto``, or
    the use of the direction keys.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current position of the axis to zero (0.00). If a reference position
offset value is configured (see the configuration command <code>rofs</code>) the current
position is set to that reference offset value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def zero(self, axis):
    &#34;&#34;&#34;
    Set the current position of the axis to zero (0.00). If a reference position
    offset value is configured (see the configuration command ``rofs``) the current
    position is set to that reference offset value.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Proxy"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Proxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6800)</span>
</code></dt>
<dd>
<div class="desc"><p>The HuberProxy class is used to connect to the Huber SMC9300 control server and send commands
to the HUBER Hardware Controller remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol
[default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address)
[default is taken from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Proxy(Proxy, HuberSMC9300Interface):
    &#34;&#34;&#34;
    The HuberProxy class is used to connect to the Huber SMC9300 control server and send commands
    to the HUBER Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol
                [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Simulator"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Simulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The class simulates the HUBER Stages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Simulator(HuberSMC9300Interface):
    &#34;&#34;&#34;
    The class simulates the HUBER Stages.
    &#34;&#34;&#34;

    def __init__(self):
        self._controller_ready = True
        self._is_connected = False
        self._version = &#34;0.1&#34;

        # The slew_speed and the encoder_conversion factor is empirically determined from the
        # hardware measures between 0 and 100. The timings that result for these stages are
        # only approximately correct.

        self._axes = [
            None,
            Axis(22_943_316, 11_930_500),
            Axis(20_000, 20_000),
            Axis(77_200, 20_000),
        ]

    def connect(self):
        self._is_connected = True

    def disconnect(self):
        self._is_connected = False

    def reconnect(self):
        self.connect()

    def is_connected(self):
        return True

    def is_simulator(self):
        return True

    def info(self):
        msg = f&#34;Info about the HuberSMC9300Simulator {self.get_version()}\n&#34;
        msg += &#34;\n&#34;
        msg += f&#34;Number of axes: {len(self._axes) - 1}&#34;
        return msg

    def get_version(self):
        return f&#34;v{self._version}&#34;

    @to_be_implemented
    def get_configuration(self, axis):
        return f&#34;Configuration for axis {axis}&#34;

    def goto(self, axis, position, wait=True):

        # For the big rotation stage use the workaround to avoid continuous movement in the same
        # direction, and to avoid the limit switch.

        if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
            current = self.get_current_position(axis)
            # FIXME: avoidance should be in the Setup of this HUBER stage
            movement = calculate_relative_movement(current, position)
            return self.move(axis, movement, wait)
        else:
            self._axes[axis].set_commanded_position(position)
            self._axes[axis].start()
            if wait:
                while not self._axes[axis].is_in_position():
                    time.sleep(0.001)

                time.sleep(0.5)

    def move(self, axis, distance, wait=True):
        cp = self._axes[axis].get_current_position()
        self._axes[axis].set_commanded_position(cp + distance)
        self._axes[axis].start()
        if wait:
            while not self._axes[axis].is_in_position():
                time.sleep(0.001)

            time.sleep(0.5)

    def get_current_position(self, axis):
        return self._axes[axis].get_current_position()

    @to_be_implemented
    def get_current_encoder_position(self, axis) -&gt; float:
        # For now we just return the current position, but this should actually
        # lag a little behind the current position. That&#39;s why it is to_be_implemented.
        return self._axes[axis].get_encoder_position()

    @to_be_implemented
    def get_current_encoder_counter_value(self, axis) -&gt; int:
        return self._axes[axis].get_encode_counter_value()

    def is_in_position(self, axis):
        return self._axes[axis].is_in_position()

    def get_slew_speed(self, axis):
        return self._axes[axis].get_slew_speed()

    def set_slew_speed(self, axis, speed: int):
        self._axes[axis].set_slew_speed(speed)

    @to_be_implemented
    def zero(self, axis):
        # FIXME: how can we implement this in this simulator? Do we keep a reference zero position
        #        and use that in our position calculations?
        pass

    @to_be_implemented
    def clear_error(self, axis):
        pass

    @to_be_implemented
    def quit(self):
        logger.warning(&#34;Quit command not yet fully functioning for simulation mode.&#34;)

    @to_be_implemented
    def get_error(self, axis):
        pass

    def get_state(self, axis) -&gt; int:
        return random.choice([0b0000, 0b0100, 0b1000, 0b1100])

    @to_be_implemented
    def get_status(self, axis):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Simulator.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self, axis) -&gt; int:
    return random.choice([0b0000, 0b0100, 0b1000, 0b1100])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Simulator.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@to_be_implemented
def get_status(self, axis):
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.stages.huber" href="index.html">egse.stages.huber</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.calculate_relative_movement" href="#egse.stages.huber.smc9300.calculate_relative_movement">calculate_relative_movement</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.stages.huber.smc9300.Axis" href="#egse.stages.huber.smc9300.Axis">Axis</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.Axis.get_converted_slew_speed" href="#egse.stages.huber.smc9300.Axis.get_converted_slew_speed">get_converted_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.get_current_position" href="#egse.stages.huber.smc9300.Axis.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.get_encode_counter_value" href="#egse.stages.huber.smc9300.Axis.get_encode_counter_value">get_encode_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.get_encoder_position" href="#egse.stages.huber.smc9300.Axis.get_encoder_position">get_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.get_slew_speed" href="#egse.stages.huber.smc9300.Axis.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.is_in_position" href="#egse.stages.huber.smc9300.Axis.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.set_commanded_position" href="#egse.stages.huber.smc9300.Axis.set_commanded_position">set_commanded_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.set_slew_speed" href="#egse.stages.huber.smc9300.Axis.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.Axis.start" href="#egse.stages.huber.smc9300.Axis.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.AxisTimer" href="#egse.stages.huber.smc9300.AxisTimer">AxisTimer</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.AxisTimer.get_delta_time" href="#egse.stages.huber.smc9300.AxisTimer.get_delta_time">get_delta_time</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.AxisTimer.start" href="#egse.stages.huber.smc9300.AxisTimer.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Controller" href="#egse.stages.huber.smc9300.HuberSMC9300Controller">HuberSMC9300Controller</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Controller.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Controller.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Controller.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Controller.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Controller.is_connected" href="#egse.stages.huber.smc9300.HuberSMC9300Controller.is_connected">is_connected</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value">get_conf_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Proxy" href="#egse.stages.huber.smc9300.HuberSMC9300Proxy">HuberSMC9300Proxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Simulator" href="#egse.stages.huber.smc9300.HuberSMC9300Simulator">HuberSMC9300Simulator</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Simulator.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Simulator.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Simulator.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Simulator.get_status">get_status</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.stages.huber.smc9300 API documentation</title>
<meta name="description" content="This module defines the device classes to be used to connect to and control the HUBER Stages." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.stages.huber.smc9300</code></h1>
</header>
<section id="section-intro">
<p>This module defines the device classes to be used to connect to and control the HUBER Stages.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the device classes to be used to connect to and control the HUBER Stages.
&#34;&#34;&#34;
from __future__ import annotations

import logging
import textwrap
from typing import Tuple

import rich
import time

from egse.control import Failure
from egse.device import DeviceConnectionError
from egse.device import DeviceConnectionState
from egse.device import DeviceInterface
from egse.mixin import DynamicCommandMixin
from egse.mixin import add_cr_lf
from egse.mixin import dynamic_command
from egse.proxy import DynamicProxy
from egse.settings import Settings
from egse.stages.huber.smc9300_devif import HuberError
from egse.stages.huber.smc9300_devif import HuberSMC9300EthernetInterface
from egse.state import GlobalState
from egse.zmq_ser import connect_address

# Explicitly set the module name instead of __name__. When module is executed instead of imported
# __name__ will result in __main__ and no logging to zmq will be done.

MODULE_LOGGER = logging.getLogger(&#34;egse.stages.huber.smc9300&#34;)

HC_SETTINGS = Settings.load(&#34;Huber Controller&#34;)
CTRL_SETTINGS = Settings.load(&#34;Huber Control Server&#34;)
DEVICE_SETTINGS = Settings.load(filename=&#34;smc9300.yaml&#34;)


def print_state(state: int) -&gt; None:
    &#34;&#34;&#34;Prints the state of the axis.&#34;&#34;&#34;

    rich.print(
        textwrap.dedent(
            f&#34;&#34;&#34;\
                axis ready: {bool(state &amp; 1)}
                reference position installed: {bool(state &amp; 2)}
                end/limit switch EL- active: {bool(state &amp; 4)}
                end/limit switch EL+ active: {bool(state &amp; 8)}
                program execution in progress: {bool(state &amp; 64)}
                controller ready: {bool(state &amp; 128)}
                oscillation in progress: {bool(state &amp; 256)}
                oscillation positioning error: {bool(state &amp; 512)}
                encoder reference installed: {bool(state &amp; 1024)}
                axis error: {bool(state &amp; 16384)}
            &#34;&#34;&#34;
        )
    )


def untangle_status(status: str) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary with all the values from the status string.&#34;&#34;&#34;

    try:

        axis, errn, errm, pos, epos, el, ref, eref, rdy, osc, prog, *_ = status.split(&#34;:&#34;)

        return {
            &#34;axis&#34;: int(axis),  # the axis id
            &#34;err_no&#34;: int(errn),  # error number
            &#34;err_msg&#34;: errm,  # error message
            &#34;pos&#34;: float(pos),  # position
            &#34;epos&#34;: float(epos),  # encode position
            &#34;elimit&#34;: int(el),  # end/limit status
            &#34;ref&#34;: int(ref),  # reference status
            &#34;eref&#34;: int(eref),  # encoder reference status
            &#34;ctrl&#34;: int(rdy),  # controller ready
            &#34;osc&#34;: int(osc),  # oscillation status
            &#34;prog&#34;: int(prog),  # program running
        }
    except ValueError as exc:
        raise ValueError(
            textwrap.dedent(
                f&#34;&#34;&#34;\
                Could not disentangle the status from SMC9300, response from the device can not be parsed.
                The expected format is &#34;axis:err_no:err_msg:pos:epos:elimit:ref:eref:ctrl:osc:prog&#34;, where
                `err_msg` is a string, `pos` and `epos` are floats and the others are of type int.
                {status=}
                &#34;&#34;&#34;
            )
        ) from exc


def decode_response(response: bytes) -&gt; str:
    &#34;&#34;&#34;Decodes the bytes object and strips off the newline.&#34;&#34;&#34;

    # MODULE_LOGGER.debug(f&#34;response -&gt; {response}&#34;)

    return response.decode().rstrip()


def decode_info(response: bytes) -&gt; str:
    response = decode_response(response).split(&#34;\r\n&#34;)

    return &#34;\n&#34;.join(response)


def decode_get_state(response: bytes) -&gt; int:
    &#34;&#34;&#34;Decodes the response from the get state command and strips off the newline.&#34;&#34;&#34;

    # The response argument has the following format: &#39;&lt;axis&gt;:&lt;state&gt;;&#39;
    # where &lt;axis&gt; is 1, 2, or 3 and we need the &lt;state&gt;, so we to
    # cut e.g. &#39;1:&#39; and &#39;;&#39; if &lt;axis&gt; is 1.

    response = decode_response(response)
    return int(response[2:-1])


def decode_get_parameter(response: bytes) -&gt; Tuple[str, int, str]:
    &#34;&#34;&#34;
    Decodes the response from a request for a parameter value. The response contains
    the parameter name, the axis, and the value.

    Returns:
        A tuple of (`&lt;parameter name: str&gt;`, `&lt;axis: int&gt;`, `&lt;value: str&gt;`)
    &#34;&#34;&#34;
    response = decode_response(response)
    name, value = response.split(&#34;:&#34;)
    axis = name[-1]
    name = name[:-1]
    return name, int(axis), value


def decode_get_error(response: bytes) -&gt; Tuple[str]:
    &#34;&#34;&#34;Decodes the response from the get error command and strips off the newline.&#34;&#34;&#34;

    response = decode_response(response)

    # The response string looks like &#39;&lt;axis&gt;:&lt;errno&gt; &lt;errmsg&gt;&#39; where &lt;axis&gt; is the axis number,
    # &lt;errno&gt; is the error number and &lt;errmsg&gt; is the error message.

    response = response[2:]

    error = response.split(maxsplit=1)

    if len(error) == 1 and error[0] == &#39;0&#39;:
        error.append(&#34;no error&#34;)

    return tuple(error)


def decode_axis_float(response: bytes) -&gt; float:
    &#34;&#34;&#34;Decodes the response of type `&lt;axis&gt;:&lt;float&gt;;` and strips off the newline.&#34;&#34;&#34;

    response = decode_response(response)

    return float(response[2:-1])


def decode_axis_int(response: bytes) -&gt; int:
    &#34;&#34;&#34;Decodes the response of type `&lt;axis&gt;:&lt;int&gt;;` and strips off the newline.&#34;&#34;&#34;

    response = decode_response(response)

    return int(response[2:-1])


def decode_get_configuration(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;Decodes the response from the controller on the request for the configuration parameters.

    Returns:
        A dictionary with parameter names and their values.
    &#34;&#34;&#34;
    all_conf = decode_response(response).split(&#34;\r\n&#34;)

    # Every item in the all_conf list has the format &#39;&lt;var&gt;&lt;axis&gt;:&lt;value&gt;&#39; where &lt;var&gt; is the
    # name of the configuration variable, &lt;axis&gt; is the axis number and &lt;value&gt; is the current
    # value for the configuration variable. A comment line starts with a &#39;#&#39; character.

    all_conf = [item.split(&#34;:&#34;) for item in all_conf if not item.startswith(&#34;#&#34;)]

    # Turn this list of lists into a dictionary and remove the &lt;axis&gt; from the variable names

    return {key[:-1]: value for key, value in all_conf}


def process_cmd_string(command: str) -&gt; str:
    &#34;&#34;&#34;Prepares the command string for sending to the controller.
    A carriage return and newline is appended to the command.&#34;&#34;&#34;

    # MODULE_LOGGER.debug(f&#34;process_command() = {command}&#34;)

    return add_cr_lf(command)


class HuberSMC9300Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Controller, Simulator and Proxy classes for this device.
    &#34;&#34;&#34;

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_info)
    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve basic information about the Huber Stages and the Controller.
        The returned string contains multiple lines seperated by a newline (`\n`).
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?conf${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_configuration)
    def get_configuration(self, axis) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Returns the configuration parameters for the given axis.

        Returns:
            A dictionary with configuration parameter names and their values.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_conf_value(self, axis, name):
        &#34;&#34;&#34;
        Returns the value of the requested configuration parameter.

        Returns:
            A string containing the value of the requested parameter. The returned object is
            always a string and needs to be converted to int or float by the caller if needed.
        &#34;&#34;&#34;
        conf = self.get_configuration(axis)
        return conf[name] if name in conf else None

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?v&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_response)
    def get_version(self):
        &#34;&#34;&#34;
        Returns the version information about the current control program on the HUBER controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    def goto(self, axis: int, position: float, wait: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Moves the stage to the given absolute position. For the big rotation stage, the movement is done
        relative to the current position and the avoidance range and hard stop from the Setup are taken
        into account.

        A positive angle moves the rotation stage counter clockwise.

        Args:
            axis (int): the integer identifier of one of the axis controlled by the SMC
            position (float): when the given axis is a rotation stage, the position is given
                in degrees [deg], for a translation stage, the position is given
                in millimeter [mm].
            wait (bool): Only return when the device is in position [default=True]

        Returns:
            Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
            was hit, and -1 is returned when the LIMIT- switch was hit.
        &#34;&#34;&#34;

        # For the big rotation stage use the workaround to avoid continuous movement in the same
        # direction, and to avoid the limit switch.

        if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
            current = self.get_current_position(axis)
            movement = calculate_relative_movement(current, position)
            self.move_direct(axis, movement)
        else:
            self.goto_direct(axis, position)

        if wait:
            return self.wait_until_axis_ready(axis)

        return 0

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;goto${axis}:${position}&#34;,
        process_cmd_string=process_cmd_string)
    def goto_direct(self, axis: int, position: float) -&gt; None:
        &#34;&#34;&#34;
        Moves the stage to the given absolute position. No position checking nor conversion is done.

        A positive angle moves the rotation stage counter clockwise.

        Args:
            axis (int): the integer identifier of one of the axis controlled by the SMC
            position (float): when the given axis is a rotation stage, the position is given
                in degrees [deg], for a translation stage, the position is given
                in millimeter [mm].
        &#34;&#34;&#34;
        raise NotImplementedError

    def move(self, axis: int, distance: float, wait: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Moves the stage relative to the current position in the given distance.

        A positive angle moves the rotation stage counterclockwise.

        Args:
            axis: the integer identifier of one of the axis controlled by the SMC
            distance: when the given axis is a rotation stage, the distance is given
                in degrees [deg], for a translation stage, the distance is given
                in millimeter [mm].
            wait (bool): Only return when the device is in position [default=True]

        Returns:
            Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
            was hit, and -1 is returned when the LIMIT- switch was hit.
        &#34;&#34;&#34;
        self.move_direct(axis, distance)
        if wait:
            return self.wait_until_axis_ready(axis)
        return 0

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;move${axis}:${distance}&#34;,
        process_cmd_string=process_cmd_string)
    def move_direct(self, axis: int, distance: float) -&gt; None:
        &#34;&#34;&#34;
        Moves the stage relative to the current position in the given distance.

        A positive angle moves the rotation stage counterclockwise.

        Args:
            axis: the integer identifier of one of the axis controlled by the SMC
            distance: when the given axis is a rotation stage, the distance is given
                in degrees [deg], for a translation stage, the distance is given
                in millimeter [mm].
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;ffast${axis}:${speed}&#34;,
        process_cmd_string=process_cmd_string)
    def set_slew_speed(self, axis, speed):
        &#34;&#34;&#34;
        Configures the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.

        For axis=1 (big rotation stage) the slew speed is given in 1e-4 deg/s, i.e. a slew_speed of
        15_000 results in an actual speed of 1.5deg/s.

        Manual positioning commands are i.e. ``fast``, ``move``, ``goto``, or
        the use of the direction keys.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_slew_speed(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.
        &#34;&#34;&#34;
        return int(self.get_parameter(axis, &#34;ffast&#34;)[-1])

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;edev${axis}:${value}&#34;,
        process_cmd_string=process_cmd_string)
    def set_edev(self, axis, value):
        &#34;&#34;&#34;
        Configure the maximum allowed deviation between actual position
        and commanded target position for closed-loop positioning. this
        value must not be less than the resolution of the used encoder.

        This command cannot be executed during positioning or program execution.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_edev(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the maximum allowed deviation between actual position
        and commanded target position for closed-loop positioning.
        &#34;&#34;&#34;
        return float(self.get_parameter(axis, &#34;edev&#34;)[-1])

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;edir${axis}:${value}&#34;,
        process_cmd_string=process_cmd_string)
    def set_edir(self, axis, value):
        &#34;&#34;&#34;
        Configure the encoder rotation sense. For the case the controller returns the encoder
        position information with the wrong sign, use this command to change it correspondingly.

        This command cannot be executed during positioning or program execution.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_edir(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the encoder rotation sense: 0 is normal, 1 is inverted.
        &#34;&#34;&#34;
        return int(self.get_parameter(axis, &#34;edir&#34;)[-1])

    def is_in_position(self, axis) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the mechanism is in position and not moving.
        &#34;&#34;&#34;

        # The sleep of 0.5s here is empirically determined because tests failed randomly
        # because the position was apparently not completely reached. We also noticed an
        # oscilation when arriving at a certain position. A diagnostic test revealed that
        # the status sometimes changes bit 0 and bit 7 indicating the axis/controller
        # ready before the mechanism actually reached the setpoint. We need about
        # 0.2s before the actual value is reached, 0.5 seconds is a safe wait time.

        time.sleep(0.5)

        state = self.get_state(axis)

        return state &amp; 0b10000001 == 0b10000001

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?p${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_axis_float)
    def get_current_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current position for this axis as a float. The position is
        given in degrees for rotation stages and in mm for translation stages.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?e${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_axis_float)
    def get_current_encoder_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current encoder position for this axis as a float. The position
        is given in degrees for rotation stages and in mm for translation stages.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?ec${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_axis_int)
    def get_current_encoder_counter_value(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the current encoder counter value for this axis as an int.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?err${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_error)
    def get_error(self, axis) -&gt; Tuple[str]:
        &#34;&#34;&#34;
        Returns the last occurred error and corresponding error message for the given axis.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?${name}${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_parameter)
    def get_parameter(self, axis, name) -&gt; Tuple[str, int, str]:
        &#34;&#34;&#34;
        Queries the device for the current value of the given parameter and the given axis.

        Returns:
            A tuple containing the parameter name (str), axis (int), and the value (str).
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;cerr${axis}&#34;,
        process_cmd_string=process_cmd_string)
    def clear_error(self, axis):
        &#34;&#34;&#34;
        Reset the last occurred error and clear the error message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;quit&#34;,
        process_cmd_string=process_cmd_string)
    def quit(self) -&gt; None:
        &#34;&#34;&#34;
        Immediately stop any positioning process.

        The controller decelerates with the configured deceleration ramp.
        In contrast to an emergency stop caused by limit switch events,
        the position information remains valid in this case.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;write&#34;, cmd_string=&#34;update&#34;, process_cmd_string=process_cmd_string)
    def save_configuration(self):
        &#34;&#34;&#34;Saves the current configuration permanently. The settings will be reloaded automatically
        the next time the controller starts.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;write&#34;, cmd_string=&#34;reset&#34;, process_cmd_string=process_cmd_string)
    def reset(self):
        &#34;&#34;&#34;Resets the controller back to power-on state. When you previously saved the configuration,
        those values will be reloaded automatically, otherwise the default configuration will be loaded.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?s${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_state)
    def get_state(self, axis) -&gt; int:
        &#34;&#34;&#34;Query of the current operating state of the controller.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?status${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_response)
    def get_status(self, axis) -&gt; str:
        &#34;&#34;&#34;
        Returns the status of the given axis. The status contains the following information:

            * axis: the axis number
            * err_no: the error number
            * err_msg: the error message if there is an error
            * pos: the current position
            * epos: the encoder position
            * elimit: end/limit status
            * ref: reference status
            * eref: encoder reference status
            * ctrl: is controller ready?
            * osc: status oscillation
            * pro: is program running?

        The status response can be untangled as follows:

            &gt;&gt;&gt; dev = HuberSMC9300Proxy()
            &gt;&gt;&gt; untangle_status(dev.get_status(axis=1))

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;zero${axis}&#34;,
        process_cmd_string=process_cmd_string)
    def zero(self, axis) -&gt; None:
        &#34;&#34;&#34;
        Set the current position of the axis to zero (0.00). If a reference position
        offset value is configured (see the configuration command `rofs`) the current
        position is set to that reference offset value.

        If you want to retain this zero position, you will have to also call the
        &#39;save_configuration()&#39; command. Otherwise the zero position will be lost
        after a reset or a power cycle.
        &#34;&#34;&#34;
        raise NotImplementedError

    def wait_until_axis_ready(self, axis: int) -&gt; int:
        &#34;&#34;&#34;
        Send the given axis a state query and wait for the response.

        This function will return only when one of the following states has been reached:

        * The LIMIT- switch was activated
        * The LIMIT+ switch was activated
        * The end position was reached, axis ready (bit 0) &amp; controller ready (bit 7)

        Returns:

            *  0: on success, i.e. position is reached
            * +1: when LIMIT+ switch is reached
            * -1: when LIMIT- switch is reached
        &#34;&#34;&#34;

        # MODULE_LOGGER.debug(f&#34;Wait until axis {axis} is ready...&#34;)

        while True:

            time.sleep(0.5)

            state = self.get_state(axis)

            # MODULE_LOGGER.debug(f&#34;state for axis {axis}: {beautify_binary(state)} ({state})&#34;)

            if state &amp; 4 == 4:
                MODULE_LOGGER.warning(&#34;LIMIT- active!&#34;)
                rv = -1
                break

            if state &amp; 8 == 8:
                MODULE_LOGGER.warning(&#34;LIMIT+ active!&#34;)
                rv = +1
                break

            if state &amp; 512 == 512:
                MODULE_LOGGER.error(&#34;oscillation positioning error (encoder)&#34;)

            if state &amp; 129 == 129:
                # exit loop when position is reached,
                # state bit 0 and bit 7 indicate &#39;axis ready&#39; AND &#39;controller ready&#39;,
                # i.e. all axes stopped
                rv = 0
                break

            if state &amp; 16384:  # 0b100_0000_0000_0000
                response = self.get_error(axis)
                MODULE_LOGGER.error(f&#34;ERROR on axis {axis}: {response}&#34;)
                self.clear_error(axis)

        # The sleep of 0.5s here is empirically determined because tests failed randomly
        # because the position was apparently not completely reached. We also noticed an
        # oscillation when arriving at a certain position. A diagnostic test revealed that
        # the state sometimes changes bit 0 and bit 7 indicating the axis/controller
        # ready before the mechanism actually reached the setpoint. We need about
        # 0.2s before the actual value is reached, 0.5 seconds is a safe wait time.

        time.sleep(0.5)

        return rv


class HuberSMC9300Controller(HuberSMC9300Interface, DynamicCommandMixin):
    &#34;&#34;&#34;
    The HuberSmC9300Controller class is used to directly communicate with the HUBER SMC9300
    Controller through an Ethernet interface.
    &#34;&#34;&#34;

    def __init__(self, hostname=HC_SETTINGS.HOSTNAME, port=HC_SETTINGS.PORT):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the HUBER SMC9300 Hardware Controller.

        Args:
            hostname (str): the IP address or fully qualified hostname of the HUBER hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the `settings.yaml`
                configuration file.

        &#34;&#34;&#34;
        super().__init__()

        MODULE_LOGGER.info(
            f&#34;Initializing Huber SMC9300 Controller with hostname={hostname} on port={port}&#34;)

        self.transport = self.huber = HuberSMC9300EthernetInterface(hostname, port)

        self._number_of_axes = HC_SETTINGS.NUMBER_OF_AXES

    def connect(self):
        try:
            self.huber.connect()

            # set the speed of each of the stages to the default speed from the Settings.

            for stage in 1, 2, 3:
                default_speed = HC_SETTINGS.DEFAULT_SPEED[stage - 1]
                self.set_slew_speed(stage, default_speed)

        except HuberError as exc:
            MODULE_LOGGER.warning(f&#34;HuberError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the HUBER Stage.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        try:
            # Clear the error for each of the axis before disconnecting
            for axis in range(1, self._number_of_axes + 1):
                self.clear_error(axis)
            self.huber.disconnect()
        except DeviceConnectionError as exc:
            raise ConnectionError(&#34;Couldn&#39;t disconnect from HUBER Controller.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the HUBER Stages Controller is connected. &#34;&#34;&#34;
        return self.huber.is_connected()

    def is_simulator(self):
        return &#34;simulator: true&#34; in self.info()


class HuberSMC9300Simulator(HuberSMC9300Interface):
    &#34;&#34;&#34;
    The class simulates the HUBER Stages.
    &#34;&#34;&#34;

    def __init__(self):
        super().__init__()
        MODULE_LOGGER.critical(
            textwrap.dedent(
                &#34;&#34;&#34;\
                The HuberSMC9300Simulator class is deprecated in favor of the smc9300_sim process. 
                Start the SMC9300 simulator in a separate terminal with the command:
                
                   smc9300_sim start
                
                then restart the SCM9300 Control Server: 
                
                   smc9300_cs start
                
                Make sure the local_settings.yaml file contains the correct HOSTNAME
                and PORT for accessing the simulator process. 
                &#34;&#34;&#34;
            )
        )


REQUEST_TIMEOUT = 10_000  # 10 seconds


class HuberSMC9300Proxy(DynamicProxy, HuberSMC9300Interface):
    &#34;&#34;&#34;
    The HuberProxy class is used to connect to the Huber SMC9300 control server and send commands
    to the HUBER Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
            self,
            protocol=CTRL_SETTINGS.PROTOCOL,
            hostname=CTRL_SETTINGS.HOSTNAME,
            port=CTRL_SETTINGS.COMMANDING_PORT,
            timeout=REQUEST_TIMEOUT
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol
                [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
            timeout: time out on the response from the control server [milliseconds]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)


def calculate_relative_movement(current, setpoint, hardstop=None, avoidance=None):
    &#34;&#34;&#34;
    This function calculates the relative movement from the current position to the given setpoint.
    It defines the direction and the size of the movement based on the current position,
    the setpoint, the hardstop position and the avoidance angle.

    The function strives to always return the smallest possible angle in order to minimize the
    duration of the movement.

    The target position (setpoint) can not fall in the range [hardstop - avoidance,
    hardstop + avoidance]. There is no check on the current position, it is assumed not to be in
    the avoidance range.

    If hardstop or avoidance are not given, they are loaded from the setup.

    Args:
        current (float): the current position of the rotation stage
        setpoint (float): the target position of the rotation stage
        hardstop (float): the location of the hardstop
        avoidance (float): angle of avoidance
    Returns:
        The angle to move relative from current position to setpoint.
    Raises:
        A ValueError when the setpoint falls inside the avoidance range, i.e.
        [-180 + avoidance, +180 - avoidance].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    avoidance = avoidance if avoidance is not None else setup.gse.stages.big_rotation_stage.avoidance
    hardstop = hardstop if hardstop is not None else setup.gse.stages.big_rotation_stage.hardstop

    # MODULE_LOGGER.debug(f&#34;@entry: {current=}, {setpoint=}, {hardstop=}, {avoidance=}&#34;)

    # Bring the current and the setpoint between 0 and 360 (non-inclusive)

    current %= 360
    setpoint %= 360

    # MODULE_LOGGER.debug(f&#34;After % 360: {current=}, {setpoint=}&#34;)

    # Check if the setpoint falls in the avoidance range

    if hardstop - avoidance &lt; setpoint &lt; hardstop + avoidance:
        raise ValueError(
            f&#34;setpoint argument shall NOT be between {hardstop - avoidance} and &#34;
            f&#34;{hardstop + avoidance}, given value {setpoint = }&#34;)

    # Find the smallest angle between the current and the setpoint

    movement = min(abs(current - setpoint), abs(360 + current - setpoint))
    direction = +1 if current + movement == setpoint else -1

    target = current + direction * movement

    # MODULE_LOGGER.debug(
    #     f&#34;Smallest movement: {current=}, {setpoint=}, {target=:.2f}, &#34;
    #     f&#34;{movement=:.2f}, {direction=}&#34;
    # )

    # Check if we will pass over 180º and invert direction if true.

    if (current &lt; target and current &lt; hardstop &lt; target) or \
            (current &gt; target and target &lt; hardstop &lt; current):
        movement = 360 - movement
        direction *= -1

        # target = current + direction * movement
        # MODULE_LOGGER.debug(
        #     f&#34;corrected: {current=}, {setpoint=}, {target=:.2f}, {movement=:.2f}, {direction=}&#34;
        # )

    return direction * movement


if __name__ == &#34;__main__&#34;:
    from rich import print

    huber = HuberSMC9300Controller()

    # The .connect() method takes 1.5s because it also configures the slew speed of all the axes

    huber.connect()

    print(f&#34;{huber.info()=}&#34;)
    print(f&#34;{huber.get_version()=}&#34;)
    print(f&#34;{huber.get_error(axis=1)=}&#34;)
    print(f&#34;{huber.get_error(axis=2)=}&#34;)
    print(f&#34;{huber.get_error(axis=3)=}&#34;)
    print(f&#34;{huber.get_state(axis=1)=}&#34;)
    print(f&#34;{huber.get_state(axis=2)=}&#34;)
    print(f&#34;{huber.get_state(axis=3)=}&#34;)
    print(f&#34;{huber.get_status(axis=1)=}&#34;)
    print(f&#34;{huber.get_status(axis=2)=}&#34;)
    print(f&#34;{huber.get_status(axis=3)=}&#34;)
    print(f&#34;{huber.get_configuration(axis=1)=}&#34;)
    print(f&#34;{huber.get_configuration(axis=2)=}&#34;)
    print(f&#34;{huber.get_configuration(axis=3)=}&#34;)
    print(f&#34;{huber.get_conf_value(axis=1, name=&#39;gnum&#39;)=}&#34;)
    print(f&#34;{huber.get_slew_speed(axis=1)=}&#34;)
    print(f&#34;{huber.get_slew_speed(axis=2)=}&#34;)
    print(f&#34;{huber.get_slew_speed(axis=3)=}&#34;)
    print(f&#34;{huber.is_in_position(axis=1)=}&#34;)
    print(f&#34;{huber.is_in_position(axis=2)=}&#34;)
    print(f&#34;{huber.is_in_position(axis=3)=}&#34;)
    print(f&#34;{huber.get_current_position(axis=1)=}&#34;)
    print(f&#34;{huber.get_current_position(axis=2)=}&#34;)
    print(f&#34;{huber.get_current_position(axis=3)=}&#34;)
    print(f&#34;{huber.get_current_encoder_position(axis=1)=}&#34;)
    print(f&#34;{huber.get_current_encoder_position(axis=2)=}&#34;)
    print(f&#34;{huber.get_current_encoder_position(axis=3)=}&#34;)
    print(f&#34;{huber.get_current_encoder_counter_value(axis=1)=}&#34;)
    print(f&#34;{huber.get_current_encoder_counter_value(axis=2)=}&#34;)
    print(f&#34;{huber.get_current_encoder_counter_value(axis=3)=}&#34;)

    for axis_ in range(1, 4):
        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;ffast&#39;)=}&#34;)
        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;frun&#39;)=}&#34;)
        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;rofs&#39;)=}&#34;)

        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;ecl&#39;)=}&#34;)
        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;edev&#39;)=}&#34;)
        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;edir&#39;)=}&#34;)
        print(f&#34;{huber.get_parameter(axis=axis_, name=&#39;eres&#39;)=}&#34;)

        huber.clear_error(axis=axis_)

    huber.disconnect()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.stages.huber.smc9300.calculate_relative_movement"><code class="name flex">
<span>def <span class="ident">calculate_relative_movement</span></span>(<span>current, setpoint, hardstop=None, avoidance=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function calculates the relative movement from the current position to the given setpoint.
It defines the direction and the size of the movement based on the current position,
the setpoint, the hardstop position and the avoidance angle.</p>
<p>The function strives to always return the smallest possible angle in order to minimize the
duration of the movement.</p>
<p>The target position (setpoint) can not fall in the range [hardstop - avoidance,
hardstop + avoidance]. There is no check on the current position, it is assumed not to be in
the avoidance range.</p>
<p>If hardstop or avoidance are not given, they are loaded from the setup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>current</code></strong> :&ensp;<code>float</code></dt>
<dd>the current position of the rotation stage</dd>
<dt><strong><code>setpoint</code></strong> :&ensp;<code>float</code></dt>
<dd>the target position of the rotation stage</dd>
<dt><strong><code>hardstop</code></strong> :&ensp;<code>float</code></dt>
<dd>the location of the hardstop</dd>
<dt><strong><code>avoidance</code></strong> :&ensp;<code>float</code></dt>
<dd>angle of avoidance</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The angle to move relative from current position to setpoint.</p>
<h2 id="raises">Raises</h2>
<p>A ValueError when the setpoint falls inside the avoidance range, i.e.
[-180 + avoidance, +180 - avoidance].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_relative_movement(current, setpoint, hardstop=None, avoidance=None):
    &#34;&#34;&#34;
    This function calculates the relative movement from the current position to the given setpoint.
    It defines the direction and the size of the movement based on the current position,
    the setpoint, the hardstop position and the avoidance angle.

    The function strives to always return the smallest possible angle in order to minimize the
    duration of the movement.

    The target position (setpoint) can not fall in the range [hardstop - avoidance,
    hardstop + avoidance]. There is no check on the current position, it is assumed not to be in
    the avoidance range.

    If hardstop or avoidance are not given, they are loaded from the setup.

    Args:
        current (float): the current position of the rotation stage
        setpoint (float): the target position of the rotation stage
        hardstop (float): the location of the hardstop
        avoidance (float): angle of avoidance
    Returns:
        The angle to move relative from current position to setpoint.
    Raises:
        A ValueError when the setpoint falls inside the avoidance range, i.e.
        [-180 + avoidance, +180 - avoidance].
    &#34;&#34;&#34;

    setup = GlobalState.setup

    avoidance = avoidance if avoidance is not None else setup.gse.stages.big_rotation_stage.avoidance
    hardstop = hardstop if hardstop is not None else setup.gse.stages.big_rotation_stage.hardstop

    # MODULE_LOGGER.debug(f&#34;@entry: {current=}, {setpoint=}, {hardstop=}, {avoidance=}&#34;)

    # Bring the current and the setpoint between 0 and 360 (non-inclusive)

    current %= 360
    setpoint %= 360

    # MODULE_LOGGER.debug(f&#34;After % 360: {current=}, {setpoint=}&#34;)

    # Check if the setpoint falls in the avoidance range

    if hardstop - avoidance &lt; setpoint &lt; hardstop + avoidance:
        raise ValueError(
            f&#34;setpoint argument shall NOT be between {hardstop - avoidance} and &#34;
            f&#34;{hardstop + avoidance}, given value {setpoint = }&#34;)

    # Find the smallest angle between the current and the setpoint

    movement = min(abs(current - setpoint), abs(360 + current - setpoint))
    direction = +1 if current + movement == setpoint else -1

    target = current + direction * movement

    # MODULE_LOGGER.debug(
    #     f&#34;Smallest movement: {current=}, {setpoint=}, {target=:.2f}, &#34;
    #     f&#34;{movement=:.2f}, {direction=}&#34;
    # )

    # Check if we will pass over 180º and invert direction if true.

    if (current &lt; target and current &lt; hardstop &lt; target) or \
            (current &gt; target and target &lt; hardstop &lt; current):
        movement = 360 - movement
        direction *= -1

        # target = current + direction * movement
        # MODULE_LOGGER.debug(
        #     f&#34;corrected: {current=}, {setpoint=}, {target=:.2f}, {movement=:.2f}, {direction=}&#34;
        # )

    return direction * movement</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_axis_float"><code class="name flex">
<span>def <span class="ident">decode_axis_float</span></span>(<span>response: bytes) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the response of type <code>&lt;axis&gt;:&lt;float&gt;;</code> and strips off the newline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_axis_float(response: bytes) -&gt; float:
    &#34;&#34;&#34;Decodes the response of type `&lt;axis&gt;:&lt;float&gt;;` and strips off the newline.&#34;&#34;&#34;

    response = decode_response(response)

    return float(response[2:-1])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_axis_int"><code class="name flex">
<span>def <span class="ident">decode_axis_int</span></span>(<span>response: bytes) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the response of type <code>&lt;axis&gt;:&lt;int&gt;;</code> and strips off the newline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_axis_int(response: bytes) -&gt; int:
    &#34;&#34;&#34;Decodes the response of type `&lt;axis&gt;:&lt;int&gt;;` and strips off the newline.&#34;&#34;&#34;

    response = decode_response(response)

    return int(response[2:-1])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_get_configuration"><code class="name flex">
<span>def <span class="ident">decode_get_configuration</span></span>(<span>response: bytes) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the response from the controller on the request for the configuration parameters.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary with parameter names and their values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_get_configuration(response: bytes) -&gt; dict | Failure:
    &#34;&#34;&#34;Decodes the response from the controller on the request for the configuration parameters.

    Returns:
        A dictionary with parameter names and their values.
    &#34;&#34;&#34;
    all_conf = decode_response(response).split(&#34;\r\n&#34;)

    # Every item in the all_conf list has the format &#39;&lt;var&gt;&lt;axis&gt;:&lt;value&gt;&#39; where &lt;var&gt; is the
    # name of the configuration variable, &lt;axis&gt; is the axis number and &lt;value&gt; is the current
    # value for the configuration variable. A comment line starts with a &#39;#&#39; character.

    all_conf = [item.split(&#34;:&#34;) for item in all_conf if not item.startswith(&#34;#&#34;)]

    # Turn this list of lists into a dictionary and remove the &lt;axis&gt; from the variable names

    return {key[:-1]: value for key, value in all_conf}</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_get_error"><code class="name flex">
<span>def <span class="ident">decode_get_error</span></span>(<span>response: bytes) ‑> Tuple[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the response from the get error command and strips off the newline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_get_error(response: bytes) -&gt; Tuple[str]:
    &#34;&#34;&#34;Decodes the response from the get error command and strips off the newline.&#34;&#34;&#34;

    response = decode_response(response)

    # The response string looks like &#39;&lt;axis&gt;:&lt;errno&gt; &lt;errmsg&gt;&#39; where &lt;axis&gt; is the axis number,
    # &lt;errno&gt; is the error number and &lt;errmsg&gt; is the error message.

    response = response[2:]

    error = response.split(maxsplit=1)

    if len(error) == 1 and error[0] == &#39;0&#39;:
        error.append(&#34;no error&#34;)

    return tuple(error)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_get_parameter"><code class="name flex">
<span>def <span class="ident">decode_get_parameter</span></span>(<span>response: bytes) ‑> Tuple[str, int, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the response from a request for a parameter value. The response contains
the parameter name, the axis, and the value.</p>
<h2 id="returns">Returns</h2>
<p>A tuple of (<code>&lt;parameter name: str&gt;</code>, <code>&lt;axis: int&gt;</code>, <code>&lt;value: str&gt;</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_get_parameter(response: bytes) -&gt; Tuple[str, int, str]:
    &#34;&#34;&#34;
    Decodes the response from a request for a parameter value. The response contains
    the parameter name, the axis, and the value.

    Returns:
        A tuple of (`&lt;parameter name: str&gt;`, `&lt;axis: int&gt;`, `&lt;value: str&gt;`)
    &#34;&#34;&#34;
    response = decode_response(response)
    name, value = response.split(&#34;:&#34;)
    axis = name[-1]
    name = name[:-1]
    return name, int(axis), value</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_get_state"><code class="name flex">
<span>def <span class="ident">decode_get_state</span></span>(<span>response: bytes) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the response from the get state command and strips off the newline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_get_state(response: bytes) -&gt; int:
    &#34;&#34;&#34;Decodes the response from the get state command and strips off the newline.&#34;&#34;&#34;

    # The response argument has the following format: &#39;&lt;axis&gt;:&lt;state&gt;;&#39;
    # where &lt;axis&gt; is 1, 2, or 3 and we need the &lt;state&gt;, so we to
    # cut e.g. &#39;1:&#39; and &#39;;&#39; if &lt;axis&gt; is 1.

    response = decode_response(response)
    return int(response[2:-1])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_info"><code class="name flex">
<span>def <span class="ident">decode_info</span></span>(<span>response: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_info(response: bytes) -&gt; str:
    response = decode_response(response).split(&#34;\r\n&#34;)

    return &#34;\n&#34;.join(response)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.decode_response"><code class="name flex">
<span>def <span class="ident">decode_response</span></span>(<span>response: bytes) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes the bytes object and strips off the newline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_response(response: bytes) -&gt; str:
    &#34;&#34;&#34;Decodes the bytes object and strips off the newline.&#34;&#34;&#34;

    # MODULE_LOGGER.debug(f&#34;response -&gt; {response}&#34;)

    return response.decode().rstrip()</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.print_state"><code class="name flex">
<span>def <span class="ident">print_state</span></span>(<span>state: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the state of the axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_state(state: int) -&gt; None:
    &#34;&#34;&#34;Prints the state of the axis.&#34;&#34;&#34;

    rich.print(
        textwrap.dedent(
            f&#34;&#34;&#34;\
                axis ready: {bool(state &amp; 1)}
                reference position installed: {bool(state &amp; 2)}
                end/limit switch EL- active: {bool(state &amp; 4)}
                end/limit switch EL+ active: {bool(state &amp; 8)}
                program execution in progress: {bool(state &amp; 64)}
                controller ready: {bool(state &amp; 128)}
                oscillation in progress: {bool(state &amp; 256)}
                oscillation positioning error: {bool(state &amp; 512)}
                encoder reference installed: {bool(state &amp; 1024)}
                axis error: {bool(state &amp; 16384)}
            &#34;&#34;&#34;
        )
    )</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.process_cmd_string"><code class="name flex">
<span>def <span class="ident">process_cmd_string</span></span>(<span>command: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares the command string for sending to the controller.
A carriage return and newline is appended to the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_cmd_string(command: str) -&gt; str:
    &#34;&#34;&#34;Prepares the command string for sending to the controller.
    A carriage return and newline is appended to the command.&#34;&#34;&#34;

    # MODULE_LOGGER.debug(f&#34;process_command() = {command}&#34;)

    return add_cr_lf(command)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.untangle_status"><code class="name flex">
<span>def <span class="ident">untangle_status</span></span>(<span>status: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with all the values from the status string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def untangle_status(status: str) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary with all the values from the status string.&#34;&#34;&#34;

    try:

        axis, errn, errm, pos, epos, el, ref, eref, rdy, osc, prog, *_ = status.split(&#34;:&#34;)

        return {
            &#34;axis&#34;: int(axis),  # the axis id
            &#34;err_no&#34;: int(errn),  # error number
            &#34;err_msg&#34;: errm,  # error message
            &#34;pos&#34;: float(pos),  # position
            &#34;epos&#34;: float(epos),  # encode position
            &#34;elimit&#34;: int(el),  # end/limit status
            &#34;ref&#34;: int(ref),  # reference status
            &#34;eref&#34;: int(eref),  # encoder reference status
            &#34;ctrl&#34;: int(rdy),  # controller ready
            &#34;osc&#34;: int(osc),  # oscillation status
            &#34;prog&#34;: int(prog),  # program running
        }
    except ValueError as exc:
        raise ValueError(
            textwrap.dedent(
                f&#34;&#34;&#34;\
                Could not disentangle the status from SMC9300, response from the device can not be parsed.
                The expected format is &#34;axis:err_no:err_msg:pos:epos:elimit:ref:eref:ctrl:osc:prog&#34;, where
                `err_msg` is a string, `pos` and `epos` are floats and the others are of type int.
                {status=}
                &#34;&#34;&#34;
            )
        ) from exc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Controller"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Controller</span></span>
<span>(</span><span>hostname='XXX.XXX.XXX.XXX', port=4243)</span>
</code></dt>
<dd>
<div class="desc"><p>The HuberSmC9300Controller class is used to directly communicate with the HUBER SMC9300
Controller through an Ethernet interface.</p>
<p>Opens a TCP/IP socket connection with the HUBER SMC9300 Hardware Controller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the HUBER hardware
controller. The default is defined in the <code>settings.yaml</code> configuration file.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to, by default set in the <code>settings.yaml</code>
configuration file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Controller(HuberSMC9300Interface, DynamicCommandMixin):
    &#34;&#34;&#34;
    The HuberSmC9300Controller class is used to directly communicate with the HUBER SMC9300
    Controller through an Ethernet interface.
    &#34;&#34;&#34;

    def __init__(self, hostname=HC_SETTINGS.HOSTNAME, port=HC_SETTINGS.PORT):
        &#34;&#34;&#34;
        Opens a TCP/IP socket connection with the HUBER SMC9300 Hardware Controller.

        Args:
            hostname (str): the IP address or fully qualified hostname of the HUBER hardware
                controller. The default is defined in the ``settings.yaml`` configuration file.

            port (int): the IP port number to connect to, by default set in the `settings.yaml`
                configuration file.

        &#34;&#34;&#34;
        super().__init__()

        MODULE_LOGGER.info(
            f&#34;Initializing Huber SMC9300 Controller with hostname={hostname} on port={port}&#34;)

        self.transport = self.huber = HuberSMC9300EthernetInterface(hostname, port)

        self._number_of_axes = HC_SETTINGS.NUMBER_OF_AXES

    def connect(self):
        try:
            self.huber.connect()

            # set the speed of each of the stages to the default speed from the Settings.

            for stage in 1, 2, 3:
                default_speed = HC_SETTINGS.DEFAULT_SPEED[stage - 1]
                self.set_slew_speed(stage, default_speed)

        except HuberError as exc:
            MODULE_LOGGER.warning(f&#34;HuberError caught: Couldn&#39;t establish connection ({exc})&#34;)
            raise ConnectionError(&#34;Couldn&#39;t establish a connection with the HUBER Stage.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_CONNECTED)

    def disconnect(self):
        try:
            # Clear the error for each of the axis before disconnecting
            for axis in range(1, self._number_of_axes + 1):
                self.clear_error(axis)
            self.huber.disconnect()
        except DeviceConnectionError as exc:
            raise ConnectionError(&#34;Couldn&#39;t disconnect from HUBER Controller.&#34;) from exc

        self.notify_observers(DeviceConnectionState.DEVICE_NOT_CONNECTED)

    def reconnect(self):
        if self.is_connected():
            self.disconnect()
        self.connect()

    def is_connected(self):
        &#34;&#34;&#34;Check if the HUBER Stages Controller is connected. &#34;&#34;&#34;
        return self.huber.is_connected()

    def is_simulator(self):
        return &#34;simulator: true&#34; in self.info()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
<li><a title="egse.mixin.DynamicCommandMixin" href="../../mixin.html#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Controller.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the HUBER Stages Controller is connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34;Check if the HUBER Stages Controller is connected. &#34;&#34;&#34;
    return self.huber.is_connected()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value">get_conf_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev">get_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir">get_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter">get_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct">goto_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct">move_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reset" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.reset">reset</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration">save_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev">set_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir">set_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready">wait_until_axis_ready</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.mixin.DynamicCommandMixin" href="../../mixin.html#egse.mixin.DynamicCommandMixin">DynamicCommandMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.mixin.DynamicCommandMixin.create_command_string" href="../../mixin.html#egse.mixin.DynamicCommandMixin.create_command_string">create_command_string</a></code></li>
<li><code><a title="egse.mixin.DynamicCommandMixin.handle_dynamic_command" href="../../mixin.html#egse.mixin.DynamicCommandMixin.handle_dynamic_command">handle_dynamic_command</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Interface</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for the Controller, Simulator and Proxy classes for this device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Interface(DeviceInterface):
    &#34;&#34;&#34;
    Interface definition for the Controller, Simulator and Proxy classes for this device.
    &#34;&#34;&#34;

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_info)
    def info(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve basic information about the Huber Stages and the Controller.
        The returned string contains multiple lines seperated by a newline (`\n`).
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?conf${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_configuration)
    def get_configuration(self, axis) -&gt; dict | Failure:
        &#34;&#34;&#34;
        Returns the configuration parameters for the given axis.

        Returns:
            A dictionary with configuration parameter names and their values.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_conf_value(self, axis, name):
        &#34;&#34;&#34;
        Returns the value of the requested configuration parameter.

        Returns:
            A string containing the value of the requested parameter. The returned object is
            always a string and needs to be converted to int or float by the caller if needed.
        &#34;&#34;&#34;
        conf = self.get_configuration(axis)
        return conf[name] if name in conf else None

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?v&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_response)
    def get_version(self):
        &#34;&#34;&#34;
        Returns the version information about the current control program on the HUBER controller.
        &#34;&#34;&#34;
        raise NotImplementedError

    def goto(self, axis: int, position: float, wait: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Moves the stage to the given absolute position. For the big rotation stage, the movement is done
        relative to the current position and the avoidance range and hard stop from the Setup are taken
        into account.

        A positive angle moves the rotation stage counter clockwise.

        Args:
            axis (int): the integer identifier of one of the axis controlled by the SMC
            position (float): when the given axis is a rotation stage, the position is given
                in degrees [deg], for a translation stage, the position is given
                in millimeter [mm].
            wait (bool): Only return when the device is in position [default=True]

        Returns:
            Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
            was hit, and -1 is returned when the LIMIT- switch was hit.
        &#34;&#34;&#34;

        # For the big rotation stage use the workaround to avoid continuous movement in the same
        # direction, and to avoid the limit switch.

        if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
            current = self.get_current_position(axis)
            movement = calculate_relative_movement(current, position)
            self.move_direct(axis, movement)
        else:
            self.goto_direct(axis, position)

        if wait:
            return self.wait_until_axis_ready(axis)

        return 0

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;goto${axis}:${position}&#34;,
        process_cmd_string=process_cmd_string)
    def goto_direct(self, axis: int, position: float) -&gt; None:
        &#34;&#34;&#34;
        Moves the stage to the given absolute position. No position checking nor conversion is done.

        A positive angle moves the rotation stage counter clockwise.

        Args:
            axis (int): the integer identifier of one of the axis controlled by the SMC
            position (float): when the given axis is a rotation stage, the position is given
                in degrees [deg], for a translation stage, the position is given
                in millimeter [mm].
        &#34;&#34;&#34;
        raise NotImplementedError

    def move(self, axis: int, distance: float, wait: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Moves the stage relative to the current position in the given distance.

        A positive angle moves the rotation stage counterclockwise.

        Args:
            axis: the integer identifier of one of the axis controlled by the SMC
            distance: when the given axis is a rotation stage, the distance is given
                in degrees [deg], for a translation stage, the distance is given
                in millimeter [mm].
            wait (bool): Only return when the device is in position [default=True]

        Returns:
            Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
            was hit, and -1 is returned when the LIMIT- switch was hit.
        &#34;&#34;&#34;
        self.move_direct(axis, distance)
        if wait:
            return self.wait_until_axis_ready(axis)
        return 0

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;move${axis}:${distance}&#34;,
        process_cmd_string=process_cmd_string)
    def move_direct(self, axis: int, distance: float) -&gt; None:
        &#34;&#34;&#34;
        Moves the stage relative to the current position in the given distance.

        A positive angle moves the rotation stage counterclockwise.

        Args:
            axis: the integer identifier of one of the axis controlled by the SMC
            distance: when the given axis is a rotation stage, the distance is given
                in degrees [deg], for a translation stage, the distance is given
                in millimeter [mm].
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;ffast${axis}:${speed}&#34;,
        process_cmd_string=process_cmd_string)
    def set_slew_speed(self, axis, speed):
        &#34;&#34;&#34;
        Configures the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.

        For axis=1 (big rotation stage) the slew speed is given in 1e-4 deg/s, i.e. a slew_speed of
        15_000 results in an actual speed of 1.5deg/s.

        Manual positioning commands are i.e. ``fast``, ``move``, ``goto``, or
        the use of the direction keys.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_slew_speed(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the maximum slew speed used for the execution of manual
        positioning commands. The maximum speed depends on the motor type,
        driver type and positioning hardware properties.
        &#34;&#34;&#34;
        return int(self.get_parameter(axis, &#34;ffast&#34;)[-1])

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;edev${axis}:${value}&#34;,
        process_cmd_string=process_cmd_string)
    def set_edev(self, axis, value):
        &#34;&#34;&#34;
        Configure the maximum allowed deviation between actual position
        and commanded target position for closed-loop positioning. this
        value must not be less than the resolution of the used encoder.

        This command cannot be executed during positioning or program execution.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_edev(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the maximum allowed deviation between actual position
        and commanded target position for closed-loop positioning.
        &#34;&#34;&#34;
        return float(self.get_parameter(axis, &#34;edev&#34;)[-1])

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;edir${axis}:${value}&#34;,
        process_cmd_string=process_cmd_string)
    def set_edir(self, axis, value):
        &#34;&#34;&#34;
        Configure the encoder rotation sense. For the case the controller returns the encoder
        position information with the wrong sign, use this command to change it correspondingly.

        This command cannot be executed during positioning or program execution.
        &#34;&#34;&#34;
        raise NotImplementedError

    def get_edir(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the encoder rotation sense: 0 is normal, 1 is inverted.
        &#34;&#34;&#34;
        return int(self.get_parameter(axis, &#34;edir&#34;)[-1])

    def is_in_position(self, axis) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the mechanism is in position and not moving.
        &#34;&#34;&#34;

        # The sleep of 0.5s here is empirically determined because tests failed randomly
        # because the position was apparently not completely reached. We also noticed an
        # oscilation when arriving at a certain position. A diagnostic test revealed that
        # the status sometimes changes bit 0 and bit 7 indicating the axis/controller
        # ready before the mechanism actually reached the setpoint. We need about
        # 0.2s before the actual value is reached, 0.5 seconds is a safe wait time.

        time.sleep(0.5)

        state = self.get_state(axis)

        return state &amp; 0b10000001 == 0b10000001

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?p${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_axis_float)
    def get_current_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current position for this axis as a float. The position is
        given in degrees for rotation stages and in mm for translation stages.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?e${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_axis_float)
    def get_current_encoder_position(self, axis) -&gt; float:
        &#34;&#34;&#34;
        Returns the current encoder position for this axis as a float. The position
        is given in degrees for rotation stages and in mm for translation stages.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?ec${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_axis_int)
    def get_current_encoder_counter_value(self, axis) -&gt; int:
        &#34;&#34;&#34;
        Returns the current encoder counter value for this axis as an int.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?err${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_error)
    def get_error(self, axis) -&gt; Tuple[str]:
        &#34;&#34;&#34;
        Returns the last occurred error and corresponding error message for the given axis.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?${name}${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_parameter)
    def get_parameter(self, axis, name) -&gt; Tuple[str, int, str]:
        &#34;&#34;&#34;
        Queries the device for the current value of the given parameter and the given axis.

        Returns:
            A tuple containing the parameter name (str), axis (int), and the value (str).
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;cerr${axis}&#34;,
        process_cmd_string=process_cmd_string)
    def clear_error(self, axis):
        &#34;&#34;&#34;
        Reset the last occurred error and clear the error message.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;quit&#34;,
        process_cmd_string=process_cmd_string)
    def quit(self) -&gt; None:
        &#34;&#34;&#34;
        Immediately stop any positioning process.

        The controller decelerates with the configured deceleration ramp.
        In contrast to an emergency stop caused by limit switch events,
        the position information remains valid in this case.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;write&#34;, cmd_string=&#34;update&#34;, process_cmd_string=process_cmd_string)
    def save_configuration(self):
        &#34;&#34;&#34;Saves the current configuration permanently. The settings will be reloaded automatically
        the next time the controller starts.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(cmd_type=&#34;write&#34;, cmd_string=&#34;reset&#34;, process_cmd_string=process_cmd_string)
    def reset(self):
        &#34;&#34;&#34;Resets the controller back to power-on state. When you previously saved the configuration,
        those values will be reloaded automatically, otherwise the default configuration will be loaded.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?s${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_get_state)
    def get_state(self, axis) -&gt; int:
        &#34;&#34;&#34;Query of the current operating state of the controller.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;query&#34;, cmd_string=&#34;?status${axis}&#34;,
        process_cmd_string=process_cmd_string,
        process_response=decode_response)
    def get_status(self, axis) -&gt; str:
        &#34;&#34;&#34;
        Returns the status of the given axis. The status contains the following information:

            * axis: the axis number
            * err_no: the error number
            * err_msg: the error message if there is an error
            * pos: the current position
            * epos: the encoder position
            * elimit: end/limit status
            * ref: reference status
            * eref: encoder reference status
            * ctrl: is controller ready?
            * osc: status oscillation
            * pro: is program running?

        The status response can be untangled as follows:

            &gt;&gt;&gt; dev = HuberSMC9300Proxy()
            &gt;&gt;&gt; untangle_status(dev.get_status(axis=1))

        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_command(
        cmd_type=&#34;write&#34;, cmd_string=&#34;zero${axis}&#34;,
        process_cmd_string=process_cmd_string)
    def zero(self, axis) -&gt; None:
        &#34;&#34;&#34;
        Set the current position of the axis to zero (0.00). If a reference position
        offset value is configured (see the configuration command `rofs`) the current
        position is set to that reference offset value.

        If you want to retain this zero position, you will have to also call the
        &#39;save_configuration()&#39; command. Otherwise the zero position will be lost
        after a reset or a power cycle.
        &#34;&#34;&#34;
        raise NotImplementedError

    def wait_until_axis_ready(self, axis: int) -&gt; int:
        &#34;&#34;&#34;
        Send the given axis a state query and wait for the response.

        This function will return only when one of the following states has been reached:

        * The LIMIT- switch was activated
        * The LIMIT+ switch was activated
        * The end position was reached, axis ready (bit 0) &amp; controller ready (bit 7)

        Returns:

            *  0: on success, i.e. position is reached
            * +1: when LIMIT+ switch is reached
            * -1: when LIMIT- switch is reached
        &#34;&#34;&#34;

        # MODULE_LOGGER.debug(f&#34;Wait until axis {axis} is ready...&#34;)

        while True:

            time.sleep(0.5)

            state = self.get_state(axis)

            # MODULE_LOGGER.debug(f&#34;state for axis {axis}: {beautify_binary(state)} ({state})&#34;)

            if state &amp; 4 == 4:
                MODULE_LOGGER.warning(&#34;LIMIT- active!&#34;)
                rv = -1
                break

            if state &amp; 8 == 8:
                MODULE_LOGGER.warning(&#34;LIMIT+ active!&#34;)
                rv = +1
                break

            if state &amp; 512 == 512:
                MODULE_LOGGER.error(&#34;oscillation positioning error (encoder)&#34;)

            if state &amp; 129 == 129:
                # exit loop when position is reached,
                # state bit 0 and bit 7 indicate &#39;axis ready&#39; AND &#39;controller ready&#39;,
                # i.e. all axes stopped
                rv = 0
                break

            if state &amp; 16384:  # 0b100_0000_0000_0000
                response = self.get_error(axis)
                MODULE_LOGGER.error(f&#34;ERROR on axis {axis}: {response}&#34;)
                self.clear_error(axis)

        # The sleep of 0.5s here is empirically determined because tests failed randomly
        # because the position was apparently not completely reached. We also noticed an
        # oscillation when arriving at a certain position. A diagnostic test revealed that
        # the state sometimes changes bit 0 and bit 7 indicating the axis/controller
        # ready before the mechanism actually reached the setpoint. We need about
        # 0.2s before the actual value is reached, 0.5 seconds is a safe wait time.

        time.sleep(0.5)

        return rv</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Controller" href="#egse.stages.huber.smc9300.HuberSMC9300Controller">HuberSMC9300Controller</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Proxy" href="#egse.stages.huber.smc9300.HuberSMC9300Proxy">HuberSMC9300Proxy</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Simulator" href="#egse.stages.huber.smc9300.HuberSMC9300Simulator">HuberSMC9300Simulator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error"><code class="name flex">
<span>def <span class="ident">clear_error</span></span>(<span>self, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the last occurred error and clear the error message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;cerr${axis}&#34;,
    process_cmd_string=process_cmd_string)
def clear_error(self, axis):
    &#34;&#34;&#34;
    Reset the last occurred error and clear the error message.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value"><code class="name flex">
<span>def <span class="ident">get_conf_value</span></span>(<span>self, axis, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value of the requested configuration parameter.</p>
<h2 id="returns">Returns</h2>
<p>A string containing the value of the requested parameter. The returned object is
always a string and needs to be converted to int or float by the caller if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conf_value(self, axis, name):
    &#34;&#34;&#34;
    Returns the value of the requested configuration parameter.

    Returns:
        A string containing the value of the requested parameter. The returned object is
        always a string and needs to be converted to int or float by the caller if needed.
    &#34;&#34;&#34;
    conf = self.get_configuration(axis)
    return conf[name] if name in conf else None</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration"><code class="name flex">
<span>def <span class="ident">get_configuration</span></span>(<span>self, axis) ‑> dict | Failure</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the configuration parameters for the given axis.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary with configuration parameter names and their values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?conf${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_get_configuration)
def get_configuration(self, axis) -&gt; dict | Failure:
    &#34;&#34;&#34;
    Returns the configuration parameters for the given axis.

    Returns:
        A dictionary with configuration parameter names and their values.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value"><code class="name flex">
<span>def <span class="ident">get_current_encoder_counter_value</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current encoder counter value for this axis as an int.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?ec${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_axis_int)
def get_current_encoder_counter_value(self, axis) -&gt; int:
    &#34;&#34;&#34;
    Returns the current encoder counter value for this axis as an int.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position"><code class="name flex">
<span>def <span class="ident">get_current_encoder_position</span></span>(<span>self, axis) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current encoder position for this axis as a float. The position
is given in degrees for rotation stages and in mm for translation stages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?e${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_axis_float)
def get_current_encoder_position(self, axis) -&gt; float:
    &#34;&#34;&#34;
    Returns the current encoder position for this axis as a float. The position
    is given in degrees for rotation stages and in mm for translation stages.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position"><code class="name flex">
<span>def <span class="ident">get_current_position</span></span>(<span>self, axis) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current position for this axis as a float. The position is
given in degrees for rotation stages and in mm for translation stages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?p${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_axis_float)
def get_current_position(self, axis) -&gt; float:
    &#34;&#34;&#34;
    Returns the current position for this axis as a float. The position is
    given in degrees for rotation stages and in mm for translation stages.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev"><code class="name flex">
<span>def <span class="ident">get_edev</span></span>(<span>self, axis) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum allowed deviation between actual position
and commanded target position for closed-loop positioning.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edev(self, axis) -&gt; float:
    &#34;&#34;&#34;
    Returns the maximum allowed deviation between actual position
    and commanded target position for closed-loop positioning.
    &#34;&#34;&#34;
    return float(self.get_parameter(axis, &#34;edev&#34;)[-1])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir"><code class="name flex">
<span>def <span class="ident">get_edir</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the encoder rotation sense: 0 is normal, 1 is inverted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edir(self, axis) -&gt; int:
    &#34;&#34;&#34;
    Returns the encoder rotation sense: 0 is normal, 1 is inverted.
    &#34;&#34;&#34;
    return int(self.get_parameter(axis, &#34;edir&#34;)[-1])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>self, axis) ‑> Tuple[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the last occurred error and corresponding error message for the given axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?err${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_get_error)
def get_error(self, axis) -&gt; Tuple[str]:
    &#34;&#34;&#34;
    Returns the last occurred error and corresponding error message for the given axis.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter"><code class="name flex">
<span>def <span class="ident">get_parameter</span></span>(<span>self, axis, name) ‑> Tuple[str, int, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Queries the device for the current value of the given parameter and the given axis.</p>
<h2 id="returns">Returns</h2>
<p>A tuple containing the parameter name (str), axis (int), and the value (str).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?${name}${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_get_parameter)
def get_parameter(self, axis, name) -&gt; Tuple[str, int, str]:
    &#34;&#34;&#34;
    Queries the device for the current value of the given parameter and the given axis.

    Returns:
        A tuple containing the parameter name (str), axis (int), and the value (str).
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed"><code class="name flex">
<span>def <span class="ident">get_slew_speed</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum slew speed used for the execution of manual
positioning commands. The maximum speed depends on the motor type,
driver type and positioning hardware properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_speed(self, axis) -&gt; int:
    &#34;&#34;&#34;
    Returns the maximum slew speed used for the execution of manual
    positioning commands. The maximum speed depends on the motor type,
    driver type and positioning hardware properties.
    &#34;&#34;&#34;
    return int(self.get_parameter(axis, &#34;ffast&#34;)[-1])</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self, axis) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Query of the current operating state of the controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?s${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_get_state)
def get_state(self, axis) -&gt; int:
    &#34;&#34;&#34;Query of the current operating state of the controller.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, axis) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the status of the given axis. The status contains the following information:</p>
<pre><code>* axis: the axis number
* err_no: the error number
* err_msg: the error message if there is an error
* pos: the current position
* epos: the encoder position
* elimit: end/limit status
* ref: reference status
* eref: encoder reference status
* ctrl: is controller ready?
* osc: status oscillation
* pro: is program running?
</code></pre>
<p>The status response can be untangled as follows:</p>
<pre><code>&gt;&gt;&gt; dev = HuberSMC9300Proxy()
&gt;&gt;&gt; untangle_status(dev.get_status(axis=1))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?status${axis}&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_response)
def get_status(self, axis) -&gt; str:
    &#34;&#34;&#34;
    Returns the status of the given axis. The status contains the following information:

        * axis: the axis number
        * err_no: the error number
        * err_msg: the error message if there is an error
        * pos: the current position
        * epos: the encoder position
        * elimit: end/limit status
        * ref: reference status
        * eref: encoder reference status
        * ctrl: is controller ready?
        * osc: status oscillation
        * pro: is program running?

    The status response can be untangled as follows:

        &gt;&gt;&gt; dev = HuberSMC9300Proxy()
        &gt;&gt;&gt; untangle_status(dev.get_status(axis=1))

    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the version information about the current control program on the HUBER controller.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?v&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_response)
def get_version(self):
    &#34;&#34;&#34;
    Returns the version information about the current control program on the HUBER controller.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, axis: int, position: float, wait: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the stage to the given absolute position. For the big rotation stage, the movement is done
relative to the current position and the avoidance range and hard stop from the Setup are taken
into account.</p>
<p>A positive angle moves the rotation stage counter clockwise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>the integer identifier of one of the axis controlled by the SMC</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>float</code></dt>
<dd>when the given axis is a rotation stage, the position is given
in degrees [deg], for a translation stage, the position is given
in millimeter [mm].</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only return when the device is in position [default=True]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
was hit, and -1 is returned when the LIMIT- switch was hit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, axis: int, position: float, wait: bool = True) -&gt; int:
    &#34;&#34;&#34;
    Moves the stage to the given absolute position. For the big rotation stage, the movement is done
    relative to the current position and the avoidance range and hard stop from the Setup are taken
    into account.

    A positive angle moves the rotation stage counter clockwise.

    Args:
        axis (int): the integer identifier of one of the axis controlled by the SMC
        position (float): when the given axis is a rotation stage, the position is given
            in degrees [deg], for a translation stage, the position is given
            in millimeter [mm].
        wait (bool): Only return when the device is in position [default=True]

    Returns:
        Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
        was hit, and -1 is returned when the LIMIT- switch was hit.
    &#34;&#34;&#34;

    # For the big rotation stage use the workaround to avoid continuous movement in the same
    # direction, and to avoid the limit switch.

    if axis == HC_SETTINGS.BIG_ROTATION_STAGE:
        current = self.get_current_position(axis)
        movement = calculate_relative_movement(current, position)
        self.move_direct(axis, movement)
    else:
        self.goto_direct(axis, position)

    if wait:
        return self.wait_until_axis_ready(axis)

    return 0</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct"><code class="name flex">
<span>def <span class="ident">goto_direct</span></span>(<span>self, axis: int, position: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the stage to the given absolute position. No position checking nor conversion is done.</p>
<p>A positive angle moves the rotation stage counter clockwise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code></dt>
<dd>the integer identifier of one of the axis controlled by the SMC</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>float</code></dt>
<dd>when the given axis is a rotation stage, the position is given
in degrees [deg], for a translation stage, the position is given
in millimeter [mm].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;goto${axis}:${position}&#34;,
    process_cmd_string=process_cmd_string)
def goto_direct(self, axis: int, position: float) -&gt; None:
    &#34;&#34;&#34;
    Moves the stage to the given absolute position. No position checking nor conversion is done.

    A positive angle moves the rotation stage counter clockwise.

    Args:
        axis (int): the integer identifier of one of the axis controlled by the SMC
        position (float): when the given axis is a rotation stage, the position is given
            in degrees [deg], for a translation stage, the position is given
            in millimeter [mm].
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve basic information about the Huber Stages and the Controller.
The returned string contains multiple lines seperated by a newline (<code></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;query&#34;, cmd_string=&#34;?&#34;,
    process_cmd_string=process_cmd_string,
    process_response=decode_info)
def info(self) -&gt; str:
    &#34;&#34;&#34;
    Retrieve basic information about the Huber Stages and the Controller.
    The returned string contains multiple lines seperated by a newline (`\n`).
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position"><code class="name flex">
<span>def <span class="ident">is_in_position</span></span>(<span>self, axis) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the mechanism is in position and not moving.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_position(self, axis) -&gt; bool:
    &#34;&#34;&#34;
    Returns True if the mechanism is in position and not moving.
    &#34;&#34;&#34;

    # The sleep of 0.5s here is empirically determined because tests failed randomly
    # because the position was apparently not completely reached. We also noticed an
    # oscilation when arriving at a certain position. A diagnostic test revealed that
    # the status sometimes changes bit 0 and bit 7 indicating the axis/controller
    # ready before the mechanism actually reached the setpoint. We need about
    # 0.2s before the actual value is reached, 0.5 seconds is a safe wait time.

    time.sleep(0.5)

    state = self.get_state(axis)

    return state &amp; 0b10000001 == 0b10000001</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, axis: int, distance: float, wait: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the stage relative to the current position in the given distance.</p>
<p>A positive angle moves the rotation stage counterclockwise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong></dt>
<dd>the integer identifier of one of the axis controlled by the SMC</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>when the given axis is a rotation stage, the distance is given
in degrees [deg], for a translation stage, the distance is given
in millimeter [mm].</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only return when the device is in position [default=True]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
was hit, and -1 is returned when the LIMIT- switch was hit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, axis: int, distance: float, wait: bool = True) -&gt; int:
    &#34;&#34;&#34;
    Moves the stage relative to the current position in the given distance.

    A positive angle moves the rotation stage counterclockwise.

    Args:
        axis: the integer identifier of one of the axis controlled by the SMC
        distance: when the given axis is a rotation stage, the distance is given
            in degrees [deg], for a translation stage, the distance is given
            in millimeter [mm].
        wait (bool): Only return when the device is in position [default=True]

    Returns:
        Zero (0) is returned unless a limit switch was hit, in which case +1 is returned when the LIMIT+ switch
        was hit, and -1 is returned when the LIMIT- switch was hit.
    &#34;&#34;&#34;
    self.move_direct(axis, distance)
    if wait:
        return self.wait_until_axis_ready(axis)
    return 0</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct"><code class="name flex">
<span>def <span class="ident">move_direct</span></span>(<span>self, axis: int, distance: float) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the stage relative to the current position in the given distance.</p>
<p>A positive angle moves the rotation stage counterclockwise.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axis</code></strong></dt>
<dd>the integer identifier of one of the axis controlled by the SMC</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>when the given axis is a rotation stage, the distance is given
in degrees [deg], for a translation stage, the distance is given
in millimeter [mm].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;move${axis}:${distance}&#34;,
    process_cmd_string=process_cmd_string)
def move_direct(self, axis: int, distance: float) -&gt; None:
    &#34;&#34;&#34;
    Moves the stage relative to the current position in the given distance.

    A positive angle moves the rotation stage counterclockwise.

    Args:
        axis: the integer identifier of one of the axis controlled by the SMC
        distance: when the given axis is a rotation stage, the distance is given
            in degrees [deg], for a translation stage, the distance is given
            in millimeter [mm].
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Immediately stop any positioning process.</p>
<p>The controller decelerates with the configured deceleration ramp.
In contrast to an emergency stop caused by limit switch events,
the position information remains valid in this case.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;quit&#34;,
    process_cmd_string=process_cmd_string)
def quit(self) -&gt; None:
    &#34;&#34;&#34;
    Immediately stop any positioning process.

    The controller decelerates with the configured deceleration ramp.
    In contrast to an emergency stop caused by limit switch events,
    the position information remains valid in this case.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the controller back to power-on state. When you previously saved the configuration,
those values will be reloaded automatically, otherwise the default configuration will be loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;write&#34;, cmd_string=&#34;reset&#34;, process_cmd_string=process_cmd_string)
def reset(self):
    &#34;&#34;&#34;Resets the controller back to power-on state. When you previously saved the configuration,
    those values will be reloaded automatically, otherwise the default configuration will be loaded.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration"><code class="name flex">
<span>def <span class="ident">save_configuration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the current configuration permanently. The settings will be reloaded automatically
the next time the controller starts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(cmd_type=&#34;write&#34;, cmd_string=&#34;update&#34;, process_cmd_string=process_cmd_string)
def save_configuration(self):
    &#34;&#34;&#34;Saves the current configuration permanently. The settings will be reloaded automatically
    the next time the controller starts.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev"><code class="name flex">
<span>def <span class="ident">set_edev</span></span>(<span>self, axis, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the maximum allowed deviation between actual position
and commanded target position for closed-loop positioning. this
value must not be less than the resolution of the used encoder.</p>
<p>This command cannot be executed during positioning or program execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;edev${axis}:${value}&#34;,
    process_cmd_string=process_cmd_string)
def set_edev(self, axis, value):
    &#34;&#34;&#34;
    Configure the maximum allowed deviation between actual position
    and commanded target position for closed-loop positioning. this
    value must not be less than the resolution of the used encoder.

    This command cannot be executed during positioning or program execution.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir"><code class="name flex">
<span>def <span class="ident">set_edir</span></span>(<span>self, axis, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the encoder rotation sense. For the case the controller returns the encoder
position information with the wrong sign, use this command to change it correspondingly.</p>
<p>This command cannot be executed during positioning or program execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;edir${axis}:${value}&#34;,
    process_cmd_string=process_cmd_string)
def set_edir(self, axis, value):
    &#34;&#34;&#34;
    Configure the encoder rotation sense. For the case the controller returns the encoder
    position information with the wrong sign, use this command to change it correspondingly.

    This command cannot be executed during positioning or program execution.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed"><code class="name flex">
<span>def <span class="ident">set_slew_speed</span></span>(<span>self, axis, speed)</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the maximum slew speed used for the execution of manual
positioning commands. The maximum speed depends on the motor type,
driver type and positioning hardware properties.</p>
<p>For axis=1 (big rotation stage) the slew speed is given in 1e-4 deg/s, i.e. a slew_speed of
15_000 results in an actual speed of 1.5deg/s.</p>
<p>Manual positioning commands are i.e. <code>fast</code>, <code>move</code>, <code>goto</code>, or
the use of the direction keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;ffast${axis}:${speed}&#34;,
    process_cmd_string=process_cmd_string)
def set_slew_speed(self, axis, speed):
    &#34;&#34;&#34;
    Configures the maximum slew speed used for the execution of manual
    positioning commands. The maximum speed depends on the motor type,
    driver type and positioning hardware properties.

    For axis=1 (big rotation stage) the slew speed is given in 1e-4 deg/s, i.e. a slew_speed of
    15_000 results in an actual speed of 1.5deg/s.

    Manual positioning commands are i.e. ``fast``, ``move``, ``goto``, or
    the use of the direction keys.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready"><code class="name flex">
<span>def <span class="ident">wait_until_axis_ready</span></span>(<span>self, axis: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Send the given axis a state query and wait for the response.</p>
<p>This function will return only when one of the following states has been reached:</p>
<ul>
<li>The LIMIT- switch was activated</li>
<li>The LIMIT+ switch was activated</li>
<li>The end position was reached, axis ready (bit 0) &amp; controller ready (bit 7)</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>0: on success, i.e. position is reached</li>
<li>+1: when LIMIT+ switch is reached</li>
<li>-1: when LIMIT- switch is reached</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until_axis_ready(self, axis: int) -&gt; int:
    &#34;&#34;&#34;
    Send the given axis a state query and wait for the response.

    This function will return only when one of the following states has been reached:

    * The LIMIT- switch was activated
    * The LIMIT+ switch was activated
    * The end position was reached, axis ready (bit 0) &amp; controller ready (bit 7)

    Returns:

        *  0: on success, i.e. position is reached
        * +1: when LIMIT+ switch is reached
        * -1: when LIMIT- switch is reached
    &#34;&#34;&#34;

    # MODULE_LOGGER.debug(f&#34;Wait until axis {axis} is ready...&#34;)

    while True:

        time.sleep(0.5)

        state = self.get_state(axis)

        # MODULE_LOGGER.debug(f&#34;state for axis {axis}: {beautify_binary(state)} ({state})&#34;)

        if state &amp; 4 == 4:
            MODULE_LOGGER.warning(&#34;LIMIT- active!&#34;)
            rv = -1
            break

        if state &amp; 8 == 8:
            MODULE_LOGGER.warning(&#34;LIMIT+ active!&#34;)
            rv = +1
            break

        if state &amp; 512 == 512:
            MODULE_LOGGER.error(&#34;oscillation positioning error (encoder)&#34;)

        if state &amp; 129 == 129:
            # exit loop when position is reached,
            # state bit 0 and bit 7 indicate &#39;axis ready&#39; AND &#39;controller ready&#39;,
            # i.e. all axes stopped
            rv = 0
            break

        if state &amp; 16384:  # 0b100_0000_0000_0000
            response = self.get_error(axis)
            MODULE_LOGGER.error(f&#34;ERROR on axis {axis}: {response}&#34;)
            self.clear_error(axis)

    # The sleep of 0.5s here is empirically determined because tests failed randomly
    # because the position was apparently not completely reached. We also noticed an
    # oscillation when arriving at a certain position. A diagnostic test revealed that
    # the state sometimes changes bit 0 and bit 7 indicating the axis/controller
    # ready before the mechanism actually reached the setpoint. We need about
    # 0.2s before the actual value is reached, 0.5 seconds is a safe wait time.

    time.sleep(0.5)

    return rv</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Interface.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>self, axis) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current position of the axis to zero (0.00). If a reference position
offset value is configured (see the configuration command <code>rofs</code>) the current
position is set to that reference offset value.</p>
<p>If you want to retain this zero position, you will have to also call the
'save_configuration()' command. Otherwise the zero position will be lost
after a reset or a power cycle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_command(
    cmd_type=&#34;write&#34;, cmd_string=&#34;zero${axis}&#34;,
    process_cmd_string=process_cmd_string)
def zero(self, axis) -&gt; None:
    &#34;&#34;&#34;
    Set the current position of the axis to zero (0.00). If a reference position
    offset value is configured (see the configuration command `rofs`) the current
    position is set to that reference offset value.

    If you want to retain this zero position, you will have to also call the
    &#39;save_configuration()&#39; command. Otherwise the zero position will be lost
    after a reset or a power cycle.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceInterface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.device.DeviceInterface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.device.DeviceInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Proxy"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Proxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6800, timeout=10000)</span>
</code></dt>
<dd>
<div class="desc"><p>The HuberProxy class is used to connect to the Huber SMC9300 control server and send commands
to the HUBER Hardware Controller remotely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol
[default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address)
[default is taken from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>time out on the response from the control server [milliseconds]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Proxy(DynamicProxy, HuberSMC9300Interface):
    &#34;&#34;&#34;
    The HuberProxy class is used to connect to the Huber SMC9300 control server and send commands
    to the HUBER Hardware Controller remotely.
    &#34;&#34;&#34;

    def __init__(
            self,
            protocol=CTRL_SETTINGS.PROTOCOL,
            hostname=CTRL_SETTINGS.HOSTNAME,
            port=CTRL_SETTINGS.COMMANDING_PORT,
            timeout=REQUEST_TIMEOUT
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol
                [default is taken from settings file]
            hostname: location of the control server (IP address)
                [default is taken from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
            timeout: time out on the response from the control server [milliseconds]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.DynamicProxy" href="../../proxy.html#egse.proxy.DynamicProxy">DynamicProxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li>egse.mixin.DynamicClientCommandMixin</li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.DynamicProxy" href="../../proxy.html#egse.proxy.DynamicProxy">DynamicProxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.DynamicProxy.connect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.disconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_commanding_port" href="../../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_endpoint" href="../../proxy.html#egse.proxy.BaseProxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_ip_address" href="../../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_monitoring_port" href="../../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_service_port" href="../../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.get_service_proxy" href="../../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.is_cs_connected" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.reconnect_cs" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.reset_cs_connection" href="../../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.DynamicProxy.send" href="../../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value">get_conf_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev">get_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir">get_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter">get_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct">goto_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct">move_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reset" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.reset">reset</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration">save_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev">set_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir">set_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready">wait_until_axis_ready</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300.HuberSMC9300Simulator"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Simulator</span></span>
</code></dt>
<dd>
<div class="desc"><p>The class simulates the HUBER Stages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Simulator(HuberSMC9300Interface):
    &#34;&#34;&#34;
    The class simulates the HUBER Stages.
    &#34;&#34;&#34;

    def __init__(self):
        super().__init__()
        MODULE_LOGGER.critical(
            textwrap.dedent(
                &#34;&#34;&#34;\
                The HuberSMC9300Simulator class is deprecated in favor of the smc9300_sim process. 
                Start the SMC9300 simulator in a separate terminal with the command:
                
                   smc9300_sim start
                
                then restart the SCM9300 Control Server: 
                
                   smc9300_cs start
                
                Make sure the local_settings.yaml file contains the correct HOSTNAME
                and PORT for accessing the simulator process. 
                &#34;&#34;&#34;
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></li>
<li><a title="egse.device.DeviceInterface" href="../../device.html#egse.device.DeviceInterface">DeviceInterface</a></li>
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.connect" href="../../device.html#egse.device.DeviceConnectionInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.disconnect" href="../../device.html#egse.device.DeviceConnectionInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value">get_conf_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev">get_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir">get_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter">get_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct">goto_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_connected" href="../../device.html#egse.device.DeviceConnectionInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_simulator" href="../../device.html#egse.device.DeviceInterface.is_simulator">is_simulator</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct">move_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reset" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.reset">reset</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration">save_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev">set_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir">set_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready">wait_until_axis_ready</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.stages.huber" href="index.html">egse.stages.huber</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.calculate_relative_movement" href="#egse.stages.huber.smc9300.calculate_relative_movement">calculate_relative_movement</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_axis_float" href="#egse.stages.huber.smc9300.decode_axis_float">decode_axis_float</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_axis_int" href="#egse.stages.huber.smc9300.decode_axis_int">decode_axis_int</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_get_configuration" href="#egse.stages.huber.smc9300.decode_get_configuration">decode_get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_get_error" href="#egse.stages.huber.smc9300.decode_get_error">decode_get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_get_parameter" href="#egse.stages.huber.smc9300.decode_get_parameter">decode_get_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_get_state" href="#egse.stages.huber.smc9300.decode_get_state">decode_get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_info" href="#egse.stages.huber.smc9300.decode_info">decode_info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.decode_response" href="#egse.stages.huber.smc9300.decode_response">decode_response</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.print_state" href="#egse.stages.huber.smc9300.print_state">print_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.process_cmd_string" href="#egse.stages.huber.smc9300.process_cmd_string">process_cmd_string</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.untangle_status" href="#egse.stages.huber.smc9300.untangle_status">untangle_status</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Controller" href="#egse.stages.huber.smc9300.HuberSMC9300Controller">HuberSMC9300Controller</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Controller.is_connected" href="#egse.stages.huber.smc9300.HuberSMC9300Controller.is_connected">is_connected</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface" href="#egse.stages.huber.smc9300.HuberSMC9300Interface">HuberSMC9300Interface</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_conf_value">get_conf_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edev">get_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_edir">get_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_error" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_parameter">get_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_state" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_status" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.get_version" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.get_version">get_version</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto">goto</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.goto_direct">goto_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.info" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.info">info</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move">move</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.move_direct">move_direct</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.quit" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.quit">quit</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.reset" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.reset">reset</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.save_configuration">save_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edev">set_edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_edir">set_edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.wait_until_axis_ready">wait_until_axis_ready</a></code></li>
<li><code><a title="egse.stages.huber.smc9300.HuberSMC9300Interface.zero" href="#egse.stages.huber.smc9300.HuberSMC9300Interface.zero">zero</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Proxy" href="#egse.stages.huber.smc9300.HuberSMC9300Proxy">HuberSMC9300Proxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300.HuberSMC9300Simulator" href="#egse.stages.huber.smc9300.HuberSMC9300Simulator">HuberSMC9300Simulator</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
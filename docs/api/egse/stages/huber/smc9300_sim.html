<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.stages.huber.smc9300_sim API documentation</title>
<meta name="description" content="This module provides a simple simulator for the HUBER stages SMC9300 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.stages.huber.smc9300_sim</code></h1>
</header>
<section id="section-intro">
<p>This module provides a simple simulator for the HUBER stages SMC9300.</p>
<p>The difference between this simulator and the HuberSMC9300Simulator class is that this module is a
standalone process that will accept the command set as accepted by the SMC9300 device controller,
while the HuberSMC9300Simulator class replaces the Huber9300Controller and never communicates
with a device.</p>
<p>This simulator is a very simple implementation. It responds to a number of known commands with
little to no intelligence behind it.</p>
<p>Known commands are:</p>
<ul>
<li>version - returns a version string</li>
</ul>
<h2 id="usage">Usage</h2>
<p>$ smc9300_sim start</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides a simple simulator for the HUBER stages SMC9300.

The difference between this simulator and the HuberSMC9300Simulator class is that this module is a
standalone process that will accept the command set as accepted by the SMC9300 device controller,
while the HuberSMC9300Simulator class replaces the Huber9300Controller and never communicates
with a device.

This simulator is a very simple implementation. It responds to a number of known commands with
little to no intelligence behind it.

Known commands are:

* version - returns a version string

Usage:

   $ smc9300_sim start

&#34;&#34;&#34;
from __future__ import annotations

import multiprocessing.process
import textwrap
import time
from typing import Optional

multiprocessing.current_process().name = &#34;smc9300_sim&#34;

import logging
import re
import socket
from enum import Enum

import click

logging.basicConfig(level=logging.DEBUG)

LOGGER = logging.getLogger(&#34;egse.stages.huber.smc9300_sim&#34;)

HOST = &#34;localhost&#34;
PORT = 4243


class InvalidStateError(Exception):
    pass


def write(conn, response: str) -&gt; None:
    &#34;&#34;&#34;
    Writes a response string on the socket connection.

    Args:
        conn: the socket that is used for communication
        response: the response of the previous command

    Returns:
        None.
    &#34;&#34;&#34;
    response = f&#34;{response}\r\n&#34;.encode()
    LOGGER.debug(f&#34;{response=}&#34;)
    conn.sendall(response)


def read(conn) -&gt; str:
    &#34;&#34;&#34;
    Reads one command string from the socket, i.e. until a linefeed (&#39;\n&#39;) is received.

    Returns:
        The command string with the linefeed stripped off.
    &#34;&#34;&#34;

    idx, n_total = 0, 0
    buf_size = 1024 * 4
    command_string = bytes()

    try:
        for _ in range(100):
            data = conn.recv(buf_size)
            n = len(data)
            n_total += n
            command_string += data
            # if data.endswith(b&#39;\n&#39;):
            if n &lt; buf_size:
                break
    except socket.timeout as e_timeout:
        LOGGER.warning(f&#34;Socket timeout error from {e_timeout}&#34;)
        return &#34;&#34;

    # LOGGER.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)
    # LOGGER.debug(f&#34;{command_string=}&#34;)

    return command_string.decode().rstrip()


class AxisTimer:
    &#34;&#34;&#34;
    This class controls all the timings of an axis.
    &#34;&#34;&#34;

    def __init__(self):
        self._start_time = time.time()
        self._running = False

    def is_running(self):
        return self._running

    def start(self):
        &#34;&#34;&#34;Start the timer.&#34;&#34;&#34;
        self._start_time = time.time()
        self._running = True


    def stop(self):
        &#34;&#34;&#34;Stop the timer.&#34;&#34;&#34;
        self._start_time = time.time()
        self._running = False

    def get_delta_time(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the delta time since the start() method was called on this
        AxisTimer.

        :returns: delta time in seconds since the start of the timer
        &#34;&#34;&#34;
        return time.time() - self._start_time if self._running else 0.0


class Axis:
    &#34;&#34;&#34;
    This class controls the settings and movements of one particular axis
    for the HUBER Stages.

    Do not use this class directly, it is used from within the HuberSimulator.
    &#34;&#34;&#34;

    def __init__(self, slew_speed, encoder_conversion, alias, type_):
        # Translation Stage: slew_speed = 77_200, encoder_conversion = 20_000
        # Big Rotation: slew_speed = 22_943_316, encoder_conversion = 11_930_500
        self._alias = alias
        self._type = type_
        self._slew_speed = slew_speed  # 1e-4 deg per second -&gt; 15_000 is 1.5 deg/s
        self._encoder_conversion_factor = encoder_conversion  # encoder positions per mm/deg
        self._encoder_counter_offset = 4287251092
        self._encoder_position = 0.0
        self._current_position = 0.0
        self._start_position = 0.0
        self._edev = 0.001
        self._edir = 0
        self._frun = 0
        self._commanded_position = None
        self._moving = False
        self._distance = 0
        self._direction = 0
        self._timer = AxisTimer()
        self._biss_t = 360 if self._type == 0 else 0

        self._unit = &#34;deg&#34; if self._type == 0 else &#34;mm&#34;

    @property
    def alias(self):
        return self._alias

    @property
    def type(self):
        return self._type

    @property
    def unit(self):
        return self._unit

    @property
    def ffast(self):
        return self._slew_speed

    @property
    def frun(self):
        return self._frun

    @property
    def edev(self):
        return self._edev

    @edev.setter
    def edev(self, value: float):
        self._edev = value

    @property
    def edir(self):
        return self._edir

    @edir.setter
    def edir(self, value: int):
        # value can be 0 or 1 only
        self._edir = value

    def get_slew_speed(self) -&gt; int:
        return self._slew_speed

    def set_slew_speed(self, speed: int):
        self._slew_speed = speed

    def get_converted_slew_speed(self) -&gt; float:
        &#34;&#34;&#34;Returns the slew speed in mm/s or deg/s&#34;&#34;&#34;
        return self._slew_speed * 1e-4

    def get_state(self) -&gt; int:
        state = 0
        if not self._moving:
            state = 129
        return state

    def start(self):
        &#34;&#34;&#34;
        Start a movement. A movement is defined as the change from the current
        position to the commanded position. Therefore, the start position will
        be set to the current position and all calculations including time will
        be with respect to the starting position.
        &#34;&#34;&#34;
        if self._commanded_position is None:
            raise InvalidStateError(&#34;Can not start a movement if commanded position is not set.&#34;)

        self._timer.start()
        self._moving = True
        self._distance = self._current_position - self._commanded_position
        self._direction = 1 if self._commanded_position &gt; self._current_position else -1
        self._start_position = self._current_position

    def stop(self):
        &#34;&#34;&#34;
        Stop a movement by

        &#34;&#34;&#34;
        self._moving = False
        self._timer.stop()

    def set_commanded_position(self, position):
        self._commanded_position = position

    def get_current_position(self) -&gt; float:
        self._calc_current_position()
        return self._current_position

    def get_encoder_position(self) -&gt; float:
        return self.get_current_position()  # add some noise here

    def get_encoder_counter_value(self) -&gt; int:
        return self._encoder_counter_offset + int(self.get_encoder_position() * self._encoder_conversion_factor)

    def is_in_position(self) -&gt; bool:
        self._calc_current_position()
        return not self._moving

    def _calc_current_position(self):
        if not self._moving:
            return

        delta_t = self._timer.get_delta_time()
        slew_speed = self.get_converted_slew_speed()
        travel = slew_speed * delta_t

        LOGGER.info(f&#34;{delta_t=}, {slew_speed=}, {travel=}&#34;)

        if travel &gt;= abs(self._distance):
            self._current_position = self._commanded_position
            self._moving = False
            self._distance = 0.0
        else:
            self._current_position = self._start_position + travel * self._direction


class OnOff(str, Enum):

    ON = &#34;ON&#34;
    OFF = &#34;OFF&#34;


class State:
    def __init__(self, axis: int):
        self.axis = axis
        self.errors = []
        self.slew_speed = 20_000
        self.current_position = 270
        self.current_encoder_position = 271
        self.current_encoder_counter = 272_000
        self.controller_ready = True
        self.is_connected = False


# The slew_speed and the encoder_conversion factor is empirically determined from the
# hardware measures between 0 and 100. The timings that result for these stages are
# only approximately correct.

axes = [
    None,
    Axis(22_943_316, 11_930_500, alias=&#34;01~rot (420-20913)&#34;, type_=0),
    Axis(20_000, 20_000, alias=&#34;02~rot (409-10661)&#34;, type_=0),
    Axis(77_200, 20_000, alias=&#34;03~lin (5101.30-943)&#34;, type_=1),
]


states = [None, State(1), State(2), State(3)]

error_msg = &#34;&#34;


def get_configuration(axis: str) -&gt; str:
    axis = int(axis)
    response = (
        f&#34;# configuration settings of axis {axis}\r\n&#34;
        f&#34;alias{axis}:{axes[axis].alias}\r\n&#34;
        f&#34;type{axis}:{axes[axis].type}\r\n&#34;
        f&#34;unit{axis}:{axes[axis].unit}\r\n&#34;
        f&#34;ffast{axis}:{axes[axis].ffast}\r\n&#34;
        f&#34;frun{axis}:{axes[axis].frun}\r\n&#34;
        f&#34;gnum{axis}:10000\r\n&#34;
        f&#34;biss_t{axis}:{axes[axis]._biss_t}&#34;  # last line doesn&#39;t have a \r\n, will be added later
    )
    return response


def cancel_movement(axis: Optional[str] = None):

    if axis is None:
        for axis in axes:
            axis and axis.stop()
    else:
        axes[int(axis)].stop()


def clear_error(axis: str) -&gt; None:
    states[int(axis)].errors = []


def get_error(axis: str) -&gt; str:
    return f&#34;{axis}:0&#34;


def get_parameter(par_name: str, axis: str) -&gt; str:
    LOGGER.info(f&#34;get_parameter({par_name=}, {axis=})&#34;)
    if par_name == &#34;edev&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].edev}&#34;
    elif par_name == &#34;edir&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].edir}&#34;
    elif par_name == &#34;ffast&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].ffast}&#34;
    elif par_name == &#34;frun&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].frun}&#34;

    return f&#34;{par_name}{axis}:0&#34;


def set_parameter(par_name: str, axis: str, value: int | float):
    LOGGER.info(f&#34;set_parameter({par_name=}, {axis=}, {value=}&#34;)
    if par_name == &#34;edev&#34;:
        axes[int(axis)].edev = float(value)
    elif par_name == &#34;edir&#34;:
        axes[int(axis)].edir = int(value)


def get_status(axis: str):
    return f&#34;{axis}:0::0:{axes[int(axis)].get_encoder_position()}:0:0:0:1:0:0:0:0:0:0:0:0\r\n&#34;


def get_state(axis: str):
    return f&#34;{axis}:{axes[int(axis)].get_state()};&#34;


def set_slew_speed(axis: str, slew_speed: str):
    axes[int(axis)].set_slew_speed(int(slew_speed))


def get_current_position(axis: str) -&gt; str:
    return f&#34;{axis}:{axes[int(axis)].get_current_position()};&#34;


def get_current_encoder_position(axis: str) -&gt; str:
    # For now, we just return the current position, but this should actually
    # lag a little behind the current position. That&#39;s why it is to_be_implemented.
    return f&#34;{axis}:{axes[int(axis)].get_encoder_position()};&#34;


def get_current_encoder_counter_value(axis: str) -&gt; str:
    return f&#34;{axis}:{axes[int(axis)].get_encoder_counter_value()};&#34;


def goto_position(axis, position):

    axis = int(axis)
    position = float(position)

    # For the big rotation stage use the workaround to avoid continuous movement in the same
    # direction, and to avoid the limit switch.

    axes[axis].set_commanded_position(position)
    axes[axis].start()


def move_to_position(axis, distance):

    axis = int(axis)
    distance = float(distance)

    cp = axes[axis].get_current_position()
    axes[axis].set_commanded_position(cp + distance)
    axes[axis].start()


def nothing():
    return None


class Pass:
    &#34;&#34;&#34;
    Used to indicate that the arguments from the pattern match should be passed on to the
    response function.
    &#34;&#34;&#34;
    def __bool__(self):
        return False


pass_args = Pass()


COMMAND_ACTIONS_RESPONSES = {
    &#34;?v&#34;: (None, &#34;smc 1.2.1093&#34;),
    &#34;?&#34;: (None,
        textwrap.dedent(&#34;&#34;&#34;\
            system date: June 20, 2022 08:44:22
            os image: wes7
            control IC: MCX
            FBWF/UWF: disabled
            available axes: 3
            counter: not installed.
            filter device: not available.
            half screen device: not available.
            
            ?:cmdlist returns a command list,
            ?:xyz returns help for command &#39;xyz&#39;.
            ?&lt;parameter&gt;{:&lt;axis&gt;} returns current setting.&#34;&#34;&#34;
        )
    ),
    &#34;quit&#34;: (cancel_movement, nothing)
}

COMMAND_PATTERNS_ACTIONS_RESPONSES = {
    r&#34;cerr(\d)&#34;: (clear_error, nothing),
    r&#34;ffast(\d)\:(\d+)&#34;: (set_slew_speed, nothing),
    r&#34;(edev)(\d):(\d+(?:\.\d+)?)&#34;: (set_parameter, nothing),
    r&#34;(edir)(\d):(\d)&#34;: (set_parameter, nothing),
    r&#34;goto(\d):(-?\d+(?:\.\d+)?)&#34;: (goto_position, nothing),
    r&#34;move(\d):(-?\d+(?:\.\d+)?)&#34;: (move_to_position, nothing),
    r&#34;\?err(\d)&#34;: (pass_args, get_error),
    r&#34;\?p(\d)&#34;: (pass_args, get_current_position),
    r&#34;\?e(\d)&#34;: (pass_args, get_current_encoder_position),
    r&#34;\?ec(\d)&#34;: (pass_args, get_current_encoder_counter_value),
    r&#34;\?s(\d)&#34;: (pass_args, get_state),
    r&#34;\?status(\d)&#34;: (pass_args, get_status),
    r&#34;\?conf(\d)&#34;: (pass_args, get_configuration),
    r&#34;\?(\w+)(\d)&#34;: (pass_args, get_parameter),
}


def process_command(command_string: str) -&gt; str:

    LOGGER.debug(f&#34;{command_string = }&#34;)

    try:
        action, response = COMMAND_ACTIONS_RESPONSES[command_string]
        action and action()
        if error_msg:
            return error_msg
        else:
            return response if isinstance(response, str) else response()
    except KeyError:
        # try to match with a value
        for key, value in COMMAND_PATTERNS_ACTIONS_RESPONSES.items():
            if match := re.match(key, command_string):
                # LOGGER.debug(f&#34;{match=}, {match.groups()}&#34;)
                action, response = value
                # LOGGER.debug(f&#34;{action=}, {response=}&#34;)
                # if action is not None and not isinstance(action, Pass):
                action and action(*match.groups())
                if error_msg:
                    return error_msg
                if isinstance(response, str):
                    return response
                elif isinstance(action, Pass):
                    return response(*match.groups())
                else:
                    return response()
        return f&#34;ERROR: unknown command string: {command_string}&#34;


@click.group()
def cli():
    pass


@cli.command()
def start():  # sourcery skip: hoist-statement-from-loop
    global error_msg

    LOGGER.info(&#34;Starting the SMC9300 Simulator&#34;)

    quit_request = False

    while not quit_request:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind((HOST, PORT))
            s.listen()
            conn, addr = s.accept()
            with conn:
                print(&#39;Accepted connection from&#39;, addr)
                write(conn, &#39;smc 1.2.1093&#39;)
                try:
                    while True:
                        error_msg = &#34;&#34;
                        data = read(conn)
                        if (response := process_command(data)) is not None:
                            write(conn, response)
                        LOGGER.debug(f&#34;{data = } -&gt; {response = }&#34;)
                        if not data:
                            break  # connection closed by peer
                except KeyboardInterrupt:
                    print(&#34;Keyboard interrupt, closing.&#34;)
                except ConnectionResetError as exc:
                    print(f&#34;ConnectionResetError: {exc}&#34;, flush=True)

    print(flush=True)


if __name__ == &#34;__main__&#34;:
    cli()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.stages.huber.smc9300_sim.cancel_movement"><code class="name flex">
<span>def <span class="ident">cancel_movement</span></span>(<span>axis: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_movement(axis: Optional[str] = None):

    if axis is None:
        for axis in axes:
            axis and axis.stop()
    else:
        axes[int(axis)].stop()</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.clear_error"><code class="name flex">
<span>def <span class="ident">clear_error</span></span>(<span>axis: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_error(axis: str) -&gt; None:
    states[int(axis)].errors = []</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_configuration"><code class="name flex">
<span>def <span class="ident">get_configuration</span></span>(<span>axis: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_configuration(axis: str) -&gt; str:
    axis = int(axis)
    response = (
        f&#34;# configuration settings of axis {axis}\r\n&#34;
        f&#34;alias{axis}:{axes[axis].alias}\r\n&#34;
        f&#34;type{axis}:{axes[axis].type}\r\n&#34;
        f&#34;unit{axis}:{axes[axis].unit}\r\n&#34;
        f&#34;ffast{axis}:{axes[axis].ffast}\r\n&#34;
        f&#34;frun{axis}:{axes[axis].frun}\r\n&#34;
        f&#34;gnum{axis}:10000\r\n&#34;
        f&#34;biss_t{axis}:{axes[axis]._biss_t}&#34;  # last line doesn&#39;t have a \r\n, will be added later
    )
    return response</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_current_encoder_counter_value"><code class="name flex">
<span>def <span class="ident">get_current_encoder_counter_value</span></span>(<span>axis: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_encoder_counter_value(axis: str) -&gt; str:
    return f&#34;{axis}:{axes[int(axis)].get_encoder_counter_value()};&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_current_encoder_position"><code class="name flex">
<span>def <span class="ident">get_current_encoder_position</span></span>(<span>axis: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_encoder_position(axis: str) -&gt; str:
    # For now, we just return the current position, but this should actually
    # lag a little behind the current position. That&#39;s why it is to_be_implemented.
    return f&#34;{axis}:{axes[int(axis)].get_encoder_position()};&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_current_position"><code class="name flex">
<span>def <span class="ident">get_current_position</span></span>(<span>axis: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_position(axis: str) -&gt; str:
    return f&#34;{axis}:{axes[int(axis)].get_current_position()};&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>axis: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error(axis: str) -&gt; str:
    return f&#34;{axis}:0&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_parameter"><code class="name flex">
<span>def <span class="ident">get_parameter</span></span>(<span>par_name: str, axis: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameter(par_name: str, axis: str) -&gt; str:
    LOGGER.info(f&#34;get_parameter({par_name=}, {axis=})&#34;)
    if par_name == &#34;edev&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].edev}&#34;
    elif par_name == &#34;edir&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].edir}&#34;
    elif par_name == &#34;ffast&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].ffast}&#34;
    elif par_name == &#34;frun&#34;:
        return f&#34;{par_name}{axis}:{axes[int(axis)].frun}&#34;

    return f&#34;{par_name}{axis}:0&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>axis: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(axis: str):
    return f&#34;{axis}:{axes[int(axis)].get_state()};&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>axis: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(axis: str):
    return f&#34;{axis}:0::0:{axes[int(axis)].get_encoder_position()}:0:0:0:1:0:0:0:0:0:0:0:0\r\n&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.goto_position"><code class="name flex">
<span>def <span class="ident">goto_position</span></span>(<span>axis, position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto_position(axis, position):

    axis = int(axis)
    position = float(position)

    # For the big rotation stage use the workaround to avoid continuous movement in the same
    # direction, and to avoid the limit switch.

    axes[axis].set_commanded_position(position)
    axes[axis].start()</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.move_to_position"><code class="name flex">
<span>def <span class="ident">move_to_position</span></span>(<span>axis, distance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_position(axis, distance):

    axis = int(axis)
    distance = float(distance)

    cp = axes[axis].get_current_position()
    axes[axis].set_commanded_position(cp + distance)
    axes[axis].start()</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.nothing"><code class="name flex">
<span>def <span class="ident">nothing</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nothing():
    return None</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.process_command"><code class="name flex">
<span>def <span class="ident">process_command</span></span>(<span>command_string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_command(command_string: str) -&gt; str:

    LOGGER.debug(f&#34;{command_string = }&#34;)

    try:
        action, response = COMMAND_ACTIONS_RESPONSES[command_string]
        action and action()
        if error_msg:
            return error_msg
        else:
            return response if isinstance(response, str) else response()
    except KeyError:
        # try to match with a value
        for key, value in COMMAND_PATTERNS_ACTIONS_RESPONSES.items():
            if match := re.match(key, command_string):
                # LOGGER.debug(f&#34;{match=}, {match.groups()}&#34;)
                action, response = value
                # LOGGER.debug(f&#34;{action=}, {response=}&#34;)
                # if action is not None and not isinstance(action, Pass):
                action and action(*match.groups())
                if error_msg:
                    return error_msg
                if isinstance(response, str):
                    return response
                elif isinstance(action, Pass):
                    return response(*match.groups())
                else:
                    return response()
        return f&#34;ERROR: unknown command string: {command_string}&#34;</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>conn) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Reads one command string from the socket, i.e. until a linefeed ('
') is received.</p>
<pre><code>Returns:
    The command string with the linefeed stripped off.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(conn) -&gt; str:
    &#34;&#34;&#34;
    Reads one command string from the socket, i.e. until a linefeed (&#39;\n&#39;) is received.

    Returns:
        The command string with the linefeed stripped off.
    &#34;&#34;&#34;

    idx, n_total = 0, 0
    buf_size = 1024 * 4
    command_string = bytes()

    try:
        for _ in range(100):
            data = conn.recv(buf_size)
            n = len(data)
            n_total += n
            command_string += data
            # if data.endswith(b&#39;\n&#39;):
            if n &lt; buf_size:
                break
    except socket.timeout as e_timeout:
        LOGGER.warning(f&#34;Socket timeout error from {e_timeout}&#34;)
        return &#34;&#34;

    # LOGGER.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)
    # LOGGER.debug(f&#34;{command_string=}&#34;)

    return command_string.decode().rstrip()</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.set_parameter"><code class="name flex">
<span>def <span class="ident">set_parameter</span></span>(<span>par_name: str, axis: str, value: int | float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parameter(par_name: str, axis: str, value: int | float):
    LOGGER.info(f&#34;set_parameter({par_name=}, {axis=}, {value=}&#34;)
    if par_name == &#34;edev&#34;:
        axes[int(axis)].edev = float(value)
    elif par_name == &#34;edir&#34;:
        axes[int(axis)].edir = int(value)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.set_slew_speed"><code class="name flex">
<span>def <span class="ident">set_slew_speed</span></span>(<span>axis: str, slew_speed: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_speed(axis: str, slew_speed: str):
    axes[int(axis)].set_slew_speed(int(slew_speed))</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>conn, response: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a response string on the socket connection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conn</code></strong></dt>
<dd>the socket that is used for communication</dd>
<dt><strong><code>response</code></strong></dt>
<dd>the response of the previous command</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(conn, response: str) -&gt; None:
    &#34;&#34;&#34;
    Writes a response string on the socket connection.

    Args:
        conn: the socket that is used for communication
        response: the response of the previous command

    Returns:
        None.
    &#34;&#34;&#34;
    response = f&#34;{response}\r\n&#34;.encode()
    LOGGER.debug(f&#34;{response=}&#34;)
    conn.sendall(response)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.stages.huber.smc9300_sim.Axis"><code class="flex name class">
<span>class <span class="ident">Axis</span></span>
<span>(</span><span>slew_speed, encoder_conversion, alias, type_)</span>
</code></dt>
<dd>
<div class="desc"><p>This class controls the settings and movements of one particular axis
for the HUBER Stages.</p>
<p>Do not use this class directly, it is used from within the HuberSimulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axis:
    &#34;&#34;&#34;
    This class controls the settings and movements of one particular axis
    for the HUBER Stages.

    Do not use this class directly, it is used from within the HuberSimulator.
    &#34;&#34;&#34;

    def __init__(self, slew_speed, encoder_conversion, alias, type_):
        # Translation Stage: slew_speed = 77_200, encoder_conversion = 20_000
        # Big Rotation: slew_speed = 22_943_316, encoder_conversion = 11_930_500
        self._alias = alias
        self._type = type_
        self._slew_speed = slew_speed  # 1e-4 deg per second -&gt; 15_000 is 1.5 deg/s
        self._encoder_conversion_factor = encoder_conversion  # encoder positions per mm/deg
        self._encoder_counter_offset = 4287251092
        self._encoder_position = 0.0
        self._current_position = 0.0
        self._start_position = 0.0
        self._edev = 0.001
        self._edir = 0
        self._frun = 0
        self._commanded_position = None
        self._moving = False
        self._distance = 0
        self._direction = 0
        self._timer = AxisTimer()
        self._biss_t = 360 if self._type == 0 else 0

        self._unit = &#34;deg&#34; if self._type == 0 else &#34;mm&#34;

    @property
    def alias(self):
        return self._alias

    @property
    def type(self):
        return self._type

    @property
    def unit(self):
        return self._unit

    @property
    def ffast(self):
        return self._slew_speed

    @property
    def frun(self):
        return self._frun

    @property
    def edev(self):
        return self._edev

    @edev.setter
    def edev(self, value: float):
        self._edev = value

    @property
    def edir(self):
        return self._edir

    @edir.setter
    def edir(self, value: int):
        # value can be 0 or 1 only
        self._edir = value

    def get_slew_speed(self) -&gt; int:
        return self._slew_speed

    def set_slew_speed(self, speed: int):
        self._slew_speed = speed

    def get_converted_slew_speed(self) -&gt; float:
        &#34;&#34;&#34;Returns the slew speed in mm/s or deg/s&#34;&#34;&#34;
        return self._slew_speed * 1e-4

    def get_state(self) -&gt; int:
        state = 0
        if not self._moving:
            state = 129
        return state

    def start(self):
        &#34;&#34;&#34;
        Start a movement. A movement is defined as the change from the current
        position to the commanded position. Therefore, the start position will
        be set to the current position and all calculations including time will
        be with respect to the starting position.
        &#34;&#34;&#34;
        if self._commanded_position is None:
            raise InvalidStateError(&#34;Can not start a movement if commanded position is not set.&#34;)

        self._timer.start()
        self._moving = True
        self._distance = self._current_position - self._commanded_position
        self._direction = 1 if self._commanded_position &gt; self._current_position else -1
        self._start_position = self._current_position

    def stop(self):
        &#34;&#34;&#34;
        Stop a movement by

        &#34;&#34;&#34;
        self._moving = False
        self._timer.stop()

    def set_commanded_position(self, position):
        self._commanded_position = position

    def get_current_position(self) -&gt; float:
        self._calc_current_position()
        return self._current_position

    def get_encoder_position(self) -&gt; float:
        return self.get_current_position()  # add some noise here

    def get_encoder_counter_value(self) -&gt; int:
        return self._encoder_counter_offset + int(self.get_encoder_position() * self._encoder_conversion_factor)

    def is_in_position(self) -&gt; bool:
        self._calc_current_position()
        return not self._moving

    def _calc_current_position(self):
        if not self._moving:
            return

        delta_t = self._timer.get_delta_time()
        slew_speed = self.get_converted_slew_speed()
        travel = slew_speed * delta_t

        LOGGER.info(f&#34;{delta_t=}, {slew_speed=}, {travel=}&#34;)

        if travel &gt;= abs(self._distance):
            self._current_position = self._commanded_position
            self._moving = False
            self._distance = 0.0
        else:
            self._current_position = self._start_position + travel * self._direction</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.stages.huber.smc9300_sim.Axis.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def alias(self):
    return self._alias</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.edev"><code class="name">var <span class="ident">edev</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def edev(self):
    return self._edev</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.edir"><code class="name">var <span class="ident">edir</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def edir(self):
    return self._edir</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.ffast"><code class="name">var <span class="ident">ffast</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ffast(self):
    return self._slew_speed</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.frun"><code class="name">var <span class="ident">frun</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frun(self):
    return self._frun</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    return self._type</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.unit"><code class="name">var <span class="ident">unit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit(self):
    return self._unit</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300_sim.Axis.get_converted_slew_speed"><code class="name flex">
<span>def <span class="ident">get_converted_slew_speed</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the slew speed in mm/s or deg/s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_converted_slew_speed(self) -&gt; float:
    &#34;&#34;&#34;Returns the slew speed in mm/s or deg/s&#34;&#34;&#34;
    return self._slew_speed * 1e-4</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.get_current_position"><code class="name flex">
<span>def <span class="ident">get_current_position</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_position(self) -&gt; float:
    self._calc_current_position()
    return self._current_position</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.get_encoder_counter_value"><code class="name flex">
<span>def <span class="ident">get_encoder_counter_value</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_encoder_counter_value(self) -&gt; int:
    return self._encoder_counter_offset + int(self.get_encoder_position() * self._encoder_conversion_factor)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.get_encoder_position"><code class="name flex">
<span>def <span class="ident">get_encoder_position</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_encoder_position(self) -&gt; float:
    return self.get_current_position()  # add some noise here</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.get_slew_speed"><code class="name flex">
<span>def <span class="ident">get_slew_speed</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_speed(self) -&gt; int:
    return self._slew_speed</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self) -&gt; int:
    state = 0
    if not self._moving:
        state = 129
    return state</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.is_in_position"><code class="name flex">
<span>def <span class="ident">is_in_position</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_position(self) -&gt; bool:
    self._calc_current_position()
    return not self._moving</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.set_commanded_position"><code class="name flex">
<span>def <span class="ident">set_commanded_position</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_commanded_position(self, position):
    self._commanded_position = position</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.set_slew_speed"><code class="name flex">
<span>def <span class="ident">set_slew_speed</span></span>(<span>self, speed: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_speed(self, speed: int):
    self._slew_speed = speed</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a movement. A movement is defined as the change from the current
position to the commanded position. Therefore, the start position will
be set to the current position and all calculations including time will
be with respect to the starting position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;
    Start a movement. A movement is defined as the change from the current
    position to the commanded position. Therefore, the start position will
    be set to the current position and all calculations including time will
    be with respect to the starting position.
    &#34;&#34;&#34;
    if self._commanded_position is None:
        raise InvalidStateError(&#34;Can not start a movement if commanded position is not set.&#34;)

    self._timer.start()
    self._moving = True
    self._distance = self._current_position - self._commanded_position
    self._direction = 1 if self._commanded_position &gt; self._current_position else -1
    self._start_position = self._current_position</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Axis.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop a movement by</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;
    Stop a movement by

    &#34;&#34;&#34;
    self._moving = False
    self._timer.stop()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.stages.huber.smc9300_sim.AxisTimer"><code class="flex name class">
<span>class <span class="ident">AxisTimer</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class controls all the timings of an axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AxisTimer:
    &#34;&#34;&#34;
    This class controls all the timings of an axis.
    &#34;&#34;&#34;

    def __init__(self):
        self._start_time = time.time()
        self._running = False

    def is_running(self):
        return self._running

    def start(self):
        &#34;&#34;&#34;Start the timer.&#34;&#34;&#34;
        self._start_time = time.time()
        self._running = True


    def stop(self):
        &#34;&#34;&#34;Stop the timer.&#34;&#34;&#34;
        self._start_time = time.time()
        self._running = False

    def get_delta_time(self) -&gt; float:
        &#34;&#34;&#34;
        Returns the delta time since the start() method was called on this
        AxisTimer.

        :returns: delta time in seconds since the start of the timer
        &#34;&#34;&#34;
        return time.time() - self._start_time if self._running else 0.0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300_sim.AxisTimer.get_delta_time"><code class="name flex">
<span>def <span class="ident">get_delta_time</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the delta time since the start() method was called on this
AxisTimer.</p>
<p>:returns: delta time in seconds since the start of the timer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_delta_time(self) -&gt; float:
    &#34;&#34;&#34;
    Returns the delta time since the start() method was called on this
    AxisTimer.

    :returns: delta time in seconds since the start of the timer
    &#34;&#34;&#34;
    return time.time() - self._start_time if self._running else 0.0</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.AxisTimer.is_running"><code class="name flex">
<span>def <span class="ident">is_running</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_running(self):
    return self._running</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.AxisTimer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the timer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Start the timer.&#34;&#34;&#34;
    self._start_time = time.time()
    self._running = True</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.AxisTimer.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the timer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;Stop the timer.&#34;&#34;&#34;
    self._start_time = time.time()
    self._running = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.stages.huber.smc9300_sim.InvalidStateError"><code class="flex name class">
<span>class <span class="ident">InvalidStateError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidStateError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300_sim.OnOff"><code class="flex name class">
<span>class <span class="ident">OnOff</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OnOff(str, Enum):

    ON = &#34;ON&#34;
    OFF = &#34;OFF&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="egse.stages.huber.smc9300_sim.OnOff.OFF"><code class="name">var <span class="ident">OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="egse.stages.huber.smc9300_sim.OnOff.ON"><code class="name">var <span class="ident">ON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="egse.stages.huber.smc9300_sim.Pass"><code class="flex name class">
<span>class <span class="ident">Pass</span></span>
</code></dt>
<dd>
<div class="desc"><p>Used to indicate that the arguments from the pattern match should be passed on to the
response function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pass:
    &#34;&#34;&#34;
    Used to indicate that the arguments from the pattern match should be passed on to the
    response function.
    &#34;&#34;&#34;
    def __bool__(self):
        return False</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_sim.State"><code class="flex name class">
<span>class <span class="ident">State</span></span>
<span>(</span><span>axis: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class State:
    def __init__(self, axis: int):
        self.axis = axis
        self.errors = []
        self.slew_speed = 20_000
        self.current_position = 270
        self.current_encoder_position = 271
        self.current_encoder_counter = 272_000
        self.controller_ready = True
        self.is_connected = False</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.stages.huber" href="index.html">egse.stages.huber</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300_sim.cancel_movement" href="#egse.stages.huber.smc9300_sim.cancel_movement">cancel_movement</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.clear_error" href="#egse.stages.huber.smc9300_sim.clear_error">clear_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_configuration" href="#egse.stages.huber.smc9300_sim.get_configuration">get_configuration</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_current_encoder_counter_value" href="#egse.stages.huber.smc9300_sim.get_current_encoder_counter_value">get_current_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_current_encoder_position" href="#egse.stages.huber.smc9300_sim.get_current_encoder_position">get_current_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_current_position" href="#egse.stages.huber.smc9300_sim.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_error" href="#egse.stages.huber.smc9300_sim.get_error">get_error</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_parameter" href="#egse.stages.huber.smc9300_sim.get_parameter">get_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_state" href="#egse.stages.huber.smc9300_sim.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.get_status" href="#egse.stages.huber.smc9300_sim.get_status">get_status</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.goto_position" href="#egse.stages.huber.smc9300_sim.goto_position">goto_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.move_to_position" href="#egse.stages.huber.smc9300_sim.move_to_position">move_to_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.nothing" href="#egse.stages.huber.smc9300_sim.nothing">nothing</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.process_command" href="#egse.stages.huber.smc9300_sim.process_command">process_command</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.read" href="#egse.stages.huber.smc9300_sim.read">read</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.set_parameter" href="#egse.stages.huber.smc9300_sim.set_parameter">set_parameter</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.set_slew_speed" href="#egse.stages.huber.smc9300_sim.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.write" href="#egse.stages.huber.smc9300_sim.write">write</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.stages.huber.smc9300_sim.Axis" href="#egse.stages.huber.smc9300_sim.Axis">Axis</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.alias" href="#egse.stages.huber.smc9300_sim.Axis.alias">alias</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.edev" href="#egse.stages.huber.smc9300_sim.Axis.edev">edev</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.edir" href="#egse.stages.huber.smc9300_sim.Axis.edir">edir</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.ffast" href="#egse.stages.huber.smc9300_sim.Axis.ffast">ffast</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.frun" href="#egse.stages.huber.smc9300_sim.Axis.frun">frun</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.get_converted_slew_speed" href="#egse.stages.huber.smc9300_sim.Axis.get_converted_slew_speed">get_converted_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.get_current_position" href="#egse.stages.huber.smc9300_sim.Axis.get_current_position">get_current_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.get_encoder_counter_value" href="#egse.stages.huber.smc9300_sim.Axis.get_encoder_counter_value">get_encoder_counter_value</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.get_encoder_position" href="#egse.stages.huber.smc9300_sim.Axis.get_encoder_position">get_encoder_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.get_slew_speed" href="#egse.stages.huber.smc9300_sim.Axis.get_slew_speed">get_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.get_state" href="#egse.stages.huber.smc9300_sim.Axis.get_state">get_state</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.is_in_position" href="#egse.stages.huber.smc9300_sim.Axis.is_in_position">is_in_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.set_commanded_position" href="#egse.stages.huber.smc9300_sim.Axis.set_commanded_position">set_commanded_position</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.set_slew_speed" href="#egse.stages.huber.smc9300_sim.Axis.set_slew_speed">set_slew_speed</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.start" href="#egse.stages.huber.smc9300_sim.Axis.start">start</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.stop" href="#egse.stages.huber.smc9300_sim.Axis.stop">stop</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.type" href="#egse.stages.huber.smc9300_sim.Axis.type">type</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.Axis.unit" href="#egse.stages.huber.smc9300_sim.Axis.unit">unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_sim.AxisTimer" href="#egse.stages.huber.smc9300_sim.AxisTimer">AxisTimer</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300_sim.AxisTimer.get_delta_time" href="#egse.stages.huber.smc9300_sim.AxisTimer.get_delta_time">get_delta_time</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.AxisTimer.is_running" href="#egse.stages.huber.smc9300_sim.AxisTimer.is_running">is_running</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.AxisTimer.start" href="#egse.stages.huber.smc9300_sim.AxisTimer.start">start</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.AxisTimer.stop" href="#egse.stages.huber.smc9300_sim.AxisTimer.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_sim.InvalidStateError" href="#egse.stages.huber.smc9300_sim.InvalidStateError">InvalidStateError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_sim.OnOff" href="#egse.stages.huber.smc9300_sim.OnOff">OnOff</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300_sim.OnOff.OFF" href="#egse.stages.huber.smc9300_sim.OnOff.OFF">OFF</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_sim.OnOff.ON" href="#egse.stages.huber.smc9300_sim.OnOff.ON">ON</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_sim.Pass" href="#egse.stages.huber.smc9300_sim.Pass">Pass</a></code></h4>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_sim.State" href="#egse.stages.huber.smc9300_sim.State">State</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
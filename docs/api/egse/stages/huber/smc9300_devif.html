<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.stages.huber.smc9300_devif API documentation</title>
<meta name="description" content="HUBER Device Interface to the SMC 9300 motor controller." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.stages.huber.smc9300_devif</code></h1>
</header>
<section id="section-intro">
<p>HUBER Device Interface to the SMC 9300 motor controller.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
HUBER Device Interface to the SMC 9300 motor controller.
&#34;&#34;&#34;

import logging
import socket
import threading
import time

from egse.command import ClientServerCommand
from egse.device import DeviceConnectionError
from egse.device import DeviceConnectionInterface
from egse.device import DeviceTimeoutError
from egse.device import DeviceTransport
from egse.settings import Settings
from egse.system import Timer
from egse.system import format_datetime

# Explicitly set the module name instead of __name__. When module is executed instead of imported
# __name__ will result in __main__ and no logging to zmq will be done.

MODULE_LOGGER = logging.getLogger(&#34;egse.stages.huber.smc9300_devif&#34;)

READ_TIMEOUT = 10.0  # seconds
WRITE_TIMEOUT = 1.0  # seconds
CONNECT_TIMEOUT = 3.0  # seconds

HUBER_SETTINGS = Settings.load(&#34;Huber Controller&#34;)
DEVICE_NAME = &#34;SMC9300&#34;


class HuberError(Exception):
    pass


class HuberSMC9300Command(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\r\n&#34;


class HuberSMC9300EthernetInterface(DeviceConnectionInterface, DeviceTransport):
    &#34;&#34;&#34;
    Defines the low-level interface to the HUBER stages controller.

    Args:
        hostname (str): the IP address or fully qualified hostname of the OGSE hardware
            controller. The default is defined in the ``settings.yaml`` configuration file.

        port (int): the IP port number to connect to. The default is defined in the
            `settings.yaml` configuration file.
    &#34;&#34;&#34;
    def __init__(self, hostname: str = None, port: int = None):

        super().__init__()

        # Basic connection settings, loaded from the configuration YAML file

        self.hostname = hostname or HUBER_SETTINGS.HOSTNAME
        self.port = port or HUBER_SETTINGS.PORT
        self.sock = None

        # Access-to-the-connection semaphore. Use this to lock/unlock I/O access to the
        # connection (whatever type it is) in child classes.

        self.semaphore = threading.Semaphore()

        self.is_connection_open = False

        self._num_axes = HUBER_SETTINGS.NUMBER_OF_AXES

    def connect(self):
        &#34;&#34;&#34;
        Connects the TCP socket to the device controller.

        Returns:
            None.

        Raises:
            ValueError when hostname or port number are not initialized properly.

            DeviceConnectionError on any socket error except timeouts.

            DeviceTimeoutError on a socket timeout.
        &#34;&#34;&#34;
        # Sanity checks

        if self.is_connection_open:
            MODULE_LOGGER.warning(
                f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
            return

        if self.hostname in (None, &#34;&#34;):
            raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

        if self.port in (None, 0):
            raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

        # Create a new socket instance

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            # self.sock.setblocking(1)

            # DON&#39;T set a timeout on the socket, this will not result in the expected behavior.
            #
            # If the timeout is set, this will result in the following problem:
            # DEBUG    234    huber.py  send_direct_command: Sent out to HUBER: &#39;goto1:0.0\r\n&#39;
            # DEBUG    284    huber.py  wait_until_axis_ready: Wait until axis 1 is ready...
            # DEBUG    191    huber.py  get_response: Sent out to HUBER: &#39;?s1\r\n&#39;
            # DEBUG    198    huber.py  get_response: Receiving data after cmd=&#39;&#39;?s1\r\n&#39;&#39;...
            # WARNING  263    huber.py  wait_for_response: Socket timeout error from timed out
            # DEBUG    200    huber.py  get_response: Received from HUBER: b&#39;\r\n&#39;
            #

            # self.sock.settimeout(3)

        except socket.error as e_socket:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket

        # Attempt to establish a connection to the remote host

        # FIXME: Socket shall be closed on exception?

        # We set a timeout of 3 sec before connecting and reset to None
        # (=blocking) after the connect() method. The reason for this that when no
        # HUBER SMC is available, e.g. during testing, the timeout will take about
        # two minutes which is way too long. It needs to be evaluated if this
        # approach is acceptable and not causing problems during production.

        try:
            MODULE_LOGGER.debug(
                f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
            self.sock.settimeout(CONNECT_TIMEOUT)
            self.sock.connect((self.hostname, self.port))
            self.sock.settimeout(None)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
            ) from exc
        except TimeoutError as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
            ) from exc
        except socket.gaierror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
            ) from exc
        except socket.herror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
            ) from exc
        except socket.timeout as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
            ) from exc
        except OSError as exc:
            raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

        self.is_connection_open = True

        # The first thing to receive should be the &#39;smc 1.2.1093&#39; string.

        response = self.read()
        MODULE_LOGGER.debug(f&#34;After connection, we got &#39;{response}&#39; as a response.&#34;)

    def disconnect(self):
        &#34;&#34;&#34;
        Disconnect the Ethernet connection from the device controller.

        Raises:
             a DeviceConnectionError on failure.
        &#34;&#34;&#34;
        try:
            if self.is_connection_open:
                MODULE_LOGGER.debug(f&#39;Disconnecting from {self.hostname}&#39;)
                self.semaphore.acquire()
                self.sock.close()
                self.semaphore.release()
                self.is_connection_open = False
        except Exception as e_exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc

    def reconnect(self):

        if self.is_connection_open:
            self.disconnect()
        self.connect()

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the device is connected.

        Returns:
             True is the device is connected, False otherwise.
        &#34;&#34;&#34;

        return bool(self.is_connection_open)

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read a response from the device.

        Returns:
            A bytes object containing the response from the device. No processing is done
            on the response.
        Raises:
            A DeviceTimeoutError when the read operation timed out.
        &#34;&#34;&#34;
        idx, n_total = 0, 0
        buf_size = 1024 * 10
        response = bytes()

        # Set a timeout of READ_TIMEOUT to the socket.recv

        saved_timeout = self.sock.gettimeout()
        self.sock.settimeout(READ_TIMEOUT)

        try:
            for _ in range(100):
                # time.sleep(0.1)  # Give the device time to fill the buffer
                data = self.sock.recv(buf_size)
                n = len(data)
                n_total += n
                response += data
                if n &lt; buf_size:
                    break
        except socket.timeout as e_timeout:
            MODULE_LOGGER.warning(f&#34;Socket timeout error: {e_timeout}&#34;)
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        finally:
            self.sock.settimeout(saved_timeout)

        # logger.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)
        # logger.debug(f&#34;&gt; {response[:80]=}&#34;)

        return response

    def write(self, command: str) -&gt; None:
        &#34;&#34;&#34;
        Send a command to the device.

        No processing is done on the command string, except for the encoding into a bytes object.

        Args:
            command: the command string including terminators.

        Raises:
            A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
            there was a socket related error.
        &#34;&#34;&#34;

        # MODULE_LOGGER.debug(f&#34;{command.encode() = }&#34;)

        try:
            self.sock.sendall(command.encode())

            # Give the SMC time to start a new command: see issue #1209
            time.sleep(0.5)

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as an I/O error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket

    def trans(self, command: str) -&gt; bytes:
        &#34;&#34;&#34;
        Send a command to the device and wait for the response.

        No processing is done on the command string, except for the encoding into a bytes object.

        Args:
            command: the command string including terminators.

        Returns:
            A bytes object containing the response from the device. No processing is done
            on the response.

        Raises:
            A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
            there was a socket related error.
        &#34;&#34;&#34;
        # MODULE_LOGGER.debug(f&#34;{command.encode() = }&#34;)

        try:
            # Attempt to send the complete command

            self.sock.sendall(command.encode())

            # wait for, read and return the response (will be at most TBD chars)

            return self.read()

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as an I/O error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket


if __name__ == &#34;__main__&#34;:

    from rich import print

    def send_command(cmd):
        cmd = cmd.rstrip()
        with Timer(f&#34;{DEVICE_NAME} Query&#34;):
            response = huber.query(cmd + &#34;\r\n&#34;)
        print(f&#34;{format_datetime()} Response for {cmd:&gt;20s}: {response}&#34;)
        response = response.rstrip()
        return response

    huber = HuberSMC9300EthernetInterface()

    print(f&#34;{&#39; &#39; :-&gt;10} Connecting to {DEVICE_NAME}..&#34;)

    huber.connect()

    print(f&#34;{&#39; &#39; :-&gt;10} Requesting info..&#34;)

    send_command(&#34;?&#34;)
    send_command(&#34;?v&#34;)
    send_command(&#34;?s1&#34;)
    send_command(&#34;?status1&#34;)
    send_command(&#34;?status2&#34;)
    send_command(&#34;?status3&#34;)
    send_command(&#34;?err1&#34;)
    send_command(&#34;?conf1&#34;)
    send_command(&#34;?conf2&#34;)
    send_command(&#34;?conf3&#34;)
    send_command(&#34;?p1&#34;)
    send_command(&#34;?e1&#34;)
    send_command(&#34;?ec1&#34;)
    send_command(&#34;?ip&#34;)
    send_command(&#34;?pgm&#34;)  # command not yet available
    send_command(&#34;?ffast1&#34;)
    send_command(&#34;?ffast2&#34;)
    send_command(&#34;?ffast3&#34;)

    print(f&#34;{&#39; &#39; :-&gt;10} Closing connection..&#34;)

    huber.disconnect()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.stages.huber.smc9300_devif.HuberError"><code class="flex name class">
<span>class <span class="ident">HuberError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300Command"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300Command</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300Command(ClientServerCommand):
    def get_cmd_string(self, *args, **kwargs) -&gt; str:
        out = super().get_cmd_string(*args, **kwargs)
        return out + &#34;\r\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300Command.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs) -&gt; str:
    out = super().get_cmd_string(*args, **kwargs)
    return out + &#34;\r\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface"><code class="flex name class">
<span>class <span class="ident">HuberSMC9300EthernetInterface</span></span>
<span>(</span><span>hostname: str = None, port: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the low-level interface to the HUBER stages controller.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hostname</code></strong> :&ensp;<code>str</code></dt>
<dd>the IP address or fully qualified hostname of the OGSE hardware
controller. The default is defined in the <code>settings.yaml</code> configuration file.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>the IP port number to connect to. The default is defined in the
<code>settings.yaml</code> configuration file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuberSMC9300EthernetInterface(DeviceConnectionInterface, DeviceTransport):
    &#34;&#34;&#34;
    Defines the low-level interface to the HUBER stages controller.

    Args:
        hostname (str): the IP address or fully qualified hostname of the OGSE hardware
            controller. The default is defined in the ``settings.yaml`` configuration file.

        port (int): the IP port number to connect to. The default is defined in the
            `settings.yaml` configuration file.
    &#34;&#34;&#34;
    def __init__(self, hostname: str = None, port: int = None):

        super().__init__()

        # Basic connection settings, loaded from the configuration YAML file

        self.hostname = hostname or HUBER_SETTINGS.HOSTNAME
        self.port = port or HUBER_SETTINGS.PORT
        self.sock = None

        # Access-to-the-connection semaphore. Use this to lock/unlock I/O access to the
        # connection (whatever type it is) in child classes.

        self.semaphore = threading.Semaphore()

        self.is_connection_open = False

        self._num_axes = HUBER_SETTINGS.NUMBER_OF_AXES

    def connect(self):
        &#34;&#34;&#34;
        Connects the TCP socket to the device controller.

        Returns:
            None.

        Raises:
            ValueError when hostname or port number are not initialized properly.

            DeviceConnectionError on any socket error except timeouts.

            DeviceTimeoutError on a socket timeout.
        &#34;&#34;&#34;
        # Sanity checks

        if self.is_connection_open:
            MODULE_LOGGER.warning(
                f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
            return

        if self.hostname in (None, &#34;&#34;):
            raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

        if self.port in (None, 0):
            raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

        # Create a new socket instance

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            # self.sock.setblocking(1)

            # DON&#39;T set a timeout on the socket, this will not result in the expected behavior.
            #
            # If the timeout is set, this will result in the following problem:
            # DEBUG    234    huber.py  send_direct_command: Sent out to HUBER: &#39;goto1:0.0\r\n&#39;
            # DEBUG    284    huber.py  wait_until_axis_ready: Wait until axis 1 is ready...
            # DEBUG    191    huber.py  get_response: Sent out to HUBER: &#39;?s1\r\n&#39;
            # DEBUG    198    huber.py  get_response: Receiving data after cmd=&#39;&#39;?s1\r\n&#39;&#39;...
            # WARNING  263    huber.py  wait_for_response: Socket timeout error from timed out
            # DEBUG    200    huber.py  get_response: Received from HUBER: b&#39;\r\n&#39;
            #

            # self.sock.settimeout(3)

        except socket.error as e_socket:
            raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket

        # Attempt to establish a connection to the remote host

        # FIXME: Socket shall be closed on exception?

        # We set a timeout of 3 sec before connecting and reset to None
        # (=blocking) after the connect() method. The reason for this that when no
        # HUBER SMC is available, e.g. during testing, the timeout will take about
        # two minutes which is way too long. It needs to be evaluated if this
        # approach is acceptable and not causing problems during production.

        try:
            MODULE_LOGGER.debug(
                f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
            self.sock.settimeout(CONNECT_TIMEOUT)
            self.sock.connect((self.hostname, self.port))
            self.sock.settimeout(None)
        except ConnectionRefusedError as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
            ) from exc
        except TimeoutError as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
            ) from exc
        except socket.gaierror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
            ) from exc
        except socket.herror as exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
            ) from exc
        except socket.timeout as exc:
            raise DeviceTimeoutError(
                DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
            ) from exc
        except OSError as exc:
            raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

        self.is_connection_open = True

        # The first thing to receive should be the &#39;smc 1.2.1093&#39; string.

        response = self.read()
        MODULE_LOGGER.debug(f&#34;After connection, we got &#39;{response}&#39; as a response.&#34;)

    def disconnect(self):
        &#34;&#34;&#34;
        Disconnect the Ethernet connection from the device controller.

        Raises:
             a DeviceConnectionError on failure.
        &#34;&#34;&#34;
        try:
            if self.is_connection_open:
                MODULE_LOGGER.debug(f&#39;Disconnecting from {self.hostname}&#39;)
                self.semaphore.acquire()
                self.sock.close()
                self.semaphore.release()
                self.is_connection_open = False
        except Exception as e_exc:
            raise DeviceConnectionError(
                DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc

    def reconnect(self):

        if self.is_connection_open:
            self.disconnect()
        self.connect()

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the device is connected.

        Returns:
             True is the device is connected, False otherwise.
        &#34;&#34;&#34;

        return bool(self.is_connection_open)

    def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read a response from the device.

        Returns:
            A bytes object containing the response from the device. No processing is done
            on the response.
        Raises:
            A DeviceTimeoutError when the read operation timed out.
        &#34;&#34;&#34;
        idx, n_total = 0, 0
        buf_size = 1024 * 10
        response = bytes()

        # Set a timeout of READ_TIMEOUT to the socket.recv

        saved_timeout = self.sock.gettimeout()
        self.sock.settimeout(READ_TIMEOUT)

        try:
            for _ in range(100):
                # time.sleep(0.1)  # Give the device time to fill the buffer
                data = self.sock.recv(buf_size)
                n = len(data)
                n_total += n
                response += data
                if n &lt; buf_size:
                    break
        except socket.timeout as e_timeout:
            MODULE_LOGGER.warning(f&#34;Socket timeout error: {e_timeout}&#34;)
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        finally:
            self.sock.settimeout(saved_timeout)

        # logger.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)
        # logger.debug(f&#34;&gt; {response[:80]=}&#34;)

        return response

    def write(self, command: str) -&gt; None:
        &#34;&#34;&#34;
        Send a command to the device.

        No processing is done on the command string, except for the encoding into a bytes object.

        Args:
            command: the command string including terminators.

        Raises:
            A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
            there was a socket related error.
        &#34;&#34;&#34;

        # MODULE_LOGGER.debug(f&#34;{command.encode() = }&#34;)

        try:
            self.sock.sendall(command.encode())

            # Give the SMC time to start a new command: see issue #1209
            time.sleep(0.5)

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as an I/O error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket

    def trans(self, command: str) -&gt; bytes:
        &#34;&#34;&#34;
        Send a command to the device and wait for the response.

        No processing is done on the command string, except for the encoding into a bytes object.

        Args:
            command: the command string including terminators.

        Returns:
            A bytes object containing the response from the device. No processing is done
            on the response.

        Raises:
            A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
            there was a socket related error.
        &#34;&#34;&#34;
        # MODULE_LOGGER.debug(f&#34;{command.encode() = }&#34;)

        try:
            # Attempt to send the complete command

            self.sock.sendall(command.encode())

            # wait for, read and return the response (will be at most TBD chars)

            return self.read()

        except socket.timeout as e_timeout:
            raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
        except socket.error as e_socket:
            # Interpret any socket-related error as an I/O error
            raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></li>
<li><a title="egse.device.DeviceConnectionObservable" href="../../device.html#egse.device.DeviceConnectionObservable">DeviceConnectionObservable</a></li>
<li><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connects the TCP socket to the device controller.</p>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="raises">Raises</h2>
<p>ValueError when hostname or port number are not initialized properly.</p>
<p>DeviceConnectionError on any socket error except timeouts.</p>
<p>DeviceTimeoutError on a socket timeout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;
    Connects the TCP socket to the device controller.

    Returns:
        None.

    Raises:
        ValueError when hostname or port number are not initialized properly.

        DeviceConnectionError on any socket error except timeouts.

        DeviceTimeoutError on a socket timeout.
    &#34;&#34;&#34;
    # Sanity checks

    if self.is_connection_open:
        MODULE_LOGGER.warning(
            f&#34;{DEVICE_NAME}: trying to connect to an already connected socket.&#34;)
        return

    if self.hostname in (None, &#34;&#34;):
        raise ValueError(f&#34;{DEVICE_NAME}: hostname is not initialized.&#34;)

    if self.port in (None, 0):
        raise ValueError(f&#34;{DEVICE_NAME}: port number is not initialized.&#34;)

    # Create a new socket instance

    try:
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # self.sock.setblocking(1)

        # DON&#39;T set a timeout on the socket, this will not result in the expected behavior.
        #
        # If the timeout is set, this will result in the following problem:
        # DEBUG    234    huber.py  send_direct_command: Sent out to HUBER: &#39;goto1:0.0\r\n&#39;
        # DEBUG    284    huber.py  wait_until_axis_ready: Wait until axis 1 is ready...
        # DEBUG    191    huber.py  get_response: Sent out to HUBER: &#39;?s1\r\n&#39;
        # DEBUG    198    huber.py  get_response: Receiving data after cmd=&#39;&#39;?s1\r\n&#39;&#39;...
        # WARNING  263    huber.py  wait_for_response: Socket timeout error from timed out
        # DEBUG    200    huber.py  get_response: Received from HUBER: b&#39;\r\n&#39;
        #

        # self.sock.settimeout(3)

    except socket.error as e_socket:
        raise DeviceConnectionError(DEVICE_NAME, &#34;Failed to create socket.&#34;) from e_socket

    # Attempt to establish a connection to the remote host

    # FIXME: Socket shall be closed on exception?

    # We set a timeout of 3 sec before connecting and reset to None
    # (=blocking) after the connect() method. The reason for this that when no
    # HUBER SMC is available, e.g. during testing, the timeout will take about
    # two minutes which is way too long. It needs to be evaluated if this
    # approach is acceptable and not causing problems during production.

    try:
        MODULE_LOGGER.debug(
            f&#39;Connecting a socket to host &#34;{self.hostname}&#34; using port {self.port}&#39;)
        self.sock.settimeout(CONNECT_TIMEOUT)
        self.sock.connect((self.hostname, self.port))
        self.sock.settimeout(None)
    except ConnectionRefusedError as exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;Connection refused to {self.hostname}:{self.port}.&#34;
        ) from exc
    except TimeoutError as exc:
        raise DeviceTimeoutError(
            DEVICE_NAME, f&#34;Connection to {self.hostname}:{self.port} timed out.&#34;
        ) from exc
    except socket.gaierror as exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;socket address info error for {self.hostname}&#34;
        ) from exc
    except socket.herror as exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;socket host address error for {self.hostname}&#34;
        ) from exc
    except socket.timeout as exc:
        raise DeviceTimeoutError(
            DEVICE_NAME, f&#34;socket timeout error for {self.hostname}:{self.port}&#34;
        ) from exc
    except OSError as exc:
        raise DeviceConnectionError(DEVICE_NAME, f&#34;OSError caught ({exc}).&#34;) from exc

    self.is_connection_open = True

    # The first thing to receive should be the &#39;smc 1.2.1093&#39; string.

    response = self.read()
    MODULE_LOGGER.debug(f&#34;After connection, we got &#39;{response}&#39; as a response.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect the Ethernet connection from the device controller.</p>
<h2 id="raises">Raises</h2>
<p>a DeviceConnectionError on failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;
    Disconnect the Ethernet connection from the device controller.

    Raises:
         a DeviceConnectionError on failure.
    &#34;&#34;&#34;
    try:
        if self.is_connection_open:
            MODULE_LOGGER.debug(f&#39;Disconnecting from {self.hostname}&#39;)
            self.semaphore.acquire()
            self.sock.close()
            self.semaphore.release()
            self.is_connection_open = False
    except Exception as e_exc:
        raise DeviceConnectionError(
            DEVICE_NAME, f&#34;Could not close socket to {self.hostname}&#34;) from e_exc</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the device is connected.</p>
<h2 id="returns">Returns</h2>
<p>True is the device is connected, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if the device is connected.

    Returns:
         True is the device is connected, False otherwise.
    &#34;&#34;&#34;

    return bool(self.is_connection_open)</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Read a response from the device.</p>
<h2 id="returns">Returns</h2>
<p>A bytes object containing the response from the device. No processing is done
on the response.</p>
<h2 id="raises">Raises</h2>
<p>A DeviceTimeoutError when the read operation timed out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; bytes:
    &#34;&#34;&#34;
    Read a response from the device.

    Returns:
        A bytes object containing the response from the device. No processing is done
        on the response.
    Raises:
        A DeviceTimeoutError when the read operation timed out.
    &#34;&#34;&#34;
    idx, n_total = 0, 0
    buf_size = 1024 * 10
    response = bytes()

    # Set a timeout of READ_TIMEOUT to the socket.recv

    saved_timeout = self.sock.gettimeout()
    self.sock.settimeout(READ_TIMEOUT)

    try:
        for _ in range(100):
            # time.sleep(0.1)  # Give the device time to fill the buffer
            data = self.sock.recv(buf_size)
            n = len(data)
            n_total += n
            response += data
            if n &lt; buf_size:
                break
    except socket.timeout as e_timeout:
        MODULE_LOGGER.warning(f&#34;Socket timeout error: {e_timeout}&#34;)
        raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
    finally:
        self.sock.settimeout(saved_timeout)

    # logger.debug(f&#34;Total number of bytes received is {n_total}, idx={idx}&#34;)
    # logger.debug(f&#34;&gt; {response[:80]=}&#34;)

    return response</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.trans"><code class="name flex">
<span>def <span class="ident">trans</span></span>(<span>self, command: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Send a command to the device and wait for the response.</p>
<p>No processing is done on the command string, except for the encoding into a bytes object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>the command string including terminators.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A bytes object containing the response from the device. No processing is done
on the response.</p>
<h2 id="raises">Raises</h2>
<p>A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
there was a socket related error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trans(self, command: str) -&gt; bytes:
    &#34;&#34;&#34;
    Send a command to the device and wait for the response.

    No processing is done on the command string, except for the encoding into a bytes object.

    Args:
        command: the command string including terminators.

    Returns:
        A bytes object containing the response from the device. No processing is done
        on the response.

    Raises:
        A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
        there was a socket related error.
    &#34;&#34;&#34;
    # MODULE_LOGGER.debug(f&#34;{command.encode() = }&#34;)

    try:
        # Attempt to send the complete command

        self.sock.sendall(command.encode())

        # wait for, read and return the response (will be at most TBD chars)

        return self.read()

    except socket.timeout as e_timeout:
        raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
    except socket.error as e_socket:
        # Interpret any socket-related error as an I/O error
        raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket</code></pre>
</details>
</dd>
<dt id="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, command: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Send a command to the device.</p>
<p>No processing is done on the command string, except for the encoding into a bytes object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>the command string including terminators.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
there was a socket related error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, command: str) -&gt; None:
    &#34;&#34;&#34;
    Send a command to the device.

    No processing is done on the command string, except for the encoding into a bytes object.

    Args:
        command: the command string including terminators.

    Raises:
        A DeviceTimeoutError when the sendall() timed out, and a DeviceConnectionError if
        there was a socket related error.
    &#34;&#34;&#34;

    # MODULE_LOGGER.debug(f&#34;{command.encode() = }&#34;)

    try:
        self.sock.sendall(command.encode())

        # Give the SMC time to start a new command: see issue #1209
        time.sleep(0.5)

    except socket.timeout as e_timeout:
        raise DeviceTimeoutError(DEVICE_NAME, &#34;Socket timeout error&#34;) from e_timeout
    except socket.error as e_socket:
        # Interpret any socket-related error as an I/O error
        raise DeviceConnectionError(DEVICE_NAME, &#34;Socket communication error.&#34;) from e_socket</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.device.DeviceConnectionInterface" href="../../device.html#egse.device.DeviceConnectionInterface">DeviceConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceConnectionInterface.add_observer" href="../../device.html#egse.device.DeviceConnectionObservable.add_observer">add_observer</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.notify_observers" href="../../device.html#egse.device.DeviceConnectionObservable.notify_observers">notify_observers</a></code></li>
<li><code><a title="egse.device.DeviceConnectionInterface.reconnect" href="../../device.html#egse.device.DeviceConnectionInterface.reconnect">reconnect</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.device.DeviceTransport" href="../../device.html#egse.device.DeviceTransport">DeviceTransport</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.device.DeviceTransport.query" href="../../device.html#egse.device.DeviceTransport.query">query</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.stages.huber" href="index.html">egse.stages.huber</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.stages.huber.smc9300_devif.HuberError" href="#egse.stages.huber.smc9300_devif.HuberError">HuberError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300Command" href="#egse.stages.huber.smc9300_devif.HuberSMC9300Command">HuberSMC9300Command</a></code></h4>
<ul class="">
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300Command.get_cmd_string" href="#egse.stages.huber.smc9300_devif.HuberSMC9300Command.get_cmd_string">get_cmd_string</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface">HuberSMC9300EthernetInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.connect" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.connect">connect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.disconnect" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.disconnect">disconnect</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.is_connected" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.is_connected">is_connected</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.read" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.read">read</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.trans" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.trans">trans</a></code></li>
<li><code><a title="egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.write" href="#egse.stages.huber.smc9300_devif.HuberSMC9300EthernetInterface.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.proxy API documentation</title>
<meta name="description" content="The Proxy module provides the base class for the Proxy objects for each device
controller …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.proxy</code></h1>
</header>
<section id="section-intro">
<p>The Proxy module provides the base class for the Proxy objects for each device
controller.</p>
<p>The module also provides the connection state interface and classes for
maintaining the state of the Proxy connection to the control server.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Proxy module provides the base class for the Proxy objects for each device
controller.

The module also provides the connection state interface and classes for
maintaining the state of the Proxy connection to the control server.
&#34;&#34;&#34;
import logging
import pickle
import types
from types import MethodType

import zmq

from egse.decorators import dynamic_interface
from egse.mixin import DynamicClientCommandMixin
from egse.system import AttributeDict
from egse.zmq_ser import split_address


def set_docstring(func, cmd):
    &#34;&#34;&#34;Decorator to set the docstring of the command on the dynamic method / function.&#34;&#34;&#34;

    def wrap_func(*args, **kwargs):
        return func(*args, **kwargs)

    wrap_func.__doc__ = cmd.__doc__
    wrap_func.__name__ = f&#34;{cmd.get_name()}&#34;
    return wrap_func


REQUEST_TIMEOUT = 6250
REQUEST_RETRIES = 0


class ControlServerConnectionInterface:
    &#34;&#34;&#34;This interface defines the connection commands for control servers.

    This interface shall be implemented by the Proxy class and guarantees that connection commands
    do not interfere with the commands defined in the `DeviceConnectionInterface` (which will be
    loaded from the control server).
    &#34;&#34;&#34;

    def __enter__(self):
        self.connect_cs()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect_cs()

    @dynamic_interface
    def connect_cs(self):
        &#34;&#34;&#34;Connect to the control server.

        Raises:
            ConnectionError: when the connection can not be established.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def reconnect_cs(self):
        &#34;&#34;&#34;Reconnect the control server after it has been disconnected.

        Raises:
            ConnectionError: when the connection can not be established.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def disconnect_cs(self):
        &#34;&#34;&#34;Disconnect from the control server.

        Raises:
            ConnectionError: when the connection can not be closed.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def reset_cs_connection(self):
        &#34;&#34;&#34;Resets the connection to the control server.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_cs_connected(self) -&gt; bool:
        &#34;&#34;&#34;Check if the control server is connected.

        Returns:
            True if the device is connected and responds to a command, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError


class BaseProxy(ControlServerConnectionInterface):
    def __init__(self, endpoint, timeout: int = REQUEST_TIMEOUT):
        &#34;&#34;&#34;
        The `timeout` argument specifies the number of milliseconds to wait for a reply from the
        control server.
        &#34;&#34;&#34;

        self._logger = logging.getLogger(self.__class__.__name__)

        self._ctx = zmq.Context.instance()
        self._poller = zmq.Poller()
        self._socket = None
        self._endpoint = endpoint
        self._timeout = timeout

        self.connect_cs()

    def __enter__(self):
        if not self.ping():
            raise ConnectionError(&#34;Proxy is not connected when entering the context.&#34;)

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if not self._socket.closed:
            self.disconnect_cs()

    def connect_cs(self):
        self._logger.log(0, f&#34;Trying to connect {self.__class__.__name__} to {self._endpoint}&#34;)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def disconnect_cs(self):
        self._socket.setsockopt(zmq.LINGER, 0)
        self._socket.close()
        self._poller.unregister(self._socket)

    def reconnect_cs(self):
        self._logger.log(20, f&#34;Trying to reconnect {self.__class__.__name__} to {self._endpoint}&#34;)

        if not self._socket.closed:
            self._socket.close(linger=0)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def reset_cs_connection(self):
        self._logger.log(
            10, f&#34;Trying to reset the connection from {self.__class__.__name__} to {self._endpoint}&#34;
        )

        self.disconnect_cs()
        self.connect_cs()

    def is_cs_connected(self) -&gt; bool:
        return self.ping()

    def send(self, data, retries: int = REQUEST_RETRIES, timeout: int = None):
        &#34;&#34;&#34;
        Sends a command to the control server and waits for a response.

        When not connected to the control server or when a timeout occurs, the
        ``send()`` command retries a number of times to send the command.

        The number of retries is hardcoded and currently set to &#39;2&#39;, the request
        timeout is set to 2.5 seconds.

        The command data will be pickled before sending. Make sure the ``data``
        argument can be dumped by pickle.

        Args:
            data (str): the command that is sent to the control server, usually a
                string, but that is not enforced.
            timeout (int): the time to wait for a reply [in milliseconds]
            retries (int): the number of time we should retry to send the message

        Returns:
            response: the response from the control server or ``None`` when there was
                a problem or a timeout.
        &#34;&#34;&#34;
        timeout = timeout or self._timeout

        pickle_string = pickle.dumps(data)

        retries_left = retries

        # When we enter this method, we assume the Proxy has been connected. It
        # might be the server is not responding, but that is handled by the
        # algorithm below where we have a number of retries to receive the response
        # of the sent command. Remember that we are using ZeroMQ where the connect
        # method returns gracefully even when no server is available.

        if self._socket.closed:
            self.reconnect_cs()

        self._logger.log(0, f&#34;Sending &#39;{data}&#39;&#34;)
        self._socket.send(pickle_string)

        while True:
            socks = dict(self._poller.poll(timeout))

            if self._socket in socks and socks[self._socket] == zmq.POLLIN:
                pickle_string = self._socket.recv()
                if not pickle_string:
                    break
                response = pickle.loads(pickle_string)
                self._logger.log(0, f&#34;Receiving response: {response}&#34;)
                return response
            else:
                # timeout - server unavailable

                # We should disconnect here because socket is possibly confused.
                # Close the socket and remove from the poller.

                self.disconnect_cs()

                if retries_left == 0:
                    self._logger.critical(&#34;Control Server seems to be off-line, abandoning&#34;)
                    return None
                retries_left -= 1

                self._logger.log(logging.CRITICAL, f&#34;Reconnecting {self.__class__.__name__}, {retries_left=}&#34;)

                self.reconnect_cs()

                # Now try to send the request again

                self._socket.send(pickle_string)

    def ping(self):
        return_code = self.send(&#34;Ping&#34;, retries=0, timeout=1000)
        self._logger.log(0, f&#34;Check if control server is available: Ping - {return_code}&#34;)
        return return_code == &#34;Pong&#34;

    def get_endpoint(self):
        &#34;&#34;&#34; Returns the endpoint.&#34;&#34;&#34;
        return self._endpoint

    def get_monitoring_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the monitoring port. &#34;&#34;&#34;
        return self.send(&#34;get_monitoring_port&#34;)

    def get_commanding_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the commanding port.&#34;&#34;&#34;
        return self.send(&#34;get_commanding_port&#34;)

    def get_service_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the service port. &#34;&#34;&#34;
        return self.send(&#34;get_service_port&#34;)

    def get_ip_address(self) -&gt; int:
        &#34;&#34;&#34; Returns the hostname of the control server.&#34;&#34;&#34;
        return self.send(&#34;get_ip_address&#34;)

    def get_service_proxy(self):
        &#34;&#34;&#34;Return a ServiceProxy for the control server of this proxy object.&#34;&#34;&#34;
        from egse.services import ServiceProxy  # prevent circular import problem

        transport, address, _ = split_address(self._endpoint)

        port = self.send(&#34;get_service_port&#34;)

        return ServiceProxy(
            AttributeDict({&#34;PROTOCOL&#34;: transport, &#34;HOSTNAME&#34;: address, &#34;SERVICE_PORT&#34;: port})
        )


class DynamicProxy(BaseProxy, DynamicClientCommandMixin):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


# TODO (rik): remove all methods from Proxy that are also define in the BaseProxy

class Proxy(BaseProxy, ControlServerConnectionInterface):
    &#34;&#34;&#34;
    A Proxy object will forward CommandExecutions to the connected control server
    and wait for a response. When the Proxy can not connect to its control server
    during initialization, a ConnectionError will be raised.
    &#34;&#34;&#34;

    def __init__(self, endpoint, timeout: int = REQUEST_TIMEOUT):
        &#34;&#34;&#34;
        During initialization, the Proxy will connect to the control server and send a
        handshaking `Ping` command. When that succeeds the Proxy will request and load the
        available commands from the control server. When the connection with the control server
        fails, no commands are loaded and the Proxy is left in a &#39;disconnected&#39; state. The caller
        can fix the problem with the control server and call `connect_cs()`, followed by a call to
        `load_commands()`.

        The `timeout` argument specifies the number of milliseconds
        &#34;&#34;&#34;

        super().__init__(endpoint, timeout)

        self._commands = {}

        if self.ping():
            self.load_commands()
        else:
            self._logger.warning(
                f&#34;{self.__class__.__name__} could not connect to its control server at {endpoint}. &#34;
                f&#34;No commands have been loaded.&#34;
            )

    def __enter__(self):
        if not self.ping():
            raise ConnectionError(&#34;Proxy is not connected when entering the context.&#34;)

        # The following check is here because a CS might have come alive between the __init__
        # and __enter__ calls, and while the ping() will reconnect, the Proxy will have no
        # commands loaded.

        if not self.has_commands():
            self.load_commands()

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if not self._socket.closed:
            self.disconnect_cs()

    def connect_cs(self):
        self._logger.log(0, f&#34;Trying to connect {self.__class__.__name__} to {self._endpoint}&#34;)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def disconnect_cs(self):
        self._socket.setsockopt(zmq.LINGER, 0)
        self._socket.close()
        self._poller.unregister(self._socket)

    def reconnect_cs(self):
        self._logger.log(20, f&#34;Trying to reconnect {self.__class__.__name__} to {self._endpoint}&#34;)

        if not self._socket.closed:
            self._socket.close(linger=0)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def reset_cs_connection(self):
        self._logger.log(
            10, f&#34;Trying to reset the connection from {self.__class__.__name__} to {self._endpoint}&#34;
        )

        self.disconnect_cs()
        self.connect_cs()

    def is_cs_connected(self) -&gt; bool:
        return self.ping()

    def send(self, data, retries: int = REQUEST_RETRIES, timeout: int = None):
        &#34;&#34;&#34;
        Sends a command to the control server and waits for a response.

        When not connected to the control server or when a timeout occurs, the
        ``send()`` command retries a number of times to send the command.

        The number of retries is hardcoded and currently set to &#39;2&#39;, the request
        timeout is set to 2.5 seconds.

        The command data will be pickled before sending. Make sure the ``data``
        argument can be dumped by pickle.

        Args:
            data (str): the command that is sent to the control server, usually a
                string, but that is not enforced.
            timeout (int): the time to wait for a reply [in milliseconds]
            retries (int): the number of time we should retry to send the message

        Returns:
            response: the response from the control server or ``None`` when there was
                a problem or a timeout.
        &#34;&#34;&#34;
        timeout = timeout or self._timeout

        pickle_string = pickle.dumps(data)

        retries_left = retries

        # When we enter this method, we assume the Proxy has been connected. It
        # might be the server is not responding, but that is handled by the
        # algorithm below where we have a number of retries to receive the response
        # of the sent command. Remember that we are using ZeroMQ where the connect
        # method returns gracefully even when no server is available.

        if self._socket.closed:
            self.reconnect_cs()

        self._logger.log(0, f&#34;Sending &#39;{data}&#39;&#34;)
        self._socket.send(pickle_string)

        while True:
            socks = dict(self._poller.poll(timeout))

            if self._socket in socks and socks[self._socket] == zmq.POLLIN:
                pickle_string = self._socket.recv()
                if not pickle_string:
                    break
                response = pickle.loads(pickle_string)
                self._logger.log(0, f&#34;Receiving response: {response}&#34;)
                return response
            else:
                # timeout - server unavailable

                # We should disconnect here because socket is possibly confused.
                # Close the socket and remove from the poller.

                self.disconnect_cs()

                if retries_left == 0:
                    self._logger.critical(f&#34;Control Server seems to be off-line, abandoning ({data})&#34;)
                    return None
                retries_left -= 1

                self._logger.log(logging.CRITICAL, f&#34;Reconnecting {self.__class__.__name__}, {retries_left=}&#34;)

                self.reconnect_cs()

                # Now try to send the request again

                self._socket.send(pickle_string)

    def _request_commands(self):
        self._commands = self.send(&#34;send_commands&#34;)

    def _add_commands(self):
        for key in self._commands:
            if hasattr(self, key):
                attribute = getattr(self, key)
                if isinstance(attribute, types.MethodType) and not hasattr(
                    attribute, &#34;__dynamic_interface&#34;
                ):
                    self._logger.warning(
                        f&#34;{self.__class__.__name__} already has an attribute &#39;{key}&#39;, &#34;
                        f&#34;not overwriting.&#34;
                    )
                    continue
            command = self._commands[key]
            new_method = MethodType(command.client_call, self)
            new_method = set_docstring(new_method, command)
            setattr(self, key, new_method)

    def get_service_proxy(self):
        &#34;&#34;&#34;Return a ServiceProxy for the control server of this proxy object.&#34;&#34;&#34;
        from egse.services import ServiceProxy  # prevent circular import problem

        transport, address, _ = split_address(self._endpoint)

        port = self.send(&#34;get_service_port&#34;)

        return ServiceProxy(
            AttributeDict({&#34;PROTOCOL&#34;: transport, &#34;HOSTNAME&#34;: address, &#34;SERVICE_PORT&#34;: port})
        )

    def load_commands(self):
        &#34;&#34;&#34;
        Requests all available commands from the control server and adds them to
        the Proxy public interface, i.e. each command will become a method for
        this Proxy.

        A warning will be issued when a command will overwrite an existing method
        of the Proxy class. The original method will not be overwritten and the
        behavior of the Proxy command will not be what is expected.
        &#34;&#34;&#34;
        # bind the client_call method from each Command to this Proxy object
        # TODO(rik): what will happen when the _request_commands() fails?
        if self.is_cs_connected():
            self._request_commands()
            self._add_commands()
            return True
        else:
            self._logger.warning(f&#34;{self.__class__.__name__} is not connected, try to reconnect.&#34;)
            return False

    def get_commands(self):
        &#34;&#34;&#34;
        Returns a list of command names that can be send to the device or the
        control server.

        The commands are defined in the YAML settings file of the device.
        Special commands are available for the ServiceProxy which configure and
        control the control servers.
        &#34;&#34;&#34;
        return list(self._commands.keys())

    def has_commands(self):
        &#34;&#34;&#34;Return `True` if commands have been loaded.&#34;&#34;&#34;
        return bool(self._commands)

    def ping(self):
        return_code = self.send(&#34;Ping&#34;, retries=0, timeout=1000)
        self._logger.log(0, f&#34;Check if control server is available: Ping - {return_code}&#34;)
        return return_code == &#34;Pong&#34;

    def get_endpoint(self):
        &#34;&#34;&#34; Returns the endpoint.

        Returns:
            - Endpoint.
        &#34;&#34;&#34;

        return self._endpoint

    def get_monitoring_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the monitoring port. &#34;&#34;&#34;

        return self.send(&#34;get_monitoring_port&#34;)

    def get_commanding_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the commanding port.&#34;&#34;&#34;

        return self.send(&#34;get_commanding_port&#34;)

    def get_service_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the service port. &#34;&#34;&#34;

        return self.send(&#34;get_service_port&#34;)

    def get_ip_address(self) -&gt; int:
        &#34;&#34;&#34; Returns the hostname of the control server.&#34;&#34;&#34;

        return self.send(&#34;get_ip_address&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.proxy.set_docstring"><code class="name flex">
<span>def <span class="ident">set_docstring</span></span>(<span>func, cmd)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to set the docstring of the command on the dynamic method / function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_docstring(func, cmd):
    &#34;&#34;&#34;Decorator to set the docstring of the command on the dynamic method / function.&#34;&#34;&#34;

    def wrap_func(*args, **kwargs):
        return func(*args, **kwargs)

    wrap_func.__doc__ = cmd.__doc__
    wrap_func.__name__ = f&#34;{cmd.get_name()}&#34;
    return wrap_func</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.proxy.BaseProxy"><code class="flex name class">
<span>class <span class="ident">BaseProxy</span></span>
<span>(</span><span>endpoint, timeout: int = 6250)</span>
</code></dt>
<dd>
<div class="desc"><p>This interface defines the connection commands for control servers.</p>
<p>This interface shall be implemented by the Proxy class and guarantees that connection commands
do not interfere with the commands defined in the <code>DeviceConnectionInterface</code> (which will be
loaded from the control server).</p>
<p>The <code>timeout</code> argument specifies the number of milliseconds to wait for a reply from the
control server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProxy(ControlServerConnectionInterface):
    def __init__(self, endpoint, timeout: int = REQUEST_TIMEOUT):
        &#34;&#34;&#34;
        The `timeout` argument specifies the number of milliseconds to wait for a reply from the
        control server.
        &#34;&#34;&#34;

        self._logger = logging.getLogger(self.__class__.__name__)

        self._ctx = zmq.Context.instance()
        self._poller = zmq.Poller()
        self._socket = None
        self._endpoint = endpoint
        self._timeout = timeout

        self.connect_cs()

    def __enter__(self):
        if not self.ping():
            raise ConnectionError(&#34;Proxy is not connected when entering the context.&#34;)

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if not self._socket.closed:
            self.disconnect_cs()

    def connect_cs(self):
        self._logger.log(0, f&#34;Trying to connect {self.__class__.__name__} to {self._endpoint}&#34;)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def disconnect_cs(self):
        self._socket.setsockopt(zmq.LINGER, 0)
        self._socket.close()
        self._poller.unregister(self._socket)

    def reconnect_cs(self):
        self._logger.log(20, f&#34;Trying to reconnect {self.__class__.__name__} to {self._endpoint}&#34;)

        if not self._socket.closed:
            self._socket.close(linger=0)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def reset_cs_connection(self):
        self._logger.log(
            10, f&#34;Trying to reset the connection from {self.__class__.__name__} to {self._endpoint}&#34;
        )

        self.disconnect_cs()
        self.connect_cs()

    def is_cs_connected(self) -&gt; bool:
        return self.ping()

    def send(self, data, retries: int = REQUEST_RETRIES, timeout: int = None):
        &#34;&#34;&#34;
        Sends a command to the control server and waits for a response.

        When not connected to the control server or when a timeout occurs, the
        ``send()`` command retries a number of times to send the command.

        The number of retries is hardcoded and currently set to &#39;2&#39;, the request
        timeout is set to 2.5 seconds.

        The command data will be pickled before sending. Make sure the ``data``
        argument can be dumped by pickle.

        Args:
            data (str): the command that is sent to the control server, usually a
                string, but that is not enforced.
            timeout (int): the time to wait for a reply [in milliseconds]
            retries (int): the number of time we should retry to send the message

        Returns:
            response: the response from the control server or ``None`` when there was
                a problem or a timeout.
        &#34;&#34;&#34;
        timeout = timeout or self._timeout

        pickle_string = pickle.dumps(data)

        retries_left = retries

        # When we enter this method, we assume the Proxy has been connected. It
        # might be the server is not responding, but that is handled by the
        # algorithm below where we have a number of retries to receive the response
        # of the sent command. Remember that we are using ZeroMQ where the connect
        # method returns gracefully even when no server is available.

        if self._socket.closed:
            self.reconnect_cs()

        self._logger.log(0, f&#34;Sending &#39;{data}&#39;&#34;)
        self._socket.send(pickle_string)

        while True:
            socks = dict(self._poller.poll(timeout))

            if self._socket in socks and socks[self._socket] == zmq.POLLIN:
                pickle_string = self._socket.recv()
                if not pickle_string:
                    break
                response = pickle.loads(pickle_string)
                self._logger.log(0, f&#34;Receiving response: {response}&#34;)
                return response
            else:
                # timeout - server unavailable

                # We should disconnect here because socket is possibly confused.
                # Close the socket and remove from the poller.

                self.disconnect_cs()

                if retries_left == 0:
                    self._logger.critical(&#34;Control Server seems to be off-line, abandoning&#34;)
                    return None
                retries_left -= 1

                self._logger.log(logging.CRITICAL, f&#34;Reconnecting {self.__class__.__name__}, {retries_left=}&#34;)

                self.reconnect_cs()

                # Now try to send the request again

                self._socket.send(pickle_string)

    def ping(self):
        return_code = self.send(&#34;Ping&#34;, retries=0, timeout=1000)
        self._logger.log(0, f&#34;Check if control server is available: Ping - {return_code}&#34;)
        return return_code == &#34;Pong&#34;

    def get_endpoint(self):
        &#34;&#34;&#34; Returns the endpoint.&#34;&#34;&#34;
        return self._endpoint

    def get_monitoring_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the monitoring port. &#34;&#34;&#34;
        return self.send(&#34;get_monitoring_port&#34;)

    def get_commanding_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the commanding port.&#34;&#34;&#34;
        return self.send(&#34;get_commanding_port&#34;)

    def get_service_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the service port. &#34;&#34;&#34;
        return self.send(&#34;get_service_port&#34;)

    def get_ip_address(self) -&gt; int:
        &#34;&#34;&#34; Returns the hostname of the control server.&#34;&#34;&#34;
        return self.send(&#34;get_ip_address&#34;)

    def get_service_proxy(self):
        &#34;&#34;&#34;Return a ServiceProxy for the control server of this proxy object.&#34;&#34;&#34;
        from egse.services import ServiceProxy  # prevent circular import problem

        transport, address, _ = split_address(self._endpoint)

        port = self.send(&#34;get_service_port&#34;)

        return ServiceProxy(
            AttributeDict({&#34;PROTOCOL&#34;: transport, &#34;HOSTNAME&#34;: address, &#34;SERVICE_PORT&#34;: port})
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.ControlServerConnectionInterface" href="#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.proxy.DynamicProxy" href="#egse.proxy.DynamicProxy">DynamicProxy</a></li>
<li><a title="egse.proxy.Proxy" href="#egse.proxy.Proxy">Proxy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.proxy.BaseProxy.get_commanding_port"><code class="name flex">
<span>def <span class="ident">get_commanding_port</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the commanding port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_commanding_port(self) -&gt; int:
    &#34;&#34;&#34; Returns the commanding port.&#34;&#34;&#34;
    return self.send(&#34;get_commanding_port&#34;)</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.get_endpoint"><code class="name flex">
<span>def <span class="ident">get_endpoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the endpoint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_endpoint(self):
    &#34;&#34;&#34; Returns the endpoint.&#34;&#34;&#34;
    return self._endpoint</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.get_ip_address"><code class="name flex">
<span>def <span class="ident">get_ip_address</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the hostname of the control server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_address(self) -&gt; int:
    &#34;&#34;&#34; Returns the hostname of the control server.&#34;&#34;&#34;
    return self.send(&#34;get_ip_address&#34;)</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.get_monitoring_port"><code class="name flex">
<span>def <span class="ident">get_monitoring_port</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the monitoring port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_monitoring_port(self) -&gt; int:
    &#34;&#34;&#34; Returns the monitoring port. &#34;&#34;&#34;
    return self.send(&#34;get_monitoring_port&#34;)</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.get_service_port"><code class="name flex">
<span>def <span class="ident">get_service_port</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the service port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_service_port(self) -&gt; int:
    &#34;&#34;&#34; Returns the service port. &#34;&#34;&#34;
    return self.send(&#34;get_service_port&#34;)</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.get_service_proxy"><code class="name flex">
<span>def <span class="ident">get_service_proxy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a ServiceProxy for the control server of this proxy object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_service_proxy(self):
    &#34;&#34;&#34;Return a ServiceProxy for the control server of this proxy object.&#34;&#34;&#34;
    from egse.services import ServiceProxy  # prevent circular import problem

    transport, address, _ = split_address(self._endpoint)

    port = self.send(&#34;get_service_port&#34;)

    return ServiceProxy(
        AttributeDict({&#34;PROTOCOL&#34;: transport, &#34;HOSTNAME&#34;: address, &#34;SERVICE_PORT&#34;: port})
    )</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self):
    return_code = self.send(&#34;Ping&#34;, retries=0, timeout=1000)
    self._logger.log(0, f&#34;Check if control server is available: Ping - {return_code}&#34;)
    return return_code == &#34;Pong&#34;</code></pre>
</details>
</dd>
<dt id="egse.proxy.BaseProxy.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, data, retries: int = 0, timeout: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a command to the control server and waits for a response.</p>
<p>When not connected to the control server or when a timeout occurs, the
<code>send()</code> command retries a number of times to send the command.</p>
<p>The number of retries is hardcoded and currently set to '2', the request
timeout is set to 2.5 seconds.</p>
<p>The command data will be pickled before sending. Make sure the <code>data</code>
argument can be dumped by pickle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>the command that is sent to the control server, usually a
string, but that is not enforced.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>the time to wait for a reply [in milliseconds]</dd>
<dt><strong><code>retries</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of time we should retry to send the message</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>the response from the control server or <code>None</code> when there was
a problem or a timeout.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, data, retries: int = REQUEST_RETRIES, timeout: int = None):
    &#34;&#34;&#34;
    Sends a command to the control server and waits for a response.

    When not connected to the control server or when a timeout occurs, the
    ``send()`` command retries a number of times to send the command.

    The number of retries is hardcoded and currently set to &#39;2&#39;, the request
    timeout is set to 2.5 seconds.

    The command data will be pickled before sending. Make sure the ``data``
    argument can be dumped by pickle.

    Args:
        data (str): the command that is sent to the control server, usually a
            string, but that is not enforced.
        timeout (int): the time to wait for a reply [in milliseconds]
        retries (int): the number of time we should retry to send the message

    Returns:
        response: the response from the control server or ``None`` when there was
            a problem or a timeout.
    &#34;&#34;&#34;
    timeout = timeout or self._timeout

    pickle_string = pickle.dumps(data)

    retries_left = retries

    # When we enter this method, we assume the Proxy has been connected. It
    # might be the server is not responding, but that is handled by the
    # algorithm below where we have a number of retries to receive the response
    # of the sent command. Remember that we are using ZeroMQ where the connect
    # method returns gracefully even when no server is available.

    if self._socket.closed:
        self.reconnect_cs()

    self._logger.log(0, f&#34;Sending &#39;{data}&#39;&#34;)
    self._socket.send(pickle_string)

    while True:
        socks = dict(self._poller.poll(timeout))

        if self._socket in socks and socks[self._socket] == zmq.POLLIN:
            pickle_string = self._socket.recv()
            if not pickle_string:
                break
            response = pickle.loads(pickle_string)
            self._logger.log(0, f&#34;Receiving response: {response}&#34;)
            return response
        else:
            # timeout - server unavailable

            # We should disconnect here because socket is possibly confused.
            # Close the socket and remove from the poller.

            self.disconnect_cs()

            if retries_left == 0:
                self._logger.critical(&#34;Control Server seems to be off-line, abandoning&#34;)
                return None
            retries_left -= 1

            self._logger.log(logging.CRITICAL, f&#34;Reconnecting {self.__class__.__name__}, {retries_left=}&#34;)

            self.reconnect_cs()

            # Now try to send the request again

            self._socket.send(pickle_string)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.ControlServerConnectionInterface" href="#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.ControlServerConnectionInterface.connect_cs" href="#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.disconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.is_cs_connected" href="#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.reconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.reset_cs_connection" href="#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.proxy.ControlServerConnectionInterface"><code class="flex name class">
<span>class <span class="ident">ControlServerConnectionInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>This interface defines the connection commands for control servers.</p>
<p>This interface shall be implemented by the Proxy class and guarantees that connection commands
do not interfere with the commands defined in the <code>DeviceConnectionInterface</code> (which will be
loaded from the control server).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControlServerConnectionInterface:
    &#34;&#34;&#34;This interface defines the connection commands for control servers.

    This interface shall be implemented by the Proxy class and guarantees that connection commands
    do not interfere with the commands defined in the `DeviceConnectionInterface` (which will be
    loaded from the control server).
    &#34;&#34;&#34;

    def __enter__(self):
        self.connect_cs()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.disconnect_cs()

    @dynamic_interface
    def connect_cs(self):
        &#34;&#34;&#34;Connect to the control server.

        Raises:
            ConnectionError: when the connection can not be established.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def reconnect_cs(self):
        &#34;&#34;&#34;Reconnect the control server after it has been disconnected.

        Raises:
            ConnectionError: when the connection can not be established.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def disconnect_cs(self):
        &#34;&#34;&#34;Disconnect from the control server.

        Raises:
            ConnectionError: when the connection can not be closed.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def reset_cs_connection(self):
        &#34;&#34;&#34;Resets the connection to the control server.&#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def is_cs_connected(self) -&gt; bool:
        &#34;&#34;&#34;Check if the control server is connected.

        Returns:
            True if the device is connected and responds to a command, False otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.proxy.BaseProxy" href="#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.Proxy" href="#egse.proxy.Proxy">Proxy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.proxy.ControlServerConnectionInterface.connect_cs"><code class="name flex">
<span>def <span class="ident">connect_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the control server.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionError</code></dt>
<dd>when the connection can not be established.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def connect_cs(self):
    &#34;&#34;&#34;Connect to the control server.

    Raises:
        ConnectionError: when the connection can not be established.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.proxy.ControlServerConnectionInterface.disconnect_cs"><code class="name flex">
<span>def <span class="ident">disconnect_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect from the control server.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionError</code></dt>
<dd>when the connection can not be closed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def disconnect_cs(self):
    &#34;&#34;&#34;Disconnect from the control server.

    Raises:
        ConnectionError: when the connection can not be closed.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.proxy.ControlServerConnectionInterface.is_cs_connected"><code class="name flex">
<span>def <span class="ident">is_cs_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the control server is connected.</p>
<h2 id="returns">Returns</h2>
<p>True if the device is connected and responds to a command, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def is_cs_connected(self) -&gt; bool:
    &#34;&#34;&#34;Check if the control server is connected.

    Returns:
        True if the device is connected and responds to a command, False otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.proxy.ControlServerConnectionInterface.reconnect_cs"><code class="name flex">
<span>def <span class="ident">reconnect_cs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconnect the control server after it has been disconnected.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ConnectionError</code></dt>
<dd>when the connection can not be established.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def reconnect_cs(self):
    &#34;&#34;&#34;Reconnect the control server after it has been disconnected.

    Raises:
        ConnectionError: when the connection can not be established.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.proxy.ControlServerConnectionInterface.reset_cs_connection"><code class="name flex">
<span>def <span class="ident">reset_cs_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the connection to the control server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def reset_cs_connection(self):
    &#34;&#34;&#34;Resets the connection to the control server.&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.proxy.DynamicProxy"><code class="flex name class">
<span>class <span class="ident">DynamicProxy</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This interface defines the connection commands for control servers.</p>
<p>This interface shall be implemented by the Proxy class and guarantees that connection commands
do not interfere with the commands defined in the <code>DeviceConnectionInterface</code> (which will be
loaded from the control server).</p>
<p>The <code>timeout</code> argument specifies the number of milliseconds to wait for a reply from the
control server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicProxy(BaseProxy, DynamicClientCommandMixin):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.BaseProxy" href="#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li>egse.mixin.DynamicClientCommandMixin</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.collimator.fcul.ogse.OGSEProxy" href="collimator/fcul/ogse.html#egse.collimator.fcul.ogse.OGSEProxy">OGSEProxy</a></li>
<li><a title="egse.tcs.tcs.TCSProxy" href="tcs/tcs.html#egse.tcs.tcs.TCSProxy">TCSProxy</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.BaseProxy" href="#egse.proxy.BaseProxy">BaseProxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.BaseProxy.connect_cs" href="#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.disconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_commanding_port" href="#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_endpoint" href="#egse.proxy.BaseProxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_ip_address" href="#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_monitoring_port" href="#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_service_port" href="#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_service_proxy" href="#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.is_cs_connected" href="#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.reconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.reset_cs_connection" href="#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.send" href="#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.proxy.Proxy"><code class="flex name class">
<span>class <span class="ident">Proxy</span></span>
<span>(</span><span>endpoint, timeout: int = 6250)</span>
</code></dt>
<dd>
<div class="desc"><p>A Proxy object will forward CommandExecutions to the connected control server
and wait for a response. When the Proxy can not connect to its control server
during initialization, a ConnectionError will be raised.</p>
<p>During initialization, the Proxy will connect to the control server and send a
handshaking <code>Ping</code> command. When that succeeds the Proxy will request and load the
available commands from the control server. When the connection with the control server
fails, no commands are loaded and the Proxy is left in a 'disconnected' state. The caller
can fix the problem with the control server and call <code>connect_cs()</code>, followed by a call to
<code>load_commands()</code>.</p>
<p>The <code>timeout</code> argument specifies the number of milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Proxy(BaseProxy, ControlServerConnectionInterface):
    &#34;&#34;&#34;
    A Proxy object will forward CommandExecutions to the connected control server
    and wait for a response. When the Proxy can not connect to its control server
    during initialization, a ConnectionError will be raised.
    &#34;&#34;&#34;

    def __init__(self, endpoint, timeout: int = REQUEST_TIMEOUT):
        &#34;&#34;&#34;
        During initialization, the Proxy will connect to the control server and send a
        handshaking `Ping` command. When that succeeds the Proxy will request and load the
        available commands from the control server. When the connection with the control server
        fails, no commands are loaded and the Proxy is left in a &#39;disconnected&#39; state. The caller
        can fix the problem with the control server and call `connect_cs()`, followed by a call to
        `load_commands()`.

        The `timeout` argument specifies the number of milliseconds
        &#34;&#34;&#34;

        super().__init__(endpoint, timeout)

        self._commands = {}

        if self.ping():
            self.load_commands()
        else:
            self._logger.warning(
                f&#34;{self.__class__.__name__} could not connect to its control server at {endpoint}. &#34;
                f&#34;No commands have been loaded.&#34;
            )

    def __enter__(self):
        if not self.ping():
            raise ConnectionError(&#34;Proxy is not connected when entering the context.&#34;)

        # The following check is here because a CS might have come alive between the __init__
        # and __enter__ calls, and while the ping() will reconnect, the Proxy will have no
        # commands loaded.

        if not self.has_commands():
            self.load_commands()

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if not self._socket.closed:
            self.disconnect_cs()

    def connect_cs(self):
        self._logger.log(0, f&#34;Trying to connect {self.__class__.__name__} to {self._endpoint}&#34;)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def disconnect_cs(self):
        self._socket.setsockopt(zmq.LINGER, 0)
        self._socket.close()
        self._poller.unregister(self._socket)

    def reconnect_cs(self):
        self._logger.log(20, f&#34;Trying to reconnect {self.__class__.__name__} to {self._endpoint}&#34;)

        if not self._socket.closed:
            self._socket.close(linger=0)

        self._socket = self._ctx.socket(zmq.REQ)
        self._socket.connect(self._endpoint)
        self._poller.register(self._socket, zmq.POLLIN)

    def reset_cs_connection(self):
        self._logger.log(
            10, f&#34;Trying to reset the connection from {self.__class__.__name__} to {self._endpoint}&#34;
        )

        self.disconnect_cs()
        self.connect_cs()

    def is_cs_connected(self) -&gt; bool:
        return self.ping()

    def send(self, data, retries: int = REQUEST_RETRIES, timeout: int = None):
        &#34;&#34;&#34;
        Sends a command to the control server and waits for a response.

        When not connected to the control server or when a timeout occurs, the
        ``send()`` command retries a number of times to send the command.

        The number of retries is hardcoded and currently set to &#39;2&#39;, the request
        timeout is set to 2.5 seconds.

        The command data will be pickled before sending. Make sure the ``data``
        argument can be dumped by pickle.

        Args:
            data (str): the command that is sent to the control server, usually a
                string, but that is not enforced.
            timeout (int): the time to wait for a reply [in milliseconds]
            retries (int): the number of time we should retry to send the message

        Returns:
            response: the response from the control server or ``None`` when there was
                a problem or a timeout.
        &#34;&#34;&#34;
        timeout = timeout or self._timeout

        pickle_string = pickle.dumps(data)

        retries_left = retries

        # When we enter this method, we assume the Proxy has been connected. It
        # might be the server is not responding, but that is handled by the
        # algorithm below where we have a number of retries to receive the response
        # of the sent command. Remember that we are using ZeroMQ where the connect
        # method returns gracefully even when no server is available.

        if self._socket.closed:
            self.reconnect_cs()

        self._logger.log(0, f&#34;Sending &#39;{data}&#39;&#34;)
        self._socket.send(pickle_string)

        while True:
            socks = dict(self._poller.poll(timeout))

            if self._socket in socks and socks[self._socket] == zmq.POLLIN:
                pickle_string = self._socket.recv()
                if not pickle_string:
                    break
                response = pickle.loads(pickle_string)
                self._logger.log(0, f&#34;Receiving response: {response}&#34;)
                return response
            else:
                # timeout - server unavailable

                # We should disconnect here because socket is possibly confused.
                # Close the socket and remove from the poller.

                self.disconnect_cs()

                if retries_left == 0:
                    self._logger.critical(f&#34;Control Server seems to be off-line, abandoning ({data})&#34;)
                    return None
                retries_left -= 1

                self._logger.log(logging.CRITICAL, f&#34;Reconnecting {self.__class__.__name__}, {retries_left=}&#34;)

                self.reconnect_cs()

                # Now try to send the request again

                self._socket.send(pickle_string)

    def _request_commands(self):
        self._commands = self.send(&#34;send_commands&#34;)

    def _add_commands(self):
        for key in self._commands:
            if hasattr(self, key):
                attribute = getattr(self, key)
                if isinstance(attribute, types.MethodType) and not hasattr(
                    attribute, &#34;__dynamic_interface&#34;
                ):
                    self._logger.warning(
                        f&#34;{self.__class__.__name__} already has an attribute &#39;{key}&#39;, &#34;
                        f&#34;not overwriting.&#34;
                    )
                    continue
            command = self._commands[key]
            new_method = MethodType(command.client_call, self)
            new_method = set_docstring(new_method, command)
            setattr(self, key, new_method)

    def get_service_proxy(self):
        &#34;&#34;&#34;Return a ServiceProxy for the control server of this proxy object.&#34;&#34;&#34;
        from egse.services import ServiceProxy  # prevent circular import problem

        transport, address, _ = split_address(self._endpoint)

        port = self.send(&#34;get_service_port&#34;)

        return ServiceProxy(
            AttributeDict({&#34;PROTOCOL&#34;: transport, &#34;HOSTNAME&#34;: address, &#34;SERVICE_PORT&#34;: port})
        )

    def load_commands(self):
        &#34;&#34;&#34;
        Requests all available commands from the control server and adds them to
        the Proxy public interface, i.e. each command will become a method for
        this Proxy.

        A warning will be issued when a command will overwrite an existing method
        of the Proxy class. The original method will not be overwritten and the
        behavior of the Proxy command will not be what is expected.
        &#34;&#34;&#34;
        # bind the client_call method from each Command to this Proxy object
        # TODO(rik): what will happen when the _request_commands() fails?
        if self.is_cs_connected():
            self._request_commands()
            self._add_commands()
            return True
        else:
            self._logger.warning(f&#34;{self.__class__.__name__} is not connected, try to reconnect.&#34;)
            return False

    def get_commands(self):
        &#34;&#34;&#34;
        Returns a list of command names that can be send to the device or the
        control server.

        The commands are defined in the YAML settings file of the device.
        Special commands are available for the ServiceProxy which configure and
        control the control servers.
        &#34;&#34;&#34;
        return list(self._commands.keys())

    def has_commands(self):
        &#34;&#34;&#34;Return `True` if commands have been loaded.&#34;&#34;&#34;
        return bool(self._commands)

    def ping(self):
        return_code = self.send(&#34;Ping&#34;, retries=0, timeout=1000)
        self._logger.log(0, f&#34;Check if control server is available: Ping - {return_code}&#34;)
        return return_code == &#34;Pong&#34;

    def get_endpoint(self):
        &#34;&#34;&#34; Returns the endpoint.

        Returns:
            - Endpoint.
        &#34;&#34;&#34;

        return self._endpoint

    def get_monitoring_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the monitoring port. &#34;&#34;&#34;

        return self.send(&#34;get_monitoring_port&#34;)

    def get_commanding_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the commanding port.&#34;&#34;&#34;

        return self.send(&#34;get_commanding_port&#34;)

    def get_service_port(self) -&gt; int:
        &#34;&#34;&#34; Returns the service port. &#34;&#34;&#34;

        return self.send(&#34;get_service_port&#34;)

    def get_ip_address(self) -&gt; int:
        &#34;&#34;&#34; Returns the hostname of the control server.&#34;&#34;&#34;

        return self.send(&#34;get_ip_address&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.BaseProxy" href="#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu.AWGProxy" href="aeu/aeu.html#egse.aeu.aeu.AWGProxy">AWGProxy</a></li>
<li><a title="egse.aeu.aeu.CRIOProxy" href="aeu/aeu.html#egse.aeu.aeu.CRIOProxy">CRIOProxy</a></li>
<li><a title="egse.aeu.aeu.PSUProxy" href="aeu/aeu.html#egse.aeu.aeu.PSUProxy">PSUProxy</a></li>
<li><a title="egse.confman.ConfigurationManagerProxy" href="confman/index.html#egse.confman.ConfigurationManagerProxy">ConfigurationManagerProxy</a></li>
<li><a title="egse.dpu.DPUProxy" href="dpu/index.html#egse.dpu.DPUProxy">DPUProxy</a></li>
<li><a title="egse.dummy.DummyProxy" href="dummy.html#egse.dummy.DummyProxy">DummyProxy</a></li>
<li><a title="egse.fdir.fdir_manager.FdirManagerProxy" href="fdir/fdir_manager.html#egse.fdir.fdir_manager.FdirManagerProxy">FdirManagerProxy</a></li>
<li><a title="egse.fdir.fdir_remote.FdirRemoteProxy" href="fdir/fdir_remote.html#egse.fdir.fdir_remote.FdirRemoteProxy">FdirRemoteProxy</a></li>
<li><a title="egse.fdir.gsm.beaglebone.BeagleboneProxy" href="fdir/gsm/beaglebone.html#egse.fdir.gsm.beaglebone.BeagleboneProxy">BeagleboneProxy</a></li>
<li><a title="egse.filterwheel.eksma.fw8smc4.FilterWheel8SMC4Proxy" href="filterwheel/eksma/fw8smc4.html#egse.filterwheel.eksma.fw8smc4.FilterWheel8SMC4Proxy">FilterWheel8SMC4Proxy</a></li>
<li><a title="egse.filterwheel.eksma.fw8smc5.Fw8Smc5Proxy" href="filterwheel/eksma/fw8smc5.html#egse.filterwheel.eksma.fw8smc5.Fw8Smc5Proxy">Fw8Smc5Proxy</a></li>
<li><a title="egse.hexapod.symetrie.puna.PunaProxy" href="hexapod/symetrie/puna.html#egse.hexapod.symetrie.puna.PunaProxy">PunaProxy</a></li>
<li><a title="egse.hexapod.symetrie.zonda.ZondaProxy" href="hexapod/symetrie/zonda.html#egse.hexapod.symetrie.zonda.ZondaProxy">ZondaProxy</a></li>
<li><a title="egse.lampcontrol.beaglebone.beaglebone.BeagleboneProxy" href="lampcontrol/beaglebone/beaglebone.html#egse.lampcontrol.beaglebone.beaglebone.BeagleboneProxy">BeagleboneProxy</a></li>
<li><a title="egse.lampcontrol.energetiq.lampEQ99.LampEQ99Proxy" href="lampcontrol/energetiq/lampEQ99.html#egse.lampcontrol.energetiq.lampEQ99.LampEQ99Proxy">LampEQ99Proxy</a></li>
<li><a title="egse.powermeter.ni.cdaq9184.cdaq9184Proxy" href="powermeter/ni/cdaq9184.html#egse.powermeter.ni.cdaq9184.cdaq9184Proxy">cdaq9184Proxy</a></li>
<li><a title="egse.powermeter.thorlabs.pm100a.ThorlabsPM100Proxy" href="powermeter/thorlabs/pm100a.html#egse.powermeter.thorlabs.pm100a.ThorlabsPM100Proxy">ThorlabsPM100Proxy</a></li>
<li><a title="egse.procman.ProcessManagerProxy" href="procman/index.html#egse.procman.ProcessManagerProxy">ProcessManagerProxy</a></li>
<li><a title="egse.services.ServiceProxy" href="services.html#egse.services.ServiceProxy">ServiceProxy</a></li>
<li><a title="egse.shutter.thorlabs.ksc101.ShutterKSC101Proxy" href="shutter/thorlabs/ksc101.html#egse.shutter.thorlabs.ksc101.ShutterKSC101Proxy">ShutterKSC101Proxy</a></li>
<li><a title="egse.shutter.thorlabs.sc10.Sc10Proxy" href="shutter/thorlabs/sc10.html#egse.shutter.thorlabs.sc10.Sc10Proxy">Sc10Proxy</a></li>
<li><a title="egse.stages.aerotech.ensemble.EnsembleProxy" href="stages/aerotech/ensemble.html#egse.stages.aerotech.ensemble.EnsembleProxy">EnsembleProxy</a></li>
<li><a title="egse.stages.arun.smd3.Smd3Proxy" href="stages/arun/smd3.html#egse.stages.arun.smd3.Smd3Proxy">Smd3Proxy</a></li>
<li><a title="egse.stages.huber.smc9300.HuberSMC9300Proxy" href="stages/huber/smc9300.html#egse.stages.huber.smc9300.HuberSMC9300Proxy">HuberSMC9300Proxy</a></li>
<li><a title="egse.storage.StorageProxy" href="storage/index.html#egse.storage.StorageProxy">StorageProxy</a></li>
<li><a title="egse.synoptics.SynopticsManagerProxy" href="synoptics/index.html#egse.synoptics.SynopticsManagerProxy">SynopticsManagerProxy</a></li>
<li><a title="egse.tempcontrol.agilent.agilent34970.Agilent34970Proxy" href="tempcontrol/agilent/agilent34970.html#egse.tempcontrol.agilent.agilent34970.Agilent34970Proxy">Agilent34970Proxy</a></li>
<li><a title="egse.tempcontrol.agilent.agilent34972.Agilent34972Proxy" href="tempcontrol/agilent/agilent34972.html#egse.tempcontrol.agilent.agilent34972.Agilent34972Proxy">Agilent34972Proxy</a></li>
<li><a title="egse.tempcontrol.beaglebone.beaglebone.BeagleboneProxy" href="tempcontrol/beaglebone/beaglebone.html#egse.tempcontrol.beaglebone.beaglebone.BeagleboneProxy">BeagleboneProxy</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510.DAQ6510Proxy" href="tempcontrol/keithley/daq6510.html#egse.tempcontrol.keithley.daq6510.DAQ6510Proxy">DAQ6510Proxy</a></li>
<li><a title="egse.tempcontrol.lakeshore.lsci336.LakeShore336Proxy" href="tempcontrol/lakeshore/lsci336.html#egse.tempcontrol.lakeshore.lsci336.LakeShore336Proxy">LakeShore336Proxy</a></li>
<li><a title="egse.tempcontrol.spid.spid.PidProxy" href="tempcontrol/spid/spid.html#egse.tempcontrol.spid.spid.PidProxy">PidProxy</a></li>
<li><a title="egse.tempcontrol.srs.ptc10.ptc10Proxy" href="tempcontrol/srs/ptc10.html#egse.tempcontrol.srs.ptc10.ptc10Proxy">ptc10Proxy</a></li>
<li><a title="egse.ups.apc.apc.APCProxy" href="ups/apc/apc.html#egse.ups.apc.apc.APCProxy">APCProxy</a></li>
<li><a title="egse.vacuum.beaglebone.beaglebone.BeagleboneProxy" href="vacuum/beaglebone/beaglebone.html#egse.vacuum.beaglebone.beaglebone.BeagleboneProxy">BeagleboneProxy</a></li>
<li><a title="egse.vacuum.instrutech.igm402.Igm402Proxy" href="vacuum/instrutech/igm402.html#egse.vacuum.instrutech.igm402.Igm402Proxy">Igm402Proxy</a></li>
<li><a title="egse.vacuum.mks.vacscan.VacscanProxy" href="vacuum/mks/vacscan.html#egse.vacuum.mks.vacscan.VacscanProxy">VacscanProxy</a></li>
<li><a title="egse.vacuum.pfeiffer.acp40.Acp40Proxy" href="vacuum/pfeiffer/acp40.html#egse.vacuum.pfeiffer.acp40.Acp40Proxy">Acp40Proxy</a></li>
<li><a title="egse.vacuum.pfeiffer.tc400.Tc400Proxy" href="vacuum/pfeiffer/tc400.html#egse.vacuum.pfeiffer.tc400.Tc400Proxy">Tc400Proxy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.proxy.Proxy.get_commands"><code class="name flex">
<span>def <span class="ident">get_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of command names that can be send to the device or the
control server.</p>
<p>The commands are defined in the YAML settings file of the device.
Special commands are available for the ServiceProxy which configure and
control the control servers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_commands(self):
    &#34;&#34;&#34;
    Returns a list of command names that can be send to the device or the
    control server.

    The commands are defined in the YAML settings file of the device.
    Special commands are available for the ServiceProxy which configure and
    control the control servers.
    &#34;&#34;&#34;
    return list(self._commands.keys())</code></pre>
</details>
</dd>
<dt id="egse.proxy.Proxy.get_endpoint"><code class="name flex">
<span>def <span class="ident">get_endpoint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the endpoint.</p>
<h2 id="returns">Returns</h2>
<ul>
<li>Endpoint.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_endpoint(self):
    &#34;&#34;&#34; Returns the endpoint.

    Returns:
        - Endpoint.
    &#34;&#34;&#34;

    return self._endpoint</code></pre>
</details>
</dd>
<dt id="egse.proxy.Proxy.has_commands"><code class="name flex">
<span>def <span class="ident">has_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if commands have been loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_commands(self):
    &#34;&#34;&#34;Return `True` if commands have been loaded.&#34;&#34;&#34;
    return bool(self._commands)</code></pre>
</details>
</dd>
<dt id="egse.proxy.Proxy.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Requests all available commands from the control server and adds them to
the Proxy public interface, i.e. each command will become a method for
this Proxy.</p>
<p>A warning will be issued when a command will overwrite an existing method
of the Proxy class. The original method will not be overwritten and the
behavior of the Proxy command will not be what is expected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(self):
    &#34;&#34;&#34;
    Requests all available commands from the control server and adds them to
    the Proxy public interface, i.e. each command will become a method for
    this Proxy.

    A warning will be issued when a command will overwrite an existing method
    of the Proxy class. The original method will not be overwritten and the
    behavior of the Proxy command will not be what is expected.
    &#34;&#34;&#34;
    # bind the client_call method from each Command to this Proxy object
    # TODO(rik): what will happen when the _request_commands() fails?
    if self.is_cs_connected():
        self._request_commands()
        self._add_commands()
        return True
    else:
        self._logger.warning(f&#34;{self.__class__.__name__} is not connected, try to reconnect.&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="egse.proxy.Proxy.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self):
    return_code = self.send(&#34;Ping&#34;, retries=0, timeout=1000)
    self._logger.log(0, f&#34;Check if control server is available: Ping - {return_code}&#34;)
    return return_code == &#34;Pong&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.BaseProxy" href="#egse.proxy.BaseProxy">BaseProxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.BaseProxy.connect_cs" href="#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.disconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_commanding_port" href="#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_ip_address" href="#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_monitoring_port" href="#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_service_port" href="#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_service_proxy" href="#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.is_cs_connected" href="#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.reconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.reset_cs_connection" href="#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.send" href="#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.proxy.set_docstring" href="#egse.proxy.set_docstring">set_docstring</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.proxy.BaseProxy" href="#egse.proxy.BaseProxy">BaseProxy</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.proxy.BaseProxy.get_commanding_port" href="#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_endpoint" href="#egse.proxy.BaseProxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_ip_address" href="#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_monitoring_port" href="#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_service_port" href="#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.get_service_proxy" href="#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.ping" href="#egse.proxy.BaseProxy.ping">ping</a></code></li>
<li><code><a title="egse.proxy.BaseProxy.send" href="#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.proxy.ControlServerConnectionInterface" href="#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></code></h4>
<ul class="">
<li><code><a title="egse.proxy.ControlServerConnectionInterface.connect_cs" href="#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.disconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.is_cs_connected" href="#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.reconnect_cs" href="#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.ControlServerConnectionInterface.reset_cs_connection" href="#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.proxy.DynamicProxy" href="#egse.proxy.DynamicProxy">DynamicProxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.proxy.Proxy" href="#egse.proxy.Proxy">Proxy</a></code></h4>
<ul class="">
<li><code><a title="egse.proxy.Proxy.get_commands" href="#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.ping" href="#egse.proxy.Proxy.ping">ping</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
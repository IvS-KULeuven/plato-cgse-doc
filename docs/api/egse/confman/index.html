<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.confman API documentation</title>
<meta name="description" content="This module provides configuration management for the Common-EGSE â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.confman</code></h1>
</header>
<section id="section-intro">
<p>This module provides configuration management for the Common-EGSE.</p>
<p>The configuration manager knows about the configuration of the system and the test setup. It's
main responsibility is to maintain the setup of the tests that are performed. It is the single
point access for all configuration information.</p>
<h2 id="the-configuration-aka-setup">The Configuration aka Setup</h2>
<p>The Setup contains the identification of all the devices, mechanisms, controllers etc. that are
used for a particular test. For each of these items the Setup contains hardware and software
version, conversion and calibration information, location, components, specific settings,
defaults, in a word, all information that is needed to uniquely identify the components,
and to reproduce the test under the same circumstances. The details for the Setup are explained
in the <code><a title="egse.setup" href="../setup.html">egse.setup</a></code> module.</p>
<h2 id="prerequisites">Prerequisites:</h2>
<p>When the configuration manager (<code>cm_cs</code>) is started, no Setup is loaded. The configuration
manager will then be in a default Setup state without any devices configured. This is called the
<em>Zero</em> Setup. The only keyword/attribute available from this Setup is <code>site_id</code>.</p>
<h2 id="setup-commands">Setup commands</h2>
<p>The main purpose of the configuration manager is to maintain and manage Setups. These Setups
will reside in a GitHub repository for which the <code>cm_cs</code> has access to read and write Setups. The
<code>cm_cs</code> provides all configuration information on request with the following commands that
are available from the <code><a title="egse.confman.ConfigurationManagerProxy" href="#egse.confman.ConfigurationManagerProxy">ConfigurationManagerProxy</a></code>.</p>
<h4 id="list_setups"><code>list_setups()</code></h4>
<p>You can request a list of available Setups with the <code>list_setups</code> command. This function takes
keyword arguments which are the attributes of the Setup and compares the attribute with the
given value. An example should make this clear. A setup has a <code>site_id</code> and for the CSL site
also a <code>position</code>. You can access these value as follows:</p>
<pre><code>&gt;&gt;&gt; from egse.state import GlobalState
&gt;&gt;&gt; setup = GlobalState.setup
&gt;&gt;&gt; setup.site_id
'CSL'
&gt;&gt;&gt; setup.position
2
</code></pre>
<p>When you now want a list of all Setups specific for CSL that were applicable for position 2,
the following command will return that list.</p>
<pre><code>with ConfigurationManagerProxy() as cm:
    print(cm.list_setups(site_id=&quot;CSL&quot;, position=2))
</code></pre>
<p>When you need to know which of these setups has the PUNA Hexapod with id=172543, add this
attribute as a keyword.</p>
<pre><code>with ConfigurationManagerProxy() as cm:
    print(cm.list_setups(site_id=&quot;CSL&quot;, position=2, gse__hexapod__ID=172543))
</code></pre>
<p>When multiple attributes are specified, they are checked using a logical AND, not a logical OR,
meaning they have to meet <em>every</em> attribute passed in and not just one of them.</p>
<p>You probably also noticed that instead of using the normal dot-notation to reach the hexapod id,
e.g. <code>gse.hexapod.ID</code>, we use double underscores to replace the dots. The reason for that is
that you can not have dots in keyword argument names. When you put a dot, you will get a
<code>SyntaxError</code>.</p>
<h4 id="load_setupsetup_id-int"><code>load_setup(setup_id: int)</code></h4>
<p>Load a new Setup into the configuration manager. This command can only be called outside the
scope of an observation and will not have any effect when an observation is currently running.
Since the <code>cm_cs</code> knowns what the site_id is, the Setup for the current site is loaded
automativally.</p>
<h4 id="get_setup"><code>get_setup()</code></h4>
<p>Returns the Setup that is currently loaded on the configuration manager.</p>
<h2 id="observation-aka-test-commands">Observation (aka Test) Commands</h2>
<p>The configuration manager needs to know when an observation is started. It will keep track and
inform clients of the running observation.</p>
<h4 id="start_observation"><code>start_observation()</code></h4>
<p>This command starts a new observation. This will assign an new unique observation
identifier (<code>obsid</code>) for the observation and inform the Storage Manager that a new test has been
started with that <code>obsid</code>. A new test can not start before the previous test has been finished.
Also, a new Setup can not be loaded when an observation is running.</p>
<h4 id="end_observation"><code>end_observation()</code></h4>
<p>This command ends the current observation and notifies the Storage Manager that the test
has been ended.</p>
<h4 id="get_obsid"><code>get_obsid()</code></h4>
<p>Returns the observation identifier of the currently running observation.</p>
<h2 id="convenience-functions">Convenience Functions</h2>
<p>The package also defines a number of convenience functions that simplify the communication
with the configuration manager <code>cm_cs</code>.</p>
<h4 id="is_configuration_manager_active"><code><a title="egse.confman.is_configuration_manager_active" href="#egse.confman.is_configuration_manager_active">is_configuration_manager_active()</a></code></h4>
<p>A function that checks if the <code>cm_cs</code> is running and responding to commands. This function makes
a connection with the <code>cm_cs</code> and sends it a <em>Ping</em> command. This is the recommended way to check
the availability of the configuration manager.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides configuration management for the Common-EGSE.

The configuration manager knows about the configuration of the system and the test setup. It&#39;s
main responsibility is to maintain the setup of the tests that are performed. It is the single
point access for all configuration information.

## The Configuration aka Setup

The Setup contains the identification of all the devices, mechanisms, controllers etc. that are
used for a particular test. For each of these items the Setup contains hardware and software
version, conversion and calibration information, location, components, specific settings,
defaults, in a word, all information that is needed to uniquely identify the components,
and to reproduce the test under the same circumstances. The details for the Setup are explained
in the `egse.setup` module.

## Prerequisites:

When the configuration manager (`cm_cs`) is started, no Setup is loaded. The configuration
manager will then be in a default Setup state without any devices configured. This is called the
_Zero_ Setup. The only keyword/attribute available from this Setup is `site_id`.

## Setup commands

The main purpose of the configuration manager is to maintain and manage Setups. These Setups
will reside in a GitHub repository for which the `cm_cs` has access to read and write Setups. The
`cm_cs` provides all configuration information on request with the following commands that
are available from the `ConfigurationManagerProxy`.

#### `list_setups()`

You can request a list of available Setups with the `list_setups` command. This function takes
keyword arguments which are the attributes of the Setup and compares the attribute with the
given value. An example should make this clear. A setup has a `site_id` and for the CSL site
also a `position`. You can access these value as follows:

    &gt;&gt;&gt; from egse.state import GlobalState
    &gt;&gt;&gt; setup = GlobalState.setup
    &gt;&gt;&gt; setup.site_id
    &#39;CSL&#39;
    &gt;&gt;&gt; setup.position
    2

When you now want a list of all Setups specific for CSL that were applicable for position 2,
the following command will return that list.
```
with ConfigurationManagerProxy() as cm:
    print(cm.list_setups(site_id=&#34;CSL&#34;, position=2))
```
When you need to know which of these setups has the PUNA Hexapod with id=172543, add this
attribute as a keyword.
```
with ConfigurationManagerProxy() as cm:
    print(cm.list_setups(site_id=&#34;CSL&#34;, position=2, gse__hexapod__ID=172543))
```
When multiple attributes are specified, they are checked using a logical AND, not a logical OR,
meaning they have to meet _every_ attribute passed in and not just one of them.

You probably also noticed that instead of using the normal dot-notation to reach the hexapod id,
e.g. `gse.hexapod.ID`, we use double underscores to replace the dots. The reason for that is
that you can not have dots in keyword argument names. When you put a dot, you will get a
`SyntaxError`.

#### `load_setup(setup_id: int)`

Load a new Setup into the configuration manager. This command can only be called outside the
scope of an observation and will not have any effect when an observation is currently running.
Since the `cm_cs` knowns what the site_id is, the Setup for the current site is loaded
automativally.

#### `get_setup()`

Returns the Setup that is currently loaded on the configuration manager.


## Observation (aka Test) Commands

The configuration manager needs to know when an observation is started. It will keep track and
inform clients of the running observation.

#### `start_observation()`

This command starts a new observation. This will assign an new unique observation
identifier (`obsid`) for the observation and inform the Storage Manager that a new test has been
started with that `obsid`. A new test can not start before the previous test has been finished.
Also, a new Setup can not be loaded when an observation is running.

#### `end_observation()`

This command ends the current observation and notifies the Storage Manager that the test
has been ended.

#### `get_obsid()`

Returns the observation identifier of the currently running observation.


## Convenience Functions

The package also defines a number of convenience functions that simplify the communication
with the configuration manager `cm_cs`.

#### `is_configuration_manager_active()`

A function that checks if the `cm_cs` is running and responding to commands. This function makes
a connection with the `cm_cs` and sends it a _Ping_ command. This is the recommended way to check
the availability of the configuration manager.

&#34;&#34;&#34;
from __future__ import annotations

import logging
import operator
import subprocess
import textwrap
import threading
from pathlib import Path
from typing import NamedTuple
from typing import Optional
from typing import Union

import git
import rich
from git import GitCommandError
from prometheus_client import Gauge

from egse.command import ClientServerCommand
from egse.command import stringify_function_call
from egse.config import find_file
from egse.config import find_files
from egse.config import get_common_egse_root
from egse.control import ControlServer
from egse.control import Failure
from egse.control import Response
from egse.control import Success
from egse.control import is_control_server_active
from egse.decorators import dynamic_interface
from egse.decorators import static_vars
from egse.exceptions import InternalError
from egse.listener import EVENT_ID
from egse.obsid import ObservationIdentifier
from egse.protocol import CommandProtocol
from egse.proxy import Proxy
from egse.settings import Settings
from egse.settings import SettingsError
from egse.setup import Setup
from egse.setup import load_last_setup_id
from egse.setup import save_last_setup_id
from egse.system import Timer
from egse.system import filter_by_attr
from egse.system import format_datetime
from egse.system import duration
from egse.system import humanize_seconds
from egse.system import replace_environment_variable
from egse.version import VERSION
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

LOGGER = logging.getLogger(__name__)

CTRL_SETTINGS = Settings.load(&#34;Configuration Manager Control Server&#34;)
SITE = Settings.load(&#34;SITE&#34;)
COMMAND_SETTINGS = Settings.load(filename=&#34;confman.yaml&#34;)
REPO = Settings.load(&#34;REPO&#34;)

CM_SETUP_ID = Gauge(&#34;CM_SETUP_ID&#34;, &#39;Setup ID&#39;)
CM_TEST_ID = Gauge(&#34;CM_TEST_ID&#34;, &#39;Test ID&#39;)

PROXY_TIMEOUT = 10_000  # don&#39;t wait longer than 10s by default


def _push_setup_to_repo(filename: str, commit_msg: str) -&gt; Failure | Success:
    &#34;&#34;&#34;
    Push the Setup file to the `plato-cgse-conf` repository on GitHub.

    Args:
        filename: the basename of the new Setup file

    Returns:
        None.
    &#34;&#34;&#34;

    repo_workdir = REPO.PLATO_CGSE_CONF
    repo_workdir = replace_environment_variable(repo_workdir)
    if repo_workdir is None:
        msg = textwrap.dedent(
            &#34;&#34;&#34;\
            Couldn&#39;t determine the repository location for plato-cgse-conf. 
            Check if the environment variable &#39;PLATO_CONF_REPO_LOCATION&#39; is set 
            before starting the configuration manager.
            &#34;&#34;&#34;
        )
        LOGGER.error(msg)
        return Failure(msg)

    repo = git.Repo(repo_workdir)

    if repo.is_dirty():
        LOGGER.warning(
            f&#34;The plato-cgse-conf repository is dirty. Check the git status at &#39;{repo_workdir}&#39;.&#34;)

    untracked = repo.untracked_files

    if len(untracked) != 1:
        msg = textwrap.dedent(
            f&#34;&#34;&#34;\
            The number of untracked files ({len(untracked)}) in the plato-cgse-conf repository doesn&#39;t match 
            the expected. Check the git status at &#39;{repo_workdir}&#39; on the egse-server. 
            Only &#39;{filename}&#39; should be untracked.
            
            Untracked files: {untracked}
            &#34;&#34;&#34;
        )
        LOGGER.error(msg)
        return Failure(msg)

    # match the filename to extract the full path to the file

    untracked = [x for x in untracked if filename in x]
    if (n := len(untracked)) != 1:
        msg = f&#34;There should be one match for the filename, found {n}{&#39;&#39; if n == 0 else untracked}.&#34;
        LOGGER.error(msg)
        return Failure(msg)

    untracked = untracked[0]

    # The response is a list of tuples containing the path of the file added to the stages/index.

    try:
        response = repo.index.add(untracked)
        # assert response[0].path == untracked
    except FileNotFoundError:
        # if for some reason the untracked file can not be found, should not happen..
        LOGGER.warning(
            f&#34;Untracked file {untracked} not found. Check the git status at {repo_workdir}.&#34;
        )

    # The response is a Commit object containing e.g. the commit message, the hash, the author, ...

    response = repo.index.commit(message=commit_msg)

    # The response is a list of FetchInfo instances
    # We need this `pull` command before we will push the changes because otherwise the push will
    # be rejected, see https://github.com/IvS-KULeuven/plato-common-egse/issues/2027. The problem
    # should not abort the submit command, but needs to be logged.

    try:
        response = repo.remote(&#39;upload&#39;).pull(&#34;main&#34;)
    except Exception as exc:
        LOGGER.error(exc, exc_info=True)

    # The response is a PushInfo object

    try:
        response = repo.remote(&#39;upload&#39;).push(&#34;main&#34;)
    except ValueError as exc:
        LOGGER.error(exc, exc_info=True)
        return Failure(f&#34;Push of setup [{filename}] failed&#34;, exc)
    except GitCommandError as exc:
        LOGGER.error(exc, exc_info=True)
        return Failure(f&#34;Push of setup [{filename}] failed&#34;, exc)

    return Success(f&#34;Successfully pushed the setup to the repo {repo}&#34;)

# We have seen that especially when listing the setups, we have a performance problem.
# Therefore, we implement a cache for the Setup info that we use in different functions.
#
# The key is the Setup ID
# The value is the named tuple SetupInfo

_cached_setup_info = {}


class SetupInfo(NamedTuple):
    path: Path
    site_id: str
    cam_id: str
    description: str


def _populate_cached_setup_info():
    &#34;&#34;&#34;
    Populates the internal cache of Setup information.

    Raises:
        InternalError when a Setup is loaded that doesn&#39;t have an ID associated.

    &#34;&#34;&#34;
    global _cached_setup_info

    LOGGER.info(&#34;Populating cache with Setup Info.&#34;)

    location = replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)
    data_conf_location = Path(location) if location else get_common_egse_root()

    setup_info = {}

    for fn in find_files(pattern=&#34;SETUP*&#34;, root=data_conf_location):
        setup = Setup.from_yaml_file(fn)
        if id := setup.get_id():
            id = int(id)
            site_id = _get_site_id_for_setup(setup)
            cam_id = _get_cam_id_for_setup(setup)
            description = _get_description_for_setup(setup)
            setup_info[id] = SetupInfo(fn, site_id, cam_id, description)
        else:
            raise InternalError(f&#34;Setup loaded without an ID, {fn=}&#34;)

    _cached_setup_info = dict(sorted(setup_info.items()))

    LOGGER.info(&#34;SetupInfo cache populated.&#34;)


def _add_setup_info_to_cache(setup: Setup):
    global _cached_setup_info

    if (_id := setup.get_id()) is None:
        raise InternalError(f&#34;Setup loaded without an ID, {setup=!s}&#34;)

    if (_fn := setup.get_filename()) is None:
        raise InternalError(f&#34;Setup with id={_id} has no filename associated.&#34;)

    _id = int(_id)
    _fn = Path(_fn)

    site_id = _get_site_id_for_setup(setup)
    cam_id = _get_cam_id_for_setup(setup)
    description = _get_description_for_setup(setup)

    _cached_setup_info[_id] = SetupInfo(_fn, site_id, cam_id, description)


def _print_cached_setup_info():
    global _cached_setup_info

    rich.print(_cached_setup_info)


def _get_cached_setup_info(setup_id: int) -&gt; Optional[SetupInfo]:
    &#34;&#34;&#34;Returns a setup info named tuple for the given setup id or None when no
    SetupInfo for the given setup_id is available..&#34;&#34;&#34;
    global _cached_setup_info

    return _cached_setup_info.get(setup_id)


def _reload_cached_setup_info():

    try:
        Setup.from_yaml_file.cache_clear()
    except AttributeError:
        LOGGER.warning(&#34;Setup.from_yaml_file() method is not decorated with an lru_cache.&#34;)

    _populate_cached_setup_info()


def is_configuration_manager_active(timeout: float = 0.5):
    &#34;&#34;&#34;
    Checks whether the Configuration Manager is running.

    Args:
        timeout (float): Timeout when waiting for a reply [seconds, default=0.01]

    Returns:
        True if the Configuration Manager is running and replied with the expected answer.
    &#34;&#34;&#34;

    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )

    return is_control_server_active(endpoint, timeout)


def _construct_filename(site_id: str, setup_id: int, creation_time: str = None):
    &#34;&#34;&#34;Construct a filename for a Setup.

    FIXME: describe the restrictions on file naming and how they are parsed etc.

    Args:
        site_id (str): the site identifier
        setup_id (int): the setup identifier
        creation_time (str): the date-time shall be formatted as `YYMMDD_HHMMSS`
    &#34;&#34;&#34;

    if creation_time:
        filename = f&#34;SETUP_{site_id}_{setup_id:05d}_{creation_time}.yaml&#34;
    else:
        filename = f&#34;SETUP_{site_id}_{setup_id:05d}_{format_datetime(fmt=&#39;%y%m%d_%H%M%S&#39;)}.yaml&#34;

    return filename


def _get_description_for_setup(setup: Setup, setup_id: int = None) -&gt; str:
    setup_id = setup_id or int(setup.get_id())
    try:
        description = setup.history.get(setup_id)
    except AttributeError:
        description = None
    return description or f&#34;no description found for Setup {setup_id}&#34;


def _get_cam_id_for_setup(setup: Setup) -&gt; str:

    try:
        if &#34;id&#34; in setup.camera:
            cam_id = setup.camera.id
        elif &#34;ID&#34; in setup.camera:
            cam_id = setup.camera.ID
        else:
            cam_id = None
    except AttributeError:
        cam_id = None

    return cam_id or &#34;no cam_id&#34;


def _get_site_id_for_setup(setup: Setup) -&gt; str:

    try:
        site_id = setup.site_id if &#34;site_id&#34; in setup else None
    except AttributeError:
        site_id = None

    return site_id or &#34;no site_id&#34;


@static_vars(test_id=0)
def create_obsid(last_obsid: str, site_id: str, setup_id: int):
    # This is method is currently just a prove of concept, the real thing should
    # read the LID, SID from the current Setup and then generate or keep track
    # of a TEST ID.

    # How do we guarantee a unique OBSID? OBSIDs need to be made persistent at least for the Site.
    # That way we can, when a new ObservationIdentifier is generated, check if it&#39;s indeed unique.

    if last_obsid:
        create_obsid.test_id = int(last_obsid.split(maxsplit=1)[0])

    create_obsid.test_id += 1

    # We need access to the setup, because we need the LabID, the SetupID
    # How do we define the configuration ID and Test ID?

    return ObservationIdentifier(site_id, setup_id, create_obsid.test_id)


class ConfigurationManagerInterface:
    &#34;&#34;&#34;
    This interface is for sending commands to the configuration manager to e.g. start and stop
    an observation/test, or get information about the Setups.

    The interface should be implemented by the `ConfigurationManagerController` and the
    `ConfigurationManagerProxy` (and possibly a `ConfigurationManagerSimulator` should we
    need that e.g. for testing purposes).
    &#34;&#34;&#34;

    @dynamic_interface
    def start_observation(self, function_info: dict) -&gt; Response:
        &#34;&#34;&#34;Starts a new observation or test. The following actions will be taken:

        * create an observation identifier, aka `obsid`
        * notify the Storage Control Server that a new observation is started
        * return the generated `obsid`

        Args:
            function_info: dictionary with information about the function called
        Returns:
            `Success` (with `obsid` as `return_code`) or `Failure` when already in an observation
            or Storage returned Failure.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def end_observation(self) -&gt; Response:
        &#34;&#34;&#34;Ends the current observation and notifies the Storage Control Server.

        Returns:
            `Success` when the observation could be closed properly and the Storage CS was notified
            or `Failure` otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_obsid(self) -&gt; Success:
        &#34;&#34;&#34;Returns the current observation identifier. When no observation is running, `None` is
        returned as the `return_code` in `Success`.

        Returns:
            Always returns `Success` with current observation identifier, i.e. `obsid`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def load_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
        raise NotImplementedError

    @dynamic_interface
    def get_setup(self, setup_id: int = None):
        raise NotImplementedError

    @dynamic_interface
    def reload_setups(self):
        raise NotImplementedError

    @dynamic_interface
    def list_setups(self, **attr):
        raise NotImplementedError

    @dynamic_interface
    def submit_setup(self, setup: Setup, description: str, replace: bool = True) -&gt; Setup | None:
        raise NotImplementedError

    @dynamic_interface
    def get_setup_for_obsid(self, obsid):
        raise NotImplementedError

    @dynamic_interface
    def get_listener_names(self):
        raise NotImplementedError


class ConfigurationManagerController(ConfigurationManagerInterface):
    &#34;&#34;&#34;Handles the commands that are sent to the configuration manager.

    .. note::
        The docstrings for each of the commands are in the `ConfigurationManagerInterface`.
    &#34;&#34;&#34;

    def __init__(self, control_server: ControlServer | None = None):

        # Import these modules here as to optimize the import of classes and functions in other parts of the CGSE.
        # The CongifurationManagerController is only used by the CM CS and these Storage imports are only used in
        # this class and take too much loading time...

        from egse.storage import StorageProxy
        from egse.storage import is_storage_manager_active
        from egse.storage.persistence import TXT

        self._obsid: ObservationIdentifier | None = None
        self._obsid_start_dt: str | None = None
        self._setup: Setup | None = None
        self._setup_id: int | None = None
        self._camera_name: str | None = None
        self._control_server: ControlServer | None = control_server

        if is_storage_manager_active(timeout=2.0):
            self._storage = StorageProxy()
            response = self._storage.register(
                {
                    &#34;origin&#34;: &#34;obsid&#34;,
                    &#34;persistence_class&#34;: TXT,
                    &#34;prep&#34;: {&#34;mode&#34;: &#34;a&#34;, &#34;ending&#34;: &#34;\n&#34;},
                    &#34;persistence_count&#34;: True,
                    &#34;filename&#34;: &#34;obsid-table.txt&#34;,
                }
            )
            LOGGER.info(response)
        else:
            self._storage = None
            LOGGER.error(&#34;No Storage Manager available !!!!&#34;)

        # Find the location for the configuration data

        location = replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)
        self._data_conf_location = Path(location) if location else get_common_egse_root()

        # Populate the cache with information from the available Setups. This will also load each
        # Setup and cache them with the lru_cache decorator. Since this takes about 5s for 100
        # Setups, we run this function in a daemon thread in order not to block the cm_cs from
        # reacting to command requests.

        cache_thread = threading.Thread(target=_populate_cached_setup_info)
        cache_thread.daemon = True
        cache_thread.start()

        # Load the last used Setup

        setup_id = load_last_setup_id()
        self.load_setup(setup_id)

    def quit(self):
        if self._storage:
            self._storage.disconnect_cs()

    @property
    def data_location(self) -&gt; Path:
        &#34;&#34;&#34;Return the location of the configuration data, i.e. the Setup YAML files.&#34;&#34;&#34;
        return self._data_conf_location

    def start_observation(self, function_info: dict) -&gt; Response:
        if self._obsid is not None:
            return Failure(
                &#34;An new observation can not be started before the previous observation is &#34;
                &#34;finished. You will need to first send an end_observation request to the &#34;
                &#34;configuration manager.&#34;
            )

        last_obsid = None

        if self._storage:
            last_obsid = self._storage.read({&#34;origin&#34;: &#34;obsid&#34;, &#34;select&#34;: &#34;last_line&#34;})
            last_obsid = last_obsid.return_code if isinstance(last_obsid, Success) else None

        self._obsid = create_obsid(last_obsid, SITE.ID, self._setup_id)
        self._obsid_start_dt = format_datetime()

        if self._storage:
            response = self._storage.start_observation(self._obsid, self._camera_name)
        else:
            return Failure(
                &#34;Couldn&#39;t send start observation to Storage Manager, no Storage Manager available.&#34;
            )

        if not response.successful:
            self._obsid = None
            return Failure(
                &#34;Sending a start_observation to the Storage Control Server failed&#34;,
                response,
            )

        description = function_info.pop(&#34;description&#34;, &#34;&#34;)
        cmd = stringify_function_call(function_info).replace(&#39;\n&#39;, &#39; &#39;)

        if description:
            cmd += f&#34; [{description}]&#34;

        response = self._storage.save(
            {
                &#34;origin&#34;: &#34;obsid&#34;,
                &#34;data&#34;: f&#34;{self._obsid.test_id:05d} &#34;
                f&#34;{self._obsid.lab_id} &#34;
                f&#34;{self._obsid.setup_id:05d} &#34;
                f&#34;{self._obsid_start_dt} &#34;
                f&#34;{cmd}&#34;,
            }
        )

        if isinstance(response, Failure):
            LOGGER.warning(
                f&#34;There was a Failure when saving to the obsid-table: &#34;
                f&#34;{response}&#34;)
        else:
            LOGGER.info(f&#34;Successfully created an observation with obsid={self._obsid}.&#34;)

        return Success(&#34;Returning the OBSID&#34;, self._obsid)

    def end_observation(self) -&gt; Response:
        if not self._obsid:
            return Failure(
                &#34;Received end_observation command while not currently in an observation context.&#34;
            )

        if self._storage:
            response = self._storage.end_observation(self._obsid)
        else:
            return Failure(
                &#34;Couldn&#39;t send end observation to Storage Manager, no Storage Manager available.&#34;
            )

        if not response.successful:
            return Failure(
                &#34;Sending an end_observation to the Storage Control Server failed.&#34;,
                response,
            )

        obsid_end_dt = format_datetime()
        obs_duration = humanize_seconds(
            duration(self._obsid_start_dt, obsid_end_dt).total_seconds(),
            include_micro_seconds=False
        )
        LOGGER.info(f&#34;Successfully ended observation with obsid={self._obsid}, duration={obs_duration}.&#34;)

        self._obsid = None
        self._obsid_start_dt = None

        return Success(&#34;Successfully ended the observation.&#34;)

    def get_obsid(self) -&gt; Success:
        if self._obsid:
            msg = &#34;Returning the current OBSID.&#34;
        else:
            msg = &#34;No observation running. Use start_observation() to start an observation.&#34;
        return Success(msg, self._obsid)

    def load_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
        &#34;&#34;&#34;Load the Setup with the given setup_id.

        Args:
            setup_id (int): the identifier for the requested Setup.
        Returns:
            The requested Setup.
        &#34;&#34;&#34;
        # The current implementation is file based. The files have a strict naming convention and
        # are located in the `data/conf` directory.
        #
        # 1. Find the Setup for the given setup_id and the Site (is this read from the Settings
        #    file, or set by some GUI or process?
        # 2. Load that Setup from its file at the default location
        # 3. Return an acknowledgement that the Setup is loaded on the CM_CS or not

        if setup_id is None:
            return Failure(
                f&#34;No Setup ID was given, cannot load a Setup into the configuration manager. &#34;
                f&#34;If you wanted to get the current Setup from the configuration manager, use the &#34;
                f&#34;get_setup() method instead.&#34;
            )

        if self._obsid:
            return Failure(
                f&#34;A new Setup can not be loaded when an observation is running. &#34;
                f&#34;The current obsid is {self._obsid}. Use `end_observation()` before &#34;
                f&#34;loading a new Setup.&#34;
            )

        setup_files = list(
            find_files(
                pattern=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
            )
        )

        if len(setup_files) != 1:
            LOGGER.error(
                msg := f&#34;Expected to find just one Setup YAML file, found {len(setup_files)}. &#34;
                       f&#34;[{SITE.ID = }, {setup_id = }, data_conf_location={self._data_conf_location}]&#34;
            )
            return Failure(&#34;Loading Setup&#34;, InternalError(msg))

        setup_file = setup_files[0]

        try:
            self._setup = Setup.from_yaml_file(setup_file)
            self._setup_id = setup_id
            self._camera_name = self._setup.camera.ID.lower()
            LOGGER.info(f&#34;New Setup loaded from {setup_file}&#34;)
            save_last_setup_id(self._setup_id)
            if self._control_server:
                LOGGER.info(&#34;Notifying listeners for a new Setup!&#34;)
                with Timer(f&#34;Notify Listeners for Setup change, Setup={self._setup_id}&#34;):
                    self._control_server.notify_listeners(
                        EVENT_ID.SETUP,
                        {&#39;event_type&#39;: &#39;new_setup&#39;, &#39;setup_id&#39;: self._setup_id}
                    )

            return self._setup
        except SettingsError as exc:
            return Failure(f&#34;The Setup file can not be loaded from {setup_file}.&#34;, exc)
        except AttributeError as exc:
            msg = f&#34;The Setup [id={setup_id}] has no camera.ID entry.&#34;
            LOGGER.error(msg, exc_info=True)
            # FIXME: if we come here, shouldn&#39;t we load the zero Setup so that the problem of the
            #        missing camera ID gets solved?
            return Failure(msg)

    def get_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
        &#34;&#34;&#34;
        Returns the Setup for the given setup_id. If no setup_id argument was provided,
        the current Setup from the configuration manager will be returned.

        This is a -read-only function.
        Under no circumstance will the Setup of the configuration manager be changed.

        Args:
            setup_id (int): the identifier for the requested Setup.
        Returns:
            The requested Setup.
        &#34;&#34;&#34;

        if setup_id:
            # If a Setup ID is given, just load and return the Setup for that ID
            # The Setup is NOT added to the Configuration Manager as the current Setup.

            setup_files = list(
                find_files(
                    pattern=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
                )
            )

            if len(setup_files) != 1:
                LOGGER.error(
                    msg := f&#34;Expected to find just one Setup YAML file, found {len(setup_files)}.&#34;
                )
                return Failure(&#34;Expected only one Setup.&#34;, InternalError(msg))

            setup_file = setup_files[0]

            try:
                return Setup.from_yaml_file(setup_file)
            except SettingsError as exc:
                return Failure(f&#34;The Setup file can not be loaded from {setup_file}.&#34;, exc)

        else:
            # No Setup ID was given, so we return the current Setup loaded in the Configuration Manager

            if self._setup:
                return self._setup
            else:
                return Failure(&#34;No Setup was loaded on the Configuration Manager.&#34;)

    def get_setup_id(self) -&gt; int:
        &#34;&#34;&#34;Returns the Setup identifier for the currently loaded Setup.

        Returns:
            The `setup_id` of the Setup loaded by the `cm_cs`, or None.
        &#34;&#34;&#34;

        return self._setup_id

    def get_site_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the Site identifier that is used by the configuration manager.

        Returns:
            The Site identifier as a string.
        &#34;&#34;&#34;

        return SITE.ID

    def reload_setups(self):
        &#34;&#34;&#34;
        Clears the cache and Reloads the available Setups.

        This function does not affect the currently loaded Setup.
        &#34;&#34;&#34;
        _reload_cached_setup_info()

    def list_setups(self, **attr):
        &#34;&#34;&#34;
        Returns a sorted list of all the available Setups for the current site. The list contains
        tuples with the following content: setup_id, site_id, description, cam_id.

        Args:
            **attr: see egse.system.filter_by_attr()

        Returns:
            A list with information on the available Setups.
        &#34;&#34;&#34;
        # The current implementation is file based. The files have a strict naming convention and
        # are located in the `data/conf` directory.
        #
        # 1. Get a list of the Setup files from the default location, i.e. data/conf
        # 2. Prepare a list of tuples with that information ordered by Setup ID
        # 3. Return that list

        setup_list = []

        setups = [Setup.from_yaml_file(info.path) for info in _cached_setup_info.values()]

        setups = filter_by_attr(setups, **attr)

        for setup in setups:
            _, setup_site, setup_id, _ = str(setup._filename).split(&#34;_&#34;, maxsplit=3)
            description = _get_description_for_setup(setup, int(setup_id))
            cam_id = _get_cam_id_for_setup(setup)
            setup_list.append((setup_id, setup_site, description, cam_id))

        # Sort by site, then by id

        return sorted(setup_list, key=operator.itemgetter(1, 0), reverse=False)

    def get_setup_for_obsid(self, obsid):
        obsid = f&#34;{obsid:05d}&#34; if isinstance(obsid, int) else obsid
        rc = self._storage.read({&#34;origin&#34;: &#34;obsid&#34;, &#34;select&#34;: (&#34;startswith&#34;, obsid)})
        if rc.successful:
            # FIXME: this should be a function that can also be used in load_setup(),
            #  because they do basically the same thing
            try:
                setup_id = int(rc.return_code[-1].split(maxsplit=3)[2])
                setup_file = find_file(
                    name=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
                )
                setup = Setup.from_yaml_file(setup_file)
            except (IndexError, SettingsError):
                setup = None

        return setup

    def submit_setup(self, setup: Setup, description: str, replace: bool = True):

        # 1. Determine the Site for this Setup, or should this be the Site that is known by the
        #    CM_CS?
        # 2. Find the correct (next) number for the Setup for the given Site
        # 3. Do I want to make some comparison?
        #    Do we need to keep a record from which this Setup is derived?

        # FIXME: define and handle exceptional conditions, like IOError

        if self._obsid is not None:
            return Failure(
                &#34;An new Setup can not be submitted when an observation is running. You will need &#34;
                &#34;to first send an end_observation request to the configuration manager.&#34;
            )

        site = setup.site_id

        setup_id = self.get_next_setup_id_for_site(site)

        filename = _construct_filename(SITE.ID, setup_id)

        if not hasattr(setup, &#34;history&#34;):
            setup.history = {}

        setup.history.update({f&#34;{setup_id}&#34;: description})
        setup.set_private_attribute(&#34;_setup_id&#34;, setup_id)
        setup.to_yaml_file(self._data_conf_location / filename)

        try:
            rc = _push_setup_to_repo(filename, description)
            if isinstance(rc, Failure):
                return rc
            _add_setup_info_to_cache(setup)
        except (Exception, ) as exc:
            msg = &#34;Submit_setup could not complete it&#39;s task to send the new Setup to the repo.&#34;
            LOGGER.error(msg, exc_info=True)
            return Failure(&#34;Submit_setup could not complete it&#39;s task to send the new Setup to the repo.&#34;, exc)
        else:
            LOGGER.info(f&#34;Successfully pushed Setup {setup_id} to the repository.&#34;)

        if replace:
            self._setup = setup
            self._setup_id = setup_id
            LOGGER.info(f&#34;New Setup was submitted and loaded: {setup_id=}&#34;)
            self._camera_name = self._setup.camera.ID.lower()
            save_last_setup_id(setup_id)
            if self._control_server:
                LOGGER.info(&#34;Notifying listeners for a new Setup!&#34;)
                with Timer(f&#34;Notify Listeners for Setup change, Setup={self._setup_id}&#34;):
                    self._control_server.notify_listeners(
                        EVENT_ID.SETUP,
                        {&#39;event_type&#39;: &#39;new_setup&#39;, &#39;setup_id&#39;: setup_id}
                    )

        return setup

    def get_next_setup_id_for_site(self, site: str) -&gt; int:
        &#34;&#34;&#34;Return the next available Setup ID for the given Site.

        Args:
            site (str): site identification, e.g. CSL, SRON, ...
        &#34;&#34;&#34;
        site = site or SITE.ID
        files = sorted(find_files(pattern=f&#34;SETUP_{site}_*.yaml&#34;, root=self._data_conf_location))
        last_file = files[-1]
        setup_id = last_file.name.split(&#34;_&#34;)[2]

        return int(setup_id) + 1

    def get_listener_names(self):
        &#34;&#34;&#34;Returns the names of the control servers that are listening for a new Setup.&#34;&#34;&#34;
        return self._control_server.get_listener_names()


class ConfigurationManagerCommand(ClientServerCommand):
    pass


class ConfigurationManagerProxy(Proxy, ConfigurationManagerInterface):
    &#34;&#34;&#34;
    The Configuration Manager Proxy class is used to connect to the Configuration Manager
    Control Server and send commands and requests for the configuration manager.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
        timeout=PROXY_TIMEOUT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address) [default is taken
                from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)


class ConfigurationManagerProtocol(CommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__()
        self.control_server = control_server

        self.controller = ConfigurationManagerController(control_server)

        self.load_commands(
            COMMAND_SETTINGS.Commands,
            ConfigurationManagerCommand,
            ConfigurationManagerController,
        )

        self.build_device_method_lookup_table(self.controller)

        self.cgse_version = VERSION

        try:
            self.git_version = subprocess.check_output(
                [&#34;git&#34;, &#34;describe&#34;, &#34;--tags&#34;, &#34;--long&#34;], stderr=subprocess.STDOUT)
            self.git_version = self.git_version.strip().decode(&#34;ascii&#34;)
        except subprocess.CalledProcessError as exc:
            LOGGER.debug(
                f&#34;A git error occurred for the `git describe` command: {exc}&#34;, stack_info=True)
            self.git_version = &#34;no git-version determined&#34;

    def get_bind_address(self):
        return bind_address(
            self.control_server.get_communication_protocol(),
            self.control_server.get_commanding_port(),
        )

    def get_status(self) -&gt; dict:
        status = super().get_status()

        status.update({&#34;obsid&#34;: self.controller.get_obsid().return_code})
        status.update({&#34;setup&#34;: self.controller.get_setup()})

        return status

    def get_housekeeping(self) -&gt; dict:
        obsid = self.controller.get_obsid().return_code
        test_id = obsid.test_id if obsid else float(&#39;nan&#39;)
        setup_id = self.controller.get_setup_id()
        site_id = self.controller.get_site_id()

        hk = {
            &#34;timestamp&#34;: format_datetime(),
            &#34;CM_SITE_ID&#34;: site_id,
            &#34;CM_SETUP_ID&#34;: setup_id,
            &#34;CM_TEST_ID&#34;: test_id,
            &#34;CM_OBSID&#34;: obsid,
            &#34;CM_CGSE_VERSION&#34;: self.cgse_version,
            &#34;CM_GIT_VERSION&#34;: self.git_version,
        }

        # Update the metrics

        CM_SETUP_ID.set(float(setup_id))
        CM_TEST_ID.set(float(test_id))

        return hk

    def quit(self):
        self.controller.quit()


# The following functions are defined here to allow them to be used in the list_setups() method
# and be pickled and passed over ZeroMQ.


def is_in(a, b):
    &#34;&#34;&#34;Returns result of `a in b`.&#34;&#34;&#34;
    return a in b


def is_not_in(a, b):
    &#34;&#34;&#34;Returns result of `a not in b`.&#34;&#34;&#34;
    return a not in b</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="egse.confman.confman_cs" href="confman_cs.html">egse.confman.confman_cs</a></code></dt>
<dd>
<div class="desc"><p>The Configuration Manager is a server that controls and distributes configuration settings â€¦</p></div>
</dd>
<dt><code class="name"><a title="egse.confman.confman_ui" href="confman_ui.html">egse.confman.confman_ui</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="egse.confman.setup_ui" href="setup_ui.html">egse.confman.setup_ui</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.confman.create_obsid"><code class="name flex">
<span>def <span class="ident">create_obsid</span></span>(<span>last_obsid:Â str, site_id:Â str, setup_id:Â int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@static_vars(test_id=0)
def create_obsid(last_obsid: str, site_id: str, setup_id: int):
    # This is method is currently just a prove of concept, the real thing should
    # read the LID, SID from the current Setup and then generate or keep track
    # of a TEST ID.

    # How do we guarantee a unique OBSID? OBSIDs need to be made persistent at least for the Site.
    # That way we can, when a new ObservationIdentifier is generated, check if it&#39;s indeed unique.

    if last_obsid:
        create_obsid.test_id = int(last_obsid.split(maxsplit=1)[0])

    create_obsid.test_id += 1

    # We need access to the setup, because we need the LabID, the SetupID
    # How do we define the configuration ID and Test ID?

    return ObservationIdentifier(site_id, setup_id, create_obsid.test_id)</code></pre>
</details>
</dd>
<dt id="egse.confman.is_configuration_manager_active"><code class="name flex">
<span>def <span class="ident">is_configuration_manager_active</span></span>(<span>timeout:Â floatÂ =Â 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the Configuration Manager is running.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>Timeout when waiting for a reply [seconds, default=0.01]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the Configuration Manager is running and replied with the expected answer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_configuration_manager_active(timeout: float = 0.5):
    &#34;&#34;&#34;
    Checks whether the Configuration Manager is running.

    Args:
        timeout (float): Timeout when waiting for a reply [seconds, default=0.01]

    Returns:
        True if the Configuration Manager is running and replied with the expected answer.
    &#34;&#34;&#34;

    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )

    return is_control_server_active(endpoint, timeout)</code></pre>
</details>
</dd>
<dt id="egse.confman.is_in"><code class="name flex">
<span>def <span class="ident">is_in</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns result of <code>a in b</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in(a, b):
    &#34;&#34;&#34;Returns result of `a in b`.&#34;&#34;&#34;
    return a in b</code></pre>
</details>
</dd>
<dt id="egse.confman.is_not_in"><code class="name flex">
<span>def <span class="ident">is_not_in</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns result of <code>a not in b</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_not_in(a, b):
    &#34;&#34;&#34;Returns result of `a not in b`.&#34;&#34;&#34;
    return a not in b</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.confman.ConfigurationManagerCommand"><code class="flex name class">
<span>class <span class="ident">ConfigurationManagerCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationManagerCommand(ClientServerCommand):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></li>
<li><a title="egse.command.Command" href="../command.html#egse.command.Command">Command</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.command.ClientServerCommand" href="../command.html#egse.command.ClientServerCommand">ClientServerCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="../command.html#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="../command.html#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.confman.ConfigurationManagerController"><code class="flex name class">
<span>class <span class="ident">ConfigurationManagerController</span></span>
<span>(</span><span>control_server:Â ControlServerÂ |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles the commands that are sent to the configuration manager.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The docstrings for each of the commands are in the <code><a title="egse.confman.ConfigurationManagerInterface" href="#egse.confman.ConfigurationManagerInterface">ConfigurationManagerInterface</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationManagerController(ConfigurationManagerInterface):
    &#34;&#34;&#34;Handles the commands that are sent to the configuration manager.

    .. note::
        The docstrings for each of the commands are in the `ConfigurationManagerInterface`.
    &#34;&#34;&#34;

    def __init__(self, control_server: ControlServer | None = None):

        # Import these modules here as to optimize the import of classes and functions in other parts of the CGSE.
        # The CongifurationManagerController is only used by the CM CS and these Storage imports are only used in
        # this class and take too much loading time...

        from egse.storage import StorageProxy
        from egse.storage import is_storage_manager_active
        from egse.storage.persistence import TXT

        self._obsid: ObservationIdentifier | None = None
        self._obsid_start_dt: str | None = None
        self._setup: Setup | None = None
        self._setup_id: int | None = None
        self._camera_name: str | None = None
        self._control_server: ControlServer | None = control_server

        if is_storage_manager_active(timeout=2.0):
            self._storage = StorageProxy()
            response = self._storage.register(
                {
                    &#34;origin&#34;: &#34;obsid&#34;,
                    &#34;persistence_class&#34;: TXT,
                    &#34;prep&#34;: {&#34;mode&#34;: &#34;a&#34;, &#34;ending&#34;: &#34;\n&#34;},
                    &#34;persistence_count&#34;: True,
                    &#34;filename&#34;: &#34;obsid-table.txt&#34;,
                }
            )
            LOGGER.info(response)
        else:
            self._storage = None
            LOGGER.error(&#34;No Storage Manager available !!!!&#34;)

        # Find the location for the configuration data

        location = replace_environment_variable(CTRL_SETTINGS.FILE_STORAGE_LOCATION)
        self._data_conf_location = Path(location) if location else get_common_egse_root()

        # Populate the cache with information from the available Setups. This will also load each
        # Setup and cache them with the lru_cache decorator. Since this takes about 5s for 100
        # Setups, we run this function in a daemon thread in order not to block the cm_cs from
        # reacting to command requests.

        cache_thread = threading.Thread(target=_populate_cached_setup_info)
        cache_thread.daemon = True
        cache_thread.start()

        # Load the last used Setup

        setup_id = load_last_setup_id()
        self.load_setup(setup_id)

    def quit(self):
        if self._storage:
            self._storage.disconnect_cs()

    @property
    def data_location(self) -&gt; Path:
        &#34;&#34;&#34;Return the location of the configuration data, i.e. the Setup YAML files.&#34;&#34;&#34;
        return self._data_conf_location

    def start_observation(self, function_info: dict) -&gt; Response:
        if self._obsid is not None:
            return Failure(
                &#34;An new observation can not be started before the previous observation is &#34;
                &#34;finished. You will need to first send an end_observation request to the &#34;
                &#34;configuration manager.&#34;
            )

        last_obsid = None

        if self._storage:
            last_obsid = self._storage.read({&#34;origin&#34;: &#34;obsid&#34;, &#34;select&#34;: &#34;last_line&#34;})
            last_obsid = last_obsid.return_code if isinstance(last_obsid, Success) else None

        self._obsid = create_obsid(last_obsid, SITE.ID, self._setup_id)
        self._obsid_start_dt = format_datetime()

        if self._storage:
            response = self._storage.start_observation(self._obsid, self._camera_name)
        else:
            return Failure(
                &#34;Couldn&#39;t send start observation to Storage Manager, no Storage Manager available.&#34;
            )

        if not response.successful:
            self._obsid = None
            return Failure(
                &#34;Sending a start_observation to the Storage Control Server failed&#34;,
                response,
            )

        description = function_info.pop(&#34;description&#34;, &#34;&#34;)
        cmd = stringify_function_call(function_info).replace(&#39;\n&#39;, &#39; &#39;)

        if description:
            cmd += f&#34; [{description}]&#34;

        response = self._storage.save(
            {
                &#34;origin&#34;: &#34;obsid&#34;,
                &#34;data&#34;: f&#34;{self._obsid.test_id:05d} &#34;
                f&#34;{self._obsid.lab_id} &#34;
                f&#34;{self._obsid.setup_id:05d} &#34;
                f&#34;{self._obsid_start_dt} &#34;
                f&#34;{cmd}&#34;,
            }
        )

        if isinstance(response, Failure):
            LOGGER.warning(
                f&#34;There was a Failure when saving to the obsid-table: &#34;
                f&#34;{response}&#34;)
        else:
            LOGGER.info(f&#34;Successfully created an observation with obsid={self._obsid}.&#34;)

        return Success(&#34;Returning the OBSID&#34;, self._obsid)

    def end_observation(self) -&gt; Response:
        if not self._obsid:
            return Failure(
                &#34;Received end_observation command while not currently in an observation context.&#34;
            )

        if self._storage:
            response = self._storage.end_observation(self._obsid)
        else:
            return Failure(
                &#34;Couldn&#39;t send end observation to Storage Manager, no Storage Manager available.&#34;
            )

        if not response.successful:
            return Failure(
                &#34;Sending an end_observation to the Storage Control Server failed.&#34;,
                response,
            )

        obsid_end_dt = format_datetime()
        obs_duration = humanize_seconds(
            duration(self._obsid_start_dt, obsid_end_dt).total_seconds(),
            include_micro_seconds=False
        )
        LOGGER.info(f&#34;Successfully ended observation with obsid={self._obsid}, duration={obs_duration}.&#34;)

        self._obsid = None
        self._obsid_start_dt = None

        return Success(&#34;Successfully ended the observation.&#34;)

    def get_obsid(self) -&gt; Success:
        if self._obsid:
            msg = &#34;Returning the current OBSID.&#34;
        else:
            msg = &#34;No observation running. Use start_observation() to start an observation.&#34;
        return Success(msg, self._obsid)

    def load_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
        &#34;&#34;&#34;Load the Setup with the given setup_id.

        Args:
            setup_id (int): the identifier for the requested Setup.
        Returns:
            The requested Setup.
        &#34;&#34;&#34;
        # The current implementation is file based. The files have a strict naming convention and
        # are located in the `data/conf` directory.
        #
        # 1. Find the Setup for the given setup_id and the Site (is this read from the Settings
        #    file, or set by some GUI or process?
        # 2. Load that Setup from its file at the default location
        # 3. Return an acknowledgement that the Setup is loaded on the CM_CS or not

        if setup_id is None:
            return Failure(
                f&#34;No Setup ID was given, cannot load a Setup into the configuration manager. &#34;
                f&#34;If you wanted to get the current Setup from the configuration manager, use the &#34;
                f&#34;get_setup() method instead.&#34;
            )

        if self._obsid:
            return Failure(
                f&#34;A new Setup can not be loaded when an observation is running. &#34;
                f&#34;The current obsid is {self._obsid}. Use `end_observation()` before &#34;
                f&#34;loading a new Setup.&#34;
            )

        setup_files = list(
            find_files(
                pattern=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
            )
        )

        if len(setup_files) != 1:
            LOGGER.error(
                msg := f&#34;Expected to find just one Setup YAML file, found {len(setup_files)}. &#34;
                       f&#34;[{SITE.ID = }, {setup_id = }, data_conf_location={self._data_conf_location}]&#34;
            )
            return Failure(&#34;Loading Setup&#34;, InternalError(msg))

        setup_file = setup_files[0]

        try:
            self._setup = Setup.from_yaml_file(setup_file)
            self._setup_id = setup_id
            self._camera_name = self._setup.camera.ID.lower()
            LOGGER.info(f&#34;New Setup loaded from {setup_file}&#34;)
            save_last_setup_id(self._setup_id)
            if self._control_server:
                LOGGER.info(&#34;Notifying listeners for a new Setup!&#34;)
                with Timer(f&#34;Notify Listeners for Setup change, Setup={self._setup_id}&#34;):
                    self._control_server.notify_listeners(
                        EVENT_ID.SETUP,
                        {&#39;event_type&#39;: &#39;new_setup&#39;, &#39;setup_id&#39;: self._setup_id}
                    )

            return self._setup
        except SettingsError as exc:
            return Failure(f&#34;The Setup file can not be loaded from {setup_file}.&#34;, exc)
        except AttributeError as exc:
            msg = f&#34;The Setup [id={setup_id}] has no camera.ID entry.&#34;
            LOGGER.error(msg, exc_info=True)
            # FIXME: if we come here, shouldn&#39;t we load the zero Setup so that the problem of the
            #        missing camera ID gets solved?
            return Failure(msg)

    def get_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
        &#34;&#34;&#34;
        Returns the Setup for the given setup_id. If no setup_id argument was provided,
        the current Setup from the configuration manager will be returned.

        This is a -read-only function.
        Under no circumstance will the Setup of the configuration manager be changed.

        Args:
            setup_id (int): the identifier for the requested Setup.
        Returns:
            The requested Setup.
        &#34;&#34;&#34;

        if setup_id:
            # If a Setup ID is given, just load and return the Setup for that ID
            # The Setup is NOT added to the Configuration Manager as the current Setup.

            setup_files = list(
                find_files(
                    pattern=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
                )
            )

            if len(setup_files) != 1:
                LOGGER.error(
                    msg := f&#34;Expected to find just one Setup YAML file, found {len(setup_files)}.&#34;
                )
                return Failure(&#34;Expected only one Setup.&#34;, InternalError(msg))

            setup_file = setup_files[0]

            try:
                return Setup.from_yaml_file(setup_file)
            except SettingsError as exc:
                return Failure(f&#34;The Setup file can not be loaded from {setup_file}.&#34;, exc)

        else:
            # No Setup ID was given, so we return the current Setup loaded in the Configuration Manager

            if self._setup:
                return self._setup
            else:
                return Failure(&#34;No Setup was loaded on the Configuration Manager.&#34;)

    def get_setup_id(self) -&gt; int:
        &#34;&#34;&#34;Returns the Setup identifier for the currently loaded Setup.

        Returns:
            The `setup_id` of the Setup loaded by the `cm_cs`, or None.
        &#34;&#34;&#34;

        return self._setup_id

    def get_site_id(self) -&gt; str:
        &#34;&#34;&#34;Returns the Site identifier that is used by the configuration manager.

        Returns:
            The Site identifier as a string.
        &#34;&#34;&#34;

        return SITE.ID

    def reload_setups(self):
        &#34;&#34;&#34;
        Clears the cache and Reloads the available Setups.

        This function does not affect the currently loaded Setup.
        &#34;&#34;&#34;
        _reload_cached_setup_info()

    def list_setups(self, **attr):
        &#34;&#34;&#34;
        Returns a sorted list of all the available Setups for the current site. The list contains
        tuples with the following content: setup_id, site_id, description, cam_id.

        Args:
            **attr: see egse.system.filter_by_attr()

        Returns:
            A list with information on the available Setups.
        &#34;&#34;&#34;
        # The current implementation is file based. The files have a strict naming convention and
        # are located in the `data/conf` directory.
        #
        # 1. Get a list of the Setup files from the default location, i.e. data/conf
        # 2. Prepare a list of tuples with that information ordered by Setup ID
        # 3. Return that list

        setup_list = []

        setups = [Setup.from_yaml_file(info.path) for info in _cached_setup_info.values()]

        setups = filter_by_attr(setups, **attr)

        for setup in setups:
            _, setup_site, setup_id, _ = str(setup._filename).split(&#34;_&#34;, maxsplit=3)
            description = _get_description_for_setup(setup, int(setup_id))
            cam_id = _get_cam_id_for_setup(setup)
            setup_list.append((setup_id, setup_site, description, cam_id))

        # Sort by site, then by id

        return sorted(setup_list, key=operator.itemgetter(1, 0), reverse=False)

    def get_setup_for_obsid(self, obsid):
        obsid = f&#34;{obsid:05d}&#34; if isinstance(obsid, int) else obsid
        rc = self._storage.read({&#34;origin&#34;: &#34;obsid&#34;, &#34;select&#34;: (&#34;startswith&#34;, obsid)})
        if rc.successful:
            # FIXME: this should be a function that can also be used in load_setup(),
            #  because they do basically the same thing
            try:
                setup_id = int(rc.return_code[-1].split(maxsplit=3)[2])
                setup_file = find_file(
                    name=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
                )
                setup = Setup.from_yaml_file(setup_file)
            except (IndexError, SettingsError):
                setup = None

        return setup

    def submit_setup(self, setup: Setup, description: str, replace: bool = True):

        # 1. Determine the Site for this Setup, or should this be the Site that is known by the
        #    CM_CS?
        # 2. Find the correct (next) number for the Setup for the given Site
        # 3. Do I want to make some comparison?
        #    Do we need to keep a record from which this Setup is derived?

        # FIXME: define and handle exceptional conditions, like IOError

        if self._obsid is not None:
            return Failure(
                &#34;An new Setup can not be submitted when an observation is running. You will need &#34;
                &#34;to first send an end_observation request to the configuration manager.&#34;
            )

        site = setup.site_id

        setup_id = self.get_next_setup_id_for_site(site)

        filename = _construct_filename(SITE.ID, setup_id)

        if not hasattr(setup, &#34;history&#34;):
            setup.history = {}

        setup.history.update({f&#34;{setup_id}&#34;: description})
        setup.set_private_attribute(&#34;_setup_id&#34;, setup_id)
        setup.to_yaml_file(self._data_conf_location / filename)

        try:
            rc = _push_setup_to_repo(filename, description)
            if isinstance(rc, Failure):
                return rc
            _add_setup_info_to_cache(setup)
        except (Exception, ) as exc:
            msg = &#34;Submit_setup could not complete it&#39;s task to send the new Setup to the repo.&#34;
            LOGGER.error(msg, exc_info=True)
            return Failure(&#34;Submit_setup could not complete it&#39;s task to send the new Setup to the repo.&#34;, exc)
        else:
            LOGGER.info(f&#34;Successfully pushed Setup {setup_id} to the repository.&#34;)

        if replace:
            self._setup = setup
            self._setup_id = setup_id
            LOGGER.info(f&#34;New Setup was submitted and loaded: {setup_id=}&#34;)
            self._camera_name = self._setup.camera.ID.lower()
            save_last_setup_id(setup_id)
            if self._control_server:
                LOGGER.info(&#34;Notifying listeners for a new Setup!&#34;)
                with Timer(f&#34;Notify Listeners for Setup change, Setup={self._setup_id}&#34;):
                    self._control_server.notify_listeners(
                        EVENT_ID.SETUP,
                        {&#39;event_type&#39;: &#39;new_setup&#39;, &#39;setup_id&#39;: setup_id}
                    )

        return setup

    def get_next_setup_id_for_site(self, site: str) -&gt; int:
        &#34;&#34;&#34;Return the next available Setup ID for the given Site.

        Args:
            site (str): site identification, e.g. CSL, SRON, ...
        &#34;&#34;&#34;
        site = site or SITE.ID
        files = sorted(find_files(pattern=f&#34;SETUP_{site}_*.yaml&#34;, root=self._data_conf_location))
        last_file = files[-1]
        setup_id = last_file.name.split(&#34;_&#34;)[2]

        return int(setup_id) + 1

    def get_listener_names(self):
        &#34;&#34;&#34;Returns the names of the control servers that are listening for a new Setup.&#34;&#34;&#34;
        return self._control_server.get_listener_names()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.confman.ConfigurationManagerInterface" href="#egse.confman.ConfigurationManagerInterface">ConfigurationManagerInterface</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="egse.confman.ConfigurationManagerController.data_location"><code class="name">var <span class="ident">data_location</span> :Â pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Return the location of the configuration data, i.e. the Setup YAML files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_location(self) -&gt; Path:
    &#34;&#34;&#34;Return the location of the configuration data, i.e. the Setup YAML files.&#34;&#34;&#34;
    return self._data_conf_location</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.confman.ConfigurationManagerController.get_listener_names"><code class="name flex">
<span>def <span class="ident">get_listener_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the names of the control servers that are listening for a new Setup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_listener_names(self):
    &#34;&#34;&#34;Returns the names of the control servers that are listening for a new Setup.&#34;&#34;&#34;
    return self._control_server.get_listener_names()</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.get_next_setup_id_for_site"><code class="name flex">
<span>def <span class="ident">get_next_setup_id_for_site</span></span>(<span>self, site:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the next available Setup ID for the given Site.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code></dt>
<dd>site identification, e.g. CSL, SRON, &hellip;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_setup_id_for_site(self, site: str) -&gt; int:
    &#34;&#34;&#34;Return the next available Setup ID for the given Site.

    Args:
        site (str): site identification, e.g. CSL, SRON, ...
    &#34;&#34;&#34;
    site = site or SITE.ID
    files = sorted(find_files(pattern=f&#34;SETUP_{site}_*.yaml&#34;, root=self._data_conf_location))
    last_file = files[-1]
    setup_id = last_file.name.split(&#34;_&#34;)[2]

    return int(setup_id) + 1</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.get_setup"><code class="name flex">
<span>def <span class="ident">get_setup</span></span>(<span>self, setup_id:Â intÂ =Â None) â€‘>Â Union[<a title="egse.setup.Setup" href="../setup.html#egse.setup.Setup">Setup</a>,Â <a title="egse.control.Failure" href="../control.html#egse.control.Failure">Failure</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Setup for the given setup_id. If no setup_id argument was provided,
the current Setup from the configuration manager will be returned.</p>
<p>This is a -read-only function.
Under no circumstance will the Setup of the configuration manager be changed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>setup_id</code></strong> :&ensp;<code>int</code></dt>
<dd>the identifier for the requested Setup.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested Setup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
    &#34;&#34;&#34;
    Returns the Setup for the given setup_id. If no setup_id argument was provided,
    the current Setup from the configuration manager will be returned.

    This is a -read-only function.
    Under no circumstance will the Setup of the configuration manager be changed.

    Args:
        setup_id (int): the identifier for the requested Setup.
    Returns:
        The requested Setup.
    &#34;&#34;&#34;

    if setup_id:
        # If a Setup ID is given, just load and return the Setup for that ID
        # The Setup is NOT added to the Configuration Manager as the current Setup.

        setup_files = list(
            find_files(
                pattern=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
            )
        )

        if len(setup_files) != 1:
            LOGGER.error(
                msg := f&#34;Expected to find just one Setup YAML file, found {len(setup_files)}.&#34;
            )
            return Failure(&#34;Expected only one Setup.&#34;, InternalError(msg))

        setup_file = setup_files[0]

        try:
            return Setup.from_yaml_file(setup_file)
        except SettingsError as exc:
            return Failure(f&#34;The Setup file can not be loaded from {setup_file}.&#34;, exc)

    else:
        # No Setup ID was given, so we return the current Setup loaded in the Configuration Manager

        if self._setup:
            return self._setup
        else:
            return Failure(&#34;No Setup was loaded on the Configuration Manager.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.get_setup_for_obsid"><code class="name flex">
<span>def <span class="ident">get_setup_for_obsid</span></span>(<span>self, obsid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_setup_for_obsid(self, obsid):
    obsid = f&#34;{obsid:05d}&#34; if isinstance(obsid, int) else obsid
    rc = self._storage.read({&#34;origin&#34;: &#34;obsid&#34;, &#34;select&#34;: (&#34;startswith&#34;, obsid)})
    if rc.successful:
        # FIXME: this should be a function that can also be used in load_setup(),
        #  because they do basically the same thing
        try:
            setup_id = int(rc.return_code[-1].split(maxsplit=3)[2])
            setup_file = find_file(
                name=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
            )
            setup = Setup.from_yaml_file(setup_file)
        except (IndexError, SettingsError):
            setup = None

    return setup</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.get_setup_id"><code class="name flex">
<span>def <span class="ident">get_setup_id</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Setup identifier for the currently loaded Setup.</p>
<h2 id="returns">Returns</h2>
<p>The <code>setup_id</code> of the Setup loaded by the <code>cm_cs</code>, or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_setup_id(self) -&gt; int:
    &#34;&#34;&#34;Returns the Setup identifier for the currently loaded Setup.

    Returns:
        The `setup_id` of the Setup loaded by the `cm_cs`, or None.
    &#34;&#34;&#34;

    return self._setup_id</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.get_site_id"><code class="name flex">
<span>def <span class="ident">get_site_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Site identifier that is used by the configuration manager.</p>
<h2 id="returns">Returns</h2>
<p>The Site identifier as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_site_id(self) -&gt; str:
    &#34;&#34;&#34;Returns the Site identifier that is used by the configuration manager.

    Returns:
        The Site identifier as a string.
    &#34;&#34;&#34;

    return SITE.ID</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.list_setups"><code class="name flex">
<span>def <span class="ident">list_setups</span></span>(<span>self, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sorted list of all the available Setups for the current site. The list contains
tuples with the following content: setup_id, site_id, description, cam_id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**attr</code></strong></dt>
<dd>see egse.system.filter_by_attr()</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list with information on the available Setups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_setups(self, **attr):
    &#34;&#34;&#34;
    Returns a sorted list of all the available Setups for the current site. The list contains
    tuples with the following content: setup_id, site_id, description, cam_id.

    Args:
        **attr: see egse.system.filter_by_attr()

    Returns:
        A list with information on the available Setups.
    &#34;&#34;&#34;
    # The current implementation is file based. The files have a strict naming convention and
    # are located in the `data/conf` directory.
    #
    # 1. Get a list of the Setup files from the default location, i.e. data/conf
    # 2. Prepare a list of tuples with that information ordered by Setup ID
    # 3. Return that list

    setup_list = []

    setups = [Setup.from_yaml_file(info.path) for info in _cached_setup_info.values()]

    setups = filter_by_attr(setups, **attr)

    for setup in setups:
        _, setup_site, setup_id, _ = str(setup._filename).split(&#34;_&#34;, maxsplit=3)
        description = _get_description_for_setup(setup, int(setup_id))
        cam_id = _get_cam_id_for_setup(setup)
        setup_list.append((setup_id, setup_site, description, cam_id))

    # Sort by site, then by id

    return sorted(setup_list, key=operator.itemgetter(1, 0), reverse=False)</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.load_setup"><code class="name flex">
<span>def <span class="ident">load_setup</span></span>(<span>self, setup_id:Â intÂ =Â None) â€‘>Â Union[<a title="egse.setup.Setup" href="../setup.html#egse.setup.Setup">Setup</a>,Â <a title="egse.control.Failure" href="../control.html#egse.control.Failure">Failure</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load the Setup with the given setup_id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>setup_id</code></strong> :&ensp;<code>int</code></dt>
<dd>the identifier for the requested Setup.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The requested Setup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
    &#34;&#34;&#34;Load the Setup with the given setup_id.

    Args:
        setup_id (int): the identifier for the requested Setup.
    Returns:
        The requested Setup.
    &#34;&#34;&#34;
    # The current implementation is file based. The files have a strict naming convention and
    # are located in the `data/conf` directory.
    #
    # 1. Find the Setup for the given setup_id and the Site (is this read from the Settings
    #    file, or set by some GUI or process?
    # 2. Load that Setup from its file at the default location
    # 3. Return an acknowledgement that the Setup is loaded on the CM_CS or not

    if setup_id is None:
        return Failure(
            f&#34;No Setup ID was given, cannot load a Setup into the configuration manager. &#34;
            f&#34;If you wanted to get the current Setup from the configuration manager, use the &#34;
            f&#34;get_setup() method instead.&#34;
        )

    if self._obsid:
        return Failure(
            f&#34;A new Setup can not be loaded when an observation is running. &#34;
            f&#34;The current obsid is {self._obsid}. Use `end_observation()` before &#34;
            f&#34;loading a new Setup.&#34;
        )

    setup_files = list(
        find_files(
            pattern=f&#34;SETUP_{SITE.ID}_{setup_id:05d}_*.yaml&#34;, root=self._data_conf_location
        )
    )

    if len(setup_files) != 1:
        LOGGER.error(
            msg := f&#34;Expected to find just one Setup YAML file, found {len(setup_files)}. &#34;
                   f&#34;[{SITE.ID = }, {setup_id = }, data_conf_location={self._data_conf_location}]&#34;
        )
        return Failure(&#34;Loading Setup&#34;, InternalError(msg))

    setup_file = setup_files[0]

    try:
        self._setup = Setup.from_yaml_file(setup_file)
        self._setup_id = setup_id
        self._camera_name = self._setup.camera.ID.lower()
        LOGGER.info(f&#34;New Setup loaded from {setup_file}&#34;)
        save_last_setup_id(self._setup_id)
        if self._control_server:
            LOGGER.info(&#34;Notifying listeners for a new Setup!&#34;)
            with Timer(f&#34;Notify Listeners for Setup change, Setup={self._setup_id}&#34;):
                self._control_server.notify_listeners(
                    EVENT_ID.SETUP,
                    {&#39;event_type&#39;: &#39;new_setup&#39;, &#39;setup_id&#39;: self._setup_id}
                )

        return self._setup
    except SettingsError as exc:
        return Failure(f&#34;The Setup file can not be loaded from {setup_file}.&#34;, exc)
    except AttributeError as exc:
        msg = f&#34;The Setup [id={setup_id}] has no camera.ID entry.&#34;
        LOGGER.error(msg, exc_info=True)
        # FIXME: if we come here, shouldn&#39;t we load the zero Setup so that the problem of the
        #        missing camera ID gets solved?
        return Failure(msg)</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    if self._storage:
        self._storage.disconnect_cs()</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.reload_setups"><code class="name flex">
<span>def <span class="ident">reload_setups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the cache and Reloads the available Setups.</p>
<p>This function does not affect the currently loaded Setup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload_setups(self):
    &#34;&#34;&#34;
    Clears the cache and Reloads the available Setups.

    This function does not affect the currently loaded Setup.
    &#34;&#34;&#34;
    _reload_cached_setup_info()</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerController.submit_setup"><code class="name flex">
<span>def <span class="ident">submit_setup</span></span>(<span>self, setup:Â Setup, description:Â str, replace:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_setup(self, setup: Setup, description: str, replace: bool = True):

    # 1. Determine the Site for this Setup, or should this be the Site that is known by the
    #    CM_CS?
    # 2. Find the correct (next) number for the Setup for the given Site
    # 3. Do I want to make some comparison?
    #    Do we need to keep a record from which this Setup is derived?

    # FIXME: define and handle exceptional conditions, like IOError

    if self._obsid is not None:
        return Failure(
            &#34;An new Setup can not be submitted when an observation is running. You will need &#34;
            &#34;to first send an end_observation request to the configuration manager.&#34;
        )

    site = setup.site_id

    setup_id = self.get_next_setup_id_for_site(site)

    filename = _construct_filename(SITE.ID, setup_id)

    if not hasattr(setup, &#34;history&#34;):
        setup.history = {}

    setup.history.update({f&#34;{setup_id}&#34;: description})
    setup.set_private_attribute(&#34;_setup_id&#34;, setup_id)
    setup.to_yaml_file(self._data_conf_location / filename)

    try:
        rc = _push_setup_to_repo(filename, description)
        if isinstance(rc, Failure):
            return rc
        _add_setup_info_to_cache(setup)
    except (Exception, ) as exc:
        msg = &#34;Submit_setup could not complete it&#39;s task to send the new Setup to the repo.&#34;
        LOGGER.error(msg, exc_info=True)
        return Failure(&#34;Submit_setup could not complete it&#39;s task to send the new Setup to the repo.&#34;, exc)
    else:
        LOGGER.info(f&#34;Successfully pushed Setup {setup_id} to the repository.&#34;)

    if replace:
        self._setup = setup
        self._setup_id = setup_id
        LOGGER.info(f&#34;New Setup was submitted and loaded: {setup_id=}&#34;)
        self._camera_name = self._setup.camera.ID.lower()
        save_last_setup_id(setup_id)
        if self._control_server:
            LOGGER.info(&#34;Notifying listeners for a new Setup!&#34;)
            with Timer(f&#34;Notify Listeners for Setup change, Setup={self._setup_id}&#34;):
                self._control_server.notify_listeners(
                    EVENT_ID.SETUP,
                    {&#39;event_type&#39;: &#39;new_setup&#39;, &#39;setup_id&#39;: setup_id}
                )

    return setup</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.confman.ConfigurationManagerInterface" href="#egse.confman.ConfigurationManagerInterface">ConfigurationManagerInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.confman.ConfigurationManagerInterface.end_observation" href="#egse.confman.ConfigurationManagerInterface.end_observation">end_observation</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.get_obsid" href="#egse.confman.ConfigurationManagerInterface.get_obsid">get_obsid</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.start_observation" href="#egse.confman.ConfigurationManagerInterface.start_observation">start_observation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface"><code class="flex name class">
<span>class <span class="ident">ConfigurationManagerInterface</span></span>
</code></dt>
<dd>
<div class="desc"><p>This interface is for sending commands to the configuration manager to e.g. start and stop
an observation/test, or get information about the Setups.</p>
<p>The interface should be implemented by the <code><a title="egse.confman.ConfigurationManagerController" href="#egse.confman.ConfigurationManagerController">ConfigurationManagerController</a></code> and the
<code><a title="egse.confman.ConfigurationManagerProxy" href="#egse.confman.ConfigurationManagerProxy">ConfigurationManagerProxy</a></code> (and possibly a <code>ConfigurationManagerSimulator</code> should we
need that e.g. for testing purposes).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationManagerInterface:
    &#34;&#34;&#34;
    This interface is for sending commands to the configuration manager to e.g. start and stop
    an observation/test, or get information about the Setups.

    The interface should be implemented by the `ConfigurationManagerController` and the
    `ConfigurationManagerProxy` (and possibly a `ConfigurationManagerSimulator` should we
    need that e.g. for testing purposes).
    &#34;&#34;&#34;

    @dynamic_interface
    def start_observation(self, function_info: dict) -&gt; Response:
        &#34;&#34;&#34;Starts a new observation or test. The following actions will be taken:

        * create an observation identifier, aka `obsid`
        * notify the Storage Control Server that a new observation is started
        * return the generated `obsid`

        Args:
            function_info: dictionary with information about the function called
        Returns:
            `Success` (with `obsid` as `return_code`) or `Failure` when already in an observation
            or Storage returned Failure.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def end_observation(self) -&gt; Response:
        &#34;&#34;&#34;Ends the current observation and notifies the Storage Control Server.

        Returns:
            `Success` when the observation could be closed properly and the Storage CS was notified
            or `Failure` otherwise.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def get_obsid(self) -&gt; Success:
        &#34;&#34;&#34;Returns the current observation identifier. When no observation is running, `None` is
        returned as the `return_code` in `Success`.

        Returns:
            Always returns `Success` with current observation identifier, i.e. `obsid`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @dynamic_interface
    def load_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
        raise NotImplementedError

    @dynamic_interface
    def get_setup(self, setup_id: int = None):
        raise NotImplementedError

    @dynamic_interface
    def reload_setups(self):
        raise NotImplementedError

    @dynamic_interface
    def list_setups(self, **attr):
        raise NotImplementedError

    @dynamic_interface
    def submit_setup(self, setup: Setup, description: str, replace: bool = True) -&gt; Setup | None:
        raise NotImplementedError

    @dynamic_interface
    def get_setup_for_obsid(self, obsid):
        raise NotImplementedError

    @dynamic_interface
    def get_listener_names(self):
        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.confman.ConfigurationManagerController" href="#egse.confman.ConfigurationManagerController">ConfigurationManagerController</a></li>
<li><a title="egse.confman.ConfigurationManagerProxy" href="#egse.confman.ConfigurationManagerProxy">ConfigurationManagerProxy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.confman.ConfigurationManagerInterface.end_observation"><code class="name flex">
<span>def <span class="ident">end_observation</span></span>(<span>self) â€‘>Â <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Ends the current observation and notifies the Storage Control Server.</p>
<h2 id="returns">Returns</h2>
<p><code>Success</code> when the observation could be closed properly and the Storage CS was notified
or <code>Failure</code> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def end_observation(self) -&gt; Response:
    &#34;&#34;&#34;Ends the current observation and notifies the Storage Control Server.

    Returns:
        `Success` when the observation could be closed properly and the Storage CS was notified
        or `Failure` otherwise.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.get_listener_names"><code class="name flex">
<span>def <span class="ident">get_listener_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_listener_names(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.get_obsid"><code class="name flex">
<span>def <span class="ident">get_obsid</span></span>(<span>self) â€‘>Â <a title="egse.control.Success" href="../control.html#egse.control.Success">Success</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current observation identifier. When no observation is running, <code>None</code> is
returned as the <code>return_code</code> in <code>Success</code>.</p>
<h2 id="returns">Returns</h2>
<p>Always returns <code>Success</code> with current observation identifier, i.e. <code>obsid</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_obsid(self) -&gt; Success:
    &#34;&#34;&#34;Returns the current observation identifier. When no observation is running, `None` is
    returned as the `return_code` in `Success`.

    Returns:
        Always returns `Success` with current observation identifier, i.e. `obsid`.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.get_setup"><code class="name flex">
<span>def <span class="ident">get_setup</span></span>(<span>self, setup_id:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_setup(self, setup_id: int = None):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.get_setup_for_obsid"><code class="name flex">
<span>def <span class="ident">get_setup_for_obsid</span></span>(<span>self, obsid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def get_setup_for_obsid(self, obsid):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.list_setups"><code class="name flex">
<span>def <span class="ident">list_setups</span></span>(<span>self, **attr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def list_setups(self, **attr):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.load_setup"><code class="name flex">
<span>def <span class="ident">load_setup</span></span>(<span>self, setup_id:Â intÂ =Â None) â€‘>Â Union[<a title="egse.setup.Setup" href="../setup.html#egse.setup.Setup">Setup</a>,Â <a title="egse.control.Failure" href="../control.html#egse.control.Failure">Failure</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def load_setup(self, setup_id: int = None) -&gt; Union[Setup, Failure]:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.reload_setups"><code class="name flex">
<span>def <span class="ident">reload_setups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def reload_setups(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.start_observation"><code class="name flex">
<span>def <span class="ident">start_observation</span></span>(<span>self, function_info:Â dict) â€‘>Â <a title="egse.control.Response" href="../control.html#egse.control.Response">Response</a></span>
</code></dt>
<dd>
<div class="desc"><p>Starts a new observation or test. The following actions will be taken:</p>
<ul>
<li>create an observation identifier, aka <code>obsid</code></li>
<li>notify the Storage Control Server that a new observation is started</li>
<li>return the generated <code>obsid</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function_info</code></strong></dt>
<dd>dictionary with information about the function called</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Success</code> (with <code>obsid</code> as <code>return_code</code>) or <code>Failure</code> when already in an observation
or Storage returned Failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def start_observation(self, function_info: dict) -&gt; Response:
    &#34;&#34;&#34;Starts a new observation or test. The following actions will be taken:

    * create an observation identifier, aka `obsid`
    * notify the Storage Control Server that a new observation is started
    * return the generated `obsid`

    Args:
        function_info: dictionary with information about the function called
    Returns:
        `Success` (with `obsid` as `return_code`) or `Failure` when already in an observation
        or Storage returned Failure.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="egse.confman.ConfigurationManagerInterface.submit_setup"><code class="name flex">
<span>def <span class="ident">submit_setup</span></span>(<span>self, setup:Â Setup, description:Â str, replace:Â boolÂ =Â True) â€‘>Â SetupÂ |Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dynamic_interface
def submit_setup(self, setup: Setup, description: str, replace: bool = True) -&gt; Setup | None:
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.confman.ConfigurationManagerProtocol"><code class="flex name class">
<span>class <span class="ident">ConfigurationManagerProtocol</span></span>
<span>(</span><span>control_server:Â ControlServer)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the glue between the control servers and the hardware
controllers on one side, and between the control server and the connected
proxy classes on the other side.</p>
<p>The connection with the hardware controllers is when the <code>execute()</code> method
calls the <code>server_call()</code> method of the command class.</p>
<p>The connection with the proxy classes is when the <code>client_call()</code> method is added to the
interface of the Proxy subclass (by the <code>_add_commands()</code> method).</p>
<p>FIXME: Protocol is not used at the client side, i.e. the Proxy class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationManagerProtocol(CommandProtocol):
    def __init__(self, control_server: ControlServer):
        super().__init__()
        self.control_server = control_server

        self.controller = ConfigurationManagerController(control_server)

        self.load_commands(
            COMMAND_SETTINGS.Commands,
            ConfigurationManagerCommand,
            ConfigurationManagerController,
        )

        self.build_device_method_lookup_table(self.controller)

        self.cgse_version = VERSION

        try:
            self.git_version = subprocess.check_output(
                [&#34;git&#34;, &#34;describe&#34;, &#34;--tags&#34;, &#34;--long&#34;], stderr=subprocess.STDOUT)
            self.git_version = self.git_version.strip().decode(&#34;ascii&#34;)
        except subprocess.CalledProcessError as exc:
            LOGGER.debug(
                f&#34;A git error occurred for the `git describe` command: {exc}&#34;, stack_info=True)
            self.git_version = &#34;no git-version determined&#34;

    def get_bind_address(self):
        return bind_address(
            self.control_server.get_communication_protocol(),
            self.control_server.get_commanding_port(),
        )

    def get_status(self) -&gt; dict:
        status = super().get_status()

        status.update({&#34;obsid&#34;: self.controller.get_obsid().return_code})
        status.update({&#34;setup&#34;: self.controller.get_setup()})

        return status

    def get_housekeeping(self) -&gt; dict:
        obsid = self.controller.get_obsid().return_code
        test_id = obsid.test_id if obsid else float(&#39;nan&#39;)
        setup_id = self.controller.get_setup_id()
        site_id = self.controller.get_site_id()

        hk = {
            &#34;timestamp&#34;: format_datetime(),
            &#34;CM_SITE_ID&#34;: site_id,
            &#34;CM_SETUP_ID&#34;: setup_id,
            &#34;CM_TEST_ID&#34;: test_id,
            &#34;CM_OBSID&#34;: obsid,
            &#34;CM_CGSE_VERSION&#34;: self.cgse_version,
            &#34;CM_GIT_VERSION&#34;: self.git_version,
        }

        # Update the metrics

        CM_SETUP_ID.set(float(setup_id))
        CM_TEST_ID.set(float(test_id))

        return hk

    def quit(self):
        self.controller.quit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></li>
<li><a title="egse.device.DeviceConnectionObserver" href="../device.html#egse.device.DeviceConnectionObserver">DeviceConnectionObserver</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.protocol.CommandProtocol" href="../protocol.html#egse.protocol.CommandProtocol">CommandProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.protocol.CommandProtocol.bind" href="../protocol.html#egse.protocol.CommandProtocol.bind">bind</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.build_device_method_lookup_table" href="../protocol.html#egse.protocol.CommandProtocol.build_device_method_lookup_table">build_device_method_lookup_table</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_bind_address" href="../protocol.html#egse.protocol.CommandProtocol.get_bind_address">get_bind_address</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_housekeeping" href="../protocol.html#egse.protocol.CommandProtocol.get_housekeeping">get_housekeeping</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.get_status" href="../protocol.html#egse.protocol.CommandProtocol.get_status">get_status</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.handle_device_method" href="../protocol.html#egse.protocol.CommandProtocol.handle_device_method">handle_device_method</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.is_alive" href="../protocol.html#egse.protocol.CommandProtocol.is_alive">is_alive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.load_commands" href="../protocol.html#egse.protocol.CommandProtocol.load_commands">load_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.quit" href="../protocol.html#egse.protocol.CommandProtocol.quit">quit</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.receive" href="../protocol.html#egse.protocol.CommandProtocol.receive">receive</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send" href="../protocol.html#egse.protocol.CommandProtocol.send">send</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.send_commands" href="../protocol.html#egse.protocol.CommandProtocol.send_commands">send_commands</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.state" href="../device.html#egse.device.DeviceConnectionObserver.state">state</a></code></li>
<li><code><a title="egse.protocol.CommandProtocol.update_connection_state" href="../device.html#egse.device.DeviceConnectionObserver.update_connection_state">update_connection_state</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.confman.ConfigurationManagerProxy"><code class="flex name class">
<span>class <span class="ident">ConfigurationManagerProxy</span></span>
<span>(</span><span>protocol='tcp', hostname='localhost', port=6000, timeout=10000)</span>
</code></dt>
<dd>
<div class="desc"><p>The Configuration Manager Proxy class is used to connect to the Configuration Manager
Control Server and send commands and requests for the configuration manager.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol</code></strong></dt>
<dd>the transport protocol [default is taken from settings file]</dd>
<dt><strong><code>hostname</code></strong></dt>
<dd>location of the control server (IP address) [default is taken
from settings file]</dd>
<dt><strong><code>port</code></strong></dt>
<dd>TCP port on which the control server is listening for commands
[default is taken from settings file]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigurationManagerProxy(Proxy, ConfigurationManagerInterface):
    &#34;&#34;&#34;
    The Configuration Manager Proxy class is used to connect to the Configuration Manager
    Control Server and send commands and requests for the configuration manager.
    &#34;&#34;&#34;

    def __init__(
        self,
        protocol=CTRL_SETTINGS.PROTOCOL,
        hostname=CTRL_SETTINGS.HOSTNAME,
        port=CTRL_SETTINGS.COMMANDING_PORT,
        timeout=PROXY_TIMEOUT,
    ):
        &#34;&#34;&#34;
        Args:
            protocol: the transport protocol [default is taken from settings file]
            hostname: location of the control server (IP address) [default is taken
                from settings file]
            port: TCP port on which the control server is listening for commands
                [default is taken from settings file]
        &#34;&#34;&#34;
        super().__init__(connect_address(protocol, hostname, port), timeout=timeout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.proxy.Proxy" href="../proxy.html#egse.proxy.Proxy">Proxy</a></li>
<li><a title="egse.proxy.BaseProxy" href="../proxy.html#egse.proxy.BaseProxy">BaseProxy</a></li>
<li><a title="egse.proxy.ControlServerConnectionInterface" href="../proxy.html#egse.proxy.ControlServerConnectionInterface">ControlServerConnectionInterface</a></li>
<li><a title="egse.confman.ConfigurationManagerInterface" href="#egse.confman.ConfigurationManagerInterface">ConfigurationManagerInterface</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="egse.proxy.Proxy" href="../proxy.html#egse.proxy.Proxy">Proxy</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.proxy.Proxy.connect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.connect_cs">connect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.disconnect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.disconnect_cs">disconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commanding_port" href="../proxy.html#egse.proxy.BaseProxy.get_commanding_port">get_commanding_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_commands" href="../proxy.html#egse.proxy.Proxy.get_commands">get_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_endpoint" href="../proxy.html#egse.proxy.Proxy.get_endpoint">get_endpoint</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_ip_address" href="../proxy.html#egse.proxy.BaseProxy.get_ip_address">get_ip_address</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_monitoring_port" href="../proxy.html#egse.proxy.BaseProxy.get_monitoring_port">get_monitoring_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_port" href="../proxy.html#egse.proxy.BaseProxy.get_service_port">get_service_port</a></code></li>
<li><code><a title="egse.proxy.Proxy.get_service_proxy" href="../proxy.html#egse.proxy.BaseProxy.get_service_proxy">get_service_proxy</a></code></li>
<li><code><a title="egse.proxy.Proxy.has_commands" href="../proxy.html#egse.proxy.Proxy.has_commands">has_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.is_cs_connected" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.is_cs_connected">is_cs_connected</a></code></li>
<li><code><a title="egse.proxy.Proxy.load_commands" href="../proxy.html#egse.proxy.Proxy.load_commands">load_commands</a></code></li>
<li><code><a title="egse.proxy.Proxy.reconnect_cs" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.reconnect_cs">reconnect_cs</a></code></li>
<li><code><a title="egse.proxy.Proxy.reset_cs_connection" href="../proxy.html#egse.proxy.ControlServerConnectionInterface.reset_cs_connection">reset_cs_connection</a></code></li>
<li><code><a title="egse.proxy.Proxy.send" href="../proxy.html#egse.proxy.BaseProxy.send">send</a></code></li>
</ul>
</li>
<li><code><b><a title="egse.confman.ConfigurationManagerInterface" href="#egse.confman.ConfigurationManagerInterface">ConfigurationManagerInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="egse.confman.ConfigurationManagerInterface.end_observation" href="#egse.confman.ConfigurationManagerInterface.end_observation">end_observation</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.get_obsid" href="#egse.confman.ConfigurationManagerInterface.get_obsid">get_obsid</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.start_observation" href="#egse.confman.ConfigurationManagerInterface.start_observation">start_observation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="egse.confman.SetupInfo"><code class="flex name class">
<span>class <span class="ident">SetupInfo</span></span>
<span>(</span><span>path:Â Path, site_id:Â str, cam_id:Â str, description:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>SetupInfo(path, site_id, cam_id, description)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetupInfo(NamedTuple):
    path: Path
    site_id: str
    cam_id: str
    description: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="egse.confman.SetupInfo.cam_id"><code class="name">var <span class="ident">cam_id</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="egse.confman.SetupInfo.description"><code class="name">var <span class="ident">description</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="egse.confman.SetupInfo.path"><code class="name">var <span class="ident">path</span> :Â pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="egse.confman.SetupInfo.site_id"><code class="name">var <span class="ident">site_id</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#the-configuration-aka-setup">The Configuration aka Setup</a></li>
<li><a href="#prerequisites">Prerequisites:</a></li>
<li><a href="#setup-commands">Setup commands</a><ul>
<li><a href="#list_setups">list_setups()</a></li>
<li><a href="#load_setupsetup_id-int">load_setup(setup_id: int)</a></li>
<li><a href="#get_setup">get_setup()</a></li>
</ul>
</li>
<li><a href="#observation-aka-test-commands">Observation (aka Test) Commands</a><ul>
<li><a href="#start_observation">start_observation()</a></li>
<li><a href="#end_observation">end_observation()</a></li>
<li><a href="#get_obsid">get_obsid()</a></li>
</ul>
</li>
<li><a href="#convenience-functions">Convenience Functions</a><ul>
<li><a href="#is_configuration_manager_active">is_configuration_manager_active()</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="../index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="egse.confman.confman_cs" href="confman_cs.html">egse.confman.confman_cs</a></code></li>
<li><code><a title="egse.confman.confman_ui" href="confman_ui.html">egse.confman.confman_ui</a></code></li>
<li><code><a title="egse.confman.setup_ui" href="setup_ui.html">egse.confman.setup_ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.confman.create_obsid" href="#egse.confman.create_obsid">create_obsid</a></code></li>
<li><code><a title="egse.confman.is_configuration_manager_active" href="#egse.confman.is_configuration_manager_active">is_configuration_manager_active</a></code></li>
<li><code><a title="egse.confman.is_in" href="#egse.confman.is_in">is_in</a></code></li>
<li><code><a title="egse.confman.is_not_in" href="#egse.confman.is_not_in">is_not_in</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.confman.ConfigurationManagerCommand" href="#egse.confman.ConfigurationManagerCommand">ConfigurationManagerCommand</a></code></h4>
</li>
<li>
<h4><code><a title="egse.confman.ConfigurationManagerController" href="#egse.confman.ConfigurationManagerController">ConfigurationManagerController</a></code></h4>
<ul class="">
<li><code><a title="egse.confman.ConfigurationManagerController.data_location" href="#egse.confman.ConfigurationManagerController.data_location">data_location</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.get_listener_names" href="#egse.confman.ConfigurationManagerController.get_listener_names">get_listener_names</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.get_next_setup_id_for_site" href="#egse.confman.ConfigurationManagerController.get_next_setup_id_for_site">get_next_setup_id_for_site</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.get_setup" href="#egse.confman.ConfigurationManagerController.get_setup">get_setup</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.get_setup_for_obsid" href="#egse.confman.ConfigurationManagerController.get_setup_for_obsid">get_setup_for_obsid</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.get_setup_id" href="#egse.confman.ConfigurationManagerController.get_setup_id">get_setup_id</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.get_site_id" href="#egse.confman.ConfigurationManagerController.get_site_id">get_site_id</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.list_setups" href="#egse.confman.ConfigurationManagerController.list_setups">list_setups</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.load_setup" href="#egse.confman.ConfigurationManagerController.load_setup">load_setup</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.quit" href="#egse.confman.ConfigurationManagerController.quit">quit</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.reload_setups" href="#egse.confman.ConfigurationManagerController.reload_setups">reload_setups</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerController.submit_setup" href="#egse.confman.ConfigurationManagerController.submit_setup">submit_setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.confman.ConfigurationManagerInterface" href="#egse.confman.ConfigurationManagerInterface">ConfigurationManagerInterface</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.confman.ConfigurationManagerInterface.end_observation" href="#egse.confman.ConfigurationManagerInterface.end_observation">end_observation</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.get_listener_names" href="#egse.confman.ConfigurationManagerInterface.get_listener_names">get_listener_names</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.get_obsid" href="#egse.confman.ConfigurationManagerInterface.get_obsid">get_obsid</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.get_setup" href="#egse.confman.ConfigurationManagerInterface.get_setup">get_setup</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.get_setup_for_obsid" href="#egse.confman.ConfigurationManagerInterface.get_setup_for_obsid">get_setup_for_obsid</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.list_setups" href="#egse.confman.ConfigurationManagerInterface.list_setups">list_setups</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.load_setup" href="#egse.confman.ConfigurationManagerInterface.load_setup">load_setup</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.reload_setups" href="#egse.confman.ConfigurationManagerInterface.reload_setups">reload_setups</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.start_observation" href="#egse.confman.ConfigurationManagerInterface.start_observation">start_observation</a></code></li>
<li><code><a title="egse.confman.ConfigurationManagerInterface.submit_setup" href="#egse.confman.ConfigurationManagerInterface.submit_setup">submit_setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.confman.ConfigurationManagerProtocol" href="#egse.confman.ConfigurationManagerProtocol">ConfigurationManagerProtocol</a></code></h4>
</li>
<li>
<h4><code><a title="egse.confman.ConfigurationManagerProxy" href="#egse.confman.ConfigurationManagerProxy">ConfigurationManagerProxy</a></code></h4>
</li>
<li>
<h4><code><a title="egse.confman.SetupInfo" href="#egse.confman.SetupInfo">SetupInfo</a></code></h4>
<ul class="">
<li><code><a title="egse.confman.SetupInfo.cam_id" href="#egse.confman.SetupInfo.cam_id">cam_id</a></code></li>
<li><code><a title="egse.confman.SetupInfo.description" href="#egse.confman.SetupInfo.description">description</a></code></li>
<li><code><a title="egse.confman.SetupInfo.path" href="#egse.confman.SetupInfo.path">path</a></code></li>
<li><code><a title="egse.confman.SetupInfo.site_id" href="#egse.confman.SetupInfo.site_id">site_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
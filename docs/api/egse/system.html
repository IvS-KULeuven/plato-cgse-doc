<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.system API documentation</title>
<meta name="description" content="The system module defines convenience functions that provide information on system specific
functionality like, file system interactions, timing, …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.system</code></h1>
</header>
<section id="section-intro">
<p>The system module defines convenience functions that provide information on system specific
functionality like, file system interactions, timing, operating system interactions, etc.</p>
<p>The module has external dependencies to:</p>
<ul>
<li><strong>distro</strong>: for determining the Linux distribution</li>
<li><strong>psutil</strong>: for system statistics</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The system module defines convenience functions that provide information on system specific
functionality like, file system interactions, timing, operating system interactions, etc.

The module has external dependencies to:

* __distro__: for determining the Linux distribution
* __psutil__: for system statistics

&#34;&#34;&#34;
import math

import builtins
import contextlib
import datetime
import importlib
import inspect
import itertools
import logging
import operator
import os
import platform  # For getting the operating system name
import re
import signal
import socket
import subprocess  # For executing a shell command
import sys
import time
from collections import namedtuple
from pathlib import Path
from typing import Any
from typing import Iterable
from typing import List
from typing import NamedTuple
from typing import Optional
from typing import Tuple
from typing import Union

import distro  # For determining the Linux distribution
import psutil
from rich.text import Text
from rich.tree import Tree


EPOCH_1958_1970 = 378691200
TIME_FORMAT = &#39;%Y-%m-%dT%H:%M:%S.%f%z&#39;

logger = logging.getLogger(__name__)


def format_datetime(dt: Union[str,datetime.datetime] = None, fmt: str = None, width: int = 6, precision: int = 3):
    &#34;&#34;&#34;Format a datetime as YYYY-mm-ddTHH:MM:SS.μs+0000.

    If the given argument is not timezone aware, the last part, i.e. `+0000` will not be there.

    If no argument is given, the timestamp is generated as
    `datetime.datetime.now(tz=datetime.timezone.utc)`.

    The `dt` argument can also be a string with the following values: today, yesterday, tomorrow,
    and &#39;day before yesterday&#39;. The format will then be &#39;%Y%m%d&#39; unless specified.

    Optionally, a format string can be passed in to customize the formatting of the timestamp.
    This format string will be used with the `strftime()` method and should obey those conventions.

    Example:
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138))
        &#39;2020-06-13T14:45:45.696&#39;
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138), precision=6)
        &#39;2020-06-13T14:45:45.696138&#39;
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=3)
        &#39;2020-06-13T14:45:59.999&#39;
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=6)
        &#39;2020-06-13T14:45:59.999501&#39;
        &gt;&gt;&gt; _ = format_datetime()
        ...
        &gt;&gt;&gt; format_datetime(&#34;yesterday&#34;)
        &#39;20220214&#39;
        &gt;&gt;&gt; format_datetime(&#34;yesterday&#34;, fmt=&#34;%d/%m/%Y&#34;)
        &#39;14/02/2022&#39;

    Args:
        dt (datetime): a datetime object or an agreed string like yesterday, tomorrow, ...
        fmt (str): a format string that is accepted by `strftime()`
        width (int): the width to use for formatting the microseconds
        precision (int): the precision for the microseconds
    Returns:
        a string representation of the current time in UTC, e.g. `2020-04-29T12:30:04.862+0000`.

    Raises:
        A ValueError will be raised when the given dt argument string is not understood.
    &#34;&#34;&#34;
    dt = dt or datetime.datetime.now(tz=datetime.timezone.utc)
    if isinstance(dt, str):
        fmt = fmt or &#34;%Y%m%d&#34;
        if dt.lower() == &#34;yesterday&#34;:
            dt = datetime.date.today() - datetime.timedelta(days=1)
        elif dt.lower() == &#34;today&#34;:
            dt = datetime.date.today()
        elif dt.lower() == &#34;day before yesterday&#34;:
            dt = datetime.date.today() - datetime.timedelta(days=2)
        elif dt.lower() == &#34;tomorrow&#34;:
            dt = datetime.date.today() + datetime.timedelta(days=1)
        else:
            raise ValueError(f&#34;Unknown date passed as an argument: {dt}&#34;)

    if fmt:
        timestamp = dt.strftime(fmt)
    else:
        width = min(width, precision)
        timestamp = (
            f&#34;{dt.strftime(&#39;%Y-%m-%dT%H:%M&#39;)}:&#34;
            f&#34;{dt.second:02d}.{dt.microsecond//10**(6-precision):0{width}d}{dt.strftime(&#39;%z&#39;)}&#34;
        )

    return timestamp


SECONDS_IN_A_DAY = 24 * 60 * 60
SECONDS_IN_AN_HOUR = 60 * 60
SECONDS_IN_A_MINUTE = 60


def humanize_seconds(seconds: float):
    &#34;&#34;&#34;
    The number of seconds is represented as &#34;[#D]d [#H]h[#M]m[#S]s.MS&#34; where:

    * `#D` is the number of days if days &gt; 0
    * `#H` is the number of hours if hours &gt; 0
    * `#M` is the number of minutes if minutes &gt; 0 or hours &gt; 0
    * `#S` is the number of seconds
    * `MS` is the number of microseconds

    Examples:
        &gt;&gt;&gt; humanize_seconds(20)
        &#39;20s.000&#39;
        &gt;&gt;&gt; humanize_seconds(10*24*60*60)
        &#39;10d 00s.000&#39;
        &gt;&gt;&gt; humanize_seconds(10*86400 + 3*3600 + 42.023)
        &#39;10d 03h00m42s.023&#39;

    Returns:
         a string representation for the number of seconds.
    &#34;&#34;&#34;
    micro_seconds = round((seconds - int(seconds)) * 1000)
    rest = int(seconds)

    days = rest // SECONDS_IN_A_DAY
    rest -= SECONDS_IN_A_DAY * days

    hours = rest // SECONDS_IN_AN_HOUR
    rest -= SECONDS_IN_AN_HOUR * hours

    minutes = rest // SECONDS_IN_A_MINUTE
    rest -= SECONDS_IN_A_MINUTE * minutes

    seconds = rest

    result = &#34;&#34;
    if days:
        result += f&#34;{days}d &#34;

    if hours:
        result += f&#34;{hours:02d}h&#34;

    if minutes or hours:
        result += f&#34;{minutes:02d}m&#34;

    result += f&#34;{seconds:02d}s&#34;
    result += f&#34;.{micro_seconds:03d}&#34;

    return result


def str_to_datetime(datetime_string: str):
    &#34;&#34;&#34; Convert the given string to a datetime object.

    Args:
        - datatime_string: String representing a datetime, in the format %Y-%m-%dT%H:%M:%S.%f%z.

    Returns: Datetime object.
    &#34;&#34;&#34;

    return datetime.datetime.strptime(datetime_string.strip(&#34;\r&#34;), TIME_FORMAT)


def time_since_epoch_1958(datetime_string: str):
    &#34;&#34;&#34; Calculate the time since epoch 1958 for the given string representation of a datetime.

    Args:
        - datetime_string: String representing a datetime, in the format %Y-%m-%dT%H:%M:%S.%f%z.

    Returns: Time since the 1958 epoch [s].
    &#34;&#34;&#34;

    time_since_epoch_1970 = str_to_datetime(datetime_string).timestamp()        # Since Jan 1st, 1970, midnight

    return time_since_epoch_1970 + EPOCH_1958_1970


class Timer(object):
    &#34;&#34;&#34;
    Context manager to benchmark some lines of code.

    When the context exits, the elapsed time is sent to the default logger (level=INFO).

    Elapsed time can be logged with the `log_elapsed()` method and requested in fractional seconds
    by calling the class instance. When the contexts goes out of scope, the elapsed time will not
    increase anymore.

    Log messages are sent to the logger (including egse_logger for egse.system) and the logging
    level can be passed in as an optional argument. Default logging level is INFO.

    Examples:
        &gt;&gt;&gt; with Timer(&#34;Some calculation&#34;) as timer:
        ...     # do some calculations
        ...     timer.log_elapsed()
        ...     # do some more calculations
        ...     print(f&#34;Elapsed seconds: {timer()}&#34;)  # doctest: +ELLIPSIS
        Elapsed seconds: ...

    Args:
        name (str): a name for the Timer, will be printed in the logging message
        precision (int): the precision for the presentation of the elapsed time
            (number of digits behind the comma ;)
        log_level (int): the log level to report the timing [default=INFO]

    Returns:
        a context manager class that records the elapsed time.
    &#34;&#34;&#34;

    def __init__(self, name=&#34;Timer&#34;, precision=3, log_level=logging.INFO):
        self.name = name
        self.precision = precision
        self.log_level = log_level

    def __enter__(self):
        # start is a value containing the start time in fractional seconds
        # end is a function which returns the time in fractional seconds
        self.start = time.perf_counter()
        self.end = time.perf_counter
        return self

    def __exit__(self, ty, val, tb):
        # The context goes out of scope here and we fix the elapsed time
        self._total_elapsed = time.perf_counter()

        # Overwrite self.end() so that it always returns the fixed end time
        self.end = self._end

        logger.log(self.log_level,
                   f&#34;{self.name}: {self.end() - self.start:0.{self.precision}f} seconds&#34;)
        return False

    def __call__(self):
        return self.end() - self.start

    def log_elapsed(self):
        &#34;&#34;&#34;Sends the elapsed time info to the default logger.&#34;&#34;&#34;
        logger.log(self.log_level,
                   f&#34;{self.name}: {self.end() - self.start:0.{self.precision}f} seconds elapsed&#34;)

    def _end(self):
        return self._total_elapsed


def ping(host, timeout: float = 3.0):
    &#34;&#34;&#34;
    Sends a ping request to the given host.

    Remember that a host may not respond to a ping (ICMP) request even if the host name is valid.

    Args:
        host (str): hostname or IP address (as a string)
        timeout (float): timeout in seconds

    Returns:
        True when host responds to a ping request.

    Reference:
        https://stackoverflow.com/a/32684938
    &#34;&#34;&#34;

    # Option for the number of packets as a function of
    param = &#34;-n&#34; if platform.system().lower() == &#34;windows&#34; else &#34;-c&#34;

    # Building the command. Ex: &#34;ping -c 1 google.com&#34;
    command = [&#34;ping&#34;, param, &#34;1&#34;, host]

    try:
        return subprocess.call(command, stdout=subprocess.DEVNULL, timeout=timeout) == 0
    except subprocess.TimeoutExpired:
        logging.info(f&#34;Ping to {host} timed out in {timeout} seconds.&#34;)
        return False


def get_host_ip() -&gt; Optional[str]:
    &#34;&#34;&#34;Returns the IP address.&#34;&#34;&#34;

    host_ip = None

    # The following code needs internet access

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #sock.connect((&#34;8.8.8.8&#34;, 80))
        sock.connect((&#39;10.255.255.255&#39;, 1))
        host_ip = sock.getsockname()[0]
        sock.close()
    except Exception as exc:
        logger.warning(f&#34;Exception caught: {exc}&#34;)

    if host_ip:
        return host_ip

    # This may still return 127.0.0.1 when hostname is defined in /etc/hosts
    try:
        host_name = socket.gethostname()
        host_ip = socket.gethostbyname(host_name)
        return host_ip
    except (Exception, ):
        return None


def get_caller_info(level=1) -&gt; NamedTuple:
    &#34;&#34;&#34;
    Returns the filename, function name and lineno of the caller.

    The level indicates how many levels to go back in the stack.
    When level is 0 information about this function will be returned. That is usually not
    what you want so the default level is 1 which returns information about the function
    where the call to `get_caller_info` was made.

    There is no check
    Args:
        level (int): the number of levels to go back in the stack

    Returns:
        a namedtuple: CallerInfo[&#39;filename&#39;, &#39;function&#39;, &#39;lineno&#39;].
    &#34;&#34;&#34;
    frame = inspect.currentframe()
    for _ in range(level):
        if frame.f_back is None:
            break
        frame = frame.f_back
    frame_info = inspect.getframeinfo(frame)

    caller_info = namedtuple(&#34;CallerInfo&#34;, &#34;filename function lineno&#34;)

    return caller_info(frame_info.filename, frame_info.function, frame_info.lineno)


def get_referenced_var_name(obj: Any) -&gt; List[str]:
    &#34;&#34;&#34;
    Returns a list of variable names that reference the given object.
    The names can be both in the local and global namespace of the object.

    Args:
        obj (Any): object for which the variable names are returned

    Returns:
        a list of variable names.
    &#34;&#34;&#34;
    frame = inspect.currentframe().f_back
    f_locals = frame.f_locals
    f_globals = frame.f_globals
    if &#34;self&#34; in f_locals:
        f_locals = frame.f_back.f_locals
    name_set = [k for k, v in {**f_locals, **f_globals}.items() if v is obj]
    return name_set or []


class AttributeDict(dict):
    &#34;&#34;&#34;
    This class is and acts like a dictionary but has the additional functionality
    that all keys in the dictionary are also accessible as instance attributes.

        &gt;&gt;&gt; ad = AttributeDict({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})

        &gt;&gt;&gt; assert ad.a == ad[&#39;a&#39;]
        &gt;&gt;&gt; assert ad.b == ad[&#39;b&#39;]
        &gt;&gt;&gt; assert ad.c == ad[&#39;c&#39;]

    Similarly, adding or defining attributes will make them also keys in the dict.

        &gt;&gt;&gt; ad.d = 4  # creates a new attribute
        &gt;&gt;&gt; print(ad[&#39;d&#39;])  # prints 4
        4
    &#34;&#34;&#34;

    def __init__(self, *args, label: str = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.__dict__[&#34;_label&#34;] = label

    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(key)

    def __rich__(self) -&gt; Tree:
        label = self.__dict__[&#34;_label&#34;] or &#34;AttributeDict&#34;
        tree = Tree(label, guide_style=&#34;dim&#34;)
        walk_dict_tree(self, tree, text_style=&#34;dark grey&#34;)
        return tree

    def __repr__(self):

        # We only want the first 10 key:value pairs

        count = 10
        sub_msg = &#34;, &#34;.join(f&#34;{k!r}:{v!r}&#34; for k, v in itertools.islice(self.items(), 0, count))

        # if we left out key:value pairs, print a &#39;, ...&#39; to indicate incompleteness

        return self.__class__.__name__ + f&#34;({{{sub_msg}{&#39;, ...&#39; if len(self) &gt; count else &#39;&#39;}}})&#34;


def walk_dict_tree(dictionary: dict, tree: Tree, text_style: str = &#34;green&#34;):
    for k, v in dictionary.items():
        if isinstance(v, dict):
            branch = tree.add(f&#34;[purple]{k}&#34;, style=&#34;&#34;, guide_style=&#34;dim&#34;)
            walk_dict_tree(v, branch, text_style=text_style)
        else:
            text = Text.assemble((str(k), &#34;medium_purple1&#34;), &#34;: &#34;, (str(v), text_style))
            tree.add(text)


def recursive_dict_update(this: dict, other: dict):
    &#34;&#34;&#34;
    Recursively update a dictionary `this` with the content of another dictionary `other`.

    Any key in `this` dictionary will be recursively updated with the value of the same key in the
    `other` dictionary.

    Please note that the update will be in-place, i.e. the `this` dictionaory will be
    changed/updated.

    &gt;&gt;&gt; global_settings = {&#34;A&#34;: &#34;GA&#34;, &#34;B&#34;: &#34;GB&#34;, &#34;C&#34;: &#34;GC&#34;}
    &gt;&gt;&gt; local_settings = {&#34;B&#34;: &#34;LB&#34;, &#34;D&#34;: &#34;LD&#34;}
    &gt;&gt;&gt; {**global_settings, **local_settings}
    {&#39;A&#39;: &#39;GA&#39;, &#39;B&#39;: &#39;LB&#39;, &#39;C&#39;: &#39;GC&#39;, &#39;D&#39;: &#39;LD&#39;}

    &gt;&gt;&gt; global_settings = {&#34;A&#34;: &#34;GA&#34;, &#34;B&#34;: &#34;GB&#34;, &#34;C&#34;: &#34;GC&#34;, &#34;R&#34;: {&#34;X&#34;: &#34;GX&#34;, &#34;Y&#34;: &#34;GY&#34;}}
    &gt;&gt;&gt; local_settings = {&#34;B&#34;: &#34;LB&#34;, &#34;D&#34;: &#34;LD&#34;, &#34;R&#34;: {&#34;Y&#34;: &#34;LY&#34;}}
    &gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)
    {&#39;A&#39;: &#39;GA&#39;, &#39;B&#39;: &#39;LB&#39;, &#39;C&#39;: &#39;GC&#39;, &#39;R&#39;: {&#39;X&#39;: &#39;GX&#39;, &#39;Y&#39;: &#39;LY&#39;}, &#39;D&#39;: &#39;LD&#39;}

    &gt;&gt;&gt; global_settings = {&#34;A&#34;: {&#34;B&#34;: {&#34;C&#34;: {&#34;D&#34;: 42}}}}
    &gt;&gt;&gt; local_settings = {&#34;A&#34;: {&#34;B&#34;: {&#34;C&#34;: 13, &#34;D&#34;: 73}}}
    &gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)
    {&#39;A&#39;: {&#39;B&#39;: {&#39;C&#39;: 13, &#39;D&#39;: 73}}}

    Args:
        this (dict): The origin dictionary
        other (dict): Changes that shall be applied to `this`

    Returns:
        A new dictionary with the recursive updates.
    &#34;&#34;&#34;

    if not isinstance(this, dict) or not isinstance(other, dict):
        raise ValueError(&#34;Expected arguments of type dict.&#34;)

    for key, value in other.items():
        if isinstance(value, dict) and isinstance(this.get(key), dict):
            this[key] = recursive_dict_update(this[key], other[key])
        else:
            this[key] = other[key]

    return this


def flatten_dict(source_dict: dict):
    &#34;&#34;&#34;
    Flatten the given dictionary concatenating the keys with a colon &#39;:&#39;.

    &gt;&gt;&gt; d = {&#34;A&#34;: 1, &#34;B&#34;: {&#34;E&#34;: {&#34;F&#34;: 2}}, &#34;C&#34;: {&#34;D&#34;: 3}}
    &gt;&gt;&gt; flatten_dict(d)
    {&#39;A&#39;: 1, &#39;B:E:F&#39;: 2, &#39;C:D&#39;: 3}

    &gt;&gt;&gt; d = {&#34;A&#34;: &#39;a&#39;, &#34;B&#34;: {&#34;C&#34;: {&#34;D&#34;: &#39;d&#39;, &#34;E&#34;: &#39;e&#39;}, &#34;F&#34;: &#39;f&#39;}}
    &gt;&gt;&gt; flatten_dict(d)
    {&#39;A&#39;: &#39;a&#39;, &#39;B:C:D&#39;: &#39;d&#39;, &#39;B:C:E&#39;: &#39;e&#39;, &#39;B:F&#39;: &#39;f&#39;}

    Args:
        source_dict: the original dictionary that will be flattened

    Returns:
        A new flattened dictionary.
    &#34;&#34;&#34;

    def expand(key, value):
        if isinstance(value, dict):
            return [(key + &#34;:&#34; + k, v) for k, v in flatten_dict(value).items()]
        else:
            return [(key, value)]

    items = [item for k, v in source_dict.items() for item in expand(k, v)]

    return dict(items)


def get_system_stats():
    &#34;&#34;&#34;
    Gather system information about the CPUs and memory usage and return a dictionary with the
    following information:

    * cpu_load: load average over a period of 1, 5,and 15 minutes given in in percentage
      (i.e. related to the number of CPU cores that are installed on your system) [percentage]
    * cpu_count: physical and logical CPU count, i.e. the number of CPU cores (incl. hyper-threads)
    * total_ram: total physical ram available [bytes]
    * avail_ram:  the memory that can be given instantly to processes without the system going
      into swap. This is calculated by summing different memory values depending on the platform
      [bytes]
    * boot_time: the system boot time expressed in seconds since the epoch [s]
    * since: boot time of the system, aka Up time [str]

    Returns:
        a dictionary with CPU and memory statistics.
    &#34;&#34;&#34;
    statistics = {}

    # Get Physical and Logical CPU Count

    physical_and_logical_cpu_count = psutil.cpu_count()
    statistics[&#34;cpu_count&#34;] = physical_and_logical_cpu_count

    # Load average
    # This is the average system load calculated over a given period of time of 1, 5 and 15 minutes.
    #
    # The numbers returned by psutil.getloadavg() only make sense if
    # related to the number of CPU cores installed on the system.
    #
    # Here we are converting the load average into percentage.
    # The higher the percentage the higher the load.

    cpu_load = [x / physical_and_logical_cpu_count * 100 for x in psutil.getloadavg()]
    statistics[&#34;cpu_load&#34;] = cpu_load

    # Memory usage

    vmem = psutil.virtual_memory()

    statistics[&#34;total_ram&#34;] = vmem.total
    statistics[&#34;avail_ram&#34;] = vmem.available

    # boot_time = seconds since the epoch timezone
    # the Unix epoch is 00:00:00 UTC on 1 January 1970.

    boot_time = psutil.boot_time()
    statistics[&#34;boot_time&#34;] = boot_time
    statistics[&#34;since&#34;] = datetime.datetime.fromtimestamp(
        boot_time, tz=datetime.timezone.utc
    ).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)

    return statistics


def get_system_name() -&gt; str:
    &#34;&#34;&#34;Returns the name of the system in lower case.

    Returns:
        name: &#39;linux&#39;, &#39;darwin&#39;, &#39;windows&#39;, ...
    &#34;&#34;&#34;
    return platform.system().lower()


def get_os_name() -&gt; str:
    &#34;&#34;&#34;Returns the name of the OS in lower case.

    If no name could be determined, &#39;unknown&#39; is returned.

    Returns:
        os: &#39;macos&#39;, &#39;centos&#39;
    &#34;&#34;&#34;
    sys_name = get_system_name()
    if sys_name == &#34;darwin&#34;:
        return &#34;macos&#34;
    if sys_name == &#34;linux&#34;:
        return distro.id().lower()
    if sys_name == &#34;windows&#34;:
        return &#34;windows&#34;
    return &#34;unknown&#34;


def get_os_version() -&gt; str:
    &#34;&#34;&#34;Return the version of the OS.

    If no version could be determined, &#39;unknown&#39; is returned.

    Returns:
        version: as &#39;10.15&#39; or &#39;8.0&#39; or &#39;unknown&#39;
    &#34;&#34;&#34;

    # Don&#39;t use `distro.version()` to get the macOS version. That function will return the version
    # of the Darwin kernel.

    os_name = get_os_name()
    sys_name = get_system_name()
    if os_name == &#34;unknown&#34;:
        return &#34;unknown&#34;
    if os_name == &#34;macos&#34;:
        version, _, _ = platform.mac_ver()
        return &#34;.&#34;.join(version.split(&#34;.&#34;)[:2])
    if sys_name == &#34;linux&#34;:
        return distro.version()

    # FIXME: add other OS here for their version number

    return &#34;unknown&#34;


def wait_until(condition, *args, interval=0.1, timeout=1) -&gt; int:
    &#34;&#34;&#34;
    Sleep until the given condition is fulfilled. The arguments are passed into the condition
    callable which is called in a while loop until the condition is met or the timeout is reached.

    Note that the condition can be a function, method or callable class object.
    An example of the latter is:

        class SleepUntilCount:
            def __init__(self, end):
                self._end = end
                self._count = 0

            def __call__(self, *args, **kwargs):
                self._count += 1
                if self._count &gt;= self._end:
                    return True
                else:
                    return False


    Args:
        condition: a callable that returns True when the condition is met, False otherwise
        interval: the sleep interval between condition checks [s, default=0.1]
        timeout: the period after which the function returns, even when the condition is
            not met [s, default=1]
        *args: any agruments that will be passed into the condition function

    Returns:
        True when function timed out, False otherwise
    &#34;&#34;&#34;

    if inspect.isfunction(condition) or inspect.ismethod(condition):
        func_name = condition.__name__
    else:
        func_name = condition.__class__.__name__

    caller = get_caller_info(level=2)

    start = time.time()

    while not condition(*args):
        if time.time() - start &gt; timeout:
            logger.warning(
                f&#34;Timeout after {timeout} sec, from {caller.filename} at {caller.lineno},&#34;
                f&#34; {func_name}{args} not met.&#34;
            )
            return True
        time.sleep(interval)

    logger.debug(f&#34;wait_until finished successfully, {func_name}{args} is met.&#34;)

    return False


def has_internet(host=&#34;8.8.8.8&#34;, port=53, timeout=3):
    &#34;&#34;&#34;Returns True if we have internet connection.

    Host: 8.8.8.8 (google-public-dns-a.google.com)
    OpenPort: 53/tcp
    Service: domain (DNS/TCP)

    .. Note::

        This might give the following error codes:

        * [Errno 51] Network is unreachable
        * [Errno 61] Connection refused (because the port is blocked?)
        * timed out

    Source: https://stackoverflow.com/a/33117579
    &#34;&#34;&#34;
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((host, port))
        return True
    except socket.error as ex:
        logging.info(f&#34;No Internet: Unable to open socket to {host}:{port} [{ex}]&#34;)
        return False
    finally:
        if s is not None:
            s.close()


def do_every(period: float, func: callable, *args) -&gt; None:
    &#34;&#34;&#34;

    This method executes a function periodically, taking into account
    that the function that is executed will take time also and using a
    simple `sleep()` will cause a drift. This method will not drift.

    You can use this function in combination with the threading module to execute the
    function in the background, but be careful as the function might not be thread safe.

    ```
    timer_thread = threading.Thread(target=do_every, args=(10, func))
    timer_thread.daemon = True
    timer_thread.start()
    ```

    Args:
        period: a time interval between successive executions [seconds]
        func: the function to be executed
        *args: optional arguments to be passed to the function
    &#34;&#34;&#34;

    # Code from SO:https://stackoverflow.com/a/28034554/4609203
    # The max in the yield line serves to protect sleep from negative numbers in case the
    # function being called takes longer than the period specified. In that case it would
    # execute immediately and make up the lost time in the timing of the next execution.

    def g_tick():
        next_time = time.time()
        while True:
            next_time += period
            yield max(next_time - time.time(), 0)

    g = g_tick()
    while True:
        time.sleep(next(g))
        func(*args)


@contextlib.contextmanager
def chdir(dirname=None):
    &#34;&#34;&#34;
    Context manager to temporarily change directory.

    Args:
        dirname (str or Path): temporary folder name to switch to within the context

    Examples:

        &gt;&gt;&gt; with chdir(&#39;/tmp&#39;):
        ...     # do stuff in this writable tmp folder
        ...     pass

    &#34;&#34;&#34;
    current_dir = os.getcwd()
    try:
        if dirname is not None:
            os.chdir(dirname)
        yield
    finally:
        os.chdir(current_dir)


def filter_by_attr(elements: Iterable, **attrs) -&gt; List:
    &#34;&#34;&#34;
    A helper that returns the elements from the iterable that meet all the traits passed in `attrs`.

    The attributes are compared to their value with the `operator.eq` function. However,
    when the given value for an attribute is a tuple, the first element in the tuple is
    considered a comparison function and the second value the actual value. The attribute
    is then compared to the value using this function.

    ```
    result = filter_by_attr(setups, camera__model=&#34;EM&#34;, site_id=(is_in, (&#34;CSL&#34;, &#34;INTA&#34;)))
    ```
    The function `is_in` is defined as follows:
    ```
    def is_in(a, b):
        return a in b
    ```
    but you can of course also use a lambda function: `lambda a, b: a in b`.

    One function is treated special, it is the built-in function `hasattr`. Using this function,
    the value can be `True` or `False`. Use this to return all elements in the iterable
    that have the attribute, or not. The following example returns all Setups where the
    `gse.ogse.fwc_factor` is not defined:
    ```
    result = filter_by_attr(setups, camera__model=&#34;EM&#34;, gse__ogse__fwc_factor=(hasattr, False)))
    ```

    When multiple attributes are specified, they are checked using logical AND, not logical OR.
    Meaning they have to meet every attribute passed in and not one of them.

    To have a nested attribute search (i.e. search by `gse.hexapod.ID`) then
    pass in `gse__hexapod__ID` as the keyword argument.

    If nothing is found that matches the attributes passed, then an empty list is returned.

    When an attribute is not part of the iterated object, that attribute is silently ignored.

    Args:
        elements: An iterable to search through.
        attrs: Keyword arguments that denote attributes to search with.
    &#34;&#34;&#34;

    # This code is based on and originates from the get(iterable, **attr) function in the
    # discord/utils.py package (https://github.com/Rapptz/discord.py). After my own version,
    # Ruud van der Ham, improved the code drastically to the version it is now.

    def check(attr_, func, value_, el):
        try:
            a = operator.attrgetter(attr_)(el)
            return value_ if func is hasattr else func(a, value_)
        except AttributeError:
            return not value_ if func is hasattr else False

    attr_func_values = []
    for attr, value in attrs.items():
        if not (isinstance(value, (tuple, list)) and len(value) == 2 and callable(value[0])):
            value = (operator.eq, value)
        attr_func_values.append((attr.replace(&#34;__&#34;, &#34;.&#34;), *value))

    return [
        el
        for el in elements
        if all(check(attr, func, value, el) for attr, func, value in attr_func_values)
    ]


def replace_environment_variable(input_string: str):
    &#34;&#34;&#34;Returns the `input_string` with all occurrences of ENV[&#39;var&#39;].

    &gt;&gt;&gt; replace_environment_variable(&#34;ENV[&#39;HOME&#39;]/data/CSL&#34;)
    &#39;/Users/rik/data/CSL&#39;

    Args:
        input_string (str): the string to replace
    Returns:
        The input string with the ENV[&#39;var&#39;] replaced, or None when the environment variable
        doesn&#39;t exists.
    &#34;&#34;&#34;

    match = re.search(r&#34;(.*)ENV\[[&#39;\&#34;](\w+)[&#39;\&#34;]\](.*)&#34;, input_string)
    if not match:
        return input_string
    pre_match = match.group(1)
    var = match.group(2)
    post_match = match.group(3)

    result = os.getenv(var, None)

    return pre_match + result + post_match if result else None


def read_last_line(filename: str, max_line_length=5000):
    &#34;&#34;&#34;Returns the last line of a (text) file.

    The argument `max_line_length` should be at least the length of the last line in the file,
    because this value is used to backtrack from the end of the file as an optimization.

    Args:
        filename (Option[PurePath, str]): the filename as a string or Path
        max_line_length (int): the maximum length of the lines in the file
    Returns:
        The last line in the file (whitespace stripped from the right). An empty string is returned
        when the file is empty, `None` is returned when the file doesn&#39;t exist.
    &#34;&#34;&#34;
    filename = Path(filename)

    if not filename.exists():

        return None

    with filename.open(&#34;rb&#34;) as file:
        file.seek(0, 2)  # 2 is relative to end of file
        size = file.tell()
        if size:
            file.seek(max(0, size - max_line_length))
            return file.readlines()[-1].decode(&#34;ascii&#34;).rstrip(&#34;\n&#34;)
        else:
            return &#34;&#34;


def read_last_lines(filename: str, num_lines: int):
    &#34;&#34;&#34; Return the last lines of a text file.

    Args:
        - filename: Filename.
        - num_lines: Number of lines at the back of the file that should be read and returned.

    Returns: Last lines of a text file.
    &#34;&#34;&#34;

    # See: https://www.geeksforgeeks.org/python-reading-last-n-lines-of-a-file/
    # (Method 3: Through exponential search)

    filename = Path(filename)

    assert num_lines &gt; 1

    if not filename.exists():

        return None

    assert num_lines &gt;= 0

    # Declaring variable to implement exponential search

    pos = num_lines + 1

    # List to store last N lines

    lines = []

    with open(filename) as f:

        while len(lines) &lt;= num_lines:

            try:

                f.seek(-pos, 2)

            except IOError:

                f.seek(0)
                break

            finally:

                lines = list(f)

            # Increasing value of variable exponentially

            pos *= 2

    return lines[-num_lines:]


def get_full_classname(obj: object) -&gt; str:
    &#34;&#34;&#34;Returns the fully qualified class name for this object.&#34;&#34;&#34;

    # Take into account that obj might be a class or a builtin or even a
    # literal like an int or a float or a complex number

    if type(obj) is type or obj.__class__.__module__ == str.__module__:
        try:
            module = obj.__module__
            name = obj.__qualname__
        except (TypeError, AttributeError):
            module = type(obj).__module__
            name = obj.__class__.__qualname__
    else:
        module = obj.__class__.__module__
        name = obj.__class__.__qualname__

    return module + &#39;.&#39; + name


def find_class(class_name: str):
    &#34;&#34;&#34;Find and returns a class based on the fully qualified name.

    A class name can be preceded with the string `class//`. This is used in YAML
    files where the class is then instantiated on load.

    Args:
        class_name (str): a fully qualified name for the class
    Returns:
        The class object corresponding to the fully qualified class name.
    Raises:
        AttributeError: when the class is not found in the module.
        ValueError: when the class_name can not be parsed.
        ModuleNotFoundError: if the module could not be found.
    &#34;&#34;&#34;
    if class_name.startswith(&#34;class//&#34;):
        class_name = class_name[7:]

    module_name, class_name = class_name.rsplit(&#34;.&#34;, 1)
    module = importlib.import_module(module_name)
    return getattr(module, class_name)


def type_name(var):
    &#34;&#34;&#34; Returns the name of the type of var.&#34;&#34;&#34;
    return type(var).__name__


def check_argument_type(
        obj: object, name: str, target_class: Union[type, Tuple[type]], allow_none: bool = False):
    &#34;&#34;&#34;Check that the given object is of a specific (sub)type of the given target_class.

    The target_class can be a tuple of types.

    Raises:
        TypeError when not of the required type or None when not allowed.
    &#34;&#34;&#34;
    if obj is None and allow_none:
        return
    if obj is None:
        raise TypeError(f&#34;The argument &#39;{name}&#39; cannot be None.&#34;)
    if not isinstance(obj, target_class):
        raise TypeError(f&#34;The argument &#39;{name}&#39; must be of type {target_class}, but is {type(obj)}&#34;)


def check_str_for_slash(arg: str):
    &#34;&#34;&#34;Check if there is a slash in the given string, and raise a ValueError if so.&#34;&#34;&#34;

    if &#39;/&#39; in arg:
        ValueError(f&#34;The given argument can not contain slashes, {arg=}.&#34;)


def check_is_a_string(var, allow_none=False):
    &#34;&#34;&#34; Calls is_a_string and raises a type error if the check fails.&#34;&#34;&#34;
    if var is None and allow_none:
        return
    if var is None and not allow_none:
        raise TypeError(&#34;The given variable cannot be None.&#34;)
    if not isinstance(var, str):
        raise TypeError(f&#34;var must be a string, however {type(var)=}&#34;)


def sanity_check(flag: bool, msg: str):
    &#34;&#34;&#34;
    This is a replacement for the &#39;assert&#39; statement. Use this in production code
    such that your checks are not removed during optimisations.
    &#34;&#34;&#34;
    if not flag:
        raise AssertionError(msg)


class NotSpecified:
    &#34;&#34;&#34; Class for NOT_SPECIFIED constant.
        Is used so that a parameter can have a default value other than None.

        Evaluate to False when converted to boolean.
    &#34;&#34;&#34;
    def __nonzero__(self):
        &#34;&#34;&#34; Always returns False. Called when to converting to bool in Python 2.
        &#34;&#34;&#34;
        return False

    def __bool__(self):
        &#34;&#34;&#34; Always returns False. Called when to converting to bool in Python 3.
        &#34;&#34;&#34;
        return False


NOT_SPECIFIED = NotSpecified()

# Do not try to catch SIGKILL (9) that will just terminate your script without any warning

SIGNAL_NAME = {
    1: &#34;SIGHUP&#34;,
    2: &#34;SIGINT&#34;,
    3: &#34;SIGQUIT&#34;,
    6: &#34;SIGABRT&#34;,
    15: &#34;SIGTERM&#34;,
    30: &#34;SIGUSR1&#34;,
    31: &#34;SIGUSR2&#34;,
}


class SignalCatcher:
    &#34;&#34;&#34;
    This class registers handler to signals. When a signal is caught, the handler is
    executed and a flag for termination or user action is set to True. Check for this
    flag in your application loop.

    Termination signals: 1 HUP, 2 INT, 3 QUIT, 6 ABORT, 15 TERM
    User signals: 30 USR1, 31 USR2
    &#34;&#34;&#34;

    def __init__(self):
        self.term_signal_received = False
        self.user_signal_received = False
        self.term_signals = [1, 2, 3, 6, 15]
        self.user_signals = [30, 31]
        for signal_number in self.term_signals:
            signal.signal(signal_number, self.handler)
        for signal_number in self.user_signals:
            signal.signal(signal_number, self.handler)

    def handler(self, signal_number, frame):
        &#34;&#34;&#34;Handle the known signals by setting the appropriate flag.&#34;&#34;&#34;
        logger.warning(f&#34;Received signal {SIGNAL_NAME[signal_number]} [{signal_number}].&#34;)
        if signal_number in self.term_signals:
            self.term_signal_received = True
        if signal_number in self.user_signals:
            self.user_signal_received = True

    def clear(self):
        &#34;&#34;&#34;Call this method to clear the user signal after handling.
        Termination signals are not cleared since the application is assumed to terminate.&#34;&#34;&#34;
        self.user_signal_received = False


def is_in(a, b):
    &#34;&#34;&#34;Returns result of `a in b`.&#34;&#34;&#34;
    return a in b


def is_not_in(a, b):
    &#34;&#34;&#34;Returns result of `a not in b`.&#34;&#34;&#34;
    return a not in b


def is_in_ipython():
    &#34;&#34;&#34;Returns True if the code is running in IPython.&#34;&#34;&#34;
    return hasattr(builtins, &#34;__IPYTHON__&#34;)


if __name__ == &#34;__main__&#34;:

    print(f&#34;Host IP: {get_host_ip()}&#34;)
    print(f&#34;System name: {get_system_name()}&#34;)
    print(f&#34;OS name: {get_os_name()}&#34;)
    print(f&#34;OS version: {get_os_version()}&#34;)
    print(f&#34;Python version: {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}&#34;)
    print(f&#34;Running in IPython&#34;) if is_in_ipython() else None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.system.chdir"><code class="name flex">
<span>def <span class="ident">chdir</span></span>(<span>dirname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager to temporarily change directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirname</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>temporary folder name to switch to within the context</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; with chdir('/tmp'):
...     # do stuff in this writable tmp folder
...     pass
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def chdir(dirname=None):
    &#34;&#34;&#34;
    Context manager to temporarily change directory.

    Args:
        dirname (str or Path): temporary folder name to switch to within the context

    Examples:

        &gt;&gt;&gt; with chdir(&#39;/tmp&#39;):
        ...     # do stuff in this writable tmp folder
        ...     pass

    &#34;&#34;&#34;
    current_dir = os.getcwd()
    try:
        if dirname is not None:
            os.chdir(dirname)
        yield
    finally:
        os.chdir(current_dir)</code></pre>
</details>
</dd>
<dt id="egse.system.check_argument_type"><code class="name flex">
<span>def <span class="ident">check_argument_type</span></span>(<span>obj: object, name: str, target_class: Union[type, Tuple[type]], allow_none: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that the given object is of a specific (sub)type of the given target_class.</p>
<p>The target_class can be a tuple of types.</p>
<h2 id="raises">Raises</h2>
<p>TypeError when not of the required type or None when not allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_argument_type(
        obj: object, name: str, target_class: Union[type, Tuple[type]], allow_none: bool = False):
    &#34;&#34;&#34;Check that the given object is of a specific (sub)type of the given target_class.

    The target_class can be a tuple of types.

    Raises:
        TypeError when not of the required type or None when not allowed.
    &#34;&#34;&#34;
    if obj is None and allow_none:
        return
    if obj is None:
        raise TypeError(f&#34;The argument &#39;{name}&#39; cannot be None.&#34;)
    if not isinstance(obj, target_class):
        raise TypeError(f&#34;The argument &#39;{name}&#39; must be of type {target_class}, but is {type(obj)}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.system.check_is_a_string"><code class="name flex">
<span>def <span class="ident">check_is_a_string</span></span>(<span>var, allow_none=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls is_a_string and raises a type error if the check fails.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_is_a_string(var, allow_none=False):
    &#34;&#34;&#34; Calls is_a_string and raises a type error if the check fails.&#34;&#34;&#34;
    if var is None and allow_none:
        return
    if var is None and not allow_none:
        raise TypeError(&#34;The given variable cannot be None.&#34;)
    if not isinstance(var, str):
        raise TypeError(f&#34;var must be a string, however {type(var)=}&#34;)</code></pre>
</details>
</dd>
<dt id="egse.system.check_str_for_slash"><code class="name flex">
<span>def <span class="ident">check_str_for_slash</span></span>(<span>arg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if there is a slash in the given string, and raise a ValueError if so.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_str_for_slash(arg: str):
    &#34;&#34;&#34;Check if there is a slash in the given string, and raise a ValueError if so.&#34;&#34;&#34;

    if &#39;/&#39; in arg:
        ValueError(f&#34;The given argument can not contain slashes, {arg=}.&#34;)</code></pre>
</details>
</dd>
<dt id="egse.system.do_every"><code class="name flex">
<span>def <span class="ident">do_every</span></span>(<span>period: float, func: <built-in function callable>, *args) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>This method executes a function periodically, taking into account
that the function that is executed will take time also and using a
simple <code>sleep()</code> will cause a drift. This method will not drift.</p>
<p>You can use this function in combination with the threading module to execute the
function in the background, but be careful as the function might not be thread safe.</p>
<pre><code>timer_thread = threading.Thread(target=do_every, args=(10, func))
timer_thread.daemon = True
timer_thread.start()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>period</code></strong></dt>
<dd>a time interval between successive executions [seconds]</dd>
<dt><strong><code>func</code></strong></dt>
<dd>the function to be executed</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>optional arguments to be passed to the function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_every(period: float, func: callable, *args) -&gt; None:
    &#34;&#34;&#34;

    This method executes a function periodically, taking into account
    that the function that is executed will take time also and using a
    simple `sleep()` will cause a drift. This method will not drift.

    You can use this function in combination with the threading module to execute the
    function in the background, but be careful as the function might not be thread safe.

    ```
    timer_thread = threading.Thread(target=do_every, args=(10, func))
    timer_thread.daemon = True
    timer_thread.start()
    ```

    Args:
        period: a time interval between successive executions [seconds]
        func: the function to be executed
        *args: optional arguments to be passed to the function
    &#34;&#34;&#34;

    # Code from SO:https://stackoverflow.com/a/28034554/4609203
    # The max in the yield line serves to protect sleep from negative numbers in case the
    # function being called takes longer than the period specified. In that case it would
    # execute immediately and make up the lost time in the timing of the next execution.

    def g_tick():
        next_time = time.time()
        while True:
            next_time += period
            yield max(next_time - time.time(), 0)

    g = g_tick()
    while True:
        time.sleep(next(g))
        func(*args)</code></pre>
</details>
</dd>
<dt id="egse.system.filter_by_attr"><code class="name flex">
<span>def <span class="ident">filter_by_attr</span></span>(<span>elements: Iterable[+T_co], **attrs) ‑> List[~T]</span>
</code></dt>
<dd>
<div class="desc"><p>A helper that returns the elements from the iterable that meet all the traits passed in <code>attrs</code>.</p>
<p>The attributes are compared to their value with the <code>operator.eq</code> function. However,
when the given value for an attribute is a tuple, the first element in the tuple is
considered a comparison function and the second value the actual value. The attribute
is then compared to the value using this function.</p>
<pre><code>result = filter_by_attr(setups, camera__model=&quot;EM&quot;, site_id=(is_in, (&quot;CSL&quot;, &quot;INTA&quot;)))
</code></pre>
<p>The function <code><a title="egse.system.is_in" href="#egse.system.is_in">is_in()</a></code> is defined as follows:</p>
<pre><code>def is_in(a, b):
    return a in b
</code></pre>
<p>but you can of course also use a lambda function: <code>lambda a, b: a in b</code>.</p>
<p>One function is treated special, it is the built-in function <code>hasattr</code>. Using this function,
the value can be <code>True</code> or <code>False</code>. Use this to return all elements in the iterable
that have the attribute, or not. The following example returns all Setups where the
<code>gse.ogse.fwc_factor</code> is not defined:</p>
<pre><code>result = filter_by_attr(setups, camera__model=&quot;EM&quot;, gse__ogse__fwc_factor=(hasattr, False)))
</code></pre>
<p>When multiple attributes are specified, they are checked using logical AND, not logical OR.
Meaning they have to meet every attribute passed in and not one of them.</p>
<p>To have a nested attribute search (i.e. search by <code>gse.hexapod.ID</code>) then
pass in <code>gse__hexapod__ID</code> as the keyword argument.</p>
<p>If nothing is found that matches the attributes passed, then an empty list is returned.</p>
<p>When an attribute is not part of the iterated object, that attribute is silently ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elements</code></strong></dt>
<dd>An iterable to search through.</dd>
<dt><strong><code>attrs</code></strong></dt>
<dd>Keyword arguments that denote attributes to search with.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_attr(elements: Iterable, **attrs) -&gt; List:
    &#34;&#34;&#34;
    A helper that returns the elements from the iterable that meet all the traits passed in `attrs`.

    The attributes are compared to their value with the `operator.eq` function. However,
    when the given value for an attribute is a tuple, the first element in the tuple is
    considered a comparison function and the second value the actual value. The attribute
    is then compared to the value using this function.

    ```
    result = filter_by_attr(setups, camera__model=&#34;EM&#34;, site_id=(is_in, (&#34;CSL&#34;, &#34;INTA&#34;)))
    ```
    The function `is_in` is defined as follows:
    ```
    def is_in(a, b):
        return a in b
    ```
    but you can of course also use a lambda function: `lambda a, b: a in b`.

    One function is treated special, it is the built-in function `hasattr`. Using this function,
    the value can be `True` or `False`. Use this to return all elements in the iterable
    that have the attribute, or not. The following example returns all Setups where the
    `gse.ogse.fwc_factor` is not defined:
    ```
    result = filter_by_attr(setups, camera__model=&#34;EM&#34;, gse__ogse__fwc_factor=(hasattr, False)))
    ```

    When multiple attributes are specified, they are checked using logical AND, not logical OR.
    Meaning they have to meet every attribute passed in and not one of them.

    To have a nested attribute search (i.e. search by `gse.hexapod.ID`) then
    pass in `gse__hexapod__ID` as the keyword argument.

    If nothing is found that matches the attributes passed, then an empty list is returned.

    When an attribute is not part of the iterated object, that attribute is silently ignored.

    Args:
        elements: An iterable to search through.
        attrs: Keyword arguments that denote attributes to search with.
    &#34;&#34;&#34;

    # This code is based on and originates from the get(iterable, **attr) function in the
    # discord/utils.py package (https://github.com/Rapptz/discord.py). After my own version,
    # Ruud van der Ham, improved the code drastically to the version it is now.

    def check(attr_, func, value_, el):
        try:
            a = operator.attrgetter(attr_)(el)
            return value_ if func is hasattr else func(a, value_)
        except AttributeError:
            return not value_ if func is hasattr else False

    attr_func_values = []
    for attr, value in attrs.items():
        if not (isinstance(value, (tuple, list)) and len(value) == 2 and callable(value[0])):
            value = (operator.eq, value)
        attr_func_values.append((attr.replace(&#34;__&#34;, &#34;.&#34;), *value))

    return [
        el
        for el in elements
        if all(check(attr, func, value, el) for attr, func, value in attr_func_values)
    ]</code></pre>
</details>
</dd>
<dt id="egse.system.find_class"><code class="name flex">
<span>def <span class="ident">find_class</span></span>(<span>class_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Find and returns a class based on the fully qualified name.</p>
<p>A class name can be preceded with the string <code>class//</code>. This is used in YAML
files where the class is then instantiated on load.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>class_name</code></strong> :&ensp;<code>str</code></dt>
<dd>a fully qualified name for the class</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The class object corresponding to the fully qualified class name.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>when the class is not found in the module.</dd>
<dt><code>ValueError</code></dt>
<dd>when the class_name can not be parsed.</dd>
<dt><code>ModuleNotFoundError</code></dt>
<dd>if the module could not be found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_class(class_name: str):
    &#34;&#34;&#34;Find and returns a class based on the fully qualified name.

    A class name can be preceded with the string `class//`. This is used in YAML
    files where the class is then instantiated on load.

    Args:
        class_name (str): a fully qualified name for the class
    Returns:
        The class object corresponding to the fully qualified class name.
    Raises:
        AttributeError: when the class is not found in the module.
        ValueError: when the class_name can not be parsed.
        ModuleNotFoundError: if the module could not be found.
    &#34;&#34;&#34;
    if class_name.startswith(&#34;class//&#34;):
        class_name = class_name[7:]

    module_name, class_name = class_name.rsplit(&#34;.&#34;, 1)
    module = importlib.import_module(module_name)
    return getattr(module, class_name)</code></pre>
</details>
</dd>
<dt id="egse.system.flatten_dict"><code class="name flex">
<span>def <span class="ident">flatten_dict</span></span>(<span>source_dict: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Flatten the given dictionary concatenating the keys with a colon ':'.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {&quot;A&quot;: 1, &quot;B&quot;: {&quot;E&quot;: {&quot;F&quot;: 2}}, &quot;C&quot;: {&quot;D&quot;: 3}}
&gt;&gt;&gt; flatten_dict(d)
{'A': 1, 'B:E:F': 2, 'C:D': 3}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {&quot;A&quot;: 'a', &quot;B&quot;: {&quot;C&quot;: {&quot;D&quot;: 'd', &quot;E&quot;: 'e'}, &quot;F&quot;: 'f'}}
&gt;&gt;&gt; flatten_dict(d)
{'A': 'a', 'B:C:D': 'd', 'B:C:E': 'e', 'B:F': 'f'}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_dict</code></strong></dt>
<dd>the original dictionary that will be flattened</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new flattened dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_dict(source_dict: dict):
    &#34;&#34;&#34;
    Flatten the given dictionary concatenating the keys with a colon &#39;:&#39;.

    &gt;&gt;&gt; d = {&#34;A&#34;: 1, &#34;B&#34;: {&#34;E&#34;: {&#34;F&#34;: 2}}, &#34;C&#34;: {&#34;D&#34;: 3}}
    &gt;&gt;&gt; flatten_dict(d)
    {&#39;A&#39;: 1, &#39;B:E:F&#39;: 2, &#39;C:D&#39;: 3}

    &gt;&gt;&gt; d = {&#34;A&#34;: &#39;a&#39;, &#34;B&#34;: {&#34;C&#34;: {&#34;D&#34;: &#39;d&#39;, &#34;E&#34;: &#39;e&#39;}, &#34;F&#34;: &#39;f&#39;}}
    &gt;&gt;&gt; flatten_dict(d)
    {&#39;A&#39;: &#39;a&#39;, &#39;B:C:D&#39;: &#39;d&#39;, &#39;B:C:E&#39;: &#39;e&#39;, &#39;B:F&#39;: &#39;f&#39;}

    Args:
        source_dict: the original dictionary that will be flattened

    Returns:
        A new flattened dictionary.
    &#34;&#34;&#34;

    def expand(key, value):
        if isinstance(value, dict):
            return [(key + &#34;:&#34; + k, v) for k, v in flatten_dict(value).items()]
        else:
            return [(key, value)]

    items = [item for k, v in source_dict.items() for item in expand(k, v)]

    return dict(items)</code></pre>
</details>
</dd>
<dt id="egse.system.format_datetime"><code class="name flex">
<span>def <span class="ident">format_datetime</span></span>(<span>dt: Union[str, datetime.datetime] = None, fmt: str = None, width: int = 6, precision: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a datetime as YYYY-mm-ddTHH:MM:SS.μs+0000.</p>
<p>If the given argument is not timezone aware, the last part, i.e. <code>+0000</code> will not be there.</p>
<p>If no argument is given, the timestamp is generated as
<code>datetime.datetime.now(tz=datetime.timezone.utc)</code>.</p>
<p>The <code>dt</code> argument can also be a string with the following values: today, yesterday, tomorrow,
and 'day before yesterday'. The format will then be '%Y%m%d' unless specified.</p>
<p>Optionally, a format string can be passed in to customize the formatting of the timestamp.
This format string will be used with the <code>strftime()</code> method and should obey those conventions.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138))
'2020-06-13T14:45:45.696'
&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138), precision=6)
'2020-06-13T14:45:45.696138'
&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=3)
'2020-06-13T14:45:59.999'
&gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=6)
'2020-06-13T14:45:59.999501'
&gt;&gt;&gt; _ = format_datetime()
...
&gt;&gt;&gt; format_datetime(&quot;yesterday&quot;)
'20220214'
&gt;&gt;&gt; format_datetime(&quot;yesterday&quot;, fmt=&quot;%d/%m/%Y&quot;)
'14/02/2022'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>datetime</code></dt>
<dd>a datetime object or an agreed string like yesterday, tomorrow, &hellip;</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>str</code></dt>
<dd>a format string that is accepted by <code>strftime()</code></dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>the width to use for formatting the microseconds</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code></dt>
<dd>the precision for the microseconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a string representation of the current time in UTC, e.g. <code>2020-04-29T12:30:04.862+0000</code>.</p>
<h2 id="raises">Raises</h2>
<p>A ValueError will be raised when the given dt argument string is not understood.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_datetime(dt: Union[str,datetime.datetime] = None, fmt: str = None, width: int = 6, precision: int = 3):
    &#34;&#34;&#34;Format a datetime as YYYY-mm-ddTHH:MM:SS.μs+0000.

    If the given argument is not timezone aware, the last part, i.e. `+0000` will not be there.

    If no argument is given, the timestamp is generated as
    `datetime.datetime.now(tz=datetime.timezone.utc)`.

    The `dt` argument can also be a string with the following values: today, yesterday, tomorrow,
    and &#39;day before yesterday&#39;. The format will then be &#39;%Y%m%d&#39; unless specified.

    Optionally, a format string can be passed in to customize the formatting of the timestamp.
    This format string will be used with the `strftime()` method and should obey those conventions.

    Example:
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138))
        &#39;2020-06-13T14:45:45.696&#39;
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 45, 696138), precision=6)
        &#39;2020-06-13T14:45:45.696138&#39;
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=3)
        &#39;2020-06-13T14:45:59.999&#39;
        &gt;&gt;&gt; format_datetime(datetime.datetime(2020, 6, 13, 14, 45, 59, 999501), precision=6)
        &#39;2020-06-13T14:45:59.999501&#39;
        &gt;&gt;&gt; _ = format_datetime()
        ...
        &gt;&gt;&gt; format_datetime(&#34;yesterday&#34;)
        &#39;20220214&#39;
        &gt;&gt;&gt; format_datetime(&#34;yesterday&#34;, fmt=&#34;%d/%m/%Y&#34;)
        &#39;14/02/2022&#39;

    Args:
        dt (datetime): a datetime object or an agreed string like yesterday, tomorrow, ...
        fmt (str): a format string that is accepted by `strftime()`
        width (int): the width to use for formatting the microseconds
        precision (int): the precision for the microseconds
    Returns:
        a string representation of the current time in UTC, e.g. `2020-04-29T12:30:04.862+0000`.

    Raises:
        A ValueError will be raised when the given dt argument string is not understood.
    &#34;&#34;&#34;
    dt = dt or datetime.datetime.now(tz=datetime.timezone.utc)
    if isinstance(dt, str):
        fmt = fmt or &#34;%Y%m%d&#34;
        if dt.lower() == &#34;yesterday&#34;:
            dt = datetime.date.today() - datetime.timedelta(days=1)
        elif dt.lower() == &#34;today&#34;:
            dt = datetime.date.today()
        elif dt.lower() == &#34;day before yesterday&#34;:
            dt = datetime.date.today() - datetime.timedelta(days=2)
        elif dt.lower() == &#34;tomorrow&#34;:
            dt = datetime.date.today() + datetime.timedelta(days=1)
        else:
            raise ValueError(f&#34;Unknown date passed as an argument: {dt}&#34;)

    if fmt:
        timestamp = dt.strftime(fmt)
    else:
        width = min(width, precision)
        timestamp = (
            f&#34;{dt.strftime(&#39;%Y-%m-%dT%H:%M&#39;)}:&#34;
            f&#34;{dt.second:02d}.{dt.microsecond//10**(6-precision):0{width}d}{dt.strftime(&#39;%z&#39;)}&#34;
        )

    return timestamp</code></pre>
</details>
</dd>
<dt id="egse.system.get_caller_info"><code class="name flex">
<span>def <span class="ident">get_caller_info</span></span>(<span>level=1) ‑> <class 'NamedTuple'></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the filename, function name and lineno of the caller.</p>
<p>The level indicates how many levels to go back in the stack.
When level is 0 information about this function will be returned. That is usually not
what you want so the default level is 1 which returns information about the function
where the call to <code><a title="egse.system.get_caller_info" href="#egse.system.get_caller_info">get_caller_info()</a></code> was made.</p>
<p>There is no check</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of levels to go back in the stack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a namedtuple</code></dt>
<dd>CallerInfo['filename', 'function', 'lineno'].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_caller_info(level=1) -&gt; NamedTuple:
    &#34;&#34;&#34;
    Returns the filename, function name and lineno of the caller.

    The level indicates how many levels to go back in the stack.
    When level is 0 information about this function will be returned. That is usually not
    what you want so the default level is 1 which returns information about the function
    where the call to `get_caller_info` was made.

    There is no check
    Args:
        level (int): the number of levels to go back in the stack

    Returns:
        a namedtuple: CallerInfo[&#39;filename&#39;, &#39;function&#39;, &#39;lineno&#39;].
    &#34;&#34;&#34;
    frame = inspect.currentframe()
    for _ in range(level):
        if frame.f_back is None:
            break
        frame = frame.f_back
    frame_info = inspect.getframeinfo(frame)

    caller_info = namedtuple(&#34;CallerInfo&#34;, &#34;filename function lineno&#34;)

    return caller_info(frame_info.filename, frame_info.function, frame_info.lineno)</code></pre>
</details>
</dd>
<dt id="egse.system.get_full_classname"><code class="name flex">
<span>def <span class="ident">get_full_classname</span></span>(<span>obj: object) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the fully qualified class name for this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_full_classname(obj: object) -&gt; str:
    &#34;&#34;&#34;Returns the fully qualified class name for this object.&#34;&#34;&#34;

    # Take into account that obj might be a class or a builtin or even a
    # literal like an int or a float or a complex number

    if type(obj) is type or obj.__class__.__module__ == str.__module__:
        try:
            module = obj.__module__
            name = obj.__qualname__
        except (TypeError, AttributeError):
            module = type(obj).__module__
            name = obj.__class__.__qualname__
    else:
        module = obj.__class__.__module__
        name = obj.__class__.__qualname__

    return module + &#39;.&#39; + name</code></pre>
</details>
</dd>
<dt id="egse.system.get_host_ip"><code class="name flex">
<span>def <span class="ident">get_host_ip</span></span>(<span>) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the IP address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_host_ip() -&gt; Optional[str]:
    &#34;&#34;&#34;Returns the IP address.&#34;&#34;&#34;

    host_ip = None

    # The following code needs internet access

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #sock.connect((&#34;8.8.8.8&#34;, 80))
        sock.connect((&#39;10.255.255.255&#39;, 1))
        host_ip = sock.getsockname()[0]
        sock.close()
    except Exception as exc:
        logger.warning(f&#34;Exception caught: {exc}&#34;)

    if host_ip:
        return host_ip

    # This may still return 127.0.0.1 when hostname is defined in /etc/hosts
    try:
        host_name = socket.gethostname()
        host_ip = socket.gethostbyname(host_name)
        return host_ip
    except (Exception, ):
        return None</code></pre>
</details>
</dd>
<dt id="egse.system.get_os_name"><code class="name flex">
<span>def <span class="ident">get_os_name</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the OS in lower case.</p>
<p>If no name could be determined, 'unknown' is returned.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>os</code></dt>
<dd>'macos', 'centos'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_os_name() -&gt; str:
    &#34;&#34;&#34;Returns the name of the OS in lower case.

    If no name could be determined, &#39;unknown&#39; is returned.

    Returns:
        os: &#39;macos&#39;, &#39;centos&#39;
    &#34;&#34;&#34;
    sys_name = get_system_name()
    if sys_name == &#34;darwin&#34;:
        return &#34;macos&#34;
    if sys_name == &#34;linux&#34;:
        return distro.id().lower()
    if sys_name == &#34;windows&#34;:
        return &#34;windows&#34;
    return &#34;unknown&#34;</code></pre>
</details>
</dd>
<dt id="egse.system.get_os_version"><code class="name flex">
<span>def <span class="ident">get_os_version</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the version of the OS.</p>
<p>If no version could be determined, 'unknown' is returned.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>version</code></dt>
<dd>as '10.15' or '8.0' or 'unknown'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_os_version() -&gt; str:
    &#34;&#34;&#34;Return the version of the OS.

    If no version could be determined, &#39;unknown&#39; is returned.

    Returns:
        version: as &#39;10.15&#39; or &#39;8.0&#39; or &#39;unknown&#39;
    &#34;&#34;&#34;

    # Don&#39;t use `distro.version()` to get the macOS version. That function will return the version
    # of the Darwin kernel.

    os_name = get_os_name()
    sys_name = get_system_name()
    if os_name == &#34;unknown&#34;:
        return &#34;unknown&#34;
    if os_name == &#34;macos&#34;:
        version, _, _ = platform.mac_ver()
        return &#34;.&#34;.join(version.split(&#34;.&#34;)[:2])
    if sys_name == &#34;linux&#34;:
        return distro.version()

    # FIXME: add other OS here for their version number

    return &#34;unknown&#34;</code></pre>
</details>
</dd>
<dt id="egse.system.get_referenced_var_name"><code class="name flex">
<span>def <span class="ident">get_referenced_var_name</span></span>(<span>obj: Any) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of variable names that reference the given object.
The names can be both in the local and global namespace of the object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>Any</code></dt>
<dd>object for which the variable names are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of variable names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_referenced_var_name(obj: Any) -&gt; List[str]:
    &#34;&#34;&#34;
    Returns a list of variable names that reference the given object.
    The names can be both in the local and global namespace of the object.

    Args:
        obj (Any): object for which the variable names are returned

    Returns:
        a list of variable names.
    &#34;&#34;&#34;
    frame = inspect.currentframe().f_back
    f_locals = frame.f_locals
    f_globals = frame.f_globals
    if &#34;self&#34; in f_locals:
        f_locals = frame.f_back.f_locals
    name_set = [k for k, v in {**f_locals, **f_globals}.items() if v is obj]
    return name_set or []</code></pre>
</details>
</dd>
<dt id="egse.system.get_system_name"><code class="name flex">
<span>def <span class="ident">get_system_name</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the system in lower case.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>name</code></dt>
<dd>'linux', 'darwin', 'windows', &hellip;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_name() -&gt; str:
    &#34;&#34;&#34;Returns the name of the system in lower case.

    Returns:
        name: &#39;linux&#39;, &#39;darwin&#39;, &#39;windows&#39;, ...
    &#34;&#34;&#34;
    return platform.system().lower()</code></pre>
</details>
</dd>
<dt id="egse.system.get_system_stats"><code class="name flex">
<span>def <span class="ident">get_system_stats</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Gather system information about the CPUs and memory usage and return a dictionary with the
following information:</p>
<ul>
<li>cpu_load: load average over a period of 1, 5,and 15 minutes given in in percentage
(i.e. related to the number of CPU cores that are installed on your system) [percentage]</li>
<li>cpu_count: physical and logical CPU count, i.e. the number of CPU cores (incl. hyper-threads)</li>
<li>total_ram: total physical ram available [bytes]</li>
<li>avail_ram:
the memory that can be given instantly to processes without the system going
into swap. This is calculated by summing different memory values depending on the platform
[bytes]</li>
<li>boot_time: the system boot time expressed in seconds since the epoch [s]</li>
<li>since: boot time of the system, aka Up time [str]</li>
</ul>
<h2 id="returns">Returns</h2>
<p>a dictionary with CPU and memory statistics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_stats():
    &#34;&#34;&#34;
    Gather system information about the CPUs and memory usage and return a dictionary with the
    following information:

    * cpu_load: load average over a period of 1, 5,and 15 minutes given in in percentage
      (i.e. related to the number of CPU cores that are installed on your system) [percentage]
    * cpu_count: physical and logical CPU count, i.e. the number of CPU cores (incl. hyper-threads)
    * total_ram: total physical ram available [bytes]
    * avail_ram:  the memory that can be given instantly to processes without the system going
      into swap. This is calculated by summing different memory values depending on the platform
      [bytes]
    * boot_time: the system boot time expressed in seconds since the epoch [s]
    * since: boot time of the system, aka Up time [str]

    Returns:
        a dictionary with CPU and memory statistics.
    &#34;&#34;&#34;
    statistics = {}

    # Get Physical and Logical CPU Count

    physical_and_logical_cpu_count = psutil.cpu_count()
    statistics[&#34;cpu_count&#34;] = physical_and_logical_cpu_count

    # Load average
    # This is the average system load calculated over a given period of time of 1, 5 and 15 minutes.
    #
    # The numbers returned by psutil.getloadavg() only make sense if
    # related to the number of CPU cores installed on the system.
    #
    # Here we are converting the load average into percentage.
    # The higher the percentage the higher the load.

    cpu_load = [x / physical_and_logical_cpu_count * 100 for x in psutil.getloadavg()]
    statistics[&#34;cpu_load&#34;] = cpu_load

    # Memory usage

    vmem = psutil.virtual_memory()

    statistics[&#34;total_ram&#34;] = vmem.total
    statistics[&#34;avail_ram&#34;] = vmem.available

    # boot_time = seconds since the epoch timezone
    # the Unix epoch is 00:00:00 UTC on 1 January 1970.

    boot_time = psutil.boot_time()
    statistics[&#34;boot_time&#34;] = boot_time
    statistics[&#34;since&#34;] = datetime.datetime.fromtimestamp(
        boot_time, tz=datetime.timezone.utc
    ).strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)

    return statistics</code></pre>
</details>
</dd>
<dt id="egse.system.has_internet"><code class="name flex">
<span>def <span class="ident">has_internet</span></span>(<span>host='8.8.8.8', port=53, timeout=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if we have internet connection.</p>
<p>Host: 8.8.8.8 (google-public-dns-a.google.com)
OpenPort: 53/tcp
Service: domain (DNS/TCP)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This might give the following error codes:</p>
<ul>
<li>[Errno 51] Network is unreachable</li>
<li>[Errno 61] Connection refused (because the port is blocked?)</li>
<li>timed out</li>
</ul>
</div>
<p>Source: <a href="https://stackoverflow.com/a/33117579">https://stackoverflow.com/a/33117579</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_internet(host=&#34;8.8.8.8&#34;, port=53, timeout=3):
    &#34;&#34;&#34;Returns True if we have internet connection.

    Host: 8.8.8.8 (google-public-dns-a.google.com)
    OpenPort: 53/tcp
    Service: domain (DNS/TCP)

    .. Note::

        This might give the following error codes:

        * [Errno 51] Network is unreachable
        * [Errno 61] Connection refused (because the port is blocked?)
        * timed out

    Source: https://stackoverflow.com/a/33117579
    &#34;&#34;&#34;
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((host, port))
        return True
    except socket.error as ex:
        logging.info(f&#34;No Internet: Unable to open socket to {host}:{port} [{ex}]&#34;)
        return False
    finally:
        if s is not None:
            s.close()</code></pre>
</details>
</dd>
<dt id="egse.system.humanize_seconds"><code class="name flex">
<span>def <span class="ident">humanize_seconds</span></span>(<span>seconds: float)</span>
</code></dt>
<dd>
<div class="desc"><p>The number of seconds is represented as "[#D]d [#H]h[#M]m[#S]s.MS" where:</p>
<ul>
<li><code>#D</code> is the number of days if days &gt; 0</li>
<li><code>#H</code> is the number of hours if hours &gt; 0</li>
<li><code>#M</code> is the number of minutes if minutes &gt; 0 or hours &gt; 0</li>
<li><code>#S</code> is the number of seconds</li>
<li><code>MS</code> is the number of microseconds</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; humanize_seconds(20)
'20s.000'
&gt;&gt;&gt; humanize_seconds(10*24*60*60)
'10d 00s.000'
&gt;&gt;&gt; humanize_seconds(10*86400 + 3*3600 + 42.023)
'10d 03h00m42s.023'
</code></pre>
<h2 id="returns">Returns</h2>
<p>a string representation for the number of seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def humanize_seconds(seconds: float):
    &#34;&#34;&#34;
    The number of seconds is represented as &#34;[#D]d [#H]h[#M]m[#S]s.MS&#34; where:

    * `#D` is the number of days if days &gt; 0
    * `#H` is the number of hours if hours &gt; 0
    * `#M` is the number of minutes if minutes &gt; 0 or hours &gt; 0
    * `#S` is the number of seconds
    * `MS` is the number of microseconds

    Examples:
        &gt;&gt;&gt; humanize_seconds(20)
        &#39;20s.000&#39;
        &gt;&gt;&gt; humanize_seconds(10*24*60*60)
        &#39;10d 00s.000&#39;
        &gt;&gt;&gt; humanize_seconds(10*86400 + 3*3600 + 42.023)
        &#39;10d 03h00m42s.023&#39;

    Returns:
         a string representation for the number of seconds.
    &#34;&#34;&#34;
    micro_seconds = round((seconds - int(seconds)) * 1000)
    rest = int(seconds)

    days = rest // SECONDS_IN_A_DAY
    rest -= SECONDS_IN_A_DAY * days

    hours = rest // SECONDS_IN_AN_HOUR
    rest -= SECONDS_IN_AN_HOUR * hours

    minutes = rest // SECONDS_IN_A_MINUTE
    rest -= SECONDS_IN_A_MINUTE * minutes

    seconds = rest

    result = &#34;&#34;
    if days:
        result += f&#34;{days}d &#34;

    if hours:
        result += f&#34;{hours:02d}h&#34;

    if minutes or hours:
        result += f&#34;{minutes:02d}m&#34;

    result += f&#34;{seconds:02d}s&#34;
    result += f&#34;.{micro_seconds:03d}&#34;

    return result</code></pre>
</details>
</dd>
<dt id="egse.system.is_in"><code class="name flex">
<span>def <span class="ident">is_in</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns result of <code>a in b</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in(a, b):
    &#34;&#34;&#34;Returns result of `a in b`.&#34;&#34;&#34;
    return a in b</code></pre>
</details>
</dd>
<dt id="egse.system.is_in_ipython"><code class="name flex">
<span>def <span class="ident">is_in_ipython</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the code is running in IPython.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_ipython():
    &#34;&#34;&#34;Returns True if the code is running in IPython.&#34;&#34;&#34;
    return hasattr(builtins, &#34;__IPYTHON__&#34;)</code></pre>
</details>
</dd>
<dt id="egse.system.is_not_in"><code class="name flex">
<span>def <span class="ident">is_not_in</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns result of <code>a not in b</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_not_in(a, b):
    &#34;&#34;&#34;Returns result of `a not in b`.&#34;&#34;&#34;
    return a not in b</code></pre>
</details>
</dd>
<dt id="egse.system.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>host, timeout: float = 3.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a ping request to the given host.</p>
<p>Remember that a host may not respond to a ping (ICMP) request even if the host name is valid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>hostname or IP address (as a string)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True when host responds to a ping request.</p>
<h2 id="reference">Reference</h2>
<p><a href="https://stackoverflow.com/a/32684938">https://stackoverflow.com/a/32684938</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(host, timeout: float = 3.0):
    &#34;&#34;&#34;
    Sends a ping request to the given host.

    Remember that a host may not respond to a ping (ICMP) request even if the host name is valid.

    Args:
        host (str): hostname or IP address (as a string)
        timeout (float): timeout in seconds

    Returns:
        True when host responds to a ping request.

    Reference:
        https://stackoverflow.com/a/32684938
    &#34;&#34;&#34;

    # Option for the number of packets as a function of
    param = &#34;-n&#34; if platform.system().lower() == &#34;windows&#34; else &#34;-c&#34;

    # Building the command. Ex: &#34;ping -c 1 google.com&#34;
    command = [&#34;ping&#34;, param, &#34;1&#34;, host]

    try:
        return subprocess.call(command, stdout=subprocess.DEVNULL, timeout=timeout) == 0
    except subprocess.TimeoutExpired:
        logging.info(f&#34;Ping to {host} timed out in {timeout} seconds.&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="egse.system.read_last_line"><code class="name flex">
<span>def <span class="ident">read_last_line</span></span>(<span>filename: str, max_line_length=5000)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the last line of a (text) file.</p>
<p>The argument <code>max_line_length</code> should be at least the length of the last line in the file,
because this value is used to backtrack from the end of the file as an optimization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>Option[PurePath, str]</code></dt>
<dd>the filename as a string or Path</dd>
<dt><strong><code>max_line_length</code></strong> :&ensp;<code>int</code></dt>
<dd>the maximum length of the lines in the file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The last line in the file (whitespace stripped from the right). An empty string is returned
when the file is empty, <code>None</code> is returned when the file doesn't exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_last_line(filename: str, max_line_length=5000):
    &#34;&#34;&#34;Returns the last line of a (text) file.

    The argument `max_line_length` should be at least the length of the last line in the file,
    because this value is used to backtrack from the end of the file as an optimization.

    Args:
        filename (Option[PurePath, str]): the filename as a string or Path
        max_line_length (int): the maximum length of the lines in the file
    Returns:
        The last line in the file (whitespace stripped from the right). An empty string is returned
        when the file is empty, `None` is returned when the file doesn&#39;t exist.
    &#34;&#34;&#34;
    filename = Path(filename)

    if not filename.exists():

        return None

    with filename.open(&#34;rb&#34;) as file:
        file.seek(0, 2)  # 2 is relative to end of file
        size = file.tell()
        if size:
            file.seek(max(0, size - max_line_length))
            return file.readlines()[-1].decode(&#34;ascii&#34;).rstrip(&#34;\n&#34;)
        else:
            return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="egse.system.read_last_lines"><code class="name flex">
<span>def <span class="ident">read_last_lines</span></span>(<span>filename: str, num_lines: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the last lines of a text file.</p>
<h2 id="args">Args</h2>
<ul>
<li>filename: Filename.</li>
<li>num_lines: Number of lines at the back of the file that should be read and returned.
Returns: Last lines of a text file.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_last_lines(filename: str, num_lines: int):
    &#34;&#34;&#34; Return the last lines of a text file.

    Args:
        - filename: Filename.
        - num_lines: Number of lines at the back of the file that should be read and returned.

    Returns: Last lines of a text file.
    &#34;&#34;&#34;

    # See: https://www.geeksforgeeks.org/python-reading-last-n-lines-of-a-file/
    # (Method 3: Through exponential search)

    filename = Path(filename)

    assert num_lines &gt; 1

    if not filename.exists():

        return None

    assert num_lines &gt;= 0

    # Declaring variable to implement exponential search

    pos = num_lines + 1

    # List to store last N lines

    lines = []

    with open(filename) as f:

        while len(lines) &lt;= num_lines:

            try:

                f.seek(-pos, 2)

            except IOError:

                f.seek(0)
                break

            finally:

                lines = list(f)

            # Increasing value of variable exponentially

            pos *= 2

    return lines[-num_lines:]</code></pre>
</details>
</dd>
<dt id="egse.system.recursive_dict_update"><code class="name flex">
<span>def <span class="ident">recursive_dict_update</span></span>(<span>this: dict, other: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively update a dictionary <code>this</code> with the content of another dictionary <code>other</code>.</p>
<p>Any key in <code>this</code> dictionary will be recursively updated with the value of the same key in the
<code>other</code> dictionary.</p>
<p>Please note that the update will be in-place, i.e. the <code>this</code> dictionaory will be
changed/updated.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; global_settings = {&quot;A&quot;: &quot;GA&quot;, &quot;B&quot;: &quot;GB&quot;, &quot;C&quot;: &quot;GC&quot;}
&gt;&gt;&gt; local_settings = {&quot;B&quot;: &quot;LB&quot;, &quot;D&quot;: &quot;LD&quot;}
&gt;&gt;&gt; {**global_settings, **local_settings}
{'A': 'GA', 'B': 'LB', 'C': 'GC', 'D': 'LD'}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; global_settings = {&quot;A&quot;: &quot;GA&quot;, &quot;B&quot;: &quot;GB&quot;, &quot;C&quot;: &quot;GC&quot;, &quot;R&quot;: {&quot;X&quot;: &quot;GX&quot;, &quot;Y&quot;: &quot;GY&quot;}}
&gt;&gt;&gt; local_settings = {&quot;B&quot;: &quot;LB&quot;, &quot;D&quot;: &quot;LD&quot;, &quot;R&quot;: {&quot;Y&quot;: &quot;LY&quot;}}
&gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)
{'A': 'GA', 'B': 'LB', 'C': 'GC', 'R': {'X': 'GX', 'Y': 'LY'}, 'D': 'LD'}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; global_settings = {&quot;A&quot;: {&quot;B&quot;: {&quot;C&quot;: {&quot;D&quot;: 42}}}}
&gt;&gt;&gt; local_settings = {&quot;A&quot;: {&quot;B&quot;: {&quot;C&quot;: 13, &quot;D&quot;: 73}}}
&gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)
{'A': {'B': {'C': 13, 'D': 73}}}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>this</code></strong> :&ensp;<code>dict</code></dt>
<dd>The origin dictionary</dd>
<dt><strong><code>other</code></strong> :&ensp;<code>dict</code></dt>
<dd>Changes that shall be applied to <code>this</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new dictionary with the recursive updates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursive_dict_update(this: dict, other: dict):
    &#34;&#34;&#34;
    Recursively update a dictionary `this` with the content of another dictionary `other`.

    Any key in `this` dictionary will be recursively updated with the value of the same key in the
    `other` dictionary.

    Please note that the update will be in-place, i.e. the `this` dictionaory will be
    changed/updated.

    &gt;&gt;&gt; global_settings = {&#34;A&#34;: &#34;GA&#34;, &#34;B&#34;: &#34;GB&#34;, &#34;C&#34;: &#34;GC&#34;}
    &gt;&gt;&gt; local_settings = {&#34;B&#34;: &#34;LB&#34;, &#34;D&#34;: &#34;LD&#34;}
    &gt;&gt;&gt; {**global_settings, **local_settings}
    {&#39;A&#39;: &#39;GA&#39;, &#39;B&#39;: &#39;LB&#39;, &#39;C&#39;: &#39;GC&#39;, &#39;D&#39;: &#39;LD&#39;}

    &gt;&gt;&gt; global_settings = {&#34;A&#34;: &#34;GA&#34;, &#34;B&#34;: &#34;GB&#34;, &#34;C&#34;: &#34;GC&#34;, &#34;R&#34;: {&#34;X&#34;: &#34;GX&#34;, &#34;Y&#34;: &#34;GY&#34;}}
    &gt;&gt;&gt; local_settings = {&#34;B&#34;: &#34;LB&#34;, &#34;D&#34;: &#34;LD&#34;, &#34;R&#34;: {&#34;Y&#34;: &#34;LY&#34;}}
    &gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)
    {&#39;A&#39;: &#39;GA&#39;, &#39;B&#39;: &#39;LB&#39;, &#39;C&#39;: &#39;GC&#39;, &#39;R&#39;: {&#39;X&#39;: &#39;GX&#39;, &#39;Y&#39;: &#39;LY&#39;}, &#39;D&#39;: &#39;LD&#39;}

    &gt;&gt;&gt; global_settings = {&#34;A&#34;: {&#34;B&#34;: {&#34;C&#34;: {&#34;D&#34;: 42}}}}
    &gt;&gt;&gt; local_settings = {&#34;A&#34;: {&#34;B&#34;: {&#34;C&#34;: 13, &#34;D&#34;: 73}}}
    &gt;&gt;&gt; recursive_dict_update(global_settings, local_settings)
    {&#39;A&#39;: {&#39;B&#39;: {&#39;C&#39;: 13, &#39;D&#39;: 73}}}

    Args:
        this (dict): The origin dictionary
        other (dict): Changes that shall be applied to `this`

    Returns:
        A new dictionary with the recursive updates.
    &#34;&#34;&#34;

    if not isinstance(this, dict) or not isinstance(other, dict):
        raise ValueError(&#34;Expected arguments of type dict.&#34;)

    for key, value in other.items():
        if isinstance(value, dict) and isinstance(this.get(key), dict):
            this[key] = recursive_dict_update(this[key], other[key])
        else:
            this[key] = other[key]

    return this</code></pre>
</details>
</dd>
<dt id="egse.system.replace_environment_variable"><code class="name flex">
<span>def <span class="ident">replace_environment_variable</span></span>(<span>input_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code>input_string</code> with all occurrences of ENV['var'].</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; replace_environment_variable(&quot;ENV['HOME']/data/CSL&quot;)
'/Users/rik/data/CSL'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_string</code></strong> :&ensp;<code>str</code></dt>
<dd>the string to replace</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input string with the ENV['var'] replaced, or None when the environment variable
doesn't exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_environment_variable(input_string: str):
    &#34;&#34;&#34;Returns the `input_string` with all occurrences of ENV[&#39;var&#39;].

    &gt;&gt;&gt; replace_environment_variable(&#34;ENV[&#39;HOME&#39;]/data/CSL&#34;)
    &#39;/Users/rik/data/CSL&#39;

    Args:
        input_string (str): the string to replace
    Returns:
        The input string with the ENV[&#39;var&#39;] replaced, or None when the environment variable
        doesn&#39;t exists.
    &#34;&#34;&#34;

    match = re.search(r&#34;(.*)ENV\[[&#39;\&#34;](\w+)[&#39;\&#34;]\](.*)&#34;, input_string)
    if not match:
        return input_string
    pre_match = match.group(1)
    var = match.group(2)
    post_match = match.group(3)

    result = os.getenv(var, None)

    return pre_match + result + post_match if result else None</code></pre>
</details>
</dd>
<dt id="egse.system.sanity_check"><code class="name flex">
<span>def <span class="ident">sanity_check</span></span>(<span>flag: bool, msg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a replacement for the 'assert' statement. Use this in production code
such that your checks are not removed during optimisations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanity_check(flag: bool, msg: str):
    &#34;&#34;&#34;
    This is a replacement for the &#39;assert&#39; statement. Use this in production code
    such that your checks are not removed during optimisations.
    &#34;&#34;&#34;
    if not flag:
        raise AssertionError(msg)</code></pre>
</details>
</dd>
<dt id="egse.system.str_to_datetime"><code class="name flex">
<span>def <span class="ident">str_to_datetime</span></span>(<span>datetime_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the given string to a datetime object.</p>
<h2 id="args">Args</h2>
<ul>
<li>datatime_string: String representing a datetime, in the format %Y-%m-%dT%H:%M:%S.%f%z.
Returns: Datetime object.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_to_datetime(datetime_string: str):
    &#34;&#34;&#34; Convert the given string to a datetime object.

    Args:
        - datatime_string: String representing a datetime, in the format %Y-%m-%dT%H:%M:%S.%f%z.

    Returns: Datetime object.
    &#34;&#34;&#34;

    return datetime.datetime.strptime(datetime_string.strip(&#34;\r&#34;), TIME_FORMAT)</code></pre>
</details>
</dd>
<dt id="egse.system.time_since_epoch_1958"><code class="name flex">
<span>def <span class="ident">time_since_epoch_1958</span></span>(<span>datetime_string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the time since epoch 1958 for the given string representation of a datetime.</p>
<h2 id="args">Args</h2>
<ul>
<li>datetime_string: String representing a datetime, in the format %Y-%m-%dT%H:%M:%S.%f%z.
Returns: Time since the 1958 epoch [s].</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_since_epoch_1958(datetime_string: str):
    &#34;&#34;&#34; Calculate the time since epoch 1958 for the given string representation of a datetime.

    Args:
        - datetime_string: String representing a datetime, in the format %Y-%m-%dT%H:%M:%S.%f%z.

    Returns: Time since the 1958 epoch [s].
    &#34;&#34;&#34;

    time_since_epoch_1970 = str_to_datetime(datetime_string).timestamp()        # Since Jan 1st, 1970, midnight

    return time_since_epoch_1970 + EPOCH_1958_1970</code></pre>
</details>
</dd>
<dt id="egse.system.type_name"><code class="name flex">
<span>def <span class="ident">type_name</span></span>(<span>var)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the type of var.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_name(var):
    &#34;&#34;&#34; Returns the name of the type of var.&#34;&#34;&#34;
    return type(var).__name__</code></pre>
</details>
</dd>
<dt id="egse.system.wait_until"><code class="name flex">
<span>def <span class="ident">wait_until</span></span>(<span>condition, *args, interval=0.1, timeout=1) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Sleep until the given condition is fulfilled. The arguments are passed into the condition
callable which is called in a while loop until the condition is met or the timeout is reached.</p>
<p>Note that the condition can be a function, method or callable class object.
An example of the latter is:</p>
<pre><code>class SleepUntilCount:
    def __init__(self, end):
        self._end = end
        self._count = 0

    def __call__(self, *args, **kwargs):
        self._count += 1
        if self._count &gt;= self._end:
            return True
        else:
            return False
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>a callable that returns True when the condition is met, False otherwise</dd>
<dt><strong><code>interval</code></strong></dt>
<dd>the sleep interval between condition checks [s, default=0.1]</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>the period after which the function returns, even when the condition is
not met [s, default=1]</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>any agruments that will be passed into the condition function</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True when function timed out, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until(condition, *args, interval=0.1, timeout=1) -&gt; int:
    &#34;&#34;&#34;
    Sleep until the given condition is fulfilled. The arguments are passed into the condition
    callable which is called in a while loop until the condition is met or the timeout is reached.

    Note that the condition can be a function, method or callable class object.
    An example of the latter is:

        class SleepUntilCount:
            def __init__(self, end):
                self._end = end
                self._count = 0

            def __call__(self, *args, **kwargs):
                self._count += 1
                if self._count &gt;= self._end:
                    return True
                else:
                    return False


    Args:
        condition: a callable that returns True when the condition is met, False otherwise
        interval: the sleep interval between condition checks [s, default=0.1]
        timeout: the period after which the function returns, even when the condition is
            not met [s, default=1]
        *args: any agruments that will be passed into the condition function

    Returns:
        True when function timed out, False otherwise
    &#34;&#34;&#34;

    if inspect.isfunction(condition) or inspect.ismethod(condition):
        func_name = condition.__name__
    else:
        func_name = condition.__class__.__name__

    caller = get_caller_info(level=2)

    start = time.time()

    while not condition(*args):
        if time.time() - start &gt; timeout:
            logger.warning(
                f&#34;Timeout after {timeout} sec, from {caller.filename} at {caller.lineno},&#34;
                f&#34; {func_name}{args} not met.&#34;
            )
            return True
        time.sleep(interval)

    logger.debug(f&#34;wait_until finished successfully, {func_name}{args} is met.&#34;)

    return False</code></pre>
</details>
</dd>
<dt id="egse.system.walk_dict_tree"><code class="name flex">
<span>def <span class="ident">walk_dict_tree</span></span>(<span>dictionary: dict, tree: rich.tree.Tree, text_style: str = 'green')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_dict_tree(dictionary: dict, tree: Tree, text_style: str = &#34;green&#34;):
    for k, v in dictionary.items():
        if isinstance(v, dict):
            branch = tree.add(f&#34;[purple]{k}&#34;, style=&#34;&#34;, guide_style=&#34;dim&#34;)
            walk_dict_tree(v, branch, text_style=text_style)
        else:
            text = Text.assemble((str(k), &#34;medium_purple1&#34;), &#34;: &#34;, (str(v), text_style))
            tree.add(text)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.system.AttributeDict"><code class="flex name class">
<span>class <span class="ident">AttributeDict</span></span>
<span>(</span><span>*args, label: str = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is and acts like a dictionary but has the additional functionality
that all keys in the dictionary are also accessible as instance attributes.</p>
<pre><code>&gt;&gt;&gt; ad = AttributeDict({'a': 1, 'b': 2, 'c': 3})

&gt;&gt;&gt; assert ad.a == ad['a']
&gt;&gt;&gt; assert ad.b == ad['b']
&gt;&gt;&gt; assert ad.c == ad['c']
</code></pre>
<p>Similarly, adding or defining attributes will make them also keys in the dict.</p>
<pre><code>&gt;&gt;&gt; ad.d = 4  # creates a new attribute
&gt;&gt;&gt; print(ad['d'])  # prints 4
4
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttributeDict(dict):
    &#34;&#34;&#34;
    This class is and acts like a dictionary but has the additional functionality
    that all keys in the dictionary are also accessible as instance attributes.

        &gt;&gt;&gt; ad = AttributeDict({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3})

        &gt;&gt;&gt; assert ad.a == ad[&#39;a&#39;]
        &gt;&gt;&gt; assert ad.b == ad[&#39;b&#39;]
        &gt;&gt;&gt; assert ad.c == ad[&#39;c&#39;]

    Similarly, adding or defining attributes will make them also keys in the dict.

        &gt;&gt;&gt; ad.d = 4  # creates a new attribute
        &gt;&gt;&gt; print(ad[&#39;d&#39;])  # prints 4
        4
    &#34;&#34;&#34;

    def __init__(self, *args, label: str = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.__dict__[&#34;_label&#34;] = label

    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(key)

    def __rich__(self) -&gt; Tree:
        label = self.__dict__[&#34;_label&#34;] or &#34;AttributeDict&#34;
        tree = Tree(label, guide_style=&#34;dim&#34;)
        walk_dict_tree(self, tree, text_style=&#34;dark grey&#34;)
        return tree

    def __repr__(self):

        # We only want the first 10 key:value pairs

        count = 10
        sub_msg = &#34;, &#34;.join(f&#34;{k!r}:{v!r}&#34; for k, v in itertools.islice(self.items(), 0, count))

        # if we left out key:value pairs, print a &#39;, ...&#39; to indicate incompleteness

        return self.__class__.__name__ + f&#34;({{{sub_msg}{&#39;, ...&#39; if len(self) &gt; count else &#39;&#39;}}})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="egse.system.NotSpecified"><code class="flex name class">
<span>class <span class="ident">NotSpecified</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class for NOT_SPECIFIED constant.
Is used so that a parameter can have a default value other than None.</p>
<p>Evaluate to False when converted to boolean.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotSpecified:
    &#34;&#34;&#34; Class for NOT_SPECIFIED constant.
        Is used so that a parameter can have a default value other than None.

        Evaluate to False when converted to boolean.
    &#34;&#34;&#34;
    def __nonzero__(self):
        &#34;&#34;&#34; Always returns False. Called when to converting to bool in Python 2.
        &#34;&#34;&#34;
        return False

    def __bool__(self):
        &#34;&#34;&#34; Always returns False. Called when to converting to bool in Python 3.
        &#34;&#34;&#34;
        return False</code></pre>
</details>
</dd>
<dt id="egse.system.SignalCatcher"><code class="flex name class">
<span>class <span class="ident">SignalCatcher</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class registers handler to signals. When a signal is caught, the handler is
executed and a flag for termination or user action is set to True. Check for this
flag in your application loop.</p>
<p>Termination signals: 1 HUP, 2 INT, 3 QUIT, 6 ABORT, 15 TERM
User signals: 30 USR1, 31 USR2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalCatcher:
    &#34;&#34;&#34;
    This class registers handler to signals. When a signal is caught, the handler is
    executed and a flag for termination or user action is set to True. Check for this
    flag in your application loop.

    Termination signals: 1 HUP, 2 INT, 3 QUIT, 6 ABORT, 15 TERM
    User signals: 30 USR1, 31 USR2
    &#34;&#34;&#34;

    def __init__(self):
        self.term_signal_received = False
        self.user_signal_received = False
        self.term_signals = [1, 2, 3, 6, 15]
        self.user_signals = [30, 31]
        for signal_number in self.term_signals:
            signal.signal(signal_number, self.handler)
        for signal_number in self.user_signals:
            signal.signal(signal_number, self.handler)

    def handler(self, signal_number, frame):
        &#34;&#34;&#34;Handle the known signals by setting the appropriate flag.&#34;&#34;&#34;
        logger.warning(f&#34;Received signal {SIGNAL_NAME[signal_number]} [{signal_number}].&#34;)
        if signal_number in self.term_signals:
            self.term_signal_received = True
        if signal_number in self.user_signals:
            self.user_signal_received = True

    def clear(self):
        &#34;&#34;&#34;Call this method to clear the user signal after handling.
        Termination signals are not cleared since the application is assumed to terminate.&#34;&#34;&#34;
        self.user_signal_received = False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.system.SignalCatcher.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Call this method to clear the user signal after handling.
Termination signals are not cleared since the application is assumed to terminate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Call this method to clear the user signal after handling.
    Termination signals are not cleared since the application is assumed to terminate.&#34;&#34;&#34;
    self.user_signal_received = False</code></pre>
</details>
</dd>
<dt id="egse.system.SignalCatcher.handler"><code class="name flex">
<span>def <span class="ident">handler</span></span>(<span>self, signal_number, frame)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the known signals by setting the appropriate flag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handler(self, signal_number, frame):
    &#34;&#34;&#34;Handle the known signals by setting the appropriate flag.&#34;&#34;&#34;
    logger.warning(f&#34;Received signal {SIGNAL_NAME[signal_number]} [{signal_number}].&#34;)
    if signal_number in self.term_signals:
        self.term_signal_received = True
    if signal_number in self.user_signals:
        self.user_signal_received = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.system.Timer"><code class="flex name class">
<span>class <span class="ident">Timer</span></span>
<span>(</span><span>name='Timer', precision=3, log_level=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager to benchmark some lines of code.</p>
<p>When the context exits, the elapsed time is sent to the default logger (level=INFO).</p>
<p>Elapsed time can be logged with the <code>log_elapsed()</code> method and requested in fractional seconds
by calling the class instance. When the contexts goes out of scope, the elapsed time will not
increase anymore.</p>
<p>Log messages are sent to the logger (including egse_logger for egse.system) and the logging
level can be passed in as an optional argument. Default logging level is INFO.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; with Timer(&quot;Some calculation&quot;) as timer:
...     # do some calculations
...     timer.log_elapsed()
...     # do some more calculations
...     print(f&quot;Elapsed seconds: {timer()}&quot;)  # doctest: +ELLIPSIS
Elapsed seconds: ...
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>a name for the Timer, will be printed in the logging message</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code></dt>
<dd>the precision for the presentation of the elapsed time
(number of digits behind the comma ;)</dd>
<dt><strong><code>log_level</code></strong> :&ensp;<code>int</code></dt>
<dd>the log level to report the timing [default=INFO]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a context manager class that records the elapsed time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timer(object):
    &#34;&#34;&#34;
    Context manager to benchmark some lines of code.

    When the context exits, the elapsed time is sent to the default logger (level=INFO).

    Elapsed time can be logged with the `log_elapsed()` method and requested in fractional seconds
    by calling the class instance. When the contexts goes out of scope, the elapsed time will not
    increase anymore.

    Log messages are sent to the logger (including egse_logger for egse.system) and the logging
    level can be passed in as an optional argument. Default logging level is INFO.

    Examples:
        &gt;&gt;&gt; with Timer(&#34;Some calculation&#34;) as timer:
        ...     # do some calculations
        ...     timer.log_elapsed()
        ...     # do some more calculations
        ...     print(f&#34;Elapsed seconds: {timer()}&#34;)  # doctest: +ELLIPSIS
        Elapsed seconds: ...

    Args:
        name (str): a name for the Timer, will be printed in the logging message
        precision (int): the precision for the presentation of the elapsed time
            (number of digits behind the comma ;)
        log_level (int): the log level to report the timing [default=INFO]

    Returns:
        a context manager class that records the elapsed time.
    &#34;&#34;&#34;

    def __init__(self, name=&#34;Timer&#34;, precision=3, log_level=logging.INFO):
        self.name = name
        self.precision = precision
        self.log_level = log_level

    def __enter__(self):
        # start is a value containing the start time in fractional seconds
        # end is a function which returns the time in fractional seconds
        self.start = time.perf_counter()
        self.end = time.perf_counter
        return self

    def __exit__(self, ty, val, tb):
        # The context goes out of scope here and we fix the elapsed time
        self._total_elapsed = time.perf_counter()

        # Overwrite self.end() so that it always returns the fixed end time
        self.end = self._end

        logger.log(self.log_level,
                   f&#34;{self.name}: {self.end() - self.start:0.{self.precision}f} seconds&#34;)
        return False

    def __call__(self):
        return self.end() - self.start

    def log_elapsed(self):
        &#34;&#34;&#34;Sends the elapsed time info to the default logger.&#34;&#34;&#34;
        logger.log(self.log_level,
                   f&#34;{self.name}: {self.end() - self.start:0.{self.precision}f} seconds elapsed&#34;)

    def _end(self):
        return self._total_elapsed</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.system.Timer.log_elapsed"><code class="name flex">
<span>def <span class="ident">log_elapsed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends the elapsed time info to the default logger.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_elapsed(self):
    &#34;&#34;&#34;Sends the elapsed time info to the default logger.&#34;&#34;&#34;
    logger.log(self.log_level,
               f&#34;{self.name}: {self.end() - self.start:0.{self.precision}f} seconds elapsed&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.system.chdir" href="#egse.system.chdir">chdir</a></code></li>
<li><code><a title="egse.system.check_argument_type" href="#egse.system.check_argument_type">check_argument_type</a></code></li>
<li><code><a title="egse.system.check_is_a_string" href="#egse.system.check_is_a_string">check_is_a_string</a></code></li>
<li><code><a title="egse.system.check_str_for_slash" href="#egse.system.check_str_for_slash">check_str_for_slash</a></code></li>
<li><code><a title="egse.system.do_every" href="#egse.system.do_every">do_every</a></code></li>
<li><code><a title="egse.system.filter_by_attr" href="#egse.system.filter_by_attr">filter_by_attr</a></code></li>
<li><code><a title="egse.system.find_class" href="#egse.system.find_class">find_class</a></code></li>
<li><code><a title="egse.system.flatten_dict" href="#egse.system.flatten_dict">flatten_dict</a></code></li>
<li><code><a title="egse.system.format_datetime" href="#egse.system.format_datetime">format_datetime</a></code></li>
<li><code><a title="egse.system.get_caller_info" href="#egse.system.get_caller_info">get_caller_info</a></code></li>
<li><code><a title="egse.system.get_full_classname" href="#egse.system.get_full_classname">get_full_classname</a></code></li>
<li><code><a title="egse.system.get_host_ip" href="#egse.system.get_host_ip">get_host_ip</a></code></li>
<li><code><a title="egse.system.get_os_name" href="#egse.system.get_os_name">get_os_name</a></code></li>
<li><code><a title="egse.system.get_os_version" href="#egse.system.get_os_version">get_os_version</a></code></li>
<li><code><a title="egse.system.get_referenced_var_name" href="#egse.system.get_referenced_var_name">get_referenced_var_name</a></code></li>
<li><code><a title="egse.system.get_system_name" href="#egse.system.get_system_name">get_system_name</a></code></li>
<li><code><a title="egse.system.get_system_stats" href="#egse.system.get_system_stats">get_system_stats</a></code></li>
<li><code><a title="egse.system.has_internet" href="#egse.system.has_internet">has_internet</a></code></li>
<li><code><a title="egse.system.humanize_seconds" href="#egse.system.humanize_seconds">humanize_seconds</a></code></li>
<li><code><a title="egse.system.is_in" href="#egse.system.is_in">is_in</a></code></li>
<li><code><a title="egse.system.is_in_ipython" href="#egse.system.is_in_ipython">is_in_ipython</a></code></li>
<li><code><a title="egse.system.is_not_in" href="#egse.system.is_not_in">is_not_in</a></code></li>
<li><code><a title="egse.system.ping" href="#egse.system.ping">ping</a></code></li>
<li><code><a title="egse.system.read_last_line" href="#egse.system.read_last_line">read_last_line</a></code></li>
<li><code><a title="egse.system.read_last_lines" href="#egse.system.read_last_lines">read_last_lines</a></code></li>
<li><code><a title="egse.system.recursive_dict_update" href="#egse.system.recursive_dict_update">recursive_dict_update</a></code></li>
<li><code><a title="egse.system.replace_environment_variable" href="#egse.system.replace_environment_variable">replace_environment_variable</a></code></li>
<li><code><a title="egse.system.sanity_check" href="#egse.system.sanity_check">sanity_check</a></code></li>
<li><code><a title="egse.system.str_to_datetime" href="#egse.system.str_to_datetime">str_to_datetime</a></code></li>
<li><code><a title="egse.system.time_since_epoch_1958" href="#egse.system.time_since_epoch_1958">time_since_epoch_1958</a></code></li>
<li><code><a title="egse.system.type_name" href="#egse.system.type_name">type_name</a></code></li>
<li><code><a title="egse.system.wait_until" href="#egse.system.wait_until">wait_until</a></code></li>
<li><code><a title="egse.system.walk_dict_tree" href="#egse.system.walk_dict_tree">walk_dict_tree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.system.AttributeDict" href="#egse.system.AttributeDict">AttributeDict</a></code></h4>
</li>
<li>
<h4><code><a title="egse.system.NotSpecified" href="#egse.system.NotSpecified">NotSpecified</a></code></h4>
</li>
<li>
<h4><code><a title="egse.system.SignalCatcher" href="#egse.system.SignalCatcher">SignalCatcher</a></code></h4>
<ul class="">
<li><code><a title="egse.system.SignalCatcher.clear" href="#egse.system.SignalCatcher.clear">clear</a></code></li>
<li><code><a title="egse.system.SignalCatcher.handler" href="#egse.system.SignalCatcher.handler">handler</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.system.Timer" href="#egse.system.Timer">Timer</a></code></h4>
<ul class="">
<li><code><a title="egse.system.Timer.log_elapsed" href="#egse.system.Timer.log_elapsed">log_elapsed</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
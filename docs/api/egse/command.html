<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.command API documentation</title>
<meta name="description" content="This module defines a number of classes and helper functions to define and work
with commands that operate hardware devices. The goal is to be able to …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.command</code></h1>
</header>
<section id="section-intro">
<p>This module defines a number of classes and helper functions to define and work
with commands that operate hardware devices. The goal is to be able to define /
create commands transparently from a YAML file without having to write (too much)
code.</p>
<p>A few definitions for the classes defined in this module:</p>
<p><strong>command</strong></p>
<p>a string that is sent to a device over an interface like TCP/IP or USB. This
string is generated by the get_cmd_string() method of the Command class.</p>
<p>The string contains format like syntax that looks like an f-string, but is
interpreted differently. See further: How to format device command strings.</p>
<p><strong>Command</strong></p>
<p>the base class for commands. This class contains the definition of the command
and provides methods to parse and check arguments. The Command can be 'called'
or 'executed' in which case a number of actons are performed based on the
provided arguments.</p>
<p><strong>CommandExecution</strong></p>
<p>this class contains all the information needed to execute a command, without
actually executing it. A CommandExecution contains the command definition and
the parameters for the execution. It is mainly served as a communication
mechanism to the control servers, i.e. the client side (Proxy) defines a
command execution and the server then executes the command.</p>
<p><strong>CommandError</strong></p>
<p>a catch-all exception for unrecoverable errors in this module</p>
<p><strong>InvalidArgumentsError</strong></p>
<p>a CommandError raised when the arguments provided are themselve invalid
or if the number of arguments is not matching expectations</p>
<p>The basic interface is:</p>
<pre><code>cmd = Command(name     = &lt;command name&gt;,
              cmd      = &lt;command string&gt;,
              response = &lt;callable to retreive a response&gt;,
              wait     = &lt;callable to wait a specific time/delay&gt;)
</code></pre>
<p>where:</p>
<ul>
<li>name: a name for the command, this is just needed for reporting, not used in commanding</li>
<li>cmd: the command string to send or execute, see further for details</li>
<li>response: send a second command to read or get a response on the 'cmd' sent</li>
<li>wait: a function object that will wait for a specific duration,
e.g. <code>partial(time.sleep, 10)</code></li>
</ul>
<p>How to format device command strings</p>
<p>The <code>cmd</code> argument is a string that contains placeholders (replacement fields)
for future arguments that will be passed when calling the Command. The replacement
fields are marked with curly braces and are mandatory. When a name is provided
in the curly braces, the argument shall be provided as a keyword argument, otherwise
a positional argument is expected. In the current implementation the <code>cmd</code>
can only contain either positional arguments or keyword argument, not a mix of both.</p>
<p>The replacement fields may also have a format specifier to specify a precise format
for that field.</p>
<p><strong>Examples</strong></p>
<pre><code>moveAbsolute = Command(
    name = "moveAbsolute",
    cmd  = "&amp;2 Q70=0 Q71={tx:.6f} Q72={ty:.6f} Q73={tz:.6f} "
           "Q74={rx:.6f} Q75={ry:.6f} Q76={rz:.6f} Q20=11"
)

response = moveAbsolute(1, 1, 1, 0, 0, 20)
response = moveAbsolute(tx=1, ty=1, tz=1, rx=0, ry=0, rz=20)
</code></pre>
<p>Questions</p>
<p>Do we need additional hooks into this commanding?</p>
<ul>
<li>add a meaning to the check, what is it and what is it used for?</li>
<li>add a output processor possibility. A callback function that will process the
output value before returning it by the <strong>call</strong>.</li>
<li>provide an execute method for the CommandExecution that executes the command
with the saved parameters</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines a number of classes and helper functions to define and work
with commands that operate hardware devices. The goal is to be able to define /
create commands transparently from a YAML file without having to write (too much)
code.

A few definitions for the classes defined in this module:

**command**

a string that is sent to a device over an interface like TCP/IP or USB. This
string is generated by the get_cmd_string() method of the Command class.

The string contains format like syntax that looks like an f-string, but is
interpreted differently. See further: How to format device command strings.

**Command**

the base class for commands. This class contains the definition of the command
and provides methods to parse and check arguments. The Command can be &#39;called&#39;
or &#39;executed&#39; in which case a number of actons are performed based on the
provided arguments.

**CommandExecution**

this class contains all the information needed to execute a command, without
actually executing it. A CommandExecution contains the command definition and
the parameters for the execution. It is mainly served as a communication
mechanism to the control servers, i.e. the client side (Proxy) defines a
command execution and the server then executes the command.

**CommandError**

a catch-all exception for unrecoverable errors in this module

**InvalidArgumentsError**

a CommandError raised when the arguments provided are themselve invalid
or if the number of arguments is not matching expectations

The basic interface is:

    cmd = Command(name     = &lt;command name&gt;,
                  cmd      = &lt;command string&gt;,
                  response = &lt;callable to retreive a response&gt;,
                  wait     = &lt;callable to wait a specific time/delay&gt;)

where:

* name: a name for the command, this is just needed for reporting, not used in commanding
* cmd: the command string to send or execute, see further for details
* response: send a second command to read or get a response on the &#39;cmd&#39; sent
* wait: a function object that will wait for a specific duration,
  e.g. ```partial(time.sleep, 10)```

How to format device command strings

The ``cmd`` argument is a string that contains placeholders (replacement fields)
for future arguments that will be passed when calling the Command. The replacement
fields are marked with curly braces and are mandatory. When a name is provided
in the curly braces, the argument shall be provided as a keyword argument, otherwise
a positional argument is expected. In the current implementation the ``cmd``
can only contain either positional arguments or keyword argument, not a mix of both.

The replacement fields may also have a format specifier to specify a precise format
for that field.

**Examples**

    moveAbsolute = Command(
        name = &#34;moveAbsolute&#34;,
        cmd  = &#34;&amp;2 Q70=0 Q71={tx:.6f} Q72={ty:.6f} Q73={tz:.6f} &#34;
               &#34;Q74={rx:.6f} Q75={ry:.6f} Q76={rz:.6f} Q20=11&#34;
    )

    response = moveAbsolute(1, 1, 1, 0, 0, 20)
    response = moveAbsolute(tx=1, ty=1, tz=1, rx=0, ry=0, rz=20)


Questions

Do we need additional hooks into this commanding?

* add a meaning to the check, what is it and what is it used for?
* add a output processor possibility. A callback function that will process the
  output value before returning it by the __call__.
* provide an execute method for the CommandExecution that executes the command
  with the saved parameters
&#34;&#34;&#34;
import functools
import inspect
import logging
import re
from collections import namedtuple
from typing import Callable

from egse.control import Success
from egse.exceptions import Error

logger = logging.getLogger(__name__)


def stringify_function_call(function_info: dict) -&gt; str:
    def quote(value):
        return f&#39;&#34;{value}&#34;&#39; if isinstance(value, str) else value

    description = function_info.get(&#34;description&#34;)
    if description:
        return description

    result = &#34;&#34;

    name = function_info.get(&#34;func_name&#34;)
    args = function_info.get(&#34;args&#34;)
    kwargs = function_info.get(&#34;kwargs&#34;)

    if name:
        result += name
    else:
        result += &#34;unknown_function&#34;

    result += &#34;(&#34;

    if args:
        result += f&#34;{args}&#34;[1:-1]

    if kwargs:
        result += &#34;, &#34; if args else &#34;&#34;
        result += &#34;, &#34;.join([f&#34;{k}={quote(v)}&#34; for k, v in kwargs.items()])

    result += &#34;)&#34;

    return result


def dry_run(func: Callable) -&gt; Callable:
    &#34;&#34;&#34;This decorator prepares the function to handle a dry run.

    A dry run is used to check the logic of an instrument commanding script without
    actually executing the instrument commands. The commands are instead added to the
    command sequence in the global state.

    Args:
        func: the function that needs to be executed

    Returns:
        A wrapper around the given function.
    &#34;&#34;&#34;

    @functools.wraps(func)
    def func_wrapper(self, *args, **kwargs):

        from egse.state import GlobalState  # prevent circular import

        if GlobalState.dry_run:
            if callable(func) and func.__name__ == &#34;client_call&#34;:
                # This client_call function takes an additional argument which is the Proxy.
                # the Proxy is not part of the CommandExecution signature and shall be removed
                # FIXME: do we introduce a memory leak here by adding &#39;self&#39; to this GlobalState?
                args = args[1:]
                try:
                    self.validate_arguments(*args, **kwargs)
                except CommandError as e_ce:
                    GlobalState.add_command(InvalidCommandExecution(e_ce, self, *args, **kwargs))
                else:
                    GlobalState.add_command(CommandExecution(self, *args, **kwargs))
            else:
                FunctionExecution = namedtuple(&#34;FunctionExecution&#34;, [&#34;name&#34;, &#34;args&#34;, &#34;kwargs&#34;])
                GlobalState.add_command(FunctionExecution(func.__name__, args, kwargs))
            return Success(
                &#34;Command execution appended to command sequence, function not executed in dry_run.&#34;
            )
        else:
            return func(self, *args, **kwargs)

    return func_wrapper


def parse_format_string(fstring):
    &#34;&#34;&#34;
    Parse and decode the format string.
    &#34;&#34;&#34;
    # Remove occurrences of {{ }} from the fstring as they are not replacement fields
    # and will occur after formatting as single braces.

    fstring = re.sub(r&#34;{{.*}}&#34;, lambda x: &#34;_&#34;, fstring)

    # logger.debug(f&#34;fstring = &#39;{fstring}&#39;, replaced {{{{.*}}}} with _&#34;)

    parts = re.findall(r&#34;\{(.*?)\}&#34;, fstring)

    # logger.debug(f&#34;Parts: {parts!r}, n={len(parts)}&#34;)

    tot_n_args = len(parts)
    n_args = 0
    n_kwargs = 0
    keys = []

    for part in parts:
        result = re.split(r&#34;(:)&#34;, part)
        if result[0] == &#34;&#34;:
            n_args += 1
        else:
            n_kwargs += 1
            keys.append(result[0])

    # If this assertion fails, there is a flaw in the algorithm above
    assert tot_n_args == n_args + n_kwargs, (
        f&#34;Total number of arguments ({tot_n_args}) doesn&#39;t match # args ({n_args}) + &#34;
        f&#34;# kwargs ({n_kwargs}).&#34;
    )

    if n_args &gt; 0 and n_kwargs &gt; 0:
        raise InvalidArgumentsError(&#34;Mixing of positional and keyword arguments is not available.&#34;)

    return tot_n_args, n_args, n_kwargs, keys


class CommandError(Error):
    &#34;&#34;&#34;A Command Exception as a base class for this module.&#34;&#34;&#34;


class InvalidArgumentsError(CommandError):
    &#34;&#34;&#34;The arguments provided are invalid&#34;&#34;&#34;


class CommandExecution:
    &#34;&#34;&#34;
    This class contains all the information that is needed to execute a command
    with a set of parameters/arguments. The command is however not executed
    automatically. That is the responsibility of the caller to actually execute
    the command with the given parameters.

    Developer info

    you can see this as a partial (functools) which defines the command and
    its arguments, but doesn&#39;t execute until explicitly called. You can execute
    the command by calling the `cmd` with the given arguments:

       ```
       ce = CommandExecution(cmd, 20.0)
       ...
       response = ce.run()
       ```
    &#34;&#34;&#34;

    def __init__(self, cmd, *args, **kwargs):
        self._cmd = cmd
        self._args = args
        self._kwargs = kwargs

    def get_name(self):
        return self._cmd.get_name()

    def get_cmd(self):
        return self._cmd

    def get_args(self):
        return self._args

    def get_kwargs(self):
        return self._kwargs

    def run(self):
        return self._cmd(*self._args, **self._kwargs)

    def __str__(self):
        msg = f&#34;[{self.get_cmd().__class__.__name__}] {self.get_name()}(&#34;
        for arg in self.get_args():
            msg += f&#34;{arg}, &#34;
        for k, v in self.get_kwargs().items():
            msg += f&#34;{k}={v}, &#34;
        if msg.endswith(&#34;, &#34;):
            msg = msg[:-2]
        msg += &#34;)&#34;
        return msg


class InvalidCommandExecution(CommandExecution):
    &#34;&#34;&#34;A invalid command execution.&#34;&#34;&#34;

    def __init__(self, exc, cmd, *args, **kwargs):
        &#34;&#34;&#34;
        Args:
            exc: the Exception that was raised and describes the problem
            cmd: the Command object
            *args: the positional arguments that were given
            **kwargs: the keyword arguments that were given
        &#34;&#34;&#34;
        super().__init__(cmd, *args, **kwargs)
        self._exc = exc

    def run(self):
        raise InvalidArgumentsError(
            f&#34;The command {self.get_name()} can not be executed. Reason: {self._exc}&#34;
        )

    def __str__(self):
        msg = super().__str__()
        msg += f&#34; [ERROR: {self._exc}]&#34;
        return msg


class WaitCommand:
    def __init__(self, command, condition):
        self._command = command
        self._condition = condition

    def __call__(self):

        # .. todo:: do we need a timeout possibility here?

        while True:
            return_code = self._command()
            if self._condition(return_code):
                break

        return 0


class Command:
    &#34;&#34;&#34;
    A Command is basically a string that is send to a device and for which the
    device returns a response.

    The command string can contain placeholders that will be filled when the
    command is &#39;called&#39;.

    The arguments that are given will be filled into the formatted string.
    Arguments can be positional or keyword arguments, not both.
    &#34;&#34;&#34;

    def __init__(
            self, name, cmd, response=None, wait=None, check=None, description=None,
            device_method=None
    ):
        self._name = name
        self._cmd = cmd
        self._response = response
        self._wait = wait
        self._check = check
        self._description = description
        self._device_method = device_method

        tot_n_args, n_args, n_kwargs, keys = parse_format_string(cmd)

        self._tot_n_args = tot_n_args
        self._n_args = n_args
        self._n_kwargs = n_kwargs
        self._keys = keys

        self.__doc__ = self.doc_string()

    def doc_string(self):
        msg = f&#34;usage: {self._name}(nargs={self._tot_n_args}, keys={self._keys})\n&#34;
        msg += &#34;       args &amp; kwargs can be mixed (limited)&#34;

        if self._description is not None:
            msg += &#34;\n&#34;
            msg += f&#34;{self._description}\n&#34;

        return msg

    def validate_arguments(self, *args, **kwargs):

        # Special case for commands with *args or **kwargs, we don&#39;t validate

        if self._cmd in (&#34;*&#34;, &#34;**&#34;):
            return

        nargs = len(args)
        nkwargs = len(kwargs)

        if self._tot_n_args != nargs + nkwargs:
            raise InvalidArgumentsError(
                f&#34;Expected {self._tot_n_args} arguments for command {self._name}, &#34;
                f&#34;got {nargs + nkwargs} arguments.&#34;
            )

        if self._tot_n_args == 0:
            pass
        elif nargs and nargs == self._n_args:
            pass
        elif nkwargs and nkwargs == self._n_kwargs:
            pass
        elif nargs == self._n_kwargs and nkwargs == 0:
            pass
        else:
            raise InvalidArgumentsError(
                f&#34;Expected {self._n_args} positional arguments and {self._n_kwargs} &#34;
                f&#34;keyword arguments for command {self._name}, got {nargs} positional &#34;
                f&#34;and {nkwargs} keyword arguments instead.&#34;
            )

    def execute(self, cmd):
        return 0

    def get_name(self):
        return self._name

    def needs_argument(self, name):
        if name in self._keys:
            return True
        return False

    def __repr__(self):
        name = self._name if hasattr(self, &#34;_name&#34;) else None
        return f&#34;&lt;{self.__class__.__name__}({name})&gt;&#34;

    def get_device_method(self):
        return self._device_method

    def get_device_method_name(self):
        return self._device_method.__name__

    def get_command_execution(self, *args, **kwargs):

        return CommandExecution(self, *args, **kwargs)

    def __call__(self, *args, **kwargs):
        cmd_string = self.get_cmd_string(*args, **kwargs)

        # Now execute the cmd_string

        response = self.execute(cmd_string)

        if self._wait is not None:
            self._wait()

        if self._response is not None:
            response = self._response()

        if self._check is not None:
            response = self._check(response)

        return response

    def get_raw_cmd_string(self):
        return self._cmd

    def get_cmd_string(self, *args, **kwargs):
        nargs = len(args)
        nkwargs = len(kwargs)

        if self._tot_n_args != nargs + nkwargs:
            raise CommandError(
                f&#34;Expected {self._tot_n_args} arguments for command {self._name}, &#34;
                f&#34;got {nargs + nkwargs} arguments.&#34;
            )

        if self._tot_n_args == 0:
            cmd_string = self._cmd or self._name
        elif nargs and nargs == self._n_args:
            cmd_string = self._create_command_string_from_args(*args)
        elif nkwargs and nkwargs == self._n_kwargs:
            cmd_string = self._create_command_string_from_kwargs(**kwargs)
        elif nargs == self._n_kwargs and nkwargs == 0:
            cmd_string = self._create_command_string_from_args_with_kw(*args)
        else:
            raise CommandError(
                f&#34;Expected {self._n_args} positional arguments and {self._n_kwargs} &#34;
                f&#34;keyword arguments for command {self._name}, got {nargs} positional &#34;
                f&#34;and {nkwargs} keyword arguments instead.&#34;
            )

        return cmd_string

    def _create_command_string_from_args(self, *args):
        full_command = self._cmd.format(*args)
        return full_command

    def _create_command_string_from_args_with_kw(self, *args):
        full_command = self._cmd.format(**{k: v for k, v in zip(self._keys, args)})
        return full_command

    def _create_command_string_from_kwargs(self, **kwargs):
        full_command = self._cmd.format(**kwargs)
        return full_command


class ClientServerCommand(Command):
    @dry_run
    def client_call(self, other, *args, **kwargs):
        &#34;&#34;&#34;
        This method is called at the client side. It is used by the Proxy
        as a generic command to send a command execution to the server.

        Args:
            other: a sub-class of the Proxy class
            args: arguments that will be passed on to this command when executed
            kwargs: keyword arguments that will be passed on to this command when executed

        Returns:
            the response that is returned by calling the command (at the server side).
        &#34;&#34;&#34;

        try:
            self.validate_arguments(*args, **kwargs)
        except CommandError as e_ce:
            logger.error(str(e_ce))
            return None

        ce = CommandExecution(self, *args, **kwargs)
        rc = other.send(ce)

        # FIXME:
        #   not sure if I should do this, the Success/Failure returns from the CS should be
        #   re-designed. I have put this here for the following reason: when requesting an obsid
        #   from the CM_CS we don&#39;t want a Success message back, but we need the number!

        # if isinstance(rc, Success):
        #     logger.info(rc)
        #     rc = rc.return_code

        return rc

    def server_call(self, other, *args, **kwargs):
        &#34;&#34;&#34;
        This method is called at the server side. It is used by the CommandProtocol class in the
        ``execute`` method.

        Args:
            other: a sub-class of the CommandProtocol
            args: arguments are passed on to the response method
            kwargs: keyword arguments are passed on to the response method

        Returns:
            0 on success and -1 on failure.
        &#34;&#34;&#34;

        if self._response is None:
            logger.warning(f&#34;No response defined for {other} command {self.get_name()}&#34;)
            return -1

        # Note that `_response` is of type &#39;function&#39; because it was loaded from
        # a class object and therefore not bound to a class instance. The reason
        # that we could not use a bound method for `_response` is that we pass the
        # command objects back and forth from the control server to the proxy and
        # the class instances are not known at the other side.

        if self._response.__name__ == &#34;handle_device_method&#34;:

            # call the handle_device_method of the Protocol sub-class

            logger.log(0,
                       f&#34;Executing Command {self._response.__name__}({other!r}, &#34;
                       f&#34;{self!r}, {args}, {kwargs})&#34;)

            rc = self._response(other, self, *args, **kwargs)
        else:
            logger.log(0,
                       f&#34;Executing Command {self._response.__name__}({other!r}, {args}, {kwargs})&#34;)

            rc = self._response(other, *args, **kwargs)

        logger.log(0, f&#34;Response is {rc}.&#34;)

        return 0


def get_method(parent_obj, method_name: str):
    &#34;&#34;&#34;
    Returns a bound method from a given class instance.

    Args:
        parent_obj: the class instance that provides the method
        method_name: name of the method that is requested

    Returns:
        the method [type: method].

    .. note::
        The method returned is an bound class instance method and therefore
        this method *does not* expects as its first argument the class
        instance, i.e. self, when you call this as a function.

    &#34;&#34;&#34;
    if method_name is None or method_name == &#34;None&#34;:
        return None

    if hasattr(parent_obj, method_name):
        method = getattr(parent_obj, method_name)
        if inspect.ismethod(method):
            return method
        logger.warning(f&#34;{method_name} is not a method, type={type(method)}&#34;)
    else:
        logger.warning(f&#34;{parent_obj!r} has no method called {method_name}&#34;)

    return None


def get_function(parent_class, method_name: str):
    &#34;&#34;&#34;
    Returns a function (unbound method) from a given class.

    Args:
        parent_class: the class that provides the method
        method_name: name of the method that is requested

    Returns:
        the method [type: function].

    .. note::
        The function returned is an unbound class instance method and
        therefore this function expects as its first argument the class
        instance, i.e. self, when you call it as a function.

    &#34;&#34;&#34;
    if method_name is None or method_name == &#34;None&#34;:
        return None

    if hasattr(parent_class, method_name):
        func = getattr(parent_class, method_name)
        if inspect.isfunction(func):
            return func
        logger.warning(f&#34;{method_name} is not a function, type={type(func)}&#34;)
    else:
        logger.warning(
            f&#34;{parent_class.__module__}.{parent_class.__name__} has no method called {method_name}&#34;
        )

    return None


def load_commands(protocol_class, command_settings, command_class, device_class):
    &#34;&#34;&#34;
    Loads the command definitions from the given ``command_settings`` and builds an internal
    dictionary containing the command names as keys and the corresponding ``Command`` class objects
    as values.

    The ``command_settings`` is usually loaded from a YAML configuration file containing the
    command definitions for the device.

    Args:
        protocol_class: the CommandProtocol or a sub-class
        command_settings: a dictionary containing the command definitions for this device
        command_class: the type of command to create, a subclass of Command
        device_class: the type of the base device class from which the methods are loaded
    &#34;&#34;&#34;
    commands = {}

    for name in command_settings:
        command_settings_name = command_settings[name]
        if &#34;cmd&#34; in command_settings_name:
            cmd = command_settings_name[&#34;cmd&#34;]
        else:
            cmd = &#34;&#34;

        if &#34;description&#34; in command_settings_name:
            description = command_settings_name[&#34;description&#34;]
        else:
            description = None

        # The response field is the name of a function from the CommandProtocol class
        # or a sub-class. This function shall send a response back to the client (Proxy). That&#39;s
        # why this field is called response.
        # By convention we like that this method name would start with `handle_` so that we can
        # make a distinction between response commands and normal methods in Protocol. Remember
        # that response methods should send a reply back to the client (which will be waiting for
        # it..). If no response field is given, then the `handle_device_method` will be called.

        if &#34;response&#34; in command_settings_name:
            response_method = get_function(protocol_class, command_settings_name[&#34;response&#34;])
        else:
            response_method = get_function(protocol_class, &#34;handle_device_method&#34;)
            response_method = None

        # The device_method field is used in the `handle_device_method` to call the method on the
        # device class. That is the class that implements the DeviceInterface and is usually called
        # a Controller or a Simulator.
        #
        # If no device_name field is given, the name from the command_settings is used.

        if &#34;device_method&#34; in command_settings_name:
            device_method_name = command_settings_name[&#34;device_method&#34;]
        else:
            device_method_name = name

        # check if the device_method exists in the device base class

        if device_method_name == &#34;None&#34;:
            device_method = None
        else:
            device_method = get_function(device_class, device_method_name)

        logger.debug(
            f&#34;Creating {command_class.__module__}.{command_class.__name__}(name=&#39;{name}&#39;, &#34;
            f&#34;cmd=&#39;{cmd}&#39;, response={response_method}, device_method={device_method})&#34;
        )

        commands[name] = command_class(
            name=name,
            cmd=cmd,
            response=response_method,
            description=description,
            device_method=device_method,
        )

    return commands</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.command.dry_run"><code class="name flex">
<span>def <span class="ident">dry_run</span></span>(<span>func: Callable) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>This decorator prepares the function to handle a dry run.</p>
<p>A dry run is used to check the logic of an instrument commanding script without
actually executing the instrument commands. The commands are instead added to the
command sequence in the global state.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong></dt>
<dd>the function that needs to be executed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A wrapper around the given function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dry_run(func: Callable) -&gt; Callable:
    &#34;&#34;&#34;This decorator prepares the function to handle a dry run.

    A dry run is used to check the logic of an instrument commanding script without
    actually executing the instrument commands. The commands are instead added to the
    command sequence in the global state.

    Args:
        func: the function that needs to be executed

    Returns:
        A wrapper around the given function.
    &#34;&#34;&#34;

    @functools.wraps(func)
    def func_wrapper(self, *args, **kwargs):

        from egse.state import GlobalState  # prevent circular import

        if GlobalState.dry_run:
            if callable(func) and func.__name__ == &#34;client_call&#34;:
                # This client_call function takes an additional argument which is the Proxy.
                # the Proxy is not part of the CommandExecution signature and shall be removed
                # FIXME: do we introduce a memory leak here by adding &#39;self&#39; to this GlobalState?
                args = args[1:]
                try:
                    self.validate_arguments(*args, **kwargs)
                except CommandError as e_ce:
                    GlobalState.add_command(InvalidCommandExecution(e_ce, self, *args, **kwargs))
                else:
                    GlobalState.add_command(CommandExecution(self, *args, **kwargs))
            else:
                FunctionExecution = namedtuple(&#34;FunctionExecution&#34;, [&#34;name&#34;, &#34;args&#34;, &#34;kwargs&#34;])
                GlobalState.add_command(FunctionExecution(func.__name__, args, kwargs))
            return Success(
                &#34;Command execution appended to command sequence, function not executed in dry_run.&#34;
            )
        else:
            return func(self, *args, **kwargs)

    return func_wrapper</code></pre>
</details>
</dd>
<dt id="egse.command.get_function"><code class="name flex">
<span>def <span class="ident">get_function</span></span>(<span>parent_class, method_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a function (unbound method) from a given class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_class</code></strong></dt>
<dd>the class that provides the method</dd>
<dt><strong><code>method_name</code></strong></dt>
<dd>name of the method that is requested</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>the method [type</code></dt>
<dd>function].</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function returned is an unbound class instance method and
therefore this function expects as its first argument the class
instance, i.e. self, when you call it as a function.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function(parent_class, method_name: str):
    &#34;&#34;&#34;
    Returns a function (unbound method) from a given class.

    Args:
        parent_class: the class that provides the method
        method_name: name of the method that is requested

    Returns:
        the method [type: function].

    .. note::
        The function returned is an unbound class instance method and
        therefore this function expects as its first argument the class
        instance, i.e. self, when you call it as a function.

    &#34;&#34;&#34;
    if method_name is None or method_name == &#34;None&#34;:
        return None

    if hasattr(parent_class, method_name):
        func = getattr(parent_class, method_name)
        if inspect.isfunction(func):
            return func
        logger.warning(f&#34;{method_name} is not a function, type={type(func)}&#34;)
    else:
        logger.warning(
            f&#34;{parent_class.__module__}.{parent_class.__name__} has no method called {method_name}&#34;
        )

    return None</code></pre>
</details>
</dd>
<dt id="egse.command.get_method"><code class="name flex">
<span>def <span class="ident">get_method</span></span>(<span>parent_obj, method_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a bound method from a given class instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_obj</code></strong></dt>
<dd>the class instance that provides the method</dd>
<dt><strong><code>method_name</code></strong></dt>
<dd>name of the method that is requested</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>the method [type</code></dt>
<dd>method].</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method returned is an bound class instance method and therefore
this method <em>does not</em> expects as its first argument the class
instance, i.e. self, when you call this as a function.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method(parent_obj, method_name: str):
    &#34;&#34;&#34;
    Returns a bound method from a given class instance.

    Args:
        parent_obj: the class instance that provides the method
        method_name: name of the method that is requested

    Returns:
        the method [type: method].

    .. note::
        The method returned is an bound class instance method and therefore
        this method *does not* expects as its first argument the class
        instance, i.e. self, when you call this as a function.

    &#34;&#34;&#34;
    if method_name is None or method_name == &#34;None&#34;:
        return None

    if hasattr(parent_obj, method_name):
        method = getattr(parent_obj, method_name)
        if inspect.ismethod(method):
            return method
        logger.warning(f&#34;{method_name} is not a method, type={type(method)}&#34;)
    else:
        logger.warning(f&#34;{parent_obj!r} has no method called {method_name}&#34;)

    return None</code></pre>
</details>
</dd>
<dt id="egse.command.load_commands"><code class="name flex">
<span>def <span class="ident">load_commands</span></span>(<span>protocol_class, command_settings, command_class, device_class)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the command definitions from the given <code>command_settings</code> and builds an internal
dictionary containing the command names as keys and the corresponding <code><a title="egse.command.Command" href="#egse.command.Command">Command</a></code> class objects
as values.</p>
<p>The <code>command_settings</code> is usually loaded from a YAML configuration file containing the
command definitions for the device.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>protocol_class</code></strong></dt>
<dd>the CommandProtocol or a sub-class</dd>
<dt><strong><code>command_settings</code></strong></dt>
<dd>a dictionary containing the command definitions for this device</dd>
<dt><strong><code>command_class</code></strong></dt>
<dd>the type of command to create, a subclass of Command</dd>
<dt><strong><code>device_class</code></strong></dt>
<dd>the type of the base device class from which the methods are loaded</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_commands(protocol_class, command_settings, command_class, device_class):
    &#34;&#34;&#34;
    Loads the command definitions from the given ``command_settings`` and builds an internal
    dictionary containing the command names as keys and the corresponding ``Command`` class objects
    as values.

    The ``command_settings`` is usually loaded from a YAML configuration file containing the
    command definitions for the device.

    Args:
        protocol_class: the CommandProtocol or a sub-class
        command_settings: a dictionary containing the command definitions for this device
        command_class: the type of command to create, a subclass of Command
        device_class: the type of the base device class from which the methods are loaded
    &#34;&#34;&#34;
    commands = {}

    for name in command_settings:
        command_settings_name = command_settings[name]
        if &#34;cmd&#34; in command_settings_name:
            cmd = command_settings_name[&#34;cmd&#34;]
        else:
            cmd = &#34;&#34;

        if &#34;description&#34; in command_settings_name:
            description = command_settings_name[&#34;description&#34;]
        else:
            description = None

        # The response field is the name of a function from the CommandProtocol class
        # or a sub-class. This function shall send a response back to the client (Proxy). That&#39;s
        # why this field is called response.
        # By convention we like that this method name would start with `handle_` so that we can
        # make a distinction between response commands and normal methods in Protocol. Remember
        # that response methods should send a reply back to the client (which will be waiting for
        # it..). If no response field is given, then the `handle_device_method` will be called.

        if &#34;response&#34; in command_settings_name:
            response_method = get_function(protocol_class, command_settings_name[&#34;response&#34;])
        else:
            response_method = get_function(protocol_class, &#34;handle_device_method&#34;)
            response_method = None

        # The device_method field is used in the `handle_device_method` to call the method on the
        # device class. That is the class that implements the DeviceInterface and is usually called
        # a Controller or a Simulator.
        #
        # If no device_name field is given, the name from the command_settings is used.

        if &#34;device_method&#34; in command_settings_name:
            device_method_name = command_settings_name[&#34;device_method&#34;]
        else:
            device_method_name = name

        # check if the device_method exists in the device base class

        if device_method_name == &#34;None&#34;:
            device_method = None
        else:
            device_method = get_function(device_class, device_method_name)

        logger.debug(
            f&#34;Creating {command_class.__module__}.{command_class.__name__}(name=&#39;{name}&#39;, &#34;
            f&#34;cmd=&#39;{cmd}&#39;, response={response_method}, device_method={device_method})&#34;
        )

        commands[name] = command_class(
            name=name,
            cmd=cmd,
            response=response_method,
            description=description,
            device_method=device_method,
        )

    return commands</code></pre>
</details>
</dd>
<dt id="egse.command.parse_format_string"><code class="name flex">
<span>def <span class="ident">parse_format_string</span></span>(<span>fstring)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse and decode the format string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_format_string(fstring):
    &#34;&#34;&#34;
    Parse and decode the format string.
    &#34;&#34;&#34;
    # Remove occurrences of {{ }} from the fstring as they are not replacement fields
    # and will occur after formatting as single braces.

    fstring = re.sub(r&#34;{{.*}}&#34;, lambda x: &#34;_&#34;, fstring)

    # logger.debug(f&#34;fstring = &#39;{fstring}&#39;, replaced {{{{.*}}}} with _&#34;)

    parts = re.findall(r&#34;\{(.*?)\}&#34;, fstring)

    # logger.debug(f&#34;Parts: {parts!r}, n={len(parts)}&#34;)

    tot_n_args = len(parts)
    n_args = 0
    n_kwargs = 0
    keys = []

    for part in parts:
        result = re.split(r&#34;(:)&#34;, part)
        if result[0] == &#34;&#34;:
            n_args += 1
        else:
            n_kwargs += 1
            keys.append(result[0])

    # If this assertion fails, there is a flaw in the algorithm above
    assert tot_n_args == n_args + n_kwargs, (
        f&#34;Total number of arguments ({tot_n_args}) doesn&#39;t match # args ({n_args}) + &#34;
        f&#34;# kwargs ({n_kwargs}).&#34;
    )

    if n_args &gt; 0 and n_kwargs &gt; 0:
        raise InvalidArgumentsError(&#34;Mixing of positional and keyword arguments is not available.&#34;)

    return tot_n_args, n_args, n_kwargs, keys</code></pre>
</details>
</dd>
<dt id="egse.command.stringify_function_call"><code class="name flex">
<span>def <span class="ident">stringify_function_call</span></span>(<span>function_info: dict) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stringify_function_call(function_info: dict) -&gt; str:
    def quote(value):
        return f&#39;&#34;{value}&#34;&#39; if isinstance(value, str) else value

    description = function_info.get(&#34;description&#34;)
    if description:
        return description

    result = &#34;&#34;

    name = function_info.get(&#34;func_name&#34;)
    args = function_info.get(&#34;args&#34;)
    kwargs = function_info.get(&#34;kwargs&#34;)

    if name:
        result += name
    else:
        result += &#34;unknown_function&#34;

    result += &#34;(&#34;

    if args:
        result += f&#34;{args}&#34;[1:-1]

    if kwargs:
        result += &#34;, &#34; if args else &#34;&#34;
        result += &#34;, &#34;.join([f&#34;{k}={quote(v)}&#34; for k, v in kwargs.items()])

    result += &#34;)&#34;

    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.command.ClientServerCommand"><code class="flex name class">
<span>class <span class="ident">ClientServerCommand</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClientServerCommand(Command):
    @dry_run
    def client_call(self, other, *args, **kwargs):
        &#34;&#34;&#34;
        This method is called at the client side. It is used by the Proxy
        as a generic command to send a command execution to the server.

        Args:
            other: a sub-class of the Proxy class
            args: arguments that will be passed on to this command when executed
            kwargs: keyword arguments that will be passed on to this command when executed

        Returns:
            the response that is returned by calling the command (at the server side).
        &#34;&#34;&#34;

        try:
            self.validate_arguments(*args, **kwargs)
        except CommandError as e_ce:
            logger.error(str(e_ce))
            return None

        ce = CommandExecution(self, *args, **kwargs)
        rc = other.send(ce)

        # FIXME:
        #   not sure if I should do this, the Success/Failure returns from the CS should be
        #   re-designed. I have put this here for the following reason: when requesting an obsid
        #   from the CM_CS we don&#39;t want a Success message back, but we need the number!

        # if isinstance(rc, Success):
        #     logger.info(rc)
        #     rc = rc.return_code

        return rc

    def server_call(self, other, *args, **kwargs):
        &#34;&#34;&#34;
        This method is called at the server side. It is used by the CommandProtocol class in the
        ``execute`` method.

        Args:
            other: a sub-class of the CommandProtocol
            args: arguments are passed on to the response method
            kwargs: keyword arguments are passed on to the response method

        Returns:
            0 on success and -1 on failure.
        &#34;&#34;&#34;

        if self._response is None:
            logger.warning(f&#34;No response defined for {other} command {self.get_name()}&#34;)
            return -1

        # Note that `_response` is of type &#39;function&#39; because it was loaded from
        # a class object and therefore not bound to a class instance. The reason
        # that we could not use a bound method for `_response` is that we pass the
        # command objects back and forth from the control server to the proxy and
        # the class instances are not known at the other side.

        if self._response.__name__ == &#34;handle_device_method&#34;:

            # call the handle_device_method of the Protocol sub-class

            logger.log(0,
                       f&#34;Executing Command {self._response.__name__}({other!r}, &#34;
                       f&#34;{self!r}, {args}, {kwargs})&#34;)

            rc = self._response(other, self, *args, **kwargs)
        else:
            logger.log(0,
                       f&#34;Executing Command {self._response.__name__}({other!r}, {args}, {kwargs})&#34;)

            rc = self._response(other, *args, **kwargs)

        logger.log(0, f&#34;Response is {rc}.&#34;)

        return 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.Command" href="#egse.command.Command">Command</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.aeu.aeu_protocol.AWGCommand" href="aeu/aeu_protocol.html#egse.aeu.aeu_protocol.AWGCommand">AWGCommand</a></li>
<li><a title="egse.aeu.aeu_protocol.CRIOCommand" href="aeu/aeu_protocol.html#egse.aeu.aeu_protocol.CRIOCommand">CRIOCommand</a></li>
<li><a title="egse.aeu.aeu_protocol.PSUCommand" href="aeu/aeu_protocol.html#egse.aeu.aeu_protocol.PSUCommand">PSUCommand</a></li>
<li><a title="egse.alert.AlertManagerCommand" href="alert/index.html#egse.alert.AlertManagerCommand">AlertManagerCommand</a></li>
<li><a title="egse.alert.gsm.beaglebone_devif.BeagleboneCommand" href="alert/gsm/beaglebone_devif.html#egse.alert.gsm.beaglebone_devif.BeagleboneCommand">BeagleboneCommand</a></li>
<li><a title="egse.collimator.fcul.ogse.OGSECommand" href="collimator/fcul/ogse.html#egse.collimator.fcul.ogse.OGSECommand">OGSECommand</a></li>
<li><a title="egse.confman.ConfigurationManagerCommand" href="confman/index.html#egse.confman.ConfigurationManagerCommand">ConfigurationManagerCommand</a></li>
<li><a title="egse.dpu.DPUCommand" href="dpu/index.html#egse.dpu.DPUCommand">DPUCommand</a></li>
<li><a title="egse.dummy.DummyCommand" href="dummy.html#egse.dummy.DummyCommand">DummyCommand</a></li>
<li><a title="egse.fdir.fdir_manager.FdirManagerCommand" href="fdir/fdir_manager.html#egse.fdir.fdir_manager.FdirManagerCommand">FdirManagerCommand</a></li>
<li><a title="egse.fdir.fdir_remote.FdirRemoteCommand" href="fdir/fdir_remote.html#egse.fdir.fdir_remote.FdirRemoteCommand">FdirRemoteCommand</a></li>
<li><a title="egse.filterwheel.eksma.fw8smc5.Fw8Smc5Command" href="filterwheel/eksma/fw8smc5.html#egse.filterwheel.eksma.fw8smc5.Fw8Smc5Command">Fw8Smc5Command</a></li>
<li><a title="egse.gimbal.symetrie.gimbal_protocol.GimbalCommand" href="gimbal/symetrie/gimbal_protocol.html#egse.gimbal.symetrie.gimbal_protocol.GimbalCommand">GimbalCommand</a></li>
<li><a title="egse.hexapod.symetrie.puna_protocol.PunaCommand" href="hexapod/symetrie/puna_protocol.html#egse.hexapod.symetrie.puna_protocol.PunaCommand">PunaCommand</a></li>
<li><a title="egse.hexapod.symetrie.zonda_protocol.ZondaCommand" href="hexapod/symetrie/zonda_protocol.html#egse.hexapod.symetrie.zonda_protocol.ZondaCommand">ZondaCommand</a></li>
<li><a title="egse.lampcontrol.beaglebone.beaglebone_devif.BeagleboneCommand" href="lampcontrol/beaglebone/beaglebone_devif.html#egse.lampcontrol.beaglebone.beaglebone_devif.BeagleboneCommand">BeagleboneCommand</a></li>
<li><a title="egse.lampcontrol.energetiq.lampEQ99_devif.LampEQ99Command" href="lampcontrol/energetiq/lampEQ99_devif.html#egse.lampcontrol.energetiq.lampEQ99_devif.LampEQ99Command">LampEQ99Command</a></li>
<li><a title="egse.ni.alarms.cdaq9375_devif.cdaq9375Command" href="ni/alarms/cdaq9375_devif.html#egse.ni.alarms.cdaq9375_devif.cdaq9375Command">cdaq9375Command</a></li>
<li><a title="egse.powermeter.ni.cdaq9184_devif.cdaq9184Command" href="powermeter/ni/cdaq9184_devif.html#egse.powermeter.ni.cdaq9184_devif.cdaq9184Command">cdaq9184Command</a></li>
<li><a title="egse.powermeter.thorlabs.pm100a_devif.ThorlabsPM100Command" href="powermeter/thorlabs/pm100a_devif.html#egse.powermeter.thorlabs.pm100a_devif.ThorlabsPM100Command">ThorlabsPM100Command</a></li>
<li><a title="egse.procman.ProcessManagerCommand" href="procman/index.html#egse.procman.ProcessManagerCommand">ProcessManagerCommand</a></li>
<li><a title="egse.services.ServiceCommand" href="services.html#egse.services.ServiceCommand">ServiceCommand</a></li>
<li><a title="egse.shutter.thorlabs.ksc101_devif.ShutterKSC101Command" href="shutter/thorlabs/ksc101_devif.html#egse.shutter.thorlabs.ksc101_devif.ShutterKSC101Command">ShutterKSC101Command</a></li>
<li><a title="egse.shutter.thorlabs.sc10.Sc10Command" href="shutter/thorlabs/sc10.html#egse.shutter.thorlabs.sc10.Sc10Command">Sc10Command</a></li>
<li><a title="egse.stages.aerotech.ensemble.EnsembleCommand" href="stages/aerotech/ensemble.html#egse.stages.aerotech.ensemble.EnsembleCommand">EnsembleCommand</a></li>
<li><a title="egse.stages.arun.smd3.Smd3Command" href="stages/arun/smd3.html#egse.stages.arun.smd3.Smd3Command">Smd3Command</a></li>
<li><a title="egse.stages.huber.smc9300_devif.HuberSMC9300Command" href="stages/huber/smc9300_devif.html#egse.stages.huber.smc9300_devif.HuberSMC9300Command">HuberSMC9300Command</a></li>
<li><a title="egse.storage.StorageCommand" href="storage/index.html#egse.storage.StorageCommand">StorageCommand</a></li>
<li><a title="egse.synoptics.SynopticsManagerCommand" href="synoptics/index.html#egse.synoptics.SynopticsManagerCommand">SynopticsManagerCommand</a></li>
<li><a title="egse.tcs.tcs_protocol.TCSCommand" href="tcs/tcs_protocol.html#egse.tcs.tcs_protocol.TCSCommand">TCSCommand</a></li>
<li><a title="egse.tempcontrol.agilent.agilent34970_devif.Agilent34970Command" href="tempcontrol/agilent/agilent34970_devif.html#egse.tempcontrol.agilent.agilent34970_devif.Agilent34970Command">Agilent34970Command</a></li>
<li><a title="egse.tempcontrol.agilent.agilent34972_devif.Agilent34972Command" href="tempcontrol/agilent/agilent34972_devif.html#egse.tempcontrol.agilent.agilent34972_devif.Agilent34972Command">Agilent34972Command</a></li>
<li><a title="egse.tempcontrol.digalox.digalox.DigaloxCommand" href="tempcontrol/digalox/digalox.html#egse.tempcontrol.digalox.digalox.DigaloxCommand">DigaloxCommand</a></li>
<li><a title="egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command" href="tempcontrol/keithley/daq6510_devif.html#egse.tempcontrol.keithley.daq6510_devif.DAQ6510Command">DAQ6510Command</a></li>
<li><a title="egse.tempcontrol.lakeshore.lsci_devif.LakeShoreCommand" href="tempcontrol/lakeshore/lsci_devif.html#egse.tempcontrol.lakeshore.lsci_devif.LakeShoreCommand">LakeShoreCommand</a></li>
<li><a title="egse.tempcontrol.srs.ptc10_devif.ptc10Command" href="tempcontrol/srs/ptc10_devif.html#egse.tempcontrol.srs.ptc10_devif.ptc10Command">ptc10Command</a></li>
<li><a title="egse.ups.apc.apc.APCCommand" href="ups/apc/apc.html#egse.ups.apc.apc.APCCommand">APCCommand</a></li>
<li><a title="egse.vacuum.beaglebone.beaglebone_devif.BeagleboneCommand" href="vacuum/beaglebone/beaglebone_devif.html#egse.vacuum.beaglebone.beaglebone_devif.BeagleboneCommand">BeagleboneCommand</a></li>
<li><a title="egse.vacuum.instrutech.igm402.Igm402Command" href="vacuum/instrutech/igm402.html#egse.vacuum.instrutech.igm402.Igm402Command">Igm402Command</a></li>
<li><a title="egse.vacuum.keller.leo3.Leo3Command" href="vacuum/keller/leo3.html#egse.vacuum.keller.leo3.Leo3Command">Leo3Command</a></li>
<li><a title="egse.vacuum.mks.evision.EvisionCommand" href="vacuum/mks/evision.html#egse.vacuum.mks.evision.EvisionCommand">EvisionCommand</a></li>
<li><a title="egse.vacuum.pfeiffer.acp40.Acp40Command" href="vacuum/pfeiffer/acp40.html#egse.vacuum.pfeiffer.acp40.Acp40Command">Acp40Command</a></li>
<li><a title="egse.vacuum.pfeiffer.tc400_interface.Tc400Command" href="vacuum/pfeiffer/tc400_interface.html#egse.vacuum.pfeiffer.tc400_interface.Tc400Command">Tc400Command</a></li>
<li><a title="egse.vacuum.pfeiffer.tpg261_interface.Tpg261Command" href="vacuum/pfeiffer/tpg261_interface.html#egse.vacuum.pfeiffer.tpg261_interface.Tpg261Command">Tpg261Command</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.command.ClientServerCommand.client_call"><code class="name flex">
<span>def <span class="ident">client_call</span></span>(<span>self, other, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called at the client side. It is used by the Proxy
as a generic command to send a command execution to the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>a sub-class of the Proxy class</dd>
<dt><strong><code>args</code></strong></dt>
<dd>arguments that will be passed on to this command when executed</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>keyword arguments that will be passed on to this command when executed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the response that is returned by calling the command (at the server side).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dry_run
def client_call(self, other, *args, **kwargs):
    &#34;&#34;&#34;
    This method is called at the client side. It is used by the Proxy
    as a generic command to send a command execution to the server.

    Args:
        other: a sub-class of the Proxy class
        args: arguments that will be passed on to this command when executed
        kwargs: keyword arguments that will be passed on to this command when executed

    Returns:
        the response that is returned by calling the command (at the server side).
    &#34;&#34;&#34;

    try:
        self.validate_arguments(*args, **kwargs)
    except CommandError as e_ce:
        logger.error(str(e_ce))
        return None

    ce = CommandExecution(self, *args, **kwargs)
    rc = other.send(ce)

    # FIXME:
    #   not sure if I should do this, the Success/Failure returns from the CS should be
    #   re-designed. I have put this here for the following reason: when requesting an obsid
    #   from the CM_CS we don&#39;t want a Success message back, but we need the number!

    # if isinstance(rc, Success):
    #     logger.info(rc)
    #     rc = rc.return_code

    return rc</code></pre>
</details>
</dd>
<dt id="egse.command.ClientServerCommand.server_call"><code class="name flex">
<span>def <span class="ident">server_call</span></span>(<span>self, other, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called at the server side. It is used by the CommandProtocol class in the
<code>execute</code> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>a sub-class of the CommandProtocol</dd>
<dt><strong><code>args</code></strong></dt>
<dd>arguments are passed on to the response method</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>keyword arguments are passed on to the response method</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success and -1 on failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server_call(self, other, *args, **kwargs):
    &#34;&#34;&#34;
    This method is called at the server side. It is used by the CommandProtocol class in the
    ``execute`` method.

    Args:
        other: a sub-class of the CommandProtocol
        args: arguments are passed on to the response method
        kwargs: keyword arguments are passed on to the response method

    Returns:
        0 on success and -1 on failure.
    &#34;&#34;&#34;

    if self._response is None:
        logger.warning(f&#34;No response defined for {other} command {self.get_name()}&#34;)
        return -1

    # Note that `_response` is of type &#39;function&#39; because it was loaded from
    # a class object and therefore not bound to a class instance. The reason
    # that we could not use a bound method for `_response` is that we pass the
    # command objects back and forth from the control server to the proxy and
    # the class instances are not known at the other side.

    if self._response.__name__ == &#34;handle_device_method&#34;:

        # call the handle_device_method of the Protocol sub-class

        logger.log(0,
                   f&#34;Executing Command {self._response.__name__}({other!r}, &#34;
                   f&#34;{self!r}, {args}, {kwargs})&#34;)

        rc = self._response(other, self, *args, **kwargs)
    else:
        logger.log(0,
                   f&#34;Executing Command {self._response.__name__}({other!r}, {args}, {kwargs})&#34;)

        rc = self._response(other, *args, **kwargs)

    logger.log(0, f&#34;Response is {rc}.&#34;)

    return 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.command.Command"><code class="flex name class">
<span>class <span class="ident">Command</span></span>
<span>(</span><span>name, cmd, response=None, wait=None, check=None, description=None, device_method=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command is basically a string that is send to a device and for which the
device returns a response.</p>
<p>The command string can contain placeholders that will be filled when the
command is 'called'.</p>
<p>The arguments that are given will be filled into the formatted string.
Arguments can be positional or keyword arguments, not both.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Command:
    &#34;&#34;&#34;
    A Command is basically a string that is send to a device and for which the
    device returns a response.

    The command string can contain placeholders that will be filled when the
    command is &#39;called&#39;.

    The arguments that are given will be filled into the formatted string.
    Arguments can be positional or keyword arguments, not both.
    &#34;&#34;&#34;

    def __init__(
            self, name, cmd, response=None, wait=None, check=None, description=None,
            device_method=None
    ):
        self._name = name
        self._cmd = cmd
        self._response = response
        self._wait = wait
        self._check = check
        self._description = description
        self._device_method = device_method

        tot_n_args, n_args, n_kwargs, keys = parse_format_string(cmd)

        self._tot_n_args = tot_n_args
        self._n_args = n_args
        self._n_kwargs = n_kwargs
        self._keys = keys

        self.__doc__ = self.doc_string()

    def doc_string(self):
        msg = f&#34;usage: {self._name}(nargs={self._tot_n_args}, keys={self._keys})\n&#34;
        msg += &#34;       args &amp; kwargs can be mixed (limited)&#34;

        if self._description is not None:
            msg += &#34;\n&#34;
            msg += f&#34;{self._description}\n&#34;

        return msg

    def validate_arguments(self, *args, **kwargs):

        # Special case for commands with *args or **kwargs, we don&#39;t validate

        if self._cmd in (&#34;*&#34;, &#34;**&#34;):
            return

        nargs = len(args)
        nkwargs = len(kwargs)

        if self._tot_n_args != nargs + nkwargs:
            raise InvalidArgumentsError(
                f&#34;Expected {self._tot_n_args} arguments for command {self._name}, &#34;
                f&#34;got {nargs + nkwargs} arguments.&#34;
            )

        if self._tot_n_args == 0:
            pass
        elif nargs and nargs == self._n_args:
            pass
        elif nkwargs and nkwargs == self._n_kwargs:
            pass
        elif nargs == self._n_kwargs and nkwargs == 0:
            pass
        else:
            raise InvalidArgumentsError(
                f&#34;Expected {self._n_args} positional arguments and {self._n_kwargs} &#34;
                f&#34;keyword arguments for command {self._name}, got {nargs} positional &#34;
                f&#34;and {nkwargs} keyword arguments instead.&#34;
            )

    def execute(self, cmd):
        return 0

    def get_name(self):
        return self._name

    def needs_argument(self, name):
        if name in self._keys:
            return True
        return False

    def __repr__(self):
        name = self._name if hasattr(self, &#34;_name&#34;) else None
        return f&#34;&lt;{self.__class__.__name__}({name})&gt;&#34;

    def get_device_method(self):
        return self._device_method

    def get_device_method_name(self):
        return self._device_method.__name__

    def get_command_execution(self, *args, **kwargs):

        return CommandExecution(self, *args, **kwargs)

    def __call__(self, *args, **kwargs):
        cmd_string = self.get_cmd_string(*args, **kwargs)

        # Now execute the cmd_string

        response = self.execute(cmd_string)

        if self._wait is not None:
            self._wait()

        if self._response is not None:
            response = self._response()

        if self._check is not None:
            response = self._check(response)

        return response

    def get_raw_cmd_string(self):
        return self._cmd

    def get_cmd_string(self, *args, **kwargs):
        nargs = len(args)
        nkwargs = len(kwargs)

        if self._tot_n_args != nargs + nkwargs:
            raise CommandError(
                f&#34;Expected {self._tot_n_args} arguments for command {self._name}, &#34;
                f&#34;got {nargs + nkwargs} arguments.&#34;
            )

        if self._tot_n_args == 0:
            cmd_string = self._cmd or self._name
        elif nargs and nargs == self._n_args:
            cmd_string = self._create_command_string_from_args(*args)
        elif nkwargs and nkwargs == self._n_kwargs:
            cmd_string = self._create_command_string_from_kwargs(**kwargs)
        elif nargs == self._n_kwargs and nkwargs == 0:
            cmd_string = self._create_command_string_from_args_with_kw(*args)
        else:
            raise CommandError(
                f&#34;Expected {self._n_args} positional arguments and {self._n_kwargs} &#34;
                f&#34;keyword arguments for command {self._name}, got {nargs} positional &#34;
                f&#34;and {nkwargs} keyword arguments instead.&#34;
            )

        return cmd_string

    def _create_command_string_from_args(self, *args):
        full_command = self._cmd.format(*args)
        return full_command

    def _create_command_string_from_args_with_kw(self, *args):
        full_command = self._cmd.format(**{k: v for k, v in zip(self._keys, args)})
        return full_command

    def _create_command_string_from_kwargs(self, **kwargs):
        full_command = self._cmd.format(**kwargs)
        return full_command</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.command.ClientServerCommand" href="#egse.command.ClientServerCommand">ClientServerCommand</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.command.Command.doc_string"><code class="name flex">
<span>def <span class="ident">doc_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doc_string(self):
    msg = f&#34;usage: {self._name}(nargs={self._tot_n_args}, keys={self._keys})\n&#34;
    msg += &#34;       args &amp; kwargs can be mixed (limited)&#34;

    if self._description is not None:
        msg += &#34;\n&#34;
        msg += f&#34;{self._description}\n&#34;

    return msg</code></pre>
</details>
</dd>
<dt id="egse.command.Command.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, cmd):
    return 0</code></pre>
</details>
</dd>
<dt id="egse.command.Command.get_cmd_string"><code class="name flex">
<span>def <span class="ident">get_cmd_string</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd_string(self, *args, **kwargs):
    nargs = len(args)
    nkwargs = len(kwargs)

    if self._tot_n_args != nargs + nkwargs:
        raise CommandError(
            f&#34;Expected {self._tot_n_args} arguments for command {self._name}, &#34;
            f&#34;got {nargs + nkwargs} arguments.&#34;
        )

    if self._tot_n_args == 0:
        cmd_string = self._cmd or self._name
    elif nargs and nargs == self._n_args:
        cmd_string = self._create_command_string_from_args(*args)
    elif nkwargs and nkwargs == self._n_kwargs:
        cmd_string = self._create_command_string_from_kwargs(**kwargs)
    elif nargs == self._n_kwargs and nkwargs == 0:
        cmd_string = self._create_command_string_from_args_with_kw(*args)
    else:
        raise CommandError(
            f&#34;Expected {self._n_args} positional arguments and {self._n_kwargs} &#34;
            f&#34;keyword arguments for command {self._name}, got {nargs} positional &#34;
            f&#34;and {nkwargs} keyword arguments instead.&#34;
        )

    return cmd_string</code></pre>
</details>
</dd>
<dt id="egse.command.Command.get_command_execution"><code class="name flex">
<span>def <span class="ident">get_command_execution</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_command_execution(self, *args, **kwargs):

    return CommandExecution(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="egse.command.Command.get_device_method"><code class="name flex">
<span>def <span class="ident">get_device_method</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_method(self):
    return self._device_method</code></pre>
</details>
</dd>
<dt id="egse.command.Command.get_device_method_name"><code class="name flex">
<span>def <span class="ident">get_device_method_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_method_name(self):
    return self._device_method.__name__</code></pre>
</details>
</dd>
<dt id="egse.command.Command.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    return self._name</code></pre>
</details>
</dd>
<dt id="egse.command.Command.get_raw_cmd_string"><code class="name flex">
<span>def <span class="ident">get_raw_cmd_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_cmd_string(self):
    return self._cmd</code></pre>
</details>
</dd>
<dt id="egse.command.Command.needs_argument"><code class="name flex">
<span>def <span class="ident">needs_argument</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def needs_argument(self, name):
    if name in self._keys:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="egse.command.Command.validate_arguments"><code class="name flex">
<span>def <span class="ident">validate_arguments</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_arguments(self, *args, **kwargs):

    # Special case for commands with *args or **kwargs, we don&#39;t validate

    if self._cmd in (&#34;*&#34;, &#34;**&#34;):
        return

    nargs = len(args)
    nkwargs = len(kwargs)

    if self._tot_n_args != nargs + nkwargs:
        raise InvalidArgumentsError(
            f&#34;Expected {self._tot_n_args} arguments for command {self._name}, &#34;
            f&#34;got {nargs + nkwargs} arguments.&#34;
        )

    if self._tot_n_args == 0:
        pass
    elif nargs and nargs == self._n_args:
        pass
    elif nkwargs and nkwargs == self._n_kwargs:
        pass
    elif nargs == self._n_kwargs and nkwargs == 0:
        pass
    else:
        raise InvalidArgumentsError(
            f&#34;Expected {self._n_args} positional arguments and {self._n_kwargs} &#34;
            f&#34;keyword arguments for command {self._name}, got {nargs} positional &#34;
            f&#34;and {nkwargs} keyword arguments instead.&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.command.CommandError"><code class="flex name class">
<span>class <span class="ident">CommandError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Command Exception as a base class for this module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandError(Error):
    &#34;&#34;&#34;A Command Exception as a base class for this module.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.exceptions.Error" href="exceptions.html#egse.exceptions.Error">Error</a></li>
<li><a title="egse.exceptions.CommonEGSEException" href="exceptions.html#egse.exceptions.CommonEGSEException">CommonEGSEException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.command.InvalidArgumentsError" href="#egse.command.InvalidArgumentsError">InvalidArgumentsError</a></li>
</ul>
</dd>
<dt id="egse.command.CommandExecution"><code class="flex name class">
<span>class <span class="ident">CommandExecution</span></span>
<span>(</span><span>cmd, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains all the information that is needed to execute a command
with a set of parameters/arguments. The command is however not executed
automatically. That is the responsibility of the caller to actually execute
the command with the given parameters.</p>
<p>Developer info</p>
<p>you can see this as a partial (functools) which defines the command and
its arguments, but doesn't execute until explicitly called. You can execute
the command by calling the <code>cmd</code> with the given arguments:</p>
<p><code>ce = CommandExecution(cmd, 20.0)
...
response = ce.run()</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandExecution:
    &#34;&#34;&#34;
    This class contains all the information that is needed to execute a command
    with a set of parameters/arguments. The command is however not executed
    automatically. That is the responsibility of the caller to actually execute
    the command with the given parameters.

    Developer info

    you can see this as a partial (functools) which defines the command and
    its arguments, but doesn&#39;t execute until explicitly called. You can execute
    the command by calling the `cmd` with the given arguments:

       ```
       ce = CommandExecution(cmd, 20.0)
       ...
       response = ce.run()
       ```
    &#34;&#34;&#34;

    def __init__(self, cmd, *args, **kwargs):
        self._cmd = cmd
        self._args = args
        self._kwargs = kwargs

    def get_name(self):
        return self._cmd.get_name()

    def get_cmd(self):
        return self._cmd

    def get_args(self):
        return self._args

    def get_kwargs(self):
        return self._kwargs

    def run(self):
        return self._cmd(*self._args, **self._kwargs)

    def __str__(self):
        msg = f&#34;[{self.get_cmd().__class__.__name__}] {self.get_name()}(&#34;
        for arg in self.get_args():
            msg += f&#34;{arg}, &#34;
        for k, v in self.get_kwargs().items():
            msg += f&#34;{k}={v}, &#34;
        if msg.endswith(&#34;, &#34;):
            msg = msg[:-2]
        msg += &#34;)&#34;
        return msg</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="egse.command.InvalidCommandExecution" href="#egse.command.InvalidCommandExecution">InvalidCommandExecution</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.command.CommandExecution.get_args"><code class="name flex">
<span>def <span class="ident">get_args</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_args(self):
    return self._args</code></pre>
</details>
</dd>
<dt id="egse.command.CommandExecution.get_cmd"><code class="name flex">
<span>def <span class="ident">get_cmd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cmd(self):
    return self._cmd</code></pre>
</details>
</dd>
<dt id="egse.command.CommandExecution.get_kwargs"><code class="name flex">
<span>def <span class="ident">get_kwargs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_kwargs(self):
    return self._kwargs</code></pre>
</details>
</dd>
<dt id="egse.command.CommandExecution.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    return self._cmd.get_name()</code></pre>
</details>
</dd>
<dt id="egse.command.CommandExecution.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    return self._cmd(*self._args, **self._kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.command.InvalidArgumentsError"><code class="flex name class">
<span>class <span class="ident">InvalidArgumentsError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The arguments provided are invalid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidArgumentsError(CommandError):
    &#34;&#34;&#34;The arguments provided are invalid&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.CommandError" href="#egse.command.CommandError">CommandError</a></li>
<li><a title="egse.exceptions.Error" href="exceptions.html#egse.exceptions.Error">Error</a></li>
<li><a title="egse.exceptions.CommonEGSEException" href="exceptions.html#egse.exceptions.CommonEGSEException">CommonEGSEException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.command.InvalidCommandExecution"><code class="flex name class">
<span>class <span class="ident">InvalidCommandExecution</span></span>
<span>(</span><span>exc, cmd, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A invalid command execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exc</code></strong></dt>
<dd>the Exception that was raised and describes the problem</dd>
<dt><strong><code>cmd</code></strong></dt>
<dd>the Command object</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>the positional arguments that were given</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>the keyword arguments that were given</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidCommandExecution(CommandExecution):
    &#34;&#34;&#34;A invalid command execution.&#34;&#34;&#34;

    def __init__(self, exc, cmd, *args, **kwargs):
        &#34;&#34;&#34;
        Args:
            exc: the Exception that was raised and describes the problem
            cmd: the Command object
            *args: the positional arguments that were given
            **kwargs: the keyword arguments that were given
        &#34;&#34;&#34;
        super().__init__(cmd, *args, **kwargs)
        self._exc = exc

    def run(self):
        raise InvalidArgumentsError(
            f&#34;The command {self.get_name()} can not be executed. Reason: {self._exc}&#34;
        )

    def __str__(self):
        msg = super().__str__()
        msg += f&#34; [ERROR: {self._exc}]&#34;
        return msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="egse.command.CommandExecution" href="#egse.command.CommandExecution">CommandExecution</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.command.InvalidCommandExecution.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    raise InvalidArgumentsError(
        f&#34;The command {self.get_name()} can not be executed. Reason: {self._exc}&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.command.WaitCommand"><code class="flex name class">
<span>class <span class="ident">WaitCommand</span></span>
<span>(</span><span>command, condition)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WaitCommand:
    def __init__(self, command, condition):
        self._command = command
        self._condition = condition

    def __call__(self):

        # .. todo:: do we need a timeout possibility here?

        while True:
            return_code = self._command()
            if self._condition(return_code):
                break

        return 0</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.command.dry_run" href="#egse.command.dry_run">dry_run</a></code></li>
<li><code><a title="egse.command.get_function" href="#egse.command.get_function">get_function</a></code></li>
<li><code><a title="egse.command.get_method" href="#egse.command.get_method">get_method</a></code></li>
<li><code><a title="egse.command.load_commands" href="#egse.command.load_commands">load_commands</a></code></li>
<li><code><a title="egse.command.parse_format_string" href="#egse.command.parse_format_string">parse_format_string</a></code></li>
<li><code><a title="egse.command.stringify_function_call" href="#egse.command.stringify_function_call">stringify_function_call</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.command.ClientServerCommand" href="#egse.command.ClientServerCommand">ClientServerCommand</a></code></h4>
<ul class="">
<li><code><a title="egse.command.ClientServerCommand.client_call" href="#egse.command.ClientServerCommand.client_call">client_call</a></code></li>
<li><code><a title="egse.command.ClientServerCommand.server_call" href="#egse.command.ClientServerCommand.server_call">server_call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.command.Command" href="#egse.command.Command">Command</a></code></h4>
<ul class="">
<li><code><a title="egse.command.Command.doc_string" href="#egse.command.Command.doc_string">doc_string</a></code></li>
<li><code><a title="egse.command.Command.execute" href="#egse.command.Command.execute">execute</a></code></li>
<li><code><a title="egse.command.Command.get_cmd_string" href="#egse.command.Command.get_cmd_string">get_cmd_string</a></code></li>
<li><code><a title="egse.command.Command.get_command_execution" href="#egse.command.Command.get_command_execution">get_command_execution</a></code></li>
<li><code><a title="egse.command.Command.get_device_method" href="#egse.command.Command.get_device_method">get_device_method</a></code></li>
<li><code><a title="egse.command.Command.get_device_method_name" href="#egse.command.Command.get_device_method_name">get_device_method_name</a></code></li>
<li><code><a title="egse.command.Command.get_name" href="#egse.command.Command.get_name">get_name</a></code></li>
<li><code><a title="egse.command.Command.get_raw_cmd_string" href="#egse.command.Command.get_raw_cmd_string">get_raw_cmd_string</a></code></li>
<li><code><a title="egse.command.Command.needs_argument" href="#egse.command.Command.needs_argument">needs_argument</a></code></li>
<li><code><a title="egse.command.Command.validate_arguments" href="#egse.command.Command.validate_arguments">validate_arguments</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.command.CommandError" href="#egse.command.CommandError">CommandError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.command.CommandExecution" href="#egse.command.CommandExecution">CommandExecution</a></code></h4>
<ul class="">
<li><code><a title="egse.command.CommandExecution.get_args" href="#egse.command.CommandExecution.get_args">get_args</a></code></li>
<li><code><a title="egse.command.CommandExecution.get_cmd" href="#egse.command.CommandExecution.get_cmd">get_cmd</a></code></li>
<li><code><a title="egse.command.CommandExecution.get_kwargs" href="#egse.command.CommandExecution.get_kwargs">get_kwargs</a></code></li>
<li><code><a title="egse.command.CommandExecution.get_name" href="#egse.command.CommandExecution.get_name">get_name</a></code></li>
<li><code><a title="egse.command.CommandExecution.run" href="#egse.command.CommandExecution.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.command.InvalidArgumentsError" href="#egse.command.InvalidArgumentsError">InvalidArgumentsError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.command.InvalidCommandExecution" href="#egse.command.InvalidCommandExecution">InvalidCommandExecution</a></code></h4>
<ul class="">
<li><code><a title="egse.command.InvalidCommandExecution.run" href="#egse.command.InvalidCommandExecution.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.command.WaitCommand" href="#egse.command.WaitCommand">WaitCommand</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
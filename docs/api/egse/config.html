<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.config API documentation</title>
<meta name="description" content="This module provides convenience functions to properly configure the Common-EGSE
and to find paths and resources." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.config</code></h1>
</header>
<section id="section-intro">
<p>This module provides convenience functions to properly configure the Common-EGSE
and to find paths and resources.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides convenience functions to properly configure the Common-EGSE
and to find paths and resources.
&#34;&#34;&#34;
from __future__ import annotations

import errno
import fnmatch
import logging
import os
from functools import lru_cache
from os.path import exists
from os.path import join
from pathlib import Path
from pathlib import PurePath
from typing import List
from typing import Optional
from typing import Tuple
from typing import Union

import git

HERE = Path(__file__).parent.resolve()
MODULE_LOGGER = logging.getLogger(__name__)


def find_first_occurrence_of_dir(pattern: str, root: Path | str = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Returns the full path of the directory that first matches the pattern. The directory hierarchy is
    traversed in alphabetical order. The pattern is matched first against all directories in the root
    folder, if there is no match, the first folder in root is traversed until a match is found. If no
    match is found, the second folder in root is traversed.

    Note that the pattern may contain parent directories, like `/egse/data/icons` or `egse/*/icons`,
    in which case the full pattern is matched.

    Args:
        pattern: a filename pattern
        root: the root folder to start the hierarchical search

    Returns:
        The full path of the matched pattern or None if no match could be found.
    &#34;&#34;&#34;
    import fnmatch

    root = Path(root).resolve() if root else HERE
    if not root.is_dir():
        root = root.parent

    parts = pattern.rsplit(&#34;/&#34;, maxsplit=1)
    if len(parts) == 2:
        first_part = parts[0]
        last_part = parts[1]
    else:
        first_part = &#34;&#34;
        last_part = parts[0]

    dirs = sorted([entry.name for entry in root.iterdir() if entry.is_dir()])

    if root.match(f&#34;*{first_part}&#34;) and (matches := fnmatch.filter(dirs, last_part)):
        return root / matches[0]

    for d in dirs:
        if match := find_first_occurrence_of_dir(pattern, root / d):
            return match

    return None


def find_dir(pattern: str, root: str = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Find the first folder that matches the given pattern.

    Note that if there are more folders that match the pattern in the distribution,
    this function only returns the first occurrence that is found, which might
    not be what you want. To be sure only one folder is returned, use the
    `find_dirs()` function and check if there is just one item returned in the list.

    Args:
        pattern (str): pattern to match (use * for wildcard)
        root (str): the top level folder to search [default=common-egse-root]

    Returns:
        the first occurrence of the directory pattern or None when not found.
    &#34;&#34;&#34;
    for folder in find_dirs(pattern, root):
        return folder

    return None


def find_dirs(pattern: str, root: str = None):
    &#34;&#34;&#34;
    Generator for returning directory paths from a walk started at `root` and matching pattern.

    The pattern can contain the asterisk &#39;*&#39; as a wildcard.

    The pattern can contain a directory separator &#39;/&#39; which means
    the last part of the path needs to match these folders.

    Examples:
        &gt;&gt;&gt; for folder in find_dirs(&#34;/egse/images&#34;):
        ...     assert folder.match(&#39;*/egse/images&#39;)

        &gt;&gt;&gt; folders = list(find_dirs(&#34;/egse/images&#34;))
        &gt;&gt;&gt; assert len(folders)

    Args:
        pattern (str): pattern to match (use * for wildcard)
        root (str): the top level folder to search [default=common-egse-root]

    Returns:
         Paths of folders matching pattern, from root.
    &#34;&#34;&#34;
    root = Path(root).resolve() if root else get_common_egse_root()
    if not root.is_dir():
        root = root.parent

    parts = pattern.rsplit(&#34;/&#34;, maxsplit=1)
    if len(parts) == 2:
        first_part = parts[0]
        last_part = parts[1]
    else:
        first_part = &#34;&#34;
        last_part = parts[0]

    for path, folders, files in os.walk(root):
        for name in fnmatch.filter(folders, last_part):
            if path.endswith(first_part):
                yield Path(path) / name


def find_files(pattern: str, root: str | Path = None, in_dir: str = None):
    &#34;&#34;&#34;
    Generator for returning file paths from a top folder, matching the pattern.

    The top folder can be specified as e.g. `__file__` in which case the parent of that file
    will be used as the top root folder. Note that when you specify &#39;.&#39; as the root argument
    the current working directory will be taken as the root folder, which is probably not what
    you intended.

    When the file shall be in a specific directory, use the `in_dir` keyword. This requires
    that the path ends with the given string in `in_dir`.

        &gt;&gt;&gt; file_pattern = &#39;EtherSpaceLink*.dylib&#39;
        &gt;&gt;&gt; in_dir = &#39;lib/CentOS-7&#39;
        &gt;&gt;&gt; for file in find_files(file_pattern, in_dir=in_dir):
        ...     assert file.match(&#34;*lib/CentOS-7/EtherSpaceLink*&#34;)

    Args:
        pattern (str) : sorting pattern (use * for wildcard)
        root (str): the top level folder to search [default=common-egse-root]
        in_dir (str): the &#39;leaf&#39; directory in which the file shall be

    Returns:
        Paths of files matching pattern, from root.
    &#34;&#34;&#34;
    root = Path(root).resolve() if root else get_common_egse_root()
    if not root.is_dir():
        root = root.parent

    exclude_dirs = (&#34;venv&#34;, &#34;venv38&#34;, &#34;.git&#34;, &#34;.idea&#34;, &#34;.DS_Store&#34;)

    for path, folders, files in os.walk(root):
        folders[:] = list(filter(lambda x: x not in exclude_dirs, folders))
        if in_dir and not path.endswith(in_dir):
            continue
        for name in fnmatch.filter(files, pattern):
            yield Path(path) / name


def find_file(name: str, root: str | Path = None, in_dir: str = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Find the path to the given file starting from the root directory of the Common-EGSE
    distribution.

    Note that if there are more files with the given name found in the distribution,
    this function only returns the first file that is found, which might not be
    what you want. To be sure only one file is returned, use the `find_files()`
    function and check if there is just one file returned in the list.

    When the file shall be in a specific directory, use the `in_dir` keyword.
    This requires that the path ends with the given string in `in_dir`.

        &gt;&gt;&gt; file_pattern = &#39;EtherSpaceLink*.dylib&#39;
        &gt;&gt;&gt; in_dir = &#39;lib/CentOS-7&#39;
        &gt;&gt;&gt; file = find_file(file_pattern, in_dir=in_dir)
        &gt;&gt;&gt; assert file.match(&#34;*/lib/CentOS-7/EtherSpace*&#34;)

    Args:
        name (str): the name of the file (can contain wildcards)
        root (str): the top level folder to search [default=common-egse-root]
        in_dir (str): the &#39;leaf&#39; directory in which the file shall be

    Returns:
        the first occurrence of the file or None when not found.
    &#34;&#34;&#34;
    for file_ in find_files(name, root, in_dir):
        return file_

    return None


def find_root(
    path: Union[str, PurePath], tests: Tuple[str, ...] = (), default: str = None
) -&gt; Union[PurePath, None]:
    &#34;&#34;&#34;
    Find the root folder based on the files in ``tests``.

    The algorithm crawls backward over the directory structure until one of the
    items in ``tests`` is matched. and it will return that directory as a ``Path``.

    When no root folder can be determined, the ``default``
    parameter is returned as a Path (or None).

    When nothing is provided in ``tests``, all matches will
    fail and the ``default`` parameter will be returned.

    Args:
        path: folder from which the search is started
        tests: names (files or dirs) to test for existence
        default: returned when no root is found

    Returns:
        a Path which is the root folder.
    &#34;&#34;&#34;

    if path is None:
        return None
    if not Path(path).exists():
        return None

    prev, test = None, Path(path)
    while prev != test:
        if any(test.joinpath(file_).exists() for file_ in tests):
            return test.resolve()
        prev, test = test, test.parent

    return Path(default) if default is not None else None


@lru_cache(maxsize=16)
def get_common_egse_root(path: Union[str, PurePath] = None) -&gt; Optional[PurePath]:
    &#34;&#34;&#34;
    Returns the absolute path to the installation directory for the Common-EGSE.

    The algorithm first tries to determine the path from the environment variable
    ``PLATO_COMMON_EGSE_PATH``. If this environment variable doesn&#39;t exist, the algorithm
    tries to determine the path automatically from (1) the git root if it is a git repository,
    or (2) from the location of this module assuming the installation is done from the
    GitHub distribution.

    When the optional argument ``path`` is given, that directory will be used to start the
    search for the root folder.

    At this moment the algorithm does not cache the ``egse_path`` in order to speed up
    the successive calls to this function.

    Args:
        path (str or Path): a directory as a Path or str [optional]

    Returns:
        Path: the absolute path to the Common-EGSE installation directory or None
    &#34;&#34;&#34;
    _TEST_NAMES = (&#34;pyproject.toml&#34;, &#34;setup.py&#34;)
    if path is not None:
        return find_root(path, tests=_TEST_NAMES)

    egse_path: Union[str, PurePath, None] = os.getenv(&#34;PLATO_COMMON_EGSE_PATH&#34;)

    if egse_path is None:

        # The root of the plato-common-egse installation shall be determined from the location
        # of this config module using git commands to find the git root folder.
        # This assumes the user has installed from git/GitHub (which is not always true)!
        #
        # Alternatively, the root directory can be determined from the location of this module
        # by going back in the directory structure until the ``setup.py`` module is found.

        _THIS_FILE_PATH = Path(__file__).resolve()
        _THIS_FILE_LOCATION = _THIS_FILE_PATH.parent

        try:
            git_repo = git.Repo(_THIS_FILE_PATH, search_parent_directories=True)
            git_root = git_repo.git.rev_parse(&#34;--show-toplevel&#34;)
            egse_path = git_root
        except (git.exc.InvalidGitRepositoryError, git.exc.NoSuchPathError):
            MODULE_LOGGER.info(&#34;no git repository found, assuming installation from distribution.&#34;)
            egse_path = find_root(_THIS_FILE_LOCATION, tests=_TEST_NAMES)

        MODULE_LOGGER.debug(f&#34;Common-EGSE location is automatically determined: {egse_path}.&#34;)

    else:
        MODULE_LOGGER.debug(
            f&#34;Common-EGSE location determined from environment variable &#34;
            f&#34;PLATO_COMMON_EGSE_PATH: {egse_path}&#34;
        )

    return Path(egse_path)


def get_resource_dirs(root_dir: Union[str, PurePath] = None) -&gt; List[Path]:
    &#34;&#34;&#34;
    Define directories that contain resources like images, icons, and data files.

    Resource directories can have the following names: `resources`, `data`, `icons`, or `images`.
    This function checks if any of the resource directories exist in the project root directory,
    in the `root_dir` that is given as an argument or in the `src/egse` sub-folder.

    So, the directories that are searched for the resource folders are:

    * `root_dir` or the project&#39;s root directory
    * the `src/egse` sub-folder of one of the above

    For all existing directories the function returns the absolute path.

    Args:
        root_dir (str): the directory to search for resource folders

    Returns:
        a list of absolute Paths.
    &#34;&#34;&#34;
    project_dir = Path(root_dir).resolve() if root_dir else get_common_egse_root()
    result = []
    for dir_ in [&#34;resources&#34;, &#34;data&#34;, &#34;icons&#34;, &#34;images&#34;]:
        if (project_dir / dir_).is_dir():
            result.append(Path(project_dir, dir_).resolve())
        if (project_dir / &#34;src&#34; / &#34;egse&#34; / dir_).is_dir():
            result.append(Path(project_dir, &#34;src&#34;, &#34;egse&#34;, dir_).resolve())
    return result


def get_resource_path(name: str, resource_root_dir: Union[str, PurePath] = None) -&gt; PurePath:
    &#34;&#34;&#34;
    Searches for a data file (resource) with the given name.

    When `resource_root_dir` is not given, the search for resources will start at the root
    folder of the project (using the function `get_common_egse_root()`). Any other root
    directory can be given, e.g. if you want to start the search from the location of your
    source code file, use `Path(__file__).parent` as the `resource_root_dir` argument.

    Args:
        name (str): the name of the resource that is requested
        resource_root_dir (str): the root directory where the search for resources should be started

    Returns:
        the absolute path of the data file with the given name. The first name that matches
        is returned. If no file with the given name or path exists, a FileNotFoundError is raised.

    &#34;&#34;&#34;
    for resource_dir in get_resource_dirs(resource_root_dir):
        resource_path = join(resource_dir, name)
        if exists(resource_path):
            return Path(resource_path).absolute()
    raise FileNotFoundError(errno.ENOENT, f&#34;Could not locate resource &#39;{name}&#39;&#34;)


def set_logger_levels(logger_levels: List[Tuple] = None):
    &#34;&#34;&#34;
    Set the logging level for the given loggers.

    &#34;&#34;&#34;
    logger_levels = logger_levels or []

    for name, level in logger_levels:
        a_logger = logging.getLogger(name)
        a_logger.setLevel(level)


class WorkingDirectory:
    &#34;&#34;&#34;WorkingDirectory is a context manager to temporarily change the working directory while
    executing some code.

    This context manager has a property `path` which returns the absolute path of the
    current directory.

    Examples:
        &gt;&gt;&gt; with WorkingDirectory(find_dir(&#34;/egse/images&#34;)) as wdir:
        ...     for file in wdir.path.glob(&#39;*&#39;):
        ...         assert file.exists()  # do something with the image files

    &#34;&#34;&#34;

    def __init__(self, path):
        &#34;&#34;&#34;
        Args:
            path (str, Path): the folder to change to within this context
        Raises:
            ValueError when the given path doesn&#39;t exist.
        &#34;&#34;&#34;
        self._temporary_path = Path(path)
        if not self._temporary_path.exists():
            raise ValueError(f&#34;The given path ({path}) doesn&#39;t exist.&#34;)
        self._current_dir = None

    def __enter__(self):
        self._current_dir = os.getcwd()
        os.chdir(self._temporary_path)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            os.chdir(self._current_dir)
        except OSError as exc:
            MODULE_LOGGER.warning(f&#34;Change back to previous directory failed: {exc}&#34;)

    @property
    def path(self):
        &#34;&#34;&#34;Resolve and return the current Path of the context.&#34;&#34;&#34;
        return self._temporary_path.resolve()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.config.find_dir"><code class="name flex">
<span>def <span class="ident">find_dir</span></span>(<span>pattern: str, root: str = None) ‑> Optional[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the first folder that matches the given pattern.</p>
<p>Note that if there are more folders that match the pattern in the distribution,
this function only returns the first occurrence that is found, which might
not be what you want. To be sure only one folder is returned, use the
<code><a title="egse.config.find_dirs" href="#egse.config.find_dirs">find_dirs()</a></code> function and check if there is just one item returned in the list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>pattern to match (use * for wildcard)</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>str</code></dt>
<dd>the top level folder to search [default=common-egse-root]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the first occurrence of the directory pattern or None when not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_dir(pattern: str, root: str = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Find the first folder that matches the given pattern.

    Note that if there are more folders that match the pattern in the distribution,
    this function only returns the first occurrence that is found, which might
    not be what you want. To be sure only one folder is returned, use the
    `find_dirs()` function and check if there is just one item returned in the list.

    Args:
        pattern (str): pattern to match (use * for wildcard)
        root (str): the top level folder to search [default=common-egse-root]

    Returns:
        the first occurrence of the directory pattern or None when not found.
    &#34;&#34;&#34;
    for folder in find_dirs(pattern, root):
        return folder

    return None</code></pre>
</details>
</dd>
<dt id="egse.config.find_dirs"><code class="name flex">
<span>def <span class="ident">find_dirs</span></span>(<span>pattern: str, root: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator for returning directory paths from a walk started at <code>root</code> and matching pattern.</p>
<p>The pattern can contain the asterisk '*' as a wildcard.</p>
<p>The pattern can contain a directory separator '/' which means
the last part of the path needs to match these folders.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; for folder in find_dirs(&quot;/egse/images&quot;):
...     assert folder.match('*/egse/images')
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; folders = list(find_dirs(&quot;/egse/images&quot;))
&gt;&gt;&gt; assert len(folders)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>pattern to match (use * for wildcard)</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>str</code></dt>
<dd>the top level folder to search [default=common-egse-root]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Paths of folders matching pattern, from root.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_dirs(pattern: str, root: str = None):
    &#34;&#34;&#34;
    Generator for returning directory paths from a walk started at `root` and matching pattern.

    The pattern can contain the asterisk &#39;*&#39; as a wildcard.

    The pattern can contain a directory separator &#39;/&#39; which means
    the last part of the path needs to match these folders.

    Examples:
        &gt;&gt;&gt; for folder in find_dirs(&#34;/egse/images&#34;):
        ...     assert folder.match(&#39;*/egse/images&#39;)

        &gt;&gt;&gt; folders = list(find_dirs(&#34;/egse/images&#34;))
        &gt;&gt;&gt; assert len(folders)

    Args:
        pattern (str): pattern to match (use * for wildcard)
        root (str): the top level folder to search [default=common-egse-root]

    Returns:
         Paths of folders matching pattern, from root.
    &#34;&#34;&#34;
    root = Path(root).resolve() if root else get_common_egse_root()
    if not root.is_dir():
        root = root.parent

    parts = pattern.rsplit(&#34;/&#34;, maxsplit=1)
    if len(parts) == 2:
        first_part = parts[0]
        last_part = parts[1]
    else:
        first_part = &#34;&#34;
        last_part = parts[0]

    for path, folders, files in os.walk(root):
        for name in fnmatch.filter(folders, last_part):
            if path.endswith(first_part):
                yield Path(path) / name</code></pre>
</details>
</dd>
<dt id="egse.config.find_file"><code class="name flex">
<span>def <span class="ident">find_file</span></span>(<span>name: str, root: str | Path = None, in_dir: str = None) ‑> Optional[Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the path to the given file starting from the root directory of the Common-EGSE
distribution.</p>
<p>Note that if there are more files with the given name found in the distribution,
this function only returns the first file that is found, which might not be
what you want. To be sure only one file is returned, use the <code><a title="egse.config.find_files" href="#egse.config.find_files">find_files()</a></code>
function and check if there is just one file returned in the list.</p>
<p>When the file shall be in a specific directory, use the <code>in_dir</code> keyword.
This requires that the path ends with the given string in <code>in_dir</code>.</p>
<pre><code>&gt;&gt;&gt; file_pattern = 'EtherSpaceLink*.dylib'
&gt;&gt;&gt; in_dir = 'lib/CentOS-7'
&gt;&gt;&gt; file = find_file(file_pattern, in_dir=in_dir)
&gt;&gt;&gt; assert file.match("*/lib/CentOS-7/EtherSpace*")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the file (can contain wildcards)</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>str</code></dt>
<dd>the top level folder to search [default=common-egse-root]</dd>
<dt><strong><code>in_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the 'leaf' directory in which the file shall be</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the first occurrence of the file or None when not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_file(name: str, root: str | Path = None, in_dir: str = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Find the path to the given file starting from the root directory of the Common-EGSE
    distribution.

    Note that if there are more files with the given name found in the distribution,
    this function only returns the first file that is found, which might not be
    what you want. To be sure only one file is returned, use the `find_files()`
    function and check if there is just one file returned in the list.

    When the file shall be in a specific directory, use the `in_dir` keyword.
    This requires that the path ends with the given string in `in_dir`.

        &gt;&gt;&gt; file_pattern = &#39;EtherSpaceLink*.dylib&#39;
        &gt;&gt;&gt; in_dir = &#39;lib/CentOS-7&#39;
        &gt;&gt;&gt; file = find_file(file_pattern, in_dir=in_dir)
        &gt;&gt;&gt; assert file.match(&#34;*/lib/CentOS-7/EtherSpace*&#34;)

    Args:
        name (str): the name of the file (can contain wildcards)
        root (str): the top level folder to search [default=common-egse-root]
        in_dir (str): the &#39;leaf&#39; directory in which the file shall be

    Returns:
        the first occurrence of the file or None when not found.
    &#34;&#34;&#34;
    for file_ in find_files(name, root, in_dir):
        return file_

    return None</code></pre>
</details>
</dd>
<dt id="egse.config.find_files"><code class="name flex">
<span>def <span class="ident">find_files</span></span>(<span>pattern: str, root: str | Path = None, in_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator for returning file paths from a top folder, matching the pattern.</p>
<p>The top folder can be specified as e.g. <code>__file__</code> in which case the parent of that file
will be used as the top root folder. Note that when you specify '.' as the root argument
the current working directory will be taken as the root folder, which is probably not what
you intended.</p>
<p>When the file shall be in a specific directory, use the <code>in_dir</code> keyword. This requires
that the path ends with the given string in <code>in_dir</code>.</p>
<pre><code>&gt;&gt;&gt; file_pattern = 'EtherSpaceLink*.dylib'
&gt;&gt;&gt; in_dir = 'lib/CentOS-7'
&gt;&gt;&gt; for file in find_files(file_pattern, in_dir=in_dir):
...     assert file.match("*lib/CentOS-7/EtherSpaceLink*")
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt>pattern (str) : sorting pattern (use * for wildcard)</dt>
<dt><strong><code>root</code></strong> :&ensp;<code>str</code></dt>
<dd>the top level folder to search [default=common-egse-root]</dd>
<dt><strong><code>in_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the 'leaf' directory in which the file shall be</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Paths of files matching pattern, from root.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_files(pattern: str, root: str | Path = None, in_dir: str = None):
    &#34;&#34;&#34;
    Generator for returning file paths from a top folder, matching the pattern.

    The top folder can be specified as e.g. `__file__` in which case the parent of that file
    will be used as the top root folder. Note that when you specify &#39;.&#39; as the root argument
    the current working directory will be taken as the root folder, which is probably not what
    you intended.

    When the file shall be in a specific directory, use the `in_dir` keyword. This requires
    that the path ends with the given string in `in_dir`.

        &gt;&gt;&gt; file_pattern = &#39;EtherSpaceLink*.dylib&#39;
        &gt;&gt;&gt; in_dir = &#39;lib/CentOS-7&#39;
        &gt;&gt;&gt; for file in find_files(file_pattern, in_dir=in_dir):
        ...     assert file.match(&#34;*lib/CentOS-7/EtherSpaceLink*&#34;)

    Args:
        pattern (str) : sorting pattern (use * for wildcard)
        root (str): the top level folder to search [default=common-egse-root]
        in_dir (str): the &#39;leaf&#39; directory in which the file shall be

    Returns:
        Paths of files matching pattern, from root.
    &#34;&#34;&#34;
    root = Path(root).resolve() if root else get_common_egse_root()
    if not root.is_dir():
        root = root.parent

    exclude_dirs = (&#34;venv&#34;, &#34;venv38&#34;, &#34;.git&#34;, &#34;.idea&#34;, &#34;.DS_Store&#34;)

    for path, folders, files in os.walk(root):
        folders[:] = list(filter(lambda x: x not in exclude_dirs, folders))
        if in_dir and not path.endswith(in_dir):
            continue
        for name in fnmatch.filter(files, pattern):
            yield Path(path) / name</code></pre>
</details>
</dd>
<dt id="egse.config.find_first_occurrence_of_dir"><code class="name flex">
<span>def <span class="ident">find_first_occurrence_of_dir</span></span>(<span>pattern: str, root: Path | str = None) ‑> Optional[Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the full path of the directory that first matches the pattern. The directory hierarchy is
traversed in alphabetical order. The pattern is matched first against all directories in the root
folder, if there is no match, the first folder in root is traversed until a match is found. If no
match is found, the second folder in root is traversed.</p>
<p>Note that the pattern may contain parent directories, like <code>/egse/data/icons</code> or <code>egse/*/icons</code>,
in which case the full pattern is matched.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong></dt>
<dd>a filename pattern</dd>
<dt><strong><code>root</code></strong></dt>
<dd>the root folder to start the hierarchical search</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The full path of the matched pattern or None if no match could be found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_first_occurrence_of_dir(pattern: str, root: Path | str = None) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    Returns the full path of the directory that first matches the pattern. The directory hierarchy is
    traversed in alphabetical order. The pattern is matched first against all directories in the root
    folder, if there is no match, the first folder in root is traversed until a match is found. If no
    match is found, the second folder in root is traversed.

    Note that the pattern may contain parent directories, like `/egse/data/icons` or `egse/*/icons`,
    in which case the full pattern is matched.

    Args:
        pattern: a filename pattern
        root: the root folder to start the hierarchical search

    Returns:
        The full path of the matched pattern or None if no match could be found.
    &#34;&#34;&#34;
    import fnmatch

    root = Path(root).resolve() if root else HERE
    if not root.is_dir():
        root = root.parent

    parts = pattern.rsplit(&#34;/&#34;, maxsplit=1)
    if len(parts) == 2:
        first_part = parts[0]
        last_part = parts[1]
    else:
        first_part = &#34;&#34;
        last_part = parts[0]

    dirs = sorted([entry.name for entry in root.iterdir() if entry.is_dir()])

    if root.match(f&#34;*{first_part}&#34;) and (matches := fnmatch.filter(dirs, last_part)):
        return root / matches[0]

    for d in dirs:
        if match := find_first_occurrence_of_dir(pattern, root / d):
            return match

    return None</code></pre>
</details>
</dd>
<dt id="egse.config.find_root"><code class="name flex">
<span>def <span class="ident">find_root</span></span>(<span>path: Union[str, PurePath], tests: Tuple[str, ...] = (), default: str = None) ‑> Optional[pathlib.PurePath]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the root folder based on the files in <code>tests</code>.</p>
<p>The algorithm crawls backward over the directory structure until one of the
items in <code>tests</code> is matched. and it will return that directory as a <code>Path</code>.</p>
<p>When no root folder can be determined, the <code>default</code>
parameter is returned as a Path (or None).</p>
<p>When nothing is provided in <code>tests</code>, all matches will
fail and the <code>default</code> parameter will be returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>folder from which the search is started</dd>
<dt><strong><code>tests</code></strong></dt>
<dd>names (files or dirs) to test for existence</dd>
<dt><strong><code>default</code></strong></dt>
<dd>returned when no root is found</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a Path which is the root folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_root(
    path: Union[str, PurePath], tests: Tuple[str, ...] = (), default: str = None
) -&gt; Union[PurePath, None]:
    &#34;&#34;&#34;
    Find the root folder based on the files in ``tests``.

    The algorithm crawls backward over the directory structure until one of the
    items in ``tests`` is matched. and it will return that directory as a ``Path``.

    When no root folder can be determined, the ``default``
    parameter is returned as a Path (or None).

    When nothing is provided in ``tests``, all matches will
    fail and the ``default`` parameter will be returned.

    Args:
        path: folder from which the search is started
        tests: names (files or dirs) to test for existence
        default: returned when no root is found

    Returns:
        a Path which is the root folder.
    &#34;&#34;&#34;

    if path is None:
        return None
    if not Path(path).exists():
        return None

    prev, test = None, Path(path)
    while prev != test:
        if any(test.joinpath(file_).exists() for file_ in tests):
            return test.resolve()
        prev, test = test, test.parent

    return Path(default) if default is not None else None</code></pre>
</details>
</dd>
<dt id="egse.config.get_common_egse_root"><code class="name flex">
<span>def <span class="ident">get_common_egse_root</span></span>(<span>path: Union[str, PurePath] = None) ‑> Optional[pathlib.PurePath]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the absolute path to the installation directory for the Common-EGSE.</p>
<p>The algorithm first tries to determine the path from the environment variable
<code>PLATO_COMMON_EGSE_PATH</code>. If this environment variable doesn't exist, the algorithm
tries to determine the path automatically from (1) the git root if it is a git repository,
or (2) from the location of this module assuming the installation is done from the
GitHub distribution.</p>
<p>When the optional argument <code>path</code> is given, that directory will be used to start the
search for the root folder.</p>
<p>At this moment the algorithm does not cache the <code>egse_path</code> in order to speed up
the successive calls to this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>a directory as a Path or str [optional]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Path</code></dt>
<dd>the absolute path to the Common-EGSE installation directory or None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lru_cache(maxsize=16)
def get_common_egse_root(path: Union[str, PurePath] = None) -&gt; Optional[PurePath]:
    &#34;&#34;&#34;
    Returns the absolute path to the installation directory for the Common-EGSE.

    The algorithm first tries to determine the path from the environment variable
    ``PLATO_COMMON_EGSE_PATH``. If this environment variable doesn&#39;t exist, the algorithm
    tries to determine the path automatically from (1) the git root if it is a git repository,
    or (2) from the location of this module assuming the installation is done from the
    GitHub distribution.

    When the optional argument ``path`` is given, that directory will be used to start the
    search for the root folder.

    At this moment the algorithm does not cache the ``egse_path`` in order to speed up
    the successive calls to this function.

    Args:
        path (str or Path): a directory as a Path or str [optional]

    Returns:
        Path: the absolute path to the Common-EGSE installation directory or None
    &#34;&#34;&#34;
    _TEST_NAMES = (&#34;pyproject.toml&#34;, &#34;setup.py&#34;)
    if path is not None:
        return find_root(path, tests=_TEST_NAMES)

    egse_path: Union[str, PurePath, None] = os.getenv(&#34;PLATO_COMMON_EGSE_PATH&#34;)

    if egse_path is None:

        # The root of the plato-common-egse installation shall be determined from the location
        # of this config module using git commands to find the git root folder.
        # This assumes the user has installed from git/GitHub (which is not always true)!
        #
        # Alternatively, the root directory can be determined from the location of this module
        # by going back in the directory structure until the ``setup.py`` module is found.

        _THIS_FILE_PATH = Path(__file__).resolve()
        _THIS_FILE_LOCATION = _THIS_FILE_PATH.parent

        try:
            git_repo = git.Repo(_THIS_FILE_PATH, search_parent_directories=True)
            git_root = git_repo.git.rev_parse(&#34;--show-toplevel&#34;)
            egse_path = git_root
        except (git.exc.InvalidGitRepositoryError, git.exc.NoSuchPathError):
            MODULE_LOGGER.info(&#34;no git repository found, assuming installation from distribution.&#34;)
            egse_path = find_root(_THIS_FILE_LOCATION, tests=_TEST_NAMES)

        MODULE_LOGGER.debug(f&#34;Common-EGSE location is automatically determined: {egse_path}.&#34;)

    else:
        MODULE_LOGGER.debug(
            f&#34;Common-EGSE location determined from environment variable &#34;
            f&#34;PLATO_COMMON_EGSE_PATH: {egse_path}&#34;
        )

    return Path(egse_path)</code></pre>
</details>
</dd>
<dt id="egse.config.get_resource_dirs"><code class="name flex">
<span>def <span class="ident">get_resource_dirs</span></span>(<span>root_dir: Union[str, PurePath] = None) ‑> List[pathlib.Path]</span>
</code></dt>
<dd>
<div class="desc"><p>Define directories that contain resources like images, icons, and data files.</p>
<p>Resource directories can have the following names: <code>resources</code>, <code>data</code>, <code>icons</code>, or <code>images</code>.
This function checks if any of the resource directories exist in the project root directory,
in the <code>root_dir</code> that is given as an argument or in the <code>src/egse</code> sub-folder.</p>
<p>So, the directories that are searched for the resource folders are:</p>
<ul>
<li><code>root_dir</code> or the project's root directory</li>
<li>the <code>src/egse</code> sub-folder of one of the above</li>
</ul>
<p>For all existing directories the function returns the absolute path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the directory to search for resource folders</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of absolute Paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_dirs(root_dir: Union[str, PurePath] = None) -&gt; List[Path]:
    &#34;&#34;&#34;
    Define directories that contain resources like images, icons, and data files.

    Resource directories can have the following names: `resources`, `data`, `icons`, or `images`.
    This function checks if any of the resource directories exist in the project root directory,
    in the `root_dir` that is given as an argument or in the `src/egse` sub-folder.

    So, the directories that are searched for the resource folders are:

    * `root_dir` or the project&#39;s root directory
    * the `src/egse` sub-folder of one of the above

    For all existing directories the function returns the absolute path.

    Args:
        root_dir (str): the directory to search for resource folders

    Returns:
        a list of absolute Paths.
    &#34;&#34;&#34;
    project_dir = Path(root_dir).resolve() if root_dir else get_common_egse_root()
    result = []
    for dir_ in [&#34;resources&#34;, &#34;data&#34;, &#34;icons&#34;, &#34;images&#34;]:
        if (project_dir / dir_).is_dir():
            result.append(Path(project_dir, dir_).resolve())
        if (project_dir / &#34;src&#34; / &#34;egse&#34; / dir_).is_dir():
            result.append(Path(project_dir, &#34;src&#34;, &#34;egse&#34;, dir_).resolve())
    return result</code></pre>
</details>
</dd>
<dt id="egse.config.get_resource_path"><code class="name flex">
<span>def <span class="ident">get_resource_path</span></span>(<span>name: str, resource_root_dir: Union[str, PurePath] = None) ‑> pathlib.PurePath</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for a data file (resource) with the given name.</p>
<p>When <code>resource_root_dir</code> is not given, the search for resources will start at the root
folder of the project (using the function <code><a title="egse.config.get_common_egse_root" href="#egse.config.get_common_egse_root">get_common_egse_root()</a></code>). Any other root
directory can be given, e.g. if you want to start the search from the location of your
source code file, use <code>Path(__file__).parent</code> as the <code>resource_root_dir</code> argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the resource that is requested</dd>
<dt><strong><code>resource_root_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>the root directory where the search for resources should be started</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the absolute path of the data file with the given name. The first name that matches
is returned. If no file with the given name or path exists, a FileNotFoundError is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_path(name: str, resource_root_dir: Union[str, PurePath] = None) -&gt; PurePath:
    &#34;&#34;&#34;
    Searches for a data file (resource) with the given name.

    When `resource_root_dir` is not given, the search for resources will start at the root
    folder of the project (using the function `get_common_egse_root()`). Any other root
    directory can be given, e.g. if you want to start the search from the location of your
    source code file, use `Path(__file__).parent` as the `resource_root_dir` argument.

    Args:
        name (str): the name of the resource that is requested
        resource_root_dir (str): the root directory where the search for resources should be started

    Returns:
        the absolute path of the data file with the given name. The first name that matches
        is returned. If no file with the given name or path exists, a FileNotFoundError is raised.

    &#34;&#34;&#34;
    for resource_dir in get_resource_dirs(resource_root_dir):
        resource_path = join(resource_dir, name)
        if exists(resource_path):
            return Path(resource_path).absolute()
    raise FileNotFoundError(errno.ENOENT, f&#34;Could not locate resource &#39;{name}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="egse.config.set_logger_levels"><code class="name flex">
<span>def <span class="ident">set_logger_levels</span></span>(<span>logger_levels: List[Tuple] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the logging level for the given loggers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_logger_levels(logger_levels: List[Tuple] = None):
    &#34;&#34;&#34;
    Set the logging level for the given loggers.

    &#34;&#34;&#34;
    logger_levels = logger_levels or []

    for name, level in logger_levels:
        a_logger = logging.getLogger(name)
        a_logger.setLevel(level)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.config.WorkingDirectory"><code class="flex name class">
<span>class <span class="ident">WorkingDirectory</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>WorkingDirectory is a context manager to temporarily change the working directory while
executing some code.</p>
<p>This context manager has a property <code>path</code> which returns the absolute path of the
current directory.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; with WorkingDirectory(find_dir(&quot;/egse/images&quot;)) as wdir:
...     for file in wdir.path.glob('*'):
...         assert file.exists()  # do something with the image files
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str, Path</code></dt>
<dd>the folder to change to within this context</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>ValueError when the given path doesn't exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkingDirectory:
    &#34;&#34;&#34;WorkingDirectory is a context manager to temporarily change the working directory while
    executing some code.

    This context manager has a property `path` which returns the absolute path of the
    current directory.

    Examples:
        &gt;&gt;&gt; with WorkingDirectory(find_dir(&#34;/egse/images&#34;)) as wdir:
        ...     for file in wdir.path.glob(&#39;*&#39;):
        ...         assert file.exists()  # do something with the image files

    &#34;&#34;&#34;

    def __init__(self, path):
        &#34;&#34;&#34;
        Args:
            path (str, Path): the folder to change to within this context
        Raises:
            ValueError when the given path doesn&#39;t exist.
        &#34;&#34;&#34;
        self._temporary_path = Path(path)
        if not self._temporary_path.exists():
            raise ValueError(f&#34;The given path ({path}) doesn&#39;t exist.&#34;)
        self._current_dir = None

    def __enter__(self):
        self._current_dir = os.getcwd()
        os.chdir(self._temporary_path)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            os.chdir(self._current_dir)
        except OSError as exc:
            MODULE_LOGGER.warning(f&#34;Change back to previous directory failed: {exc}&#34;)

    @property
    def path(self):
        &#34;&#34;&#34;Resolve and return the current Path of the context.&#34;&#34;&#34;
        return self._temporary_path.resolve()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.config.WorkingDirectory.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Resolve and return the current Path of the context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self):
    &#34;&#34;&#34;Resolve and return the current Path of the context.&#34;&#34;&#34;
    return self._temporary_path.resolve()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.config.find_dir" href="#egse.config.find_dir">find_dir</a></code></li>
<li><code><a title="egse.config.find_dirs" href="#egse.config.find_dirs">find_dirs</a></code></li>
<li><code><a title="egse.config.find_file" href="#egse.config.find_file">find_file</a></code></li>
<li><code><a title="egse.config.find_files" href="#egse.config.find_files">find_files</a></code></li>
<li><code><a title="egse.config.find_first_occurrence_of_dir" href="#egse.config.find_first_occurrence_of_dir">find_first_occurrence_of_dir</a></code></li>
<li><code><a title="egse.config.find_root" href="#egse.config.find_root">find_root</a></code></li>
<li><code><a title="egse.config.get_common_egse_root" href="#egse.config.get_common_egse_root">get_common_egse_root</a></code></li>
<li><code><a title="egse.config.get_resource_dirs" href="#egse.config.get_resource_dirs">get_resource_dirs</a></code></li>
<li><code><a title="egse.config.get_resource_path" href="#egse.config.get_resource_path">get_resource_path</a></code></li>
<li><code><a title="egse.config.set_logger_levels" href="#egse.config.set_logger_levels">set_logger_levels</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.config.WorkingDirectory" href="#egse.config.WorkingDirectory">WorkingDirectory</a></code></h4>
<ul class="">
<li><code><a title="egse.config.WorkingDirectory.path" href="#egse.config.WorkingDirectory.path">path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
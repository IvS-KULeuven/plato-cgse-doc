<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.logger.log_cs API documentation</title>
<meta name="description" content="The Log Server receives all log messages and events from control servers and client applications
and saves those messages in a log file at a given â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.logger.log_cs</code></h1>
</header>
<section id="section-intro">
<p>The Log Server receives all log messages and events from control servers and client applications
and saves those messages in a log file at a given location.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
The Log Server receives all log messages and events from control servers and client applications
and saves those messages in a log file at a given location.
&#34;&#34;&#34;
import datetime
import logging
import multiprocessing
import pickle
from logging import StreamHandler
from logging.handlers import SocketHandler
from logging.handlers import TimedRotatingFileHandler
from pathlib import Path
from typing import Optional
from typing import Union

import click
import rich
import zmq
from prometheus_client import Counter
from prometheus_client import start_http_server

from egse.env import get_log_file_location
from egse.settings import Settings
from egse.system import format_datetime
from egse.system import replace_environment_variable
from egse.zmq_ser import bind_address
from egse.zmq_ser import connect_address

CTRL_SETTINGS = Settings.load(&#34;Logging Control Server&#34;)


# The format for the log file.
# The line that is saved in the log file shall contain as much information as possible.

LOG_FORMAT_FILE = (
    &#34;%(asctime)s:%(processName)s:%(process)s:%(levelname)s:%(lineno)d:%(name)s:%(message)s&#34;
)

LOG_FORMAT_KEY_VALUE = (
    &#34;level=%(levelname)s ts=%(asctime)s process=%(processName)s process_id=%(process)s caller=%(name)s:%(lineno)s msg=\&#34;%(message)s\&#34;&#34;
)

LOG_FORMAT_DATE = &#34;%Y-%m-%dT%H:%M:%S,%f&#34;

# The format for the console output.
# The line that is printed on the console shall be concise.

LOG_FORMAT_STREAM = &#34;%(asctime)s:%(levelname)s:%(name)s:%(message)s&#34;

LOG_RECORDS = Counter(
    &#34;log_records_count&#34;, &#34;Count the number of log records processed&#34;, [&#34;source&#34;, &#34;name&#34;]
)

LOG_LEVEL_FILE = logging.DEBUG
LOG_LEVEL_STREAM = logging.ERROR
LOG_LEVEL_SOCKET = 1  # ALL records shall go to the socket handler

LOGGER_NAME = &#34;egse.logger.log_cs&#34;

file_handler: Optional[TimedRotatingFileHandler] = None
stream_handler: Optional[StreamHandler] = None
socket_handler: Optional[SocketHandler] = None


class DateTimeFormatter(logging.Formatter):

    def formatTime(self, record, datefmt=None):
        converted_time = datetime.datetime.fromtimestamp(record.created)
        if datefmt:
            return converted_time.strftime(datefmt)
        formatted_time = converted_time.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;)
        return f&#34;{formatted_time}.{record.msecs:03.0f}&#34;


file_formatter = DateTimeFormatter(fmt=LOG_FORMAT_KEY_VALUE, datefmt=LOG_FORMAT_DATE)


@click.group()
def cli():
    pass


@cli.command()
def start():
    &#34;&#34;&#34;Start the Logger Control Server.&#34;&#34;&#34;

    global file_handler, stream_handler, socket_handler

    multiprocessing.current_process().name = &#34;log_cs&#34;

    start_http_server(CTRL_SETTINGS.METRICS_PORT)

    # TODO (rik):
    #   The `max_*` values should be read from the Settings (DONE) and it shall be possible to
    #   overwrite these values from the commandline maybe.

    max_bytes = CTRL_SETTINGS.MAX_SIZE_LOG_FILES * 1024 * 1024
    max_nr_log_files = CTRL_SETTINGS.MAX_NR_LOG_FILES

    log_file_location = Path(get_log_file_location())
    if not log_file_location.exists():
        raise FileNotFoundError(f&#34;The location for the log files doesn&#39;t exist: {log_file_location!s}.&#34;)

    file_handler = TimedRotatingFileHandler(
        filename=log_file_location / &#34;general.log&#34;, when=&#39;midnight&#39;
    )
    file_handler.setFormatter(file_formatter)

    # There is no need to set the level for the handlers, because the level is checked by the
    # Logger and we use the handlers directly here. Use a filter to restrict messages.

    stream_handler = StreamHandler()
    stream_handler.setFormatter(logging.Formatter(fmt=LOG_FORMAT_STREAM))

    # Log records are also sent to the cutelog listening server

    socket_handler = SocketHandler(CTRL_SETTINGS.CUTELOG_IP_ADDRESS, CTRL_SETTINGS.CUTELOG_LISTENING_PORT)
    socket_handler.setFormatter(file_formatter)

    context = zmq.Context()

    endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.LOGGING_PORT)
    receiver = context.socket(zmq.PULL)
    receiver.bind(endpoint)

    endpoint = bind_address(CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.COMMANDING_PORT)
    commander = context.socket(zmq.REP)
    commander.bind(endpoint)

    poller = zmq.Poller()
    poller.register(receiver, zmq.POLLIN)
    poller.register(commander, zmq.POLLIN)

    while True:
        try:
            socks = dict(poller.poll())

            if commander in socks:
                pickle_string = commander.recv()
                command = pickle.loads(pickle_string)

                if command.lower() == &#34;quit&#34;:
                    commander.send(pickle.dumps(&#34;ACK&#34;))
                    break

                response = handle_command(command)
                commander.send(pickle.dumps(response))

            if receiver in socks:
                pickle_string = receiver.recv()
                record = pickle.loads(pickle_string)
                record = logging.makeLogRecord(record)

                handle_log_record(record)

        except KeyboardInterrupt:
            click.echo(&#34;KeyboardInterrupt caught!&#34;)
            break

    record = logging.LogRecord(
        name=LOGGER_NAME,
        level=logging.WARNING,
        pathname=__file__,
        lineno=137,
        msg=&#34;Logger terminated.&#34;,
        args=(),
        exc_info=None,
        func=&#34;start&#34;,
        sinfo=None
    )
    handle_log_record(record)

    file_handler.close()
    stream_handler.close()
    commander.close(linger=0)
    receiver.close(linger=0)


def handle_log_record(record):
    &#34;&#34;&#34;Send the log record to the file handler and the stream handler.&#34;&#34;&#34;
    global file_handler, stream_handler, socket_handler

    if record.levelno &gt;= LOG_LEVEL_FILE:
        file_handler.emit(record)

    if record.levelno &gt;= LOG_LEVEL_STREAM:
        stream_handler.handle(record)

    if record.levelno &gt;= LOG_LEVEL_SOCKET:
        socket_handler.handle(record)

    LOG_RECORDS.labels(source=&#34;all&#34;, name=&#34;all&#34;).inc()
    LOG_RECORDS.labels(source=&#34;logger&#34;, name=record.name).inc()
    LOG_RECORDS.labels(source=&#34;process&#34;, name=record.processName).inc()


def handle_command(command) -&gt; dict:
    &#34;&#34;&#34;Handle commands that are sent to the commanding socket.&#34;&#34;&#34;
    global file_handler
    global LOG_LEVEL_FILE

    response = dict(
        timestamp=format_datetime(),
    )
    if command.lower() == &#39;roll&#39;:
        file_handler.doRollover()
        response.update(dict(status=&#34;ACK&#34;))
        record = logging.LogRecord(
            name=LOGGER_NAME,
            level=logging.WARNING,
            pathname=__file__,
            lineno=197,
            msg=&#34;Logger rolled over.&#34;,
            args=(),
            exc_info=None,
            func=&#34;roll&#34;,
            sinfo=None
        )
        handle_log_record(record)

    elif command.lower() == &#39;status&#39;:
        response.update(dict(
            status=&#34;ACK&#34;,
            file_logger_level=logging.getLevelName(LOG_LEVEL_FILE),
            stream_logger_level=logging.getLevelName(LOG_LEVEL_STREAM),
            file_logger_location=file_handler.baseFilename,
        ))
    elif command.lower().startswith(&#34;set_level&#34;):
        new_level = command.split()[-1]
        LOG_LEVEL_FILE = logging._nameToLevel[new_level]
        response.update(dict(
            status=&#34;ACK&#34;,
            file_logger_level=logging.getLevelName(LOG_LEVEL_FILE),
        ))

    return response


@cli.command()
def stop():
    &#34;&#34;&#34;Stop the Logger Control Server.&#34;&#34;&#34;

    response = send_request(&#34;quit&#34;)
    if response == &#34;ACK&#34;:
        rich.print(&#34;Logger successfully terminated.&#34;)
    else:
        rich.print(f&#34;[red] ERROR: {response}&#34;)


@cli.command()
def roll():
    &#34;&#34;&#34;Roll over the log file of the Logger Control Server.&#34;&#34;&#34;

    response = send_request(&#34;roll&#34;)
    if response.get(&#34;status&#34;) == &#34;ACK&#34;:
        rich.print(&#34;[green]Logger files successfully rotated.&#34;)
    else:
        rich.print(f&#34;[red]ERROR: {response}&#34;)


@cli.command()
def status():
    &#34;&#34;&#34;Roll over the log file of the Logger Control Server.&#34;&#34;&#34;

    rich.print(&#34;Log Manager:&#34;)

    response = send_request(&#34;status&#34;)
    if response.get(&#34;status&#34;) == &#34;ACK&#34;:
        rich.print(&#34;  Status: [green]active&#34;)
        rich.print(f&#34;  Level [grey50](file)[black]: {response.get(&#39;file_logger_level&#39;)}&#34;)
        rich.print(f&#34;  Level [grey50](stdout)[black]: {response.get(&#39;stream_logger_level&#39;)}&#34;)
        rich.print(f&#34;  Log file location: {response.get(&#39;file_logger_location&#39;)}&#34;)
    else:
        rich.print(&#34;  Status: [red]not active&#34;)


@cli.command()
@click.argument(&#39;level&#39;)
def level(level: Union[int, str]):
    &#34;&#34;&#34;Set the logging level for &#34;&#34;&#34;
    try:
        level = logging.getLevelName(int(level))
    except ValueError:
        if level not in logging._nameToLevel:
            rich.print(f&#34;[red]Invalid logging level given &#39;{level}&#39;.&#34;)
            rich.print(f&#34;Should be one of {logging._levelToName}.&#34;)
            return

    response = send_request(f&#34;set_level {level}&#34;)
    if response.get(&#34;status&#34;) == &#34;ACK&#34;:
        rich.print(f&#34;Log level on the server is now set to {response.get(&#39;file_logger_level&#39;)}.&#34;)
    else:
        rich.print(f&#34;[red]ERROR: {response}&#34;)


TIMEOUT_RECV = 1.0  # seconds


def send_request(command_request: str):
    &#34;&#34;&#34;Sends a request to the Logger Control Server and waits for a response.&#34;&#34;&#34;
    ctx = zmq.Context().instance()
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket = ctx.socket(zmq.REQ)
    socket.connect(endpoint)

    socket.send(pickle.dumps(command_request))
    rlist, _, _ = zmq.select([socket], [], [], timeout=TIMEOUT_RECV)
    if socket in rlist:
        response = socket.recv()
        response = pickle.loads(response)
    else:
        response = {&#34;error&#34;: &#34;Receive from ZeroMQ socket timed out for Logger Control Server.&#34;}
    socket.close(linger=0)

    return response


if __name__ == &#34;__main__&#34;:
    cli()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.logger.log_cs.handle_command"><code class="name flex">
<span>def <span class="ident">handle_command</span></span>(<span>command) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Handle commands that are sent to the commanding socket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_command(command) -&gt; dict:
    &#34;&#34;&#34;Handle commands that are sent to the commanding socket.&#34;&#34;&#34;
    global file_handler
    global LOG_LEVEL_FILE

    response = dict(
        timestamp=format_datetime(),
    )
    if command.lower() == &#39;roll&#39;:
        file_handler.doRollover()
        response.update(dict(status=&#34;ACK&#34;))
        record = logging.LogRecord(
            name=LOGGER_NAME,
            level=logging.WARNING,
            pathname=__file__,
            lineno=197,
            msg=&#34;Logger rolled over.&#34;,
            args=(),
            exc_info=None,
            func=&#34;roll&#34;,
            sinfo=None
        )
        handle_log_record(record)

    elif command.lower() == &#39;status&#39;:
        response.update(dict(
            status=&#34;ACK&#34;,
            file_logger_level=logging.getLevelName(LOG_LEVEL_FILE),
            stream_logger_level=logging.getLevelName(LOG_LEVEL_STREAM),
            file_logger_location=file_handler.baseFilename,
        ))
    elif command.lower().startswith(&#34;set_level&#34;):
        new_level = command.split()[-1]
        LOG_LEVEL_FILE = logging._nameToLevel[new_level]
        response.update(dict(
            status=&#34;ACK&#34;,
            file_logger_level=logging.getLevelName(LOG_LEVEL_FILE),
        ))

    return response</code></pre>
</details>
</dd>
<dt id="egse.logger.log_cs.handle_log_record"><code class="name flex">
<span>def <span class="ident">handle_log_record</span></span>(<span>record)</span>
</code></dt>
<dd>
<div class="desc"><p>Send the log record to the file handler and the stream handler.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_log_record(record):
    &#34;&#34;&#34;Send the log record to the file handler and the stream handler.&#34;&#34;&#34;
    global file_handler, stream_handler, socket_handler

    if record.levelno &gt;= LOG_LEVEL_FILE:
        file_handler.emit(record)

    if record.levelno &gt;= LOG_LEVEL_STREAM:
        stream_handler.handle(record)

    if record.levelno &gt;= LOG_LEVEL_SOCKET:
        socket_handler.handle(record)

    LOG_RECORDS.labels(source=&#34;all&#34;, name=&#34;all&#34;).inc()
    LOG_RECORDS.labels(source=&#34;logger&#34;, name=record.name).inc()
    LOG_RECORDS.labels(source=&#34;process&#34;, name=record.processName).inc()</code></pre>
</details>
</dd>
<dt id="egse.logger.log_cs.send_request"><code class="name flex">
<span>def <span class="ident">send_request</span></span>(<span>command_request:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a request to the Logger Control Server and waits for a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request(command_request: str):
    &#34;&#34;&#34;Sends a request to the Logger Control Server and waits for a response.&#34;&#34;&#34;
    ctx = zmq.Context().instance()
    endpoint = connect_address(
        CTRL_SETTINGS.PROTOCOL, CTRL_SETTINGS.HOSTNAME, CTRL_SETTINGS.COMMANDING_PORT
    )
    socket = ctx.socket(zmq.REQ)
    socket.connect(endpoint)

    socket.send(pickle.dumps(command_request))
    rlist, _, _ = zmq.select([socket], [], [], timeout=TIMEOUT_RECV)
    if socket in rlist:
        response = socket.recv()
        response = pickle.loads(response)
    else:
        response = {&#34;error&#34;: &#34;Receive from ZeroMQ socket timed out for Logger Control Server.&#34;}
    socket.close(linger=0)

    return response</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.logger.log_cs.DateTimeFormatter"><code class="flex name class">
<span>class <span class="ident">DateTimeFormatter</span></span>
<span>(</span><span>fmt=None, datefmt=None, style='%', validate=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Formatter instances are used to convert a LogRecord to text.</p>
<p>Formatters need to know how a LogRecord is constructed. They are
responsible for converting a LogRecord to (usually) a string which can
be interpreted by either a human or an external system. The base Formatter
allows a formatting string to be specified. If none is supplied, the
style-dependent default value, "%(message)s", "{message}", or
"${message}", is used.</p>
<p>The Formatter can be initialized with a format string which makes use of
knowledge of the LogRecord attributes - e.g. the default value mentioned
above makes use of the fact that the user's message and arguments are pre-
formatted into a LogRecord's message attribute. Currently, the useful
attributes in a LogRecord are described by:</p>
<p>%(name)s
Name of the logger (logging channel)
%(levelno)s
Numeric logging level for the message (DEBUG, INFO,
WARNING, ERROR, CRITICAL)
%(levelname)s
Text logging level for the message ("DEBUG", "INFO",
"WARNING", "ERROR", "CRITICAL")
%(pathname)s
Full pathname of the source file where the logging
call was issued (if available)
%(filename)s
Filename portion of pathname
%(module)s
Module (name portion of filename)
%(lineno)d
Source line number where the logging call was issued
(if available)
%(funcName)s
Function name
%(created)f
Time when the LogRecord was created (time.time()
return value)
%(asctime)s
Textual time when the LogRecord was created
%(msecs)d
Millisecond portion of the creation time
%(relativeCreated)d Time in milliseconds when the LogRecord was created,
relative to the time the logging module was loaded
(typically at application startup time)
%(thread)d
Thread ID (if available)
%(threadName)s
Thread name (if available)
%(process)d
Process ID (if available)
%(message)s
The result of record.getMessage(), computed just as
the record is emitted</p>
<p>Initialize the formatter with specified format strings.</p>
<p>Initialize the formatter either with the specified format string, or a
default as described above. Allow for specialized date formatting with
the optional datefmt argument. If datefmt is omitted, you get an
ISO8601-like (or RFC 3339-like) format.</p>
<p>Use a style parameter of '%', '{' or '$' to specify that you want to
use one of %-formatting, :meth:<code>str.format</code> (<code>{}</code>) formatting or
:class:<code>string.Template</code> formatting in your format string.</p>
<div class="admonition versionchanged">
<p class="admonition-title">Changed in version:&ensp;3.2</p>
<p>Added the <code>style</code> parameter.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateTimeFormatter(logging.Formatter):

    def formatTime(self, record, datefmt=None):
        converted_time = datetime.datetime.fromtimestamp(record.created)
        if datefmt:
            return converted_time.strftime(datefmt)
        formatted_time = converted_time.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;)
        return f&#34;{formatted_time}.{record.msecs:03.0f}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Formatter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.logger.log_cs.DateTimeFormatter.formatTime"><code class="name flex">
<span>def <span class="ident">formatTime</span></span>(<span>self, record, datefmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the creation time of the specified LogRecord as formatted text.</p>
<p>This method should be called from format() by a formatter which
wants to make use of a formatted time. This method can be overridden
in formatters to provide for any specific requirement, but the
basic behaviour is as follows: if datefmt (a string) is specified,
it is used with time.strftime() to format the creation time of the
record. Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
The resulting string is returned. This function uses a user-configurable
function to convert the creation time to a tuple. By default,
time.localtime() is used; to change this for a particular formatter
instance, set the 'converter' attribute to a function with the same
signature as time.localtime() or time.gmtime(). To change it for all
formatters, for example if you want all logging times to be shown in GMT,
set the 'converter' attribute in the Formatter class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatTime(self, record, datefmt=None):
    converted_time = datetime.datetime.fromtimestamp(record.created)
    if datefmt:
        return converted_time.strftime(datefmt)
    formatted_time = converted_time.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;)
    return f&#34;{formatted_time}.{record.msecs:03.0f}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.logger" href="index.html">egse.logger</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.logger.log_cs.handle_command" href="#egse.logger.log_cs.handle_command">handle_command</a></code></li>
<li><code><a title="egse.logger.log_cs.handle_log_record" href="#egse.logger.log_cs.handle_log_record">handle_log_record</a></code></li>
<li><code><a title="egse.logger.log_cs.send_request" href="#egse.logger.log_cs.send_request">send_request</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.logger.log_cs.DateTimeFormatter" href="#egse.logger.log_cs.DateTimeFormatter">DateTimeFormatter</a></code></h4>
<ul class="">
<li><code><a title="egse.logger.log_cs.DateTimeFormatter.formatTime" href="#egse.logger.log_cs.DateTimeFormatter.formatTime">formatTime</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
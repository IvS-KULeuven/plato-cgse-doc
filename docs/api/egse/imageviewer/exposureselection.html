<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.imageviewer.exposureselection API documentation</title>
<meta name="description" content="This module provides a (local) plugin for the Ginga reference viewer, to select which
exposure from which window will be shown.
The exposures of any â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.imageviewer.exposureselection</code></h1>
</header>
<section id="section-intro">
<p>This module provides a (local) plugin for the Ginga reference viewer, to select which
exposure from which window will be shown.
The exposures of any given window, are
stored in extensions in the FITS file, with the same name.
By default, the image is
rotated to match the orientation of the focal-plane reference frame.
The orientation
angle of the window/sub-field (and CCD) w.r.t. the focal-plane reference frame (in degrees)
is read from the "CROTA2" keyword of the header of that image.</p>
<p>To start the Ginga reference viewer, with this extra plugin, execute the following set of commands:</p>
<pre><code>$ mkdir $HOME/.ginga/plugins
$ cp exposureselection.py $HOME/.ginga/plugins/ExposureSelection.py
$ ginga --plugins=ExposureSelection --loglevel=20 --stderr --log=/tmp/ginga.log
</code></pre>
<p>The plugin will then be available via the "Operation" button in the Plugin Manager bar
(currently under "Custom").</p>
<p>Alternatively, you can start the image viewer with the command:</p>
<pre><code>$ ./bin/start-image-viewer.bash
</code></pre>
<p>This is the same as the Ginga reference viewer, with all the additional PLATO-specific
plugins.
These plugins will then be available via the "Operation" button in the Plugin Manager bar
(under "PLATO").</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides a (local) plugin for the Ginga reference viewer, to select which
exposure from which window will be shown.  The exposures of any given window, are
stored in extensions in the FITS file, with the same name.  By default, the image is
rotated to match the orientation of the focal-plane reference frame.  The orientation 
angle of the window/sub-field (and CCD) w.r.t. the focal-plane reference frame (in degrees)
is read from the &#34;CROTA2&#34; keyword of the header of that image.

To start the Ginga reference viewer, with this extra plugin, execute the following set of commands:

    $ mkdir $HOME/.ginga/plugins
    $ cp exposureselection.py $HOME/.ginga/plugins/ExposureSelection.py
    $ ginga --plugins=ExposureSelection --loglevel=20 --stderr --log=/tmp/ginga.log

The plugin will then be available via the &#34;Operation&#34; button in the Plugin Manager bar
(currently under &#34;Custom&#34;).

Alternatively, you can start the image viewer with the command:

    $ ./bin/start-image-viewer.bash

This is the same as the Ginga reference viewer, with all the additional PLATO-specific
plugins.  These plugins will then be available via the &#34;Operation&#34; button in the Plugin Manager bar
(under &#34;PLATO&#34;).
&#34;&#34;&#34;

import time
import re
import os
import numpy as np

from ginga.gw import Widgets
from ginga.misc import Future
from ginga import GingaPlugin
from ginga.util import iohelper


class ExposureSelection(GingaPlugin.LocalPlugin):

    def __init__(self, fv, fitsimage):

        &#34;&#34;&#34;
        Initialisation of a new (local) plugin for the Ginga reference viewer, to choose
        a specific exposure for a specific window.  The names of the windows are stored in
        the &#34;EXTNAME&#34; keyword of the header of the individual HDUs.

        Called when the plugin is loaded from the first time.

        Args:
            - fv: Reference to the Ginga (reference viewer) shell.
            - fitsimage: Reference to the specific viewer object associated with
                         the channel on which the plugin is being invoked.
        &#34;&#34;&#34;

        super(ExposureSelection, self).__init__(fv, fitsimage)

        self._windows = {}

        self.gui_up = False
        self.path = None
        self.file_obj = None

        self.t_ = self.fitsimage.get_settings()

    def build_gui(self, container):

        &#34;&#34;&#34;
        When the plugin is activated, a GUI is built and packed into the given 
        container. This consists of the following elements:

            - label with the number of windows;
            - combobox to choose the window;
            - spinner to choose the exposure (for the current window);
            - close button.
        
        Args:
            - container: Container in which to pack the GUI.
        &#34;&#34;&#34;

        vbox = Widgets.VBox()
        vbox.set_border_width(1)
        vbox.set_spacing(1)

        captions = [(&#34;Number of windows:&#34;, &#34;llabel&#34;, &#34;Num Windows Label&#34;, &#34;llabel&#34;),        # Label with the number of windows
                    (&#34;Choose Window&#34;, &#34;llabel&#34;, &#34;Choose Window Combobox&#34;, &#34;combobox&#34;),      # Combobox to choose the window
                    (&#34;Choose Exposure&#34;, &#34;llabel&#34;, &#34;Choose Exposure Spinner&#34;, &#34;spinbutton&#34;), # Spinner to choose the exposure (for the current window)
                    (&#34;Spacer&#34;, &#34;spacer&#34;),
                    (&#34;Align with focal plane reference frame&#34;, &#34;checkbutton&#34;),              # Checkbutton to align with the focal-plane reference frame
                    (&#34;Spacer&#34;, &#34;spacer&#34;),
                    (&#34;Close&#34;, &#34;button&#34;)]                                             # Close button

        w, b = Widgets.build_info(captions, orientation=&#34;vertical&#34;)
        self.w.update(b)

        self.w.num_windows_label = b.num_windows_label
        self.w.num_windows_label.set_text(&#34;0&#34;)

        self.w.window_combobox = b.choose_window_combobox
        self.w.window_combobox.set_tooltip(&#34;Choose which window to view&#34;)

        self.w.exposure_spinner = b.choose_exposure_spinner
        self.w.exposure_spinner.set_tooltip(&#34;Choose which exposure to view (for the current window)&#34;)
        self.w.exposure_spinner.hide()

        self.w.alignment_checkbox = b.align_with_focal_plane_reference_frame
        self.w.alignment_checkbox.set_tooltip(&#34;Check to align images with focal-plane reference plane.  Uncheck to use CCD reference frame instead.&#34;)

        self.w.close_button = b.close
        self.w.close_button.add_callback(&#39;activated&#39;, lambda w: self.close())
            
        vbox.add_widget(w)
        container.add_widget(vbox, stretch=1)

        self.selected_window = None     # No window selected
        self.selected_exposure = None   # No exposure selected

    def start(self):

        &#34;&#34;&#34;
        Update the plugin when a new FITS file is loaded.
        &#34;&#34;&#34;

        self.resume()

    def resume(self):

        &#34;&#34;&#34;
        Update the plugin when a new FITS file is loaded.
        &#34;&#34;&#34;

        self.redo()

    def redo(self):

        &#34;&#34;&#34;
        Update the plugin when a new FITS file is loaded.
        &#34;&#34;&#34;

        self.current_image = self.channel.get_current_image()

        # No file loaded -&gt; no action needed

        if self.current_image is None:
            return True
        
        # Path to the loaded file

        path = self.current_image.get(&#39;path&#39;, None)

        # Can&#39;t open file

        if path is None:
            self.fv.show_error(&#34;Cannot open image: no value for metadata key &#39;path&#39;&#34;)
            return

        # ASDF file (instead of FITS) -&gt; no action needed

        if path.endswith(&#34;.asdf&#34;):
            return True 
        
        # New FITS file loaded

        if path != self.path:

            self.path = path

            # Close the previous file opener (if any)

            if self.file_obj is not None:

                try:
                    self.file_obj.close()
                except Exception:
                    pass
            
            self.file_obj = self.current_image.io
            self.file_obj.open_file(path)
            self.hdu_dct = self.file_obj.get_directory()

            self.build_window_list()

            self.w.num_windows_label.set_text(str(len(self._windows)))
            self.selected_window = sorted(self._windows)[0]
            self.w.exposure_spinner.show()
            self.selected_exposure = 1
            
            self.prepare_selection(self.w.window_combobox, self.w.exposure_spinner)
            self.prepare_alignment(self.w.alignment_checkbox)

            self.w.alignment_checkbox.set_state(True)

    def build_window_list(self):

        &#34;&#34;&#34;
        Take stock of the different extension names occur in the FITS file, having
        image data in it (so the primary HDU is not included).  Each extension corresponds
        to a window and for each window we store the slice indices (as they occur in the
        FITS file) of the images corresponding to that window.  These slices correspond to
        the exposures of the window.
        &#34;&#34;&#34;

        index = 0

        while True:

            info = self.hdu_dct.get(index, None)
                
            if info is None:
                break

            if info[&#34;htype&#34;] == &#34;ImageHDU&#34;:

                window = info[&#34;name&#34;]

                if window.startswith(&#34;WINDOW&#34;):

                    if window in self._windows:
                        self._windows[window].append(index)
                    else:
                        self._windows[window] = [index]
            
            index += 1

    def prepare_selection(self, window_combobox, exposure_spinner):
        &#34;&#34;&#34;
        Make sure the given combobox can be used to choose the window and the
        given spinner can be used to choose the exposure.

        Args:
            - window_combobox: Combobox used to select the window.
            - exposure_spinner: Spinner used to select the exposure for the current window.
        &#34;&#34;&#34;

        window_combobox.clear()

        sorted_windows = sorted(self._windows)

        for idx, d in enumerate(sorted_windows):
            if d.startswith(&#34;WINDOW&#34;):
                window_combobox.append_text(d)

        self.select_window(window_combobox, 0, exposure_spinner)

        window_combobox.add_callback(&#34;activated&#34;, self.select_window, exposure_spinner)
        exposure_spinner.add_callback(&#34;value-changed&#34;, self.select_exposure)

    def select_window(self, window_combobox, selected_window, exposure_spinner):
        &#34;&#34;&#34;
        Select the given window and update the spinner to select the exposure for this
        window.  When a new FITS file is loaded or when the currently selected exposure
        is not available for the newly selected window, the first exposure of the newly
        selected will be selected in the spinner and displayed in the central widget of the
        image viewer.

        Args:
            - window_combobox: Combobox used to select the window.
            - selected_window: Index (not the name!) of the new window selected by the
                               combobox.
            - exposure_spinner: Spinner used to select the exposure for the current window.
        &#34;&#34;&#34;

        self.selected_window = self.w.window_combobox.get_text()

        # Update the range of exposures that can be selected for the newly selected window

        lower, upper = 1, len(self._windows[self.selected_window])
        exposure_spinner.set_limits(lower, upper, incr_value=1)

        # If the newly selected window doesn&#39;t have as many exposures as the index of the
        # previously selected exposure (for the previously selected window), select the
        # first exposure (counting of the exposures starts at 1, conform the FITS convention).
        # Otherwise, the same exposure will be selected as before (but for the newly selected
        # window instead).

        if self.selected_exposure &gt; len(self._windows[self.selected_window]):
            self.selected_exposure = 1
        exposure_spinner.set_value(self.selected_exposure)
        
        # Convert the selected window and exposure to slice index in the FITS file

        slice_index = self._windows[self.selected_window][self.selected_exposure - 1]

        # Display the image in the central widget of the image viewer

        self.set_hdu(slice_index)

    def select_exposure(self, exposure_spinner, selected_exposure):

        &#34;&#34;&#34;
        Display the given exposure in the central widget of the image viewer, if the value
        of the given spinner changes to the given value for the current window.

        Args:
            - exposure_spinner: Spinner used to select the exposure for the current window.
            - selected_exposure: New exposure selected by the given spinner.
        &#34;&#34;&#34;

        self.selected_exposure = selected_exposure

        # Convert the selected window and exposure to slice index in the FITS file

        slice_index = self._windows[self.selected_window][selected_exposure - 1]

        # Display the image in the central widget of the image viewer

        self.set_hdu(slice_index)

    def set_hdu(self, slice_index):
        &#34;&#34;&#34;
        Display the given slice from the FITS file in the central widget of the image viewer.
        
        Args:
            - slice_index: Index of the slice that needs to be displayed.
        &#34;&#34;&#34;

        self.logger.debug(&#34;Loading index #%d&#34; % (slice_index))

        info = self.file_obj.get_info_idx(slice_index)
        aidx = (info.name, info.extver)                 # (window, exposure)

        if aidx not in self.hdu_dct:
            aidx = slice_index
        sfx = iohelper.get_hdu_suffix(aidx)

        name = self.current_image.get(&#39;name&#39;, iohelper.name_image_from_path(self.path))
        match = re.match(r&#39;^(.+)\[(.+)\]$&#39;, name)
        if match:
            name = match.group(1)
        
        imname = name + sfx
        chname = self.chname
        chinfo = self.channel

        # The image is still in memory

        if imname in chinfo.datasrc:

            self.curhdu = slice_index
            self.fv.switch_name(chname, imname)

            return

        # The image is not in memory -&gt; load it

        self.logger.debug(&#34;Index %d not in memory; refreshing from file&#34; % (slice_index))

        def _load_idx(image):

            try:

                # Create a future for re-constituting this HDU

                future = Future.Future()
                future.freeze(self.fv.load_image, self.path, idx=aidx)
                image.set(path=self.path, idx=aidx, name=imname, image_future=future)

                self.fv.add_image(imname, image, chname=chname)
                self.curhdu = slice_index
                self.logger.debug(&#34;HDU #%d loaded.&#34; % (slice_index))

            except Exception as e:

                errmsg = &#34;Error loading FITS HDU #%d: %s&#34; % (slice_index, str(e))
                self.logger.error(errmsg)
                self.fv.show_error(errmsg, raisetab=True)

        self.file_obj.load_idx_cont(slice_index, _load_idx)

        if self.w.alignment_checkbox.get_state():

            self.align_hdu_with_focal_plane()

        else:

            self.align_hdu_with_ccd()

    def prepare_alignment(self, alignment_checkbox):

        &#34;&#34;&#34;
        Make sure the checkbox can be used to choose whether to align with
        the focal-plane or the CCD reference frame.

        Args:
            - alignment_checkbox: Checkbox used to choose the alignment.
        &#34;&#34;&#34;

        alignment_checkbox.add_callback(&#34;activated&#34;, self.align_hdu)

    def align_hdu(self, alignment_checkbox, is_checked):

        &#34;&#34;&#34;
        Make sure the images in the central widget of the image viewer are showed aligned
        to either the focal-plane or CCD reference frame, depending on the state of the
        checkbox.

        Args:
            - alignment_checkbox: Checkbox used to choose the alignment.
            - is_checked: New state of the checkbox.
        &#34;&#34;&#34;

        # Checked -&gt; align with the focal-plane reference frame

        if is_checked:

            self.align_hdu_with_focal_plane()

        # Unchecked -&gt; align with the CCD reference frame

        else:

            self.align_hdu_with_ccd()

    def align_hdu_with_focal_plane(self):

        &#34;&#34;&#34;
        From now on, show the images in the central widget of the image viewer aligned
        with the focal-plane reference frame.  The rotation angle is read from the &#34;CROTA2&#34;
        keyword in the FITS header.
        &#34;&#34;&#34;

        header = self.channel.get_current_image().get_header()
        # header = self.fitsimage.get_image().get_header()
        keys = list(header.keys())

        if &#34;CROTA2&#34; in keys:

            rotation_angle = header.get_card(&#34;CROTA2&#34;)[&#34;value&#34;]
            self.t_.set(rot_deg=rotation_angle)
        
        else:
            # TODO
            pass

    def align_hdu_with_ccd(self):

        &#34;&#34;&#34;
        From now on, show the images in the central widget of the image viewer aligned
        with the CCD reference frame (i.e. zero rotation).
        &#34;&#34;&#34;

        self.t_.set(rot_deg=0)

    def close(self):

        &#34;&#34;&#34;
        Close action (to execute when the &#34;Close&#34; button is pushed).
        &#34;&#34;&#34;
        
        self.fv.stop_local_plugin(self.chname, str(self))

        return True

    def stop(self):

        &#34;&#34;&#34;
        Stop the plugin.  Set the variables to None.
        &#34;&#34;&#34;

        self.gui_up = False
        
        if self.file_obj is not None:
            try:
                self.file_obj.close()
            except Exception:
                pass
        
        self.file_obj = None
        self.path = None
        self.hdu_dct = None
        self._windows = None

        self.fv.show_status(&#34;&#34;)

    def __str__(self):
        return &#39;exposureselection&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.imageviewer.exposureselection.ExposureSelection"><code class="flex name class">
<span>class <span class="ident">ExposureSelection</span></span>
<span>(</span><span>fv, fitsimage)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to handle a local plugin.</p>
<p>Initialisation of a new (local) plugin for the Ginga reference viewer, to choose
a specific exposure for a specific window.
The names of the windows are stored in
the "EXTNAME" keyword of the header of the individual HDUs.</p>
<p>Called when the plugin is loaded from the first time.</p>
<h2 id="args">Args</h2>
<ul>
<li>fv: Reference to the Ginga (reference viewer) shell.</li>
<li>fitsimage: Reference to the specific viewer object associated with
the channel on which the plugin is being invoked.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExposureSelection(GingaPlugin.LocalPlugin):

    def __init__(self, fv, fitsimage):

        &#34;&#34;&#34;
        Initialisation of a new (local) plugin for the Ginga reference viewer, to choose
        a specific exposure for a specific window.  The names of the windows are stored in
        the &#34;EXTNAME&#34; keyword of the header of the individual HDUs.

        Called when the plugin is loaded from the first time.

        Args:
            - fv: Reference to the Ginga (reference viewer) shell.
            - fitsimage: Reference to the specific viewer object associated with
                         the channel on which the plugin is being invoked.
        &#34;&#34;&#34;

        super(ExposureSelection, self).__init__(fv, fitsimage)

        self._windows = {}

        self.gui_up = False
        self.path = None
        self.file_obj = None

        self.t_ = self.fitsimage.get_settings()

    def build_gui(self, container):

        &#34;&#34;&#34;
        When the plugin is activated, a GUI is built and packed into the given 
        container. This consists of the following elements:

            - label with the number of windows;
            - combobox to choose the window;
            - spinner to choose the exposure (for the current window);
            - close button.
        
        Args:
            - container: Container in which to pack the GUI.
        &#34;&#34;&#34;

        vbox = Widgets.VBox()
        vbox.set_border_width(1)
        vbox.set_spacing(1)

        captions = [(&#34;Number of windows:&#34;, &#34;llabel&#34;, &#34;Num Windows Label&#34;, &#34;llabel&#34;),        # Label with the number of windows
                    (&#34;Choose Window&#34;, &#34;llabel&#34;, &#34;Choose Window Combobox&#34;, &#34;combobox&#34;),      # Combobox to choose the window
                    (&#34;Choose Exposure&#34;, &#34;llabel&#34;, &#34;Choose Exposure Spinner&#34;, &#34;spinbutton&#34;), # Spinner to choose the exposure (for the current window)
                    (&#34;Spacer&#34;, &#34;spacer&#34;),
                    (&#34;Align with focal plane reference frame&#34;, &#34;checkbutton&#34;),              # Checkbutton to align with the focal-plane reference frame
                    (&#34;Spacer&#34;, &#34;spacer&#34;),
                    (&#34;Close&#34;, &#34;button&#34;)]                                             # Close button

        w, b = Widgets.build_info(captions, orientation=&#34;vertical&#34;)
        self.w.update(b)

        self.w.num_windows_label = b.num_windows_label
        self.w.num_windows_label.set_text(&#34;0&#34;)

        self.w.window_combobox = b.choose_window_combobox
        self.w.window_combobox.set_tooltip(&#34;Choose which window to view&#34;)

        self.w.exposure_spinner = b.choose_exposure_spinner
        self.w.exposure_spinner.set_tooltip(&#34;Choose which exposure to view (for the current window)&#34;)
        self.w.exposure_spinner.hide()

        self.w.alignment_checkbox = b.align_with_focal_plane_reference_frame
        self.w.alignment_checkbox.set_tooltip(&#34;Check to align images with focal-plane reference plane.  Uncheck to use CCD reference frame instead.&#34;)

        self.w.close_button = b.close
        self.w.close_button.add_callback(&#39;activated&#39;, lambda w: self.close())
            
        vbox.add_widget(w)
        container.add_widget(vbox, stretch=1)

        self.selected_window = None     # No window selected
        self.selected_exposure = None   # No exposure selected

    def start(self):

        &#34;&#34;&#34;
        Update the plugin when a new FITS file is loaded.
        &#34;&#34;&#34;

        self.resume()

    def resume(self):

        &#34;&#34;&#34;
        Update the plugin when a new FITS file is loaded.
        &#34;&#34;&#34;

        self.redo()

    def redo(self):

        &#34;&#34;&#34;
        Update the plugin when a new FITS file is loaded.
        &#34;&#34;&#34;

        self.current_image = self.channel.get_current_image()

        # No file loaded -&gt; no action needed

        if self.current_image is None:
            return True
        
        # Path to the loaded file

        path = self.current_image.get(&#39;path&#39;, None)

        # Can&#39;t open file

        if path is None:
            self.fv.show_error(&#34;Cannot open image: no value for metadata key &#39;path&#39;&#34;)
            return

        # ASDF file (instead of FITS) -&gt; no action needed

        if path.endswith(&#34;.asdf&#34;):
            return True 
        
        # New FITS file loaded

        if path != self.path:

            self.path = path

            # Close the previous file opener (if any)

            if self.file_obj is not None:

                try:
                    self.file_obj.close()
                except Exception:
                    pass
            
            self.file_obj = self.current_image.io
            self.file_obj.open_file(path)
            self.hdu_dct = self.file_obj.get_directory()

            self.build_window_list()

            self.w.num_windows_label.set_text(str(len(self._windows)))
            self.selected_window = sorted(self._windows)[0]
            self.w.exposure_spinner.show()
            self.selected_exposure = 1
            
            self.prepare_selection(self.w.window_combobox, self.w.exposure_spinner)
            self.prepare_alignment(self.w.alignment_checkbox)

            self.w.alignment_checkbox.set_state(True)

    def build_window_list(self):

        &#34;&#34;&#34;
        Take stock of the different extension names occur in the FITS file, having
        image data in it (so the primary HDU is not included).  Each extension corresponds
        to a window and for each window we store the slice indices (as they occur in the
        FITS file) of the images corresponding to that window.  These slices correspond to
        the exposures of the window.
        &#34;&#34;&#34;

        index = 0

        while True:

            info = self.hdu_dct.get(index, None)
                
            if info is None:
                break

            if info[&#34;htype&#34;] == &#34;ImageHDU&#34;:

                window = info[&#34;name&#34;]

                if window.startswith(&#34;WINDOW&#34;):

                    if window in self._windows:
                        self._windows[window].append(index)
                    else:
                        self._windows[window] = [index]
            
            index += 1

    def prepare_selection(self, window_combobox, exposure_spinner):
        &#34;&#34;&#34;
        Make sure the given combobox can be used to choose the window and the
        given spinner can be used to choose the exposure.

        Args:
            - window_combobox: Combobox used to select the window.
            - exposure_spinner: Spinner used to select the exposure for the current window.
        &#34;&#34;&#34;

        window_combobox.clear()

        sorted_windows = sorted(self._windows)

        for idx, d in enumerate(sorted_windows):
            if d.startswith(&#34;WINDOW&#34;):
                window_combobox.append_text(d)

        self.select_window(window_combobox, 0, exposure_spinner)

        window_combobox.add_callback(&#34;activated&#34;, self.select_window, exposure_spinner)
        exposure_spinner.add_callback(&#34;value-changed&#34;, self.select_exposure)

    def select_window(self, window_combobox, selected_window, exposure_spinner):
        &#34;&#34;&#34;
        Select the given window and update the spinner to select the exposure for this
        window.  When a new FITS file is loaded or when the currently selected exposure
        is not available for the newly selected window, the first exposure of the newly
        selected will be selected in the spinner and displayed in the central widget of the
        image viewer.

        Args:
            - window_combobox: Combobox used to select the window.
            - selected_window: Index (not the name!) of the new window selected by the
                               combobox.
            - exposure_spinner: Spinner used to select the exposure for the current window.
        &#34;&#34;&#34;

        self.selected_window = self.w.window_combobox.get_text()

        # Update the range of exposures that can be selected for the newly selected window

        lower, upper = 1, len(self._windows[self.selected_window])
        exposure_spinner.set_limits(lower, upper, incr_value=1)

        # If the newly selected window doesn&#39;t have as many exposures as the index of the
        # previously selected exposure (for the previously selected window), select the
        # first exposure (counting of the exposures starts at 1, conform the FITS convention).
        # Otherwise, the same exposure will be selected as before (but for the newly selected
        # window instead).

        if self.selected_exposure &gt; len(self._windows[self.selected_window]):
            self.selected_exposure = 1
        exposure_spinner.set_value(self.selected_exposure)
        
        # Convert the selected window and exposure to slice index in the FITS file

        slice_index = self._windows[self.selected_window][self.selected_exposure - 1]

        # Display the image in the central widget of the image viewer

        self.set_hdu(slice_index)

    def select_exposure(self, exposure_spinner, selected_exposure):

        &#34;&#34;&#34;
        Display the given exposure in the central widget of the image viewer, if the value
        of the given spinner changes to the given value for the current window.

        Args:
            - exposure_spinner: Spinner used to select the exposure for the current window.
            - selected_exposure: New exposure selected by the given spinner.
        &#34;&#34;&#34;

        self.selected_exposure = selected_exposure

        # Convert the selected window and exposure to slice index in the FITS file

        slice_index = self._windows[self.selected_window][selected_exposure - 1]

        # Display the image in the central widget of the image viewer

        self.set_hdu(slice_index)

    def set_hdu(self, slice_index):
        &#34;&#34;&#34;
        Display the given slice from the FITS file in the central widget of the image viewer.
        
        Args:
            - slice_index: Index of the slice that needs to be displayed.
        &#34;&#34;&#34;

        self.logger.debug(&#34;Loading index #%d&#34; % (slice_index))

        info = self.file_obj.get_info_idx(slice_index)
        aidx = (info.name, info.extver)                 # (window, exposure)

        if aidx not in self.hdu_dct:
            aidx = slice_index
        sfx = iohelper.get_hdu_suffix(aidx)

        name = self.current_image.get(&#39;name&#39;, iohelper.name_image_from_path(self.path))
        match = re.match(r&#39;^(.+)\[(.+)\]$&#39;, name)
        if match:
            name = match.group(1)
        
        imname = name + sfx
        chname = self.chname
        chinfo = self.channel

        # The image is still in memory

        if imname in chinfo.datasrc:

            self.curhdu = slice_index
            self.fv.switch_name(chname, imname)

            return

        # The image is not in memory -&gt; load it

        self.logger.debug(&#34;Index %d not in memory; refreshing from file&#34; % (slice_index))

        def _load_idx(image):

            try:

                # Create a future for re-constituting this HDU

                future = Future.Future()
                future.freeze(self.fv.load_image, self.path, idx=aidx)
                image.set(path=self.path, idx=aidx, name=imname, image_future=future)

                self.fv.add_image(imname, image, chname=chname)
                self.curhdu = slice_index
                self.logger.debug(&#34;HDU #%d loaded.&#34; % (slice_index))

            except Exception as e:

                errmsg = &#34;Error loading FITS HDU #%d: %s&#34; % (slice_index, str(e))
                self.logger.error(errmsg)
                self.fv.show_error(errmsg, raisetab=True)

        self.file_obj.load_idx_cont(slice_index, _load_idx)

        if self.w.alignment_checkbox.get_state():

            self.align_hdu_with_focal_plane()

        else:

            self.align_hdu_with_ccd()

    def prepare_alignment(self, alignment_checkbox):

        &#34;&#34;&#34;
        Make sure the checkbox can be used to choose whether to align with
        the focal-plane or the CCD reference frame.

        Args:
            - alignment_checkbox: Checkbox used to choose the alignment.
        &#34;&#34;&#34;

        alignment_checkbox.add_callback(&#34;activated&#34;, self.align_hdu)

    def align_hdu(self, alignment_checkbox, is_checked):

        &#34;&#34;&#34;
        Make sure the images in the central widget of the image viewer are showed aligned
        to either the focal-plane or CCD reference frame, depending on the state of the
        checkbox.

        Args:
            - alignment_checkbox: Checkbox used to choose the alignment.
            - is_checked: New state of the checkbox.
        &#34;&#34;&#34;

        # Checked -&gt; align with the focal-plane reference frame

        if is_checked:

            self.align_hdu_with_focal_plane()

        # Unchecked -&gt; align with the CCD reference frame

        else:

            self.align_hdu_with_ccd()

    def align_hdu_with_focal_plane(self):

        &#34;&#34;&#34;
        From now on, show the images in the central widget of the image viewer aligned
        with the focal-plane reference frame.  The rotation angle is read from the &#34;CROTA2&#34;
        keyword in the FITS header.
        &#34;&#34;&#34;

        header = self.channel.get_current_image().get_header()
        # header = self.fitsimage.get_image().get_header()
        keys = list(header.keys())

        if &#34;CROTA2&#34; in keys:

            rotation_angle = header.get_card(&#34;CROTA2&#34;)[&#34;value&#34;]
            self.t_.set(rot_deg=rotation_angle)
        
        else:
            # TODO
            pass

    def align_hdu_with_ccd(self):

        &#34;&#34;&#34;
        From now on, show the images in the central widget of the image viewer aligned
        with the CCD reference frame (i.e. zero rotation).
        &#34;&#34;&#34;

        self.t_.set(rot_deg=0)

    def close(self):

        &#34;&#34;&#34;
        Close action (to execute when the &#34;Close&#34; button is pushed).
        &#34;&#34;&#34;
        
        self.fv.stop_local_plugin(self.chname, str(self))

        return True

    def stop(self):

        &#34;&#34;&#34;
        Stop the plugin.  Set the variables to None.
        &#34;&#34;&#34;

        self.gui_up = False
        
        if self.file_obj is not None:
            try:
                self.file_obj.close()
            except Exception:
                pass
        
        self.file_obj = None
        self.path = None
        self.hdu_dct = None
        self._windows = None

        self.fv.show_status(&#34;&#34;)

    def __str__(self):
        return &#39;exposureselection&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ginga.GingaPlugin.LocalPlugin</li>
<li>ginga.GingaPlugin.BasePlugin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.align_hdu"><code class="name flex">
<span>def <span class="ident">align_hdu</span></span>(<span>self, alignment_checkbox, is_checked)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure the images in the central widget of the image viewer are showed aligned
to either the focal-plane or CCD reference frame, depending on the state of the
checkbox.</p>
<h2 id="args">Args</h2>
<ul>
<li>alignment_checkbox: Checkbox used to choose the alignment.</li>
<li>is_checked: New state of the checkbox.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_hdu(self, alignment_checkbox, is_checked):

    &#34;&#34;&#34;
    Make sure the images in the central widget of the image viewer are showed aligned
    to either the focal-plane or CCD reference frame, depending on the state of the
    checkbox.

    Args:
        - alignment_checkbox: Checkbox used to choose the alignment.
        - is_checked: New state of the checkbox.
    &#34;&#34;&#34;

    # Checked -&gt; align with the focal-plane reference frame

    if is_checked:

        self.align_hdu_with_focal_plane()

    # Unchecked -&gt; align with the CCD reference frame

    else:

        self.align_hdu_with_ccd()</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.align_hdu_with_ccd"><code class="name flex">
<span>def <span class="ident">align_hdu_with_ccd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>From now on, show the images in the central widget of the image viewer aligned
with the CCD reference frame (i.e. zero rotation).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_hdu_with_ccd(self):

    &#34;&#34;&#34;
    From now on, show the images in the central widget of the image viewer aligned
    with the CCD reference frame (i.e. zero rotation).
    &#34;&#34;&#34;

    self.t_.set(rot_deg=0)</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.align_hdu_with_focal_plane"><code class="name flex">
<span>def <span class="ident">align_hdu_with_focal_plane</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>From now on, show the images in the central widget of the image viewer aligned
with the focal-plane reference frame.
The rotation angle is read from the "CROTA2"
keyword in the FITS header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_hdu_with_focal_plane(self):

    &#34;&#34;&#34;
    From now on, show the images in the central widget of the image viewer aligned
    with the focal-plane reference frame.  The rotation angle is read from the &#34;CROTA2&#34;
    keyword in the FITS header.
    &#34;&#34;&#34;

    header = self.channel.get_current_image().get_header()
    # header = self.fitsimage.get_image().get_header()
    keys = list(header.keys())

    if &#34;CROTA2&#34; in keys:

        rotation_angle = header.get_card(&#34;CROTA2&#34;)[&#34;value&#34;]
        self.t_.set(rot_deg=rotation_angle)
    
    else:
        # TODO
        pass</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.build_gui"><code class="name flex">
<span>def <span class="ident">build_gui</span></span>(<span>self, container)</span>
</code></dt>
<dd>
<div class="desc"><p>When the plugin is activated, a GUI is built and packed into the given
container. This consists of the following elements:</p>
<pre><code>- label with the number of windows;
- combobox to choose the window;
- spinner to choose the exposure (for the current window);
- close button.
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>container: Container in which to pack the GUI.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_gui(self, container):

    &#34;&#34;&#34;
    When the plugin is activated, a GUI is built and packed into the given 
    container. This consists of the following elements:

        - label with the number of windows;
        - combobox to choose the window;
        - spinner to choose the exposure (for the current window);
        - close button.
    
    Args:
        - container: Container in which to pack the GUI.
    &#34;&#34;&#34;

    vbox = Widgets.VBox()
    vbox.set_border_width(1)
    vbox.set_spacing(1)

    captions = [(&#34;Number of windows:&#34;, &#34;llabel&#34;, &#34;Num Windows Label&#34;, &#34;llabel&#34;),        # Label with the number of windows
                (&#34;Choose Window&#34;, &#34;llabel&#34;, &#34;Choose Window Combobox&#34;, &#34;combobox&#34;),      # Combobox to choose the window
                (&#34;Choose Exposure&#34;, &#34;llabel&#34;, &#34;Choose Exposure Spinner&#34;, &#34;spinbutton&#34;), # Spinner to choose the exposure (for the current window)
                (&#34;Spacer&#34;, &#34;spacer&#34;),
                (&#34;Align with focal plane reference frame&#34;, &#34;checkbutton&#34;),              # Checkbutton to align with the focal-plane reference frame
                (&#34;Spacer&#34;, &#34;spacer&#34;),
                (&#34;Close&#34;, &#34;button&#34;)]                                             # Close button

    w, b = Widgets.build_info(captions, orientation=&#34;vertical&#34;)
    self.w.update(b)

    self.w.num_windows_label = b.num_windows_label
    self.w.num_windows_label.set_text(&#34;0&#34;)

    self.w.window_combobox = b.choose_window_combobox
    self.w.window_combobox.set_tooltip(&#34;Choose which window to view&#34;)

    self.w.exposure_spinner = b.choose_exposure_spinner
    self.w.exposure_spinner.set_tooltip(&#34;Choose which exposure to view (for the current window)&#34;)
    self.w.exposure_spinner.hide()

    self.w.alignment_checkbox = b.align_with_focal_plane_reference_frame
    self.w.alignment_checkbox.set_tooltip(&#34;Check to align images with focal-plane reference plane.  Uncheck to use CCD reference frame instead.&#34;)

    self.w.close_button = b.close
    self.w.close_button.add_callback(&#39;activated&#39;, lambda w: self.close())
        
    vbox.add_widget(w)
    container.add_widget(vbox, stretch=1)

    self.selected_window = None     # No window selected
    self.selected_exposure = None   # No exposure selected</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.build_window_list"><code class="name flex">
<span>def <span class="ident">build_window_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Take stock of the different extension names occur in the FITS file, having
image data in it (so the primary HDU is not included).
Each extension corresponds
to a window and for each window we store the slice indices (as they occur in the
FITS file) of the images corresponding to that window.
These slices correspond to
the exposures of the window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_window_list(self):

    &#34;&#34;&#34;
    Take stock of the different extension names occur in the FITS file, having
    image data in it (so the primary HDU is not included).  Each extension corresponds
    to a window and for each window we store the slice indices (as they occur in the
    FITS file) of the images corresponding to that window.  These slices correspond to
    the exposures of the window.
    &#34;&#34;&#34;

    index = 0

    while True:

        info = self.hdu_dct.get(index, None)
            
        if info is None:
            break

        if info[&#34;htype&#34;] == &#34;ImageHDU&#34;:

            window = info[&#34;name&#34;]

            if window.startswith(&#34;WINDOW&#34;):

                if window in self._windows:
                    self._windows[window].append(index)
                else:
                    self._windows[window] = [index]
        
        index += 1</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close action (to execute when the "Close" button is pushed).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):

    &#34;&#34;&#34;
    Close action (to execute when the &#34;Close&#34; button is pushed).
    &#34;&#34;&#34;
    
    self.fv.stop_local_plugin(self.chname, str(self))

    return True</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.prepare_alignment"><code class="name flex">
<span>def <span class="ident">prepare_alignment</span></span>(<span>self, alignment_checkbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure the checkbox can be used to choose whether to align with
the focal-plane or the CCD reference frame.</p>
<h2 id="args">Args</h2>
<ul>
<li>alignment_checkbox: Checkbox used to choose the alignment.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_alignment(self, alignment_checkbox):

    &#34;&#34;&#34;
    Make sure the checkbox can be used to choose whether to align with
    the focal-plane or the CCD reference frame.

    Args:
        - alignment_checkbox: Checkbox used to choose the alignment.
    &#34;&#34;&#34;

    alignment_checkbox.add_callback(&#34;activated&#34;, self.align_hdu)</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.prepare_selection"><code class="name flex">
<span>def <span class="ident">prepare_selection</span></span>(<span>self, window_combobox, exposure_spinner)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure the given combobox can be used to choose the window and the
given spinner can be used to choose the exposure.</p>
<h2 id="args">Args</h2>
<ul>
<li>window_combobox: Combobox used to select the window.</li>
<li>exposure_spinner: Spinner used to select the exposure for the current window.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_selection(self, window_combobox, exposure_spinner):
    &#34;&#34;&#34;
    Make sure the given combobox can be used to choose the window and the
    given spinner can be used to choose the exposure.

    Args:
        - window_combobox: Combobox used to select the window.
        - exposure_spinner: Spinner used to select the exposure for the current window.
    &#34;&#34;&#34;

    window_combobox.clear()

    sorted_windows = sorted(self._windows)

    for idx, d in enumerate(sorted_windows):
        if d.startswith(&#34;WINDOW&#34;):
            window_combobox.append_text(d)

    self.select_window(window_combobox, 0, exposure_spinner)

    window_combobox.add_callback(&#34;activated&#34;, self.select_window, exposure_spinner)
    exposure_spinner.add_callback(&#34;value-changed&#34;, self.select_exposure)</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.redo"><code class="name flex">
<span>def <span class="ident">redo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the plugin when a new FITS file is loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redo(self):

    &#34;&#34;&#34;
    Update the plugin when a new FITS file is loaded.
    &#34;&#34;&#34;

    self.current_image = self.channel.get_current_image()

    # No file loaded -&gt; no action needed

    if self.current_image is None:
        return True
    
    # Path to the loaded file

    path = self.current_image.get(&#39;path&#39;, None)

    # Can&#39;t open file

    if path is None:
        self.fv.show_error(&#34;Cannot open image: no value for metadata key &#39;path&#39;&#34;)
        return

    # ASDF file (instead of FITS) -&gt; no action needed

    if path.endswith(&#34;.asdf&#34;):
        return True 
    
    # New FITS file loaded

    if path != self.path:

        self.path = path

        # Close the previous file opener (if any)

        if self.file_obj is not None:

            try:
                self.file_obj.close()
            except Exception:
                pass
        
        self.file_obj = self.current_image.io
        self.file_obj.open_file(path)
        self.hdu_dct = self.file_obj.get_directory()

        self.build_window_list()

        self.w.num_windows_label.set_text(str(len(self._windows)))
        self.selected_window = sorted(self._windows)[0]
        self.w.exposure_spinner.show()
        self.selected_exposure = 1
        
        self.prepare_selection(self.w.window_combobox, self.w.exposure_spinner)
        self.prepare_alignment(self.w.alignment_checkbox)

        self.w.alignment_checkbox.set_state(True)</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.resume"><code class="name flex">
<span>def <span class="ident">resume</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the plugin when a new FITS file is loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume(self):

    &#34;&#34;&#34;
    Update the plugin when a new FITS file is loaded.
    &#34;&#34;&#34;

    self.redo()</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.select_exposure"><code class="name flex">
<span>def <span class="ident">select_exposure</span></span>(<span>self, exposure_spinner, selected_exposure)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the given exposure in the central widget of the image viewer, if the value
of the given spinner changes to the given value for the current window.</p>
<h2 id="args">Args</h2>
<ul>
<li>exposure_spinner: Spinner used to select the exposure for the current window.</li>
<li>selected_exposure: New exposure selected by the given spinner.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_exposure(self, exposure_spinner, selected_exposure):

    &#34;&#34;&#34;
    Display the given exposure in the central widget of the image viewer, if the value
    of the given spinner changes to the given value for the current window.

    Args:
        - exposure_spinner: Spinner used to select the exposure for the current window.
        - selected_exposure: New exposure selected by the given spinner.
    &#34;&#34;&#34;

    self.selected_exposure = selected_exposure

    # Convert the selected window and exposure to slice index in the FITS file

    slice_index = self._windows[self.selected_window][selected_exposure - 1]

    # Display the image in the central widget of the image viewer

    self.set_hdu(slice_index)</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.select_window"><code class="name flex">
<span>def <span class="ident">select_window</span></span>(<span>self, window_combobox, selected_window, exposure_spinner)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the given window and update the spinner to select the exposure for this
window.
When a new FITS file is loaded or when the currently selected exposure
is not available for the newly selected window, the first exposure of the newly
selected will be selected in the spinner and displayed in the central widget of the
image viewer.</p>
<h2 id="args">Args</h2>
<ul>
<li>window_combobox: Combobox used to select the window.</li>
<li>selected_window: Index (not the name!) of the new window selected by the
combobox.</li>
<li>exposure_spinner: Spinner used to select the exposure for the current window.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_window(self, window_combobox, selected_window, exposure_spinner):
    &#34;&#34;&#34;
    Select the given window and update the spinner to select the exposure for this
    window.  When a new FITS file is loaded or when the currently selected exposure
    is not available for the newly selected window, the first exposure of the newly
    selected will be selected in the spinner and displayed in the central widget of the
    image viewer.

    Args:
        - window_combobox: Combobox used to select the window.
        - selected_window: Index (not the name!) of the new window selected by the
                           combobox.
        - exposure_spinner: Spinner used to select the exposure for the current window.
    &#34;&#34;&#34;

    self.selected_window = self.w.window_combobox.get_text()

    # Update the range of exposures that can be selected for the newly selected window

    lower, upper = 1, len(self._windows[self.selected_window])
    exposure_spinner.set_limits(lower, upper, incr_value=1)

    # If the newly selected window doesn&#39;t have as many exposures as the index of the
    # previously selected exposure (for the previously selected window), select the
    # first exposure (counting of the exposures starts at 1, conform the FITS convention).
    # Otherwise, the same exposure will be selected as before (but for the newly selected
    # window instead).

    if self.selected_exposure &gt; len(self._windows[self.selected_window]):
        self.selected_exposure = 1
    exposure_spinner.set_value(self.selected_exposure)
    
    # Convert the selected window and exposure to slice index in the FITS file

    slice_index = self._windows[self.selected_window][self.selected_exposure - 1]

    # Display the image in the central widget of the image viewer

    self.set_hdu(slice_index)</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.set_hdu"><code class="name flex">
<span>def <span class="ident">set_hdu</span></span>(<span>self, slice_index)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the given slice from the FITS file in the central widget of the image viewer.</p>
<h2 id="args">Args</h2>
<ul>
<li>slice_index: Index of the slice that needs to be displayed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_hdu(self, slice_index):
    &#34;&#34;&#34;
    Display the given slice from the FITS file in the central widget of the image viewer.
    
    Args:
        - slice_index: Index of the slice that needs to be displayed.
    &#34;&#34;&#34;

    self.logger.debug(&#34;Loading index #%d&#34; % (slice_index))

    info = self.file_obj.get_info_idx(slice_index)
    aidx = (info.name, info.extver)                 # (window, exposure)

    if aidx not in self.hdu_dct:
        aidx = slice_index
    sfx = iohelper.get_hdu_suffix(aidx)

    name = self.current_image.get(&#39;name&#39;, iohelper.name_image_from_path(self.path))
    match = re.match(r&#39;^(.+)\[(.+)\]$&#39;, name)
    if match:
        name = match.group(1)
    
    imname = name + sfx
    chname = self.chname
    chinfo = self.channel

    # The image is still in memory

    if imname in chinfo.datasrc:

        self.curhdu = slice_index
        self.fv.switch_name(chname, imname)

        return

    # The image is not in memory -&gt; load it

    self.logger.debug(&#34;Index %d not in memory; refreshing from file&#34; % (slice_index))

    def _load_idx(image):

        try:

            # Create a future for re-constituting this HDU

            future = Future.Future()
            future.freeze(self.fv.load_image, self.path, idx=aidx)
            image.set(path=self.path, idx=aidx, name=imname, image_future=future)

            self.fv.add_image(imname, image, chname=chname)
            self.curhdu = slice_index
            self.logger.debug(&#34;HDU #%d loaded.&#34; % (slice_index))

        except Exception as e:

            errmsg = &#34;Error loading FITS HDU #%d: %s&#34; % (slice_index, str(e))
            self.logger.error(errmsg)
            self.fv.show_error(errmsg, raisetab=True)

    self.file_obj.load_idx_cont(slice_index, _load_idx)

    if self.w.alignment_checkbox.get_state():

        self.align_hdu_with_focal_plane()

    else:

        self.align_hdu_with_ccd()</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the plugin when a new FITS file is loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):

    &#34;&#34;&#34;
    Update the plugin when a new FITS file is loaded.
    &#34;&#34;&#34;

    self.resume()</code></pre>
</details>
</dd>
<dt id="egse.imageviewer.exposureselection.ExposureSelection.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the plugin.
Set the variables to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):

    &#34;&#34;&#34;
    Stop the plugin.  Set the variables to None.
    &#34;&#34;&#34;

    self.gui_up = False
    
    if self.file_obj is not None:
        try:
            self.file_obj.close()
        except Exception:
            pass
    
    self.file_obj = None
    self.path = None
    self.hdu_dct = None
    self._windows = None

    self.fv.show_status(&#34;&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse.imageviewer" href="index.html">egse.imageviewer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.imageviewer.exposureselection.ExposureSelection" href="#egse.imageviewer.exposureselection.ExposureSelection">ExposureSelection</a></code></h4>
<ul class="">
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.align_hdu" href="#egse.imageviewer.exposureselection.ExposureSelection.align_hdu">align_hdu</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.align_hdu_with_ccd" href="#egse.imageviewer.exposureselection.ExposureSelection.align_hdu_with_ccd">align_hdu_with_ccd</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.align_hdu_with_focal_plane" href="#egse.imageviewer.exposureselection.ExposureSelection.align_hdu_with_focal_plane">align_hdu_with_focal_plane</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.build_gui" href="#egse.imageviewer.exposureselection.ExposureSelection.build_gui">build_gui</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.build_window_list" href="#egse.imageviewer.exposureselection.ExposureSelection.build_window_list">build_window_list</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.close" href="#egse.imageviewer.exposureselection.ExposureSelection.close">close</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.prepare_alignment" href="#egse.imageviewer.exposureselection.ExposureSelection.prepare_alignment">prepare_alignment</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.prepare_selection" href="#egse.imageviewer.exposureselection.ExposureSelection.prepare_selection">prepare_selection</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.redo" href="#egse.imageviewer.exposureselection.ExposureSelection.redo">redo</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.resume" href="#egse.imageviewer.exposureselection.ExposureSelection.resume">resume</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.select_exposure" href="#egse.imageviewer.exposureselection.ExposureSelection.select_exposure">select_exposure</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.select_window" href="#egse.imageviewer.exposureselection.ExposureSelection.select_window">select_window</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.set_hdu" href="#egse.imageviewer.exposureselection.ExposureSelection.set_hdu">set_hdu</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.start" href="#egse.imageviewer.exposureselection.ExposureSelection.start">start</a></code></li>
<li><code><a title="egse.imageviewer.exposureselection.ExposureSelection.stop" href="#egse.imageviewer.exposureselection.ExposureSelection.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
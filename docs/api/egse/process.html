<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.process API documentation</title>
<meta name="description" content="This module provides functions and classes to work with processes and sub-processes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.process</code></h1>
</header>
<section id="section-intro">
<p>This module provides functions and classes to work with processes and sub-processes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides functions and classes to work with processes and sub-processes.
&#34;&#34;&#34;
from __future__ import annotations

import contextlib
import datetime
import logging
import os
import subprocess
import threading
import time
import uuid
from typing import List
from typing import Optional

import psutil
from prometheus_client import Gauge

from egse.bits import humanize_bytes
from egse.system import humanize_seconds

LOGGER = logging.getLogger(__name__)


class ProcessStatus:
    &#34;&#34;&#34;
    The ProcessStatus is basically a dataclass that contains the status information of a running
    process.

    The available information is the following:

    * pid: the process identifier
    * uptime: the process up-time as a floating point number expressed in seconds
    * uuid: the UUID1 for this process
    * memory info: memory information on the process
    * cpu usage, percentage and count (number of physical cores)

    &#34;&#34;&#34;

    def __init__(self, *, metrics_prefix: Optional[str] = None):
        self._process = psutil.Process()
        self._cpu_count = psutil.cpu_count(logical=False)
        with self._process.oneshot():
            self._pid: int = self._process.pid
            self._create_time: float = self._process.create_time()
            # not sure if we need to use interval=0.1 as an argument in the next call
            self._cpu_percent: float = self._process.cpu_percent()
            self._cpu_times = self._process.cpu_times()
            self._uptime = (
                    datetime.datetime.now(tz=datetime.timezone.utc).timestamp() - self._create_time
            )
            self._memory_info = self._process.memory_full_info()
        self._uuid: uuid.UUID = uuid.uuid1()

        metrics_prefix = f&#34;{metrics_prefix.lower()}_&#34; if metrics_prefix else &#34;&#34;

        self.metrics = dict(
            PSUTIL_NUMBER_OF_CPU=Gauge(
                f&#34;{metrics_prefix}psutil_number_of_cpu&#34;,
                &#34;Number of physical cores, excluding hyper thread CPUs&#34;
            ),
            PSUTIL_CPU_TIMES=Gauge(
                f&#34;{metrics_prefix}psutil_cpu_times_seconds&#34;,
                &#34;Accumulated process time in seconds&#34;, [&#34;type&#34;]
            ),
            PSUTIL_CPU_PERCENT=Gauge(
                f&#34;{metrics_prefix}psutil_cpu_percent&#34;,
                &#34;The current process CPU utilization as a percentage&#34;
            ),
            PSUTIL_PID=Gauge(
                f&#34;{metrics_prefix}psutil_pid&#34;, &#34;Process ID&#34;
            ),
            PSUTIL_MEMORY_INFO=Gauge(
                f&#34;{metrics_prefix}psutil_memory_info_bytes&#34;,
                &#34;Memory info for this instrumented process&#34;,
                [&#34;type&#34;]
            ),
            PSUTIL_NUMBER_OF_THREADS=Gauge(
                f&#34;{metrics_prefix}psutil_number_of_threads&#34;,
                &#34;Return the number of Thread objects currently alive&#34;
            ),
            PSUTIL_PROC_UPTIME=Gauge(
                f&#34;{metrics_prefix}psutil_proccess_uptime&#34;,
                &#34;Return the time in seconds that the process is up and running&#34;
            ),
        )

        self.metrics[&#34;PSUTIL_NUMBER_OF_CPU&#34;].set(self._cpu_count)
        self.metrics[&#34;PSUTIL_PID&#34;].set(self._process.pid)

        self.update()

    def update_metrics(self):
        &#34;&#34;&#34;
        Updates the metrics that are taken from the psutils module.

        The following metrics are never updated since they are not changed during a
        process execution:

          * PSUTIL_NUMBER_OF_CPU
          * PSUTIL_PID
        &#34;&#34;&#34;

        self.metrics[&#34;PSUTIL_MEMORY_INFO&#34;].labels(type=&#34;rss&#34;).set(self._memory_info.rss)
        self.metrics[&#34;PSUTIL_MEMORY_INFO&#34;].labels(type=&#34;uss&#34;).set(self._memory_info.uss)
        self.metrics[&#34;PSUTIL_CPU_TIMES&#34;].labels(type=&#34;user&#34;).set(self._cpu_times.user)
        self.metrics[&#34;PSUTIL_CPU_TIMES&#34;].labels(type=&#34;system&#34;).set(self._cpu_times.system)
        self.metrics[&#34;PSUTIL_CPU_PERCENT&#34;].set(self._cpu_percent)
        self.metrics[&#34;PSUTIL_NUMBER_OF_THREADS&#34;].set(threading.active_count())
        self.metrics[&#34;PSUTIL_PROC_UPTIME&#34;].set(self._uptime)

    def update(self):
        &#34;&#34;&#34;
        Updates those values that change during execution, like memory usage, number of
        connections, ...

        This call will also update the metrics!

        Returns:
            the ProcessStatus object, self.
        &#34;&#34;&#34;
        self._cpu_percent = self._process.cpu_percent()
        self._cpu_times = self._process.cpu_times()
        self._uptime = time.time() - self._create_time
        self._memory_info = self._process.memory_full_info()

        self.update_metrics()

        return self

    def as_dict(self):
        &#34;&#34;&#34;Returns all process information as a dictionary.

        This runs the `update()` method first to bring the numbers up-to-date.
        &#34;&#34;&#34;
        self.update()
        return {
            &#34;PID&#34;: self._pid,
            &#34;Up&#34;: self._uptime,
            &#34;UUID&#34;: self._uuid,
            &#34;RSS&#34;: self._memory_info.rss,
            &#34;USS&#34;: self._memory_info.uss,
            &#34;CPU User&#34;: self._cpu_times.user,
            &#34;CPU System&#34;: self._cpu_times.system,
            &#34;CPU count&#34;: self._cpu_count,
            &#34;CPU%&#34;: self._cpu_percent,
        }

    def __str__(self):
        self.update()
        msg = (
            f&#34;PID: {self._pid}, &#34;
            f&#34;Up: {humanize_seconds(self._uptime)}, &#34;
            f&#34;UUID: {self._uuid}, &#34;
            f&#34;RSS: {humanize_bytes(self._memory_info.rss)}, &#34;
            f&#34;USS: {humanize_bytes(self._memory_info.uss)}, &#34;
            f&#34;CPU User: {humanize_seconds(self._cpu_times.user)}, &#34;
            f&#34;CPU System: {humanize_seconds(self._cpu_times.system)}, &#34;
            f&#34;CPU Count: {self._cpu_count}, &#34;
            f&#34;CPU%: {self._cpu_percent}&#34;
        )
        return msg


#  * can we restart the same sub process?
#  * do we need to pass the additional arguments to the constructor or to the execute method?
#    When we can restart/re-execute a subprocess, we might want to do that with additional
#    arguments, e.g. to set a debugging flag or to start in simulator mode. Then we will need to
#    do that in the execute method.
#  * Process should have a notion of UUID, which it can request at start-up to communicate to the
#    process manager which can then check if it&#39;s known already or a new process that was started
#    (possible on another computer)


class SubProcess:
    &#34;&#34;&#34;
    A SubProcess that is usually started by the ProcessManager.

    Usage:

        hexapod_ui = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.hexapod.hexapod_ui&#34;])
        hexapod_ui.execute()

    &#34;&#34;&#34;

    def __init__(self, name: str, cmd: List, args: List = None, shell: bool = True):
        self._popen = None
        self._sub_process: psutil.Process = None
        self._name = name
        self._cmd = cmd
        self._args = args or []
        self._shell = shell

    def execute(self, detach_from_parent=False) -&gt; bool:
        &#34;&#34;&#34; Execute the sub-process.

        Args:
            - detach_from_parent: Boolean indicating whether the sub-process should be detached from the
                                  parent process.  If set to False, the sub-process will be killed whenever the
                                  parent process is interrupted or stopped.
        &#34;&#34;&#34;

        try:
            command: List = [*self._cmd, *self._args]
            LOGGER.debug(f&#34;SubProcess command: {command}&#34;)
            # self._popen = subprocess.Popen(command, env=os.environ, close_fds=detach_from_parent)
            self._popen = subprocess.Popen(
                &#34; &#34;.join(command),
                env=os.environ,
                shell=self._shell,  # executable=&#39;/bin/bash&#39;,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                stdin=subprocess.DEVNULL,
            )
            self._sub_process = psutil.Process(self._popen.pid)

            LOGGER.debug(
                f&#34;SubProcess started: {command}, pid={self._popen.pid}, sub_process=&#34;
                f&#34;{self._sub_process} [pid={self._sub_process.pid}]&#34;
            )
        except KeyError:
            LOGGER.error(f&#34;Unknown client process: {self._name}&#34;, exc_info=True)
            return False
        except (PermissionError, FileNotFoundError) as exc:
            # This error is raised when the command is not an executable or is not found
            LOGGER.error(f&#34;Could not execute sub-process: {exc}&#34;, exc_info=True)
            return False
        return True

    @property
    def name(self):
        return self._name

    @property
    def pid(self) -&gt; int:
        return self._sub_process.pid if self._sub_process else None

    def cmdline(self) -&gt; str:
        return &#34; &#34;.join(self._sub_process.cmdline())

    def children(self, recursive: bool = True) -&gt; List:
        return self._sub_process.children(recursive=recursive)

    def is_child(self, pid: int):
        return any(pid == p.pid for p in self._sub_process.children(recursive=True))

    def is_running(self):
        &#34;&#34;&#34;
        Check if this process is still running.

        * checks if process exists
        * checks if process is not a zombie and is not dead

        Returns:
            True if the process is running.
        &#34;&#34;&#34;
        if self._sub_process is None:
            return False
        if self._sub_process.is_running():
            # it still might be a zombie process
            if self._sub_process.status() in [psutil.STATUS_ZOMBIE, psutil.STATUS_DEAD]:
                LOGGER.warning(&#34;The sub-process is dead or a zombie.&#34;)
                return False
            return True
        LOGGER.debug(f&#34;Return value of the sub-process: {self._popen.returncode}&#34;)
        return False

    def exists(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the sub-process exists by checking if its process ID exists.

        Returns:
            True if the sub-process exists.
        &#34;&#34;&#34;
        return psutil.pid_exists(self.pid)

    def quit(self):
        &#34;&#34;&#34;
        Send a request to quit to the process.

        This sends a ZeroMQ message &#34;Quit&#34; to the process. The process is expected to answer with
        &#34;Quiting&#34; and then
        actually ends its execution.

        Returns:
            True when received the answer &#34;Quiting&#34;, False otherwise.
        &#34;&#34;&#34;
        return self.reap_children()

    def reap_children(self, timeout=3):
        &#34;&#34;&#34;Tries hard to terminate and ultimately kill all the children of this process.&#34;&#34;&#34;

        def on_terminate(proc):
            LOGGER.info(f&#34;process {proc} terminated with exit code {proc.returncode}&#34;)

        return_code = 0

        procs = [self._sub_process]
        procs.extend(self._sub_process.children())

        LOGGER.info(f&#34;Processes: {procs}&#34;)

        # send SIGTERM
        for p in procs:
            try:
                LOGGER.info(f&#34;Terminating process {p}&#34;)
                p.terminate()
            except psutil.NoSuchProcess:
                pass
        gone, alive = psutil.wait_procs(procs, timeout=timeout, callback=on_terminate)
        if alive:
            # send SIGKILL
            for p in alive:
                LOGGER.info(f&#34;process {p} survived SIGTERM; trying SIGKILL&#34;)
                try:
                    p.kill()
                except psutil.NoSuchProcess:
                    pass
            gone, alive = psutil.wait_procs(alive, timeout=timeout, callback=on_terminate)
            if alive:
                # give up
                for p in alive:
                    LOGGER.info(f&#34;process {p} survived SIGKILL; giving up&#34;)
                    return_code += 1  # return code indicates how many processes are still running

        return return_code

    def returncode(self):
        &#34;&#34;&#34;
        Check if the sub-process is terminated and return its return code or None when the process
        is still running.
        &#34;&#34;&#34;
        return self._popen.poll()


def is_process_running(items: List[str] | str, contains: bool = True, case_sensitive: bool = False):
    &#34;&#34;&#34;
    Check if there is any running process that contains the given items in its commandline.

    Loops over all running processes and tries to match all items in &#39;cmd_line_items&#39; to the command line
    of the process. If all &#39;cmd_line_items&#39; can be matched to a process, the function returns True.

    Args:
        items: a string or a list of strings that should match command line parts
        contains: if True, the match is done with &#39;in&#39; otherwise &#39;==&#39;
        case_sensitive: if True, the match shall be case-sensitive

    Returns:
        True if there exists a running process with the given items, False otherwise.
    &#34;&#34;&#34;

    def lower(x: str) -&gt; str:
        return x.lower()

    def pass_through(x: str) -&gt; str:
        return x

    case = pass_through if case_sensitive else lower

    if not items:
        LOGGER.warning(&#34;Expected at least one item in &#39;items&#39;, none were given. False returned.&#34;)
        return False

    items = [items] if isinstance(items, str) else items

    for proc in psutil.process_iter():
        with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            # LOGGER.info(f&#34;{proc.name().lower() = }, {proc.cmdline() = }&#34;)
            if contains:
                if all(any(case(y) in case(x) for x in proc.cmdline()) for y in items):
                    return True
            elif all(any(case(y) == case(x) for x in proc.cmdline()) for y in items):
                return True

    return False


def get_process_info(items: List[str] | str, contains: bool = True, case_sensitive: bool = False) -&gt; List:
    &#34;&#34;&#34;
    Loops over all running processes and tries to match each item in &#39;items&#39; to the command line
    of the process. Any process where all &#39;items&#39; can be matched will end up in the response.

    Returns a list with the process info (PID, cmdline, create_time) for any processes where all &#39;items&#39; match
    the process command line. An empty list is returned when not &#39;all the items&#39; match for any of the
    processes.

    Examples:
        &gt;&gt;&gt; get_process_info(items=[&#34;feesim&#34;])
        [
            {
                &#39;pid&#39;: 10166,
                &#39;cmdline&#39;: [
                    &#39;/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python&#39;,
                    &#39;/Users/rik/git/plato-common-egse/venv38/bin/feesim&#39;,
                    &#39;start&#39;,
                    &#39;--zeromq&#39;
                ],
                &#39;create_time&#39;: 1664898231.915995
            }
        ]

        &gt;&gt;&gt; get_process_info(items=[&#34;dpu_cs&#34;, &#34;--zeromq&#34;])
        [
            {
                &#39;pid&#39;: 11595,
                &#39;cmdline&#39;: [
                    &#39;/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python&#39;,
                    &#39;/Users/rik/git/plato-common-egse/venv38/bin/dpu_cs&#39;,
                    &#39;start&#39;,
                    &#39;--zeromq&#39;
                ],
                &#39;create_time&#39;: 1664898973.542281
            }
        ]

    Args:
        items: a string or a list of strings that should match command line items
        contains: if True, the match is done with &#39;in&#39; otherwise &#39;==&#39;
        case_sensitive: if True, the match shall be case-sensitive

    Returns:
        A list of process info entries.

    &#34;&#34;&#34;
    response = []

    def lower(x: str) -&gt; str:
        return x.lower()

    def pass_through(x: str) -&gt; str:
        return x

    case = pass_through if case_sensitive else lower

    if not items:
        LOGGER.warning(&#34;Expected at least one item in &#39;items&#39;, none were given. Empty list returned.&#34;)
        return response

    items = [items] if isinstance(items, str) else items

    for proc in psutil.process_iter():
        with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            # LOGGER.info(f&#34;{proc.name().lower() = }, {proc.cmdline() = }&#34;)
            if contains:
                if all(any(case(y) in case(x) for x in proc.cmdline()) for y in items):
                    response.append(proc.as_dict(attrs=[&#39;pid&#39;, &#39;cmdline&#39;, &#39;create_time&#39;]))
            elif all(any(case(y) == case(x) for x in proc.cmdline()) for y in items):
                response.append(proc.as_dict(attrs=[&#39;pid&#39;, &#39;cmdline&#39;, &#39;create_time&#39;]))

    return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.process.get_process_info"><code class="name flex">
<span>def <span class="ident">get_process_info</span></span>(<span>items: List[str] | str, contains: bool = True, case_sensitive: bool = False) ‑> List</span>
</code></dt>
<dd>
<div class="desc"><p>Loops over all running processes and tries to match each item in 'items' to the command line
of the process. Any process where all 'items' can be matched will end up in the response.</p>
<p>Returns a list with the process info (PID, cmdline, create_time) for any processes where all 'items' match
the process command line. An empty list is returned when not 'all the items' match for any of the
processes.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; get_process_info(items=[&quot;feesim&quot;])
[
    {
        'pid': 10166,
        'cmdline': [
            '/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python',
            '/Users/rik/git/plato-common-egse/venv38/bin/feesim',
            'start',
            '--zeromq'
        ],
        'create_time': 1664898231.915995
    }
]
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; get_process_info(items=[&quot;dpu_cs&quot;, &quot;--zeromq&quot;])
[
    {
        'pid': 11595,
        'cmdline': [
            '/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python',
            '/Users/rik/git/plato-common-egse/venv38/bin/dpu_cs',
            'start',
            '--zeromq'
        ],
        'create_time': 1664898973.542281
    }
]
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>items</code></strong></dt>
<dd>a string or a list of strings that should match command line items</dd>
<dt><strong><code>contains</code></strong></dt>
<dd>if True, the match is done with 'in' otherwise '=='</dd>
<dt><strong><code>case_sensitive</code></strong></dt>
<dd>if True, the match shall be case-sensitive</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of process info entries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_process_info(items: List[str] | str, contains: bool = True, case_sensitive: bool = False) -&gt; List:
    &#34;&#34;&#34;
    Loops over all running processes and tries to match each item in &#39;items&#39; to the command line
    of the process. Any process where all &#39;items&#39; can be matched will end up in the response.

    Returns a list with the process info (PID, cmdline, create_time) for any processes where all &#39;items&#39; match
    the process command line. An empty list is returned when not &#39;all the items&#39; match for any of the
    processes.

    Examples:
        &gt;&gt;&gt; get_process_info(items=[&#34;feesim&#34;])
        [
            {
                &#39;pid&#39;: 10166,
                &#39;cmdline&#39;: [
                    &#39;/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python&#39;,
                    &#39;/Users/rik/git/plato-common-egse/venv38/bin/feesim&#39;,
                    &#39;start&#39;,
                    &#39;--zeromq&#39;
                ],
                &#39;create_time&#39;: 1664898231.915995
            }
        ]

        &gt;&gt;&gt; get_process_info(items=[&#34;dpu_cs&#34;, &#34;--zeromq&#34;])
        [
            {
                &#39;pid&#39;: 11595,
                &#39;cmdline&#39;: [
                    &#39;/Library/Frameworks/Python.framework/Versions/3.8/Resources/Python.app/Contents/MacOS/Python&#39;,
                    &#39;/Users/rik/git/plato-common-egse/venv38/bin/dpu_cs&#39;,
                    &#39;start&#39;,
                    &#39;--zeromq&#39;
                ],
                &#39;create_time&#39;: 1664898973.542281
            }
        ]

    Args:
        items: a string or a list of strings that should match command line items
        contains: if True, the match is done with &#39;in&#39; otherwise &#39;==&#39;
        case_sensitive: if True, the match shall be case-sensitive

    Returns:
        A list of process info entries.

    &#34;&#34;&#34;
    response = []

    def lower(x: str) -&gt; str:
        return x.lower()

    def pass_through(x: str) -&gt; str:
        return x

    case = pass_through if case_sensitive else lower

    if not items:
        LOGGER.warning(&#34;Expected at least one item in &#39;items&#39;, none were given. Empty list returned.&#34;)
        return response

    items = [items] if isinstance(items, str) else items

    for proc in psutil.process_iter():
        with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            # LOGGER.info(f&#34;{proc.name().lower() = }, {proc.cmdline() = }&#34;)
            if contains:
                if all(any(case(y) in case(x) for x in proc.cmdline()) for y in items):
                    response.append(proc.as_dict(attrs=[&#39;pid&#39;, &#39;cmdline&#39;, &#39;create_time&#39;]))
            elif all(any(case(y) == case(x) for x in proc.cmdline()) for y in items):
                response.append(proc.as_dict(attrs=[&#39;pid&#39;, &#39;cmdline&#39;, &#39;create_time&#39;]))

    return response</code></pre>
</details>
</dd>
<dt id="egse.process.is_process_running"><code class="name flex">
<span>def <span class="ident">is_process_running</span></span>(<span>items: List[str] | str, contains: bool = True, case_sensitive: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if there is any running process that contains the given items in its commandline.</p>
<p>Loops over all running processes and tries to match all items in 'cmd_line_items' to the command line
of the process. If all 'cmd_line_items' can be matched to a process, the function returns True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>items</code></strong></dt>
<dd>a string or a list of strings that should match command line parts</dd>
<dt><strong><code>contains</code></strong></dt>
<dd>if True, the match is done with 'in' otherwise '=='</dd>
<dt><strong><code>case_sensitive</code></strong></dt>
<dd>if True, the match shall be case-sensitive</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if there exists a running process with the given items, False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_process_running(items: List[str] | str, contains: bool = True, case_sensitive: bool = False):
    &#34;&#34;&#34;
    Check if there is any running process that contains the given items in its commandline.

    Loops over all running processes and tries to match all items in &#39;cmd_line_items&#39; to the command line
    of the process. If all &#39;cmd_line_items&#39; can be matched to a process, the function returns True.

    Args:
        items: a string or a list of strings that should match command line parts
        contains: if True, the match is done with &#39;in&#39; otherwise &#39;==&#39;
        case_sensitive: if True, the match shall be case-sensitive

    Returns:
        True if there exists a running process with the given items, False otherwise.
    &#34;&#34;&#34;

    def lower(x: str) -&gt; str:
        return x.lower()

    def pass_through(x: str) -&gt; str:
        return x

    case = pass_through if case_sensitive else lower

    if not items:
        LOGGER.warning(&#34;Expected at least one item in &#39;items&#39;, none were given. False returned.&#34;)
        return False

    items = [items] if isinstance(items, str) else items

    for proc in psutil.process_iter():
        with contextlib.suppress(psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            # LOGGER.info(f&#34;{proc.name().lower() = }, {proc.cmdline() = }&#34;)
            if contains:
                if all(any(case(y) in case(x) for x in proc.cmdline()) for y in items):
                    return True
            elif all(any(case(y) == case(x) for x in proc.cmdline()) for y in items):
                return True

    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.process.ProcessStatus"><code class="flex name class">
<span>class <span class="ident">ProcessStatus</span></span>
<span>(</span><span>*, metrics_prefix: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The ProcessStatus is basically a dataclass that contains the status information of a running
process.</p>
<p>The available information is the following:</p>
<ul>
<li>pid: the process identifier</li>
<li>uptime: the process up-time as a floating point number expressed in seconds</li>
<li>uuid: the UUID1 for this process</li>
<li>memory info: memory information on the process</li>
<li>cpu usage, percentage and count (number of physical cores)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessStatus:
    &#34;&#34;&#34;
    The ProcessStatus is basically a dataclass that contains the status information of a running
    process.

    The available information is the following:

    * pid: the process identifier
    * uptime: the process up-time as a floating point number expressed in seconds
    * uuid: the UUID1 for this process
    * memory info: memory information on the process
    * cpu usage, percentage and count (number of physical cores)

    &#34;&#34;&#34;

    def __init__(self, *, metrics_prefix: Optional[str] = None):
        self._process = psutil.Process()
        self._cpu_count = psutil.cpu_count(logical=False)
        with self._process.oneshot():
            self._pid: int = self._process.pid
            self._create_time: float = self._process.create_time()
            # not sure if we need to use interval=0.1 as an argument in the next call
            self._cpu_percent: float = self._process.cpu_percent()
            self._cpu_times = self._process.cpu_times()
            self._uptime = (
                    datetime.datetime.now(tz=datetime.timezone.utc).timestamp() - self._create_time
            )
            self._memory_info = self._process.memory_full_info()
        self._uuid: uuid.UUID = uuid.uuid1()

        metrics_prefix = f&#34;{metrics_prefix.lower()}_&#34; if metrics_prefix else &#34;&#34;

        self.metrics = dict(
            PSUTIL_NUMBER_OF_CPU=Gauge(
                f&#34;{metrics_prefix}psutil_number_of_cpu&#34;,
                &#34;Number of physical cores, excluding hyper thread CPUs&#34;
            ),
            PSUTIL_CPU_TIMES=Gauge(
                f&#34;{metrics_prefix}psutil_cpu_times_seconds&#34;,
                &#34;Accumulated process time in seconds&#34;, [&#34;type&#34;]
            ),
            PSUTIL_CPU_PERCENT=Gauge(
                f&#34;{metrics_prefix}psutil_cpu_percent&#34;,
                &#34;The current process CPU utilization as a percentage&#34;
            ),
            PSUTIL_PID=Gauge(
                f&#34;{metrics_prefix}psutil_pid&#34;, &#34;Process ID&#34;
            ),
            PSUTIL_MEMORY_INFO=Gauge(
                f&#34;{metrics_prefix}psutil_memory_info_bytes&#34;,
                &#34;Memory info for this instrumented process&#34;,
                [&#34;type&#34;]
            ),
            PSUTIL_NUMBER_OF_THREADS=Gauge(
                f&#34;{metrics_prefix}psutil_number_of_threads&#34;,
                &#34;Return the number of Thread objects currently alive&#34;
            ),
            PSUTIL_PROC_UPTIME=Gauge(
                f&#34;{metrics_prefix}psutil_proccess_uptime&#34;,
                &#34;Return the time in seconds that the process is up and running&#34;
            ),
        )

        self.metrics[&#34;PSUTIL_NUMBER_OF_CPU&#34;].set(self._cpu_count)
        self.metrics[&#34;PSUTIL_PID&#34;].set(self._process.pid)

        self.update()

    def update_metrics(self):
        &#34;&#34;&#34;
        Updates the metrics that are taken from the psutils module.

        The following metrics are never updated since they are not changed during a
        process execution:

          * PSUTIL_NUMBER_OF_CPU
          * PSUTIL_PID
        &#34;&#34;&#34;

        self.metrics[&#34;PSUTIL_MEMORY_INFO&#34;].labels(type=&#34;rss&#34;).set(self._memory_info.rss)
        self.metrics[&#34;PSUTIL_MEMORY_INFO&#34;].labels(type=&#34;uss&#34;).set(self._memory_info.uss)
        self.metrics[&#34;PSUTIL_CPU_TIMES&#34;].labels(type=&#34;user&#34;).set(self._cpu_times.user)
        self.metrics[&#34;PSUTIL_CPU_TIMES&#34;].labels(type=&#34;system&#34;).set(self._cpu_times.system)
        self.metrics[&#34;PSUTIL_CPU_PERCENT&#34;].set(self._cpu_percent)
        self.metrics[&#34;PSUTIL_NUMBER_OF_THREADS&#34;].set(threading.active_count())
        self.metrics[&#34;PSUTIL_PROC_UPTIME&#34;].set(self._uptime)

    def update(self):
        &#34;&#34;&#34;
        Updates those values that change during execution, like memory usage, number of
        connections, ...

        This call will also update the metrics!

        Returns:
            the ProcessStatus object, self.
        &#34;&#34;&#34;
        self._cpu_percent = self._process.cpu_percent()
        self._cpu_times = self._process.cpu_times()
        self._uptime = time.time() - self._create_time
        self._memory_info = self._process.memory_full_info()

        self.update_metrics()

        return self

    def as_dict(self):
        &#34;&#34;&#34;Returns all process information as a dictionary.

        This runs the `update()` method first to bring the numbers up-to-date.
        &#34;&#34;&#34;
        self.update()
        return {
            &#34;PID&#34;: self._pid,
            &#34;Up&#34;: self._uptime,
            &#34;UUID&#34;: self._uuid,
            &#34;RSS&#34;: self._memory_info.rss,
            &#34;USS&#34;: self._memory_info.uss,
            &#34;CPU User&#34;: self._cpu_times.user,
            &#34;CPU System&#34;: self._cpu_times.system,
            &#34;CPU count&#34;: self._cpu_count,
            &#34;CPU%&#34;: self._cpu_percent,
        }

    def __str__(self):
        self.update()
        msg = (
            f&#34;PID: {self._pid}, &#34;
            f&#34;Up: {humanize_seconds(self._uptime)}, &#34;
            f&#34;UUID: {self._uuid}, &#34;
            f&#34;RSS: {humanize_bytes(self._memory_info.rss)}, &#34;
            f&#34;USS: {humanize_bytes(self._memory_info.uss)}, &#34;
            f&#34;CPU User: {humanize_seconds(self._cpu_times.user)}, &#34;
            f&#34;CPU System: {humanize_seconds(self._cpu_times.system)}, &#34;
            f&#34;CPU Count: {self._cpu_count}, &#34;
            f&#34;CPU%: {self._cpu_percent}&#34;
        )
        return msg</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.process.ProcessStatus.as_dict"><code class="name flex">
<span>def <span class="ident">as_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all process information as a dictionary.</p>
<p>This runs the <code>update()</code> method first to bring the numbers up-to-date.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_dict(self):
    &#34;&#34;&#34;Returns all process information as a dictionary.

    This runs the `update()` method first to bring the numbers up-to-date.
    &#34;&#34;&#34;
    self.update()
    return {
        &#34;PID&#34;: self._pid,
        &#34;Up&#34;: self._uptime,
        &#34;UUID&#34;: self._uuid,
        &#34;RSS&#34;: self._memory_info.rss,
        &#34;USS&#34;: self._memory_info.uss,
        &#34;CPU User&#34;: self._cpu_times.user,
        &#34;CPU System&#34;: self._cpu_times.system,
        &#34;CPU count&#34;: self._cpu_count,
        &#34;CPU%&#34;: self._cpu_percent,
    }</code></pre>
</details>
</dd>
<dt id="egse.process.ProcessStatus.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates those values that change during execution, like memory usage, number of
connections, &hellip;</p>
<p>This call will also update the metrics!</p>
<h2 id="returns">Returns</h2>
<p>the ProcessStatus object, self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    Updates those values that change during execution, like memory usage, number of
    connections, ...

    This call will also update the metrics!

    Returns:
        the ProcessStatus object, self.
    &#34;&#34;&#34;
    self._cpu_percent = self._process.cpu_percent()
    self._cpu_times = self._process.cpu_times()
    self._uptime = time.time() - self._create_time
    self._memory_info = self._process.memory_full_info()

    self.update_metrics()

    return self</code></pre>
</details>
</dd>
<dt id="egse.process.ProcessStatus.update_metrics"><code class="name flex">
<span>def <span class="ident">update_metrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the metrics that are taken from the psutils module.</p>
<p>The following metrics are never updated since they are not changed during a
process execution:</p>
<ul>
<li>PSUTIL_NUMBER_OF_CPU</li>
<li>PSUTIL_PID</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_metrics(self):
    &#34;&#34;&#34;
    Updates the metrics that are taken from the psutils module.

    The following metrics are never updated since they are not changed during a
    process execution:

      * PSUTIL_NUMBER_OF_CPU
      * PSUTIL_PID
    &#34;&#34;&#34;

    self.metrics[&#34;PSUTIL_MEMORY_INFO&#34;].labels(type=&#34;rss&#34;).set(self._memory_info.rss)
    self.metrics[&#34;PSUTIL_MEMORY_INFO&#34;].labels(type=&#34;uss&#34;).set(self._memory_info.uss)
    self.metrics[&#34;PSUTIL_CPU_TIMES&#34;].labels(type=&#34;user&#34;).set(self._cpu_times.user)
    self.metrics[&#34;PSUTIL_CPU_TIMES&#34;].labels(type=&#34;system&#34;).set(self._cpu_times.system)
    self.metrics[&#34;PSUTIL_CPU_PERCENT&#34;].set(self._cpu_percent)
    self.metrics[&#34;PSUTIL_NUMBER_OF_THREADS&#34;].set(threading.active_count())
    self.metrics[&#34;PSUTIL_PROC_UPTIME&#34;].set(self._uptime)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.process.SubProcess"><code class="flex name class">
<span>class <span class="ident">SubProcess</span></span>
<span>(</span><span>name: str, cmd: List, args: List = None, shell: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>A SubProcess that is usually started by the ProcessManager.</p>
<h2 id="usage">Usage</h2>
<p>hexapod_ui = SubProcess("MyApp", [sys.executable, "-m", "egse.hexapod.hexapod_ui"])
hexapod_ui.execute()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubProcess:
    &#34;&#34;&#34;
    A SubProcess that is usually started by the ProcessManager.

    Usage:

        hexapod_ui = SubProcess(&#34;MyApp&#34;, [sys.executable, &#34;-m&#34;, &#34;egse.hexapod.hexapod_ui&#34;])
        hexapod_ui.execute()

    &#34;&#34;&#34;

    def __init__(self, name: str, cmd: List, args: List = None, shell: bool = True):
        self._popen = None
        self._sub_process: psutil.Process = None
        self._name = name
        self._cmd = cmd
        self._args = args or []
        self._shell = shell

    def execute(self, detach_from_parent=False) -&gt; bool:
        &#34;&#34;&#34; Execute the sub-process.

        Args:
            - detach_from_parent: Boolean indicating whether the sub-process should be detached from the
                                  parent process.  If set to False, the sub-process will be killed whenever the
                                  parent process is interrupted or stopped.
        &#34;&#34;&#34;

        try:
            command: List = [*self._cmd, *self._args]
            LOGGER.debug(f&#34;SubProcess command: {command}&#34;)
            # self._popen = subprocess.Popen(command, env=os.environ, close_fds=detach_from_parent)
            self._popen = subprocess.Popen(
                &#34; &#34;.join(command),
                env=os.environ,
                shell=self._shell,  # executable=&#39;/bin/bash&#39;,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                stdin=subprocess.DEVNULL,
            )
            self._sub_process = psutil.Process(self._popen.pid)

            LOGGER.debug(
                f&#34;SubProcess started: {command}, pid={self._popen.pid}, sub_process=&#34;
                f&#34;{self._sub_process} [pid={self._sub_process.pid}]&#34;
            )
        except KeyError:
            LOGGER.error(f&#34;Unknown client process: {self._name}&#34;, exc_info=True)
            return False
        except (PermissionError, FileNotFoundError) as exc:
            # This error is raised when the command is not an executable or is not found
            LOGGER.error(f&#34;Could not execute sub-process: {exc}&#34;, exc_info=True)
            return False
        return True

    @property
    def name(self):
        return self._name

    @property
    def pid(self) -&gt; int:
        return self._sub_process.pid if self._sub_process else None

    def cmdline(self) -&gt; str:
        return &#34; &#34;.join(self._sub_process.cmdline())

    def children(self, recursive: bool = True) -&gt; List:
        return self._sub_process.children(recursive=recursive)

    def is_child(self, pid: int):
        return any(pid == p.pid for p in self._sub_process.children(recursive=True))

    def is_running(self):
        &#34;&#34;&#34;
        Check if this process is still running.

        * checks if process exists
        * checks if process is not a zombie and is not dead

        Returns:
            True if the process is running.
        &#34;&#34;&#34;
        if self._sub_process is None:
            return False
        if self._sub_process.is_running():
            # it still might be a zombie process
            if self._sub_process.status() in [psutil.STATUS_ZOMBIE, psutil.STATUS_DEAD]:
                LOGGER.warning(&#34;The sub-process is dead or a zombie.&#34;)
                return False
            return True
        LOGGER.debug(f&#34;Return value of the sub-process: {self._popen.returncode}&#34;)
        return False

    def exists(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the sub-process exists by checking if its process ID exists.

        Returns:
            True if the sub-process exists.
        &#34;&#34;&#34;
        return psutil.pid_exists(self.pid)

    def quit(self):
        &#34;&#34;&#34;
        Send a request to quit to the process.

        This sends a ZeroMQ message &#34;Quit&#34; to the process. The process is expected to answer with
        &#34;Quiting&#34; and then
        actually ends its execution.

        Returns:
            True when received the answer &#34;Quiting&#34;, False otherwise.
        &#34;&#34;&#34;
        return self.reap_children()

    def reap_children(self, timeout=3):
        &#34;&#34;&#34;Tries hard to terminate and ultimately kill all the children of this process.&#34;&#34;&#34;

        def on_terminate(proc):
            LOGGER.info(f&#34;process {proc} terminated with exit code {proc.returncode}&#34;)

        return_code = 0

        procs = [self._sub_process]
        procs.extend(self._sub_process.children())

        LOGGER.info(f&#34;Processes: {procs}&#34;)

        # send SIGTERM
        for p in procs:
            try:
                LOGGER.info(f&#34;Terminating process {p}&#34;)
                p.terminate()
            except psutil.NoSuchProcess:
                pass
        gone, alive = psutil.wait_procs(procs, timeout=timeout, callback=on_terminate)
        if alive:
            # send SIGKILL
            for p in alive:
                LOGGER.info(f&#34;process {p} survived SIGTERM; trying SIGKILL&#34;)
                try:
                    p.kill()
                except psutil.NoSuchProcess:
                    pass
            gone, alive = psutil.wait_procs(alive, timeout=timeout, callback=on_terminate)
            if alive:
                # give up
                for p in alive:
                    LOGGER.info(f&#34;process {p} survived SIGKILL; giving up&#34;)
                    return_code += 1  # return code indicates how many processes are still running

        return return_code

    def returncode(self):
        &#34;&#34;&#34;
        Check if the sub-process is terminated and return its return code or None when the process
        is still running.
        &#34;&#34;&#34;
        return self._popen.poll()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="egse.process.SubProcess.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.pid"><code class="name">var <span class="ident">pid</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pid(self) -&gt; int:
    return self._sub_process.pid if self._sub_process else None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="egse.process.SubProcess.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self, recursive: bool = True) ‑> List[~T]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def children(self, recursive: bool = True) -&gt; List:
    return self._sub_process.children(recursive=recursive)</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.cmdline"><code class="name flex">
<span>def <span class="ident">cmdline</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmdline(self) -&gt; str:
    return &#34; &#34;.join(self._sub_process.cmdline())</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, detach_from_parent=False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the sub-process.</p>
<h2 id="args">Args</h2>
<ul>
<li>detach_from_parent: Boolean indicating whether the sub-process should be detached from the
parent process.
If set to False, the sub-process will be killed whenever the
parent process is interrupted or stopped.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, detach_from_parent=False) -&gt; bool:
    &#34;&#34;&#34; Execute the sub-process.

    Args:
        - detach_from_parent: Boolean indicating whether the sub-process should be detached from the
                              parent process.  If set to False, the sub-process will be killed whenever the
                              parent process is interrupted or stopped.
    &#34;&#34;&#34;

    try:
        command: List = [*self._cmd, *self._args]
        LOGGER.debug(f&#34;SubProcess command: {command}&#34;)
        # self._popen = subprocess.Popen(command, env=os.environ, close_fds=detach_from_parent)
        self._popen = subprocess.Popen(
            &#34; &#34;.join(command),
            env=os.environ,
            shell=self._shell,  # executable=&#39;/bin/bash&#39;,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            stdin=subprocess.DEVNULL,
        )
        self._sub_process = psutil.Process(self._popen.pid)

        LOGGER.debug(
            f&#34;SubProcess started: {command}, pid={self._popen.pid}, sub_process=&#34;
            f&#34;{self._sub_process} [pid={self._sub_process.pid}]&#34;
        )
    except KeyError:
        LOGGER.error(f&#34;Unknown client process: {self._name}&#34;, exc_info=True)
        return False
    except (PermissionError, FileNotFoundError) as exc:
        # This error is raised when the command is not an executable or is not found
        LOGGER.error(f&#34;Could not execute sub-process: {exc}&#34;, exc_info=True)
        return False
    return True</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the sub-process exists by checking if its process ID exists.</p>
<h2 id="returns">Returns</h2>
<p>True if the sub-process exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the sub-process exists by checking if its process ID exists.

    Returns:
        True if the sub-process exists.
    &#34;&#34;&#34;
    return psutil.pid_exists(self.pid)</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.is_child"><code class="name flex">
<span>def <span class="ident">is_child</span></span>(<span>self, pid: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_child(self, pid: int):
    return any(pid == p.pid for p in self._sub_process.children(recursive=True))</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.is_running"><code class="name flex">
<span>def <span class="ident">is_running</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if this process is still running.</p>
<ul>
<li>checks if process exists</li>
<li>checks if process is not a zombie and is not dead</li>
</ul>
<h2 id="returns">Returns</h2>
<p>True if the process is running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_running(self):
    &#34;&#34;&#34;
    Check if this process is still running.

    * checks if process exists
    * checks if process is not a zombie and is not dead

    Returns:
        True if the process is running.
    &#34;&#34;&#34;
    if self._sub_process is None:
        return False
    if self._sub_process.is_running():
        # it still might be a zombie process
        if self._sub_process.status() in [psutil.STATUS_ZOMBIE, psutil.STATUS_DEAD]:
            LOGGER.warning(&#34;The sub-process is dead or a zombie.&#34;)
            return False
        return True
    LOGGER.debug(f&#34;Return value of the sub-process: {self._popen.returncode}&#34;)
    return False</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a request to quit to the process.</p>
<p>This sends a ZeroMQ message "Quit" to the process. The process is expected to answer with
"Quiting" and then
actually ends its execution.</p>
<h2 id="returns">Returns</h2>
<p>True when received the answer "Quiting", False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    &#34;&#34;&#34;
    Send a request to quit to the process.

    This sends a ZeroMQ message &#34;Quit&#34; to the process. The process is expected to answer with
    &#34;Quiting&#34; and then
    actually ends its execution.

    Returns:
        True when received the answer &#34;Quiting&#34;, False otherwise.
    &#34;&#34;&#34;
    return self.reap_children()</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.reap_children"><code class="name flex">
<span>def <span class="ident">reap_children</span></span>(<span>self, timeout=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Tries hard to terminate and ultimately kill all the children of this process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reap_children(self, timeout=3):
    &#34;&#34;&#34;Tries hard to terminate and ultimately kill all the children of this process.&#34;&#34;&#34;

    def on_terminate(proc):
        LOGGER.info(f&#34;process {proc} terminated with exit code {proc.returncode}&#34;)

    return_code = 0

    procs = [self._sub_process]
    procs.extend(self._sub_process.children())

    LOGGER.info(f&#34;Processes: {procs}&#34;)

    # send SIGTERM
    for p in procs:
        try:
            LOGGER.info(f&#34;Terminating process {p}&#34;)
            p.terminate()
        except psutil.NoSuchProcess:
            pass
    gone, alive = psutil.wait_procs(procs, timeout=timeout, callback=on_terminate)
    if alive:
        # send SIGKILL
        for p in alive:
            LOGGER.info(f&#34;process {p} survived SIGTERM; trying SIGKILL&#34;)
            try:
                p.kill()
            except psutil.NoSuchProcess:
                pass
        gone, alive = psutil.wait_procs(alive, timeout=timeout, callback=on_terminate)
        if alive:
            # give up
            for p in alive:
                LOGGER.info(f&#34;process {p} survived SIGKILL; giving up&#34;)
                return_code += 1  # return code indicates how many processes are still running

    return return_code</code></pre>
</details>
</dd>
<dt id="egse.process.SubProcess.returncode"><code class="name flex">
<span>def <span class="ident">returncode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the sub-process is terminated and return its return code or None when the process
is still running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def returncode(self):
    &#34;&#34;&#34;
    Check if the sub-process is terminated and return its return code or None when the process
    is still running.
    &#34;&#34;&#34;
    return self._popen.poll()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.process.get_process_info" href="#egse.process.get_process_info">get_process_info</a></code></li>
<li><code><a title="egse.process.is_process_running" href="#egse.process.is_process_running">is_process_running</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.process.ProcessStatus" href="#egse.process.ProcessStatus">ProcessStatus</a></code></h4>
<ul class="">
<li><code><a title="egse.process.ProcessStatus.as_dict" href="#egse.process.ProcessStatus.as_dict">as_dict</a></code></li>
<li><code><a title="egse.process.ProcessStatus.update" href="#egse.process.ProcessStatus.update">update</a></code></li>
<li><code><a title="egse.process.ProcessStatus.update_metrics" href="#egse.process.ProcessStatus.update_metrics">update_metrics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.process.SubProcess" href="#egse.process.SubProcess">SubProcess</a></code></h4>
<ul class="two-column">
<li><code><a title="egse.process.SubProcess.children" href="#egse.process.SubProcess.children">children</a></code></li>
<li><code><a title="egse.process.SubProcess.cmdline" href="#egse.process.SubProcess.cmdline">cmdline</a></code></li>
<li><code><a title="egse.process.SubProcess.execute" href="#egse.process.SubProcess.execute">execute</a></code></li>
<li><code><a title="egse.process.SubProcess.exists" href="#egse.process.SubProcess.exists">exists</a></code></li>
<li><code><a title="egse.process.SubProcess.is_child" href="#egse.process.SubProcess.is_child">is_child</a></code></li>
<li><code><a title="egse.process.SubProcess.is_running" href="#egse.process.SubProcess.is_running">is_running</a></code></li>
<li><code><a title="egse.process.SubProcess.name" href="#egse.process.SubProcess.name">name</a></code></li>
<li><code><a title="egse.process.SubProcess.pid" href="#egse.process.SubProcess.pid">pid</a></code></li>
<li><code><a title="egse.process.SubProcess.quit" href="#egse.process.SubProcess.quit">quit</a></code></li>
<li><code><a title="egse.process.SubProcess.reap_children" href="#egse.process.SubProcess.reap_children">reap_children</a></code></li>
<li><code><a title="egse.process.SubProcess.returncode" href="#egse.process.SubProcess.returncode">returncode</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
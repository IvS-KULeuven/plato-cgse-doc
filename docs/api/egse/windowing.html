<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.windowing API documentation</title>
<meta name="description" content="This module provides functions and classes to extract and mosaic windows from a CCD image â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.windowing</code></h1>
</header>
<section id="section-intro">
<p>This module provides functions and classes to extract and mosaic windows from a CCD image.</p>
<p>Windowing is used to define areas in the CCD images that need to be down-linked as imagettes.
The F-FEE and the N-FEE will use windowing to minimize the size of data packets sent to the
F-DPU and N-DPU. A <code><a title="egse.windowing.WindowList" href="#egse.windowing.WindowList">WindowList</a></code> is used by the FEE and DPU to extract these imagettes from
the full CCD image and to re-generate the CCD image from the individual imagettes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides functions and classes to extract and mosaic windows from a CCD image.

Windowing is used to define areas in the CCD images that need to be down-linked as imagettes.
The F-FEE and the N-FEE will use windowing to minimize the size of data packets sent to the
F-DPU and N-DPU. A `WindowList` is used by the FEE and DPU to extract these imagettes from
the full CCD image and to re-generate the CCD image from the individual imagettes.
&#34;&#34;&#34;
import logging
from operator import itemgetter

import numpy as np

from egse.settings import Settings

logger = logging.getLogger(__name__)

win_settings = Settings.load(&#34;Windowing&#34;)


class WindowSizeError(Exception):
    &#34;&#34;&#34;Raised when the requested window sizes are out-of-bounds.&#34;&#34;&#34;
    pass


class CCDIndexError(KeyError):
    &#34;&#34;&#34;Raised when the CCD index is out-of-bounds.&#34;&#34;&#34;
    pass


def extract_window_data(ccd_image: np.array, x_coord: int, y_coord: int, x_size: int, y_size: int, ccd_side: int) -&gt; np.array:
    &#34;&#34;&#34;
    Extract the window data from the given image.

    Right and left side of the CCD have separate coordinate systems. The origin of both
    coordinate systems is the first pixel read from the CCD. See FEE-DPU-IF-900 in the DPU-FEE
    interface document (PLATO-DLR-PL-IC-002).

    Parameters:

    * **ccd_image**: ndarray - a two-dimensional array that contains the full image
    * **x_coord**: int - x-coordinate for the requested window
    * **y_coord**: int - y-coordinate for the requested window
    * **x_size**: int - x-size of the requested window
    * **y_size**: int - y-size of the requested window
    * **ccd_side**: int - the CCD side (0 is left, 1 is right)

    Returns: two-dimensional imagette (small window extracted from the full image)
    &#34;&#34;&#34;

    # TODO
    #   - What is the full image? Are the scan maps stripped off?
    #   - The origin of the coordinate frame used to define the window is located in the serial pre-scan (not on the
    #     CCD) and starts from the first row in the image area (which is not necessarily the same as v_start)

    logger.debug(&#34;ccd size x, y = {}, {}&#34;.format(ccd_image.shape[0], ccd_image.shape[1]))
    logger.debug(&#34;x_size, y_size: {}, {}&#34;.format(x_size, y_size))
    logger.debug(&#34;x_coord, y_coord, ccd_side: {}, {}, {}&#34;.format(x_coord, y_coord, ccd_side))

    if ccd_side == win_settings.CCD_SIDE_LEFT:
        x1 = x_coord
        x2 = x_coord + x_size
        y1 = y_coord
        y2 = y_coord + y_size
        logger.debug(&#34;x1, x2, y1, y2 = {}, {}, {}, {}&#34;.format(x1, x2, y1, y2))
        im = ccd_image[y1:y2, x1:x2]
    elif ccd_side == win_settings.CCD_SIDE_RIGHT:
        ccd_x_size = ccd_image.shape[0]
        ccd_y_size = ccd_image.shape[1]
        x1 = ccd_x_size - x_coord - x_size
        x2 = ccd_x_size - x_coord
        y1 = y_coord
        y2 = y_coord + y_size
        logger.debug(&#34;x1, x2, y1, y2 = {}, {}, {}, {}&#34;.format(x1, x2, y1, y2))
        im = ccd_image[y1:y2, x1:x2]
    else:
        raise ValueError(f&#34;CCD side argument should be 0 (left) or 1 (right), {ccd_side} was given.&#34;)

    return im


class WindowList:
    &#34;&#34;&#34;
    The WindowList contains the window list for the FEE for one CCD.

    A window is defined for a specific CCD, so there are four window lists.

    Each element contains the coordinates for the window and the CCD side.  The size of the windows is identical for all
    windows on a CCD and can be configured between 2x2 and 32x32 [default size is 10x10]. The window does not need to
    be quadratic, i.e. x-size can be different from y-size.

    **Developer information**

    The internal representation of the window list is:

        set((x_coord, y_coord, ccd_side), (x_coord, y_coord, ccd_side), ...)

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34; Create an empty set&#34;&#34;&#34;

        # A set is used for the internal representation of the window list, that
        # prevents adding duplicate elements to the list.

        self._window_list = set()

        # Default window size in read from the global Settings

        self._window_x_size = win_settings.DEFAULT_WINDOW_SIZE
        self._window_y_size = win_settings.DEFAULT_WINDOW_SIZE

    def __str__(self):

        def _pp(list_):
            &#34;&#34;&#34;Pretty print a large list.&#34;&#34;&#34;
            if len(list_) &gt; 10:
                # FIXME: the representation could be better here...when time allows
                return (
                    f&#34;[{list_[0]}, {list_[1]}, {list_[2]}, {list_[3]}, {list_[4]}&#34;
                    f&#34;, ..., &#34;
                    f&#34;{list_[-2]}, {list_[-1]}]&#34;
                )
            else:
                return str(list_)

        return (
            f&#34;Window size = ({self._window_x_size}, {self._window_y_size})\n&#34;
            f&#34;Window List CCD 1: len={self.get_window_count(1)}, {_pp(self.get_window_list_for_ccd(1))}\n&#34;
            f&#34;Window List CCD 2: len={self.get_window_count(2)}, {_pp(self.get_window_list_for_ccd(2))}\n&#34;
            f&#34;Window List CCD 3: len={self.get_window_count(3)}, {_pp(self.get_window_list_for_ccd(3))}\n&#34;
            f&#34;Window List CCD 4: len={self.get_window_count(4)}, {_pp(self.get_window_list_for_ccd(4))}\n&#34;
        )

    def get_window_list(self):
        &#34;&#34;&#34; Return the window list.

        The list is a set of tuples, where each tuple contains the following information regarding one window:

            (x, y, ccd_side)

        The window list is sorted on y-coordinates first and x_coordinate second.
        &#34;&#34;&#34;

        return sorted(self._window_list, key=itemgetter(1, 0))

    def add_window(self, x: int, y: int, ccd_side):
        &#34;&#34;&#34; Add a window to the window list.

        The window is appended to the list, which renders the list unsorted.  Use the `sort()` method after all windows
        have been added.

        Args:
            - x: Column or x-coordinate of the corner of the window closest to the readout node.
            - y: Row or y-coordinate of the corner of the window closest to the readout node.
            - ccd_side: CCD side.
        &#34;&#34;&#34;

        # The window lists should be sorted first on the Y coordinate (rows), then the X-coordinate (columns).
        #
        # Internally however, the sets are not sorted because it would take too much time to keep the sets
        # sorted when this is only needed when the actual window list is requested by the caller.
        # Remember a list can take up to 100_000 elements.
        #
        # When a window list is requested using the `get_window_list()` method, a properly sorted list
        # will be returned.

        self._window_list.add((x, y, ccd_side))

    def get_window_count(self) -&gt; int:
        &#34;&#34;&#34; Return the number of windows in the list.

        Returns: Number of windows.
        &#34;&#34;&#34;

        return len(self._window_list)

    def set_window_size(self, x_size, y_size):
        &#34;&#34;&#34; Set a new window size.

        All windows have the same size. `x_size` and `y_size` do not have to be equal. The given size for both x and y
        has to be within the range [2-32] inclusive.

        Args:
            - x_side: Window size on the x-axis [pixels].
            - y_side: Window size on the y-axis [pixels].

        Raises a **WindowSizeError** when a given size is out of range.
        &#34;&#34;&#34;

        if win_settings.MIN_WINDOW_SIZE &lt;= x_size &lt;= win_settings.MAX_WINDOW_SIZE:

            self._window_x_size = x_size

        else:

            raise WindowSizeError(f&#34;Window size shall be [2, 32], {x_size} was given for x_size.&#34;)

        if win_settings.MIN_WINDOW_SIZE &lt;= y_size &lt;= win_settings.MAX_WINDOW_SIZE:

            self._window_y_size = y_size

        else:

            raise WindowSizeError(f&#34;Window size shall be [2, 32], {y_size} was given for y_size.&#34;)

    def get_window_size(self):
        &#34;&#34;&#34; Return a tuple (x_size, y_size) containing the window size in pixels.

        Returns: Tuple with the window size (x_size, y_size) [pixels].
        &#34;&#34;&#34;

        return self._window_x_size, self._window_y_size</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.windowing.extract_window_data"><code class="name flex">
<span>def <span class="ident">extract_window_data</span></span>(<span>ccd_image:Â <built-inÂ functionÂ array>, x_coord:Â int, y_coord:Â int, x_size:Â int, y_size:Â int, ccd_side:Â int) â€‘>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Extract the window data from the given image.</p>
<p>Right and left side of the CCD have separate coordinate systems. The origin of both
coordinate systems is the first pixel read from the CCD. See FEE-DPU-IF-900 in the DPU-FEE
interface document (PLATO-DLR-PL-IC-002).</p>
<p>Parameters:</p>
<ul>
<li><strong>ccd_image</strong>: ndarray - a two-dimensional array that contains the full image</li>
<li><strong>x_coord</strong>: int - x-coordinate for the requested window</li>
<li><strong>y_coord</strong>: int - y-coordinate for the requested window</li>
<li><strong>x_size</strong>: int - x-size of the requested window</li>
<li><strong>y_size</strong>: int - y-size of the requested window</li>
<li><strong>ccd_side</strong>: int - the CCD side (0 is left, 1 is right)</li>
</ul>
<p>Returns: two-dimensional imagette (small window extracted from the full image)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_window_data(ccd_image: np.array, x_coord: int, y_coord: int, x_size: int, y_size: int, ccd_side: int) -&gt; np.array:
    &#34;&#34;&#34;
    Extract the window data from the given image.

    Right and left side of the CCD have separate coordinate systems. The origin of both
    coordinate systems is the first pixel read from the CCD. See FEE-DPU-IF-900 in the DPU-FEE
    interface document (PLATO-DLR-PL-IC-002).

    Parameters:

    * **ccd_image**: ndarray - a two-dimensional array that contains the full image
    * **x_coord**: int - x-coordinate for the requested window
    * **y_coord**: int - y-coordinate for the requested window
    * **x_size**: int - x-size of the requested window
    * **y_size**: int - y-size of the requested window
    * **ccd_side**: int - the CCD side (0 is left, 1 is right)

    Returns: two-dimensional imagette (small window extracted from the full image)
    &#34;&#34;&#34;

    # TODO
    #   - What is the full image? Are the scan maps stripped off?
    #   - The origin of the coordinate frame used to define the window is located in the serial pre-scan (not on the
    #     CCD) and starts from the first row in the image area (which is not necessarily the same as v_start)

    logger.debug(&#34;ccd size x, y = {}, {}&#34;.format(ccd_image.shape[0], ccd_image.shape[1]))
    logger.debug(&#34;x_size, y_size: {}, {}&#34;.format(x_size, y_size))
    logger.debug(&#34;x_coord, y_coord, ccd_side: {}, {}, {}&#34;.format(x_coord, y_coord, ccd_side))

    if ccd_side == win_settings.CCD_SIDE_LEFT:
        x1 = x_coord
        x2 = x_coord + x_size
        y1 = y_coord
        y2 = y_coord + y_size
        logger.debug(&#34;x1, x2, y1, y2 = {}, {}, {}, {}&#34;.format(x1, x2, y1, y2))
        im = ccd_image[y1:y2, x1:x2]
    elif ccd_side == win_settings.CCD_SIDE_RIGHT:
        ccd_x_size = ccd_image.shape[0]
        ccd_y_size = ccd_image.shape[1]
        x1 = ccd_x_size - x_coord - x_size
        x2 = ccd_x_size - x_coord
        y1 = y_coord
        y2 = y_coord + y_size
        logger.debug(&#34;x1, x2, y1, y2 = {}, {}, {}, {}&#34;.format(x1, x2, y1, y2))
        im = ccd_image[y1:y2, x1:x2]
    else:
        raise ValueError(f&#34;CCD side argument should be 0 (left) or 1 (right), {ccd_side} was given.&#34;)

    return im</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.windowing.CCDIndexError"><code class="flex name class">
<span>class <span class="ident">CCDIndexError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when the CCD index is out-of-bounds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CCDIndexError(KeyError):
    &#34;&#34;&#34;Raised when the CCD index is out-of-bounds.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.KeyError</li>
<li>builtins.LookupError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="egse.windowing.WindowList"><code class="flex name class">
<span>class <span class="ident">WindowList</span></span>
</code></dt>
<dd>
<div class="desc"><p>The WindowList contains the window list for the FEE for one CCD.</p>
<p>A window is defined for a specific CCD, so there are four window lists.</p>
<p>Each element contains the coordinates for the window and the CCD side.
The size of the windows is identical for all
windows on a CCD and can be configured between 2x2 and 32x32 [default size is 10x10]. The window does not need to
be quadratic, i.e. x-size can be different from y-size.</p>
<p><strong>Developer information</strong></p>
<p>The internal representation of the window list is:</p>
<pre><code>set((x_coord, y_coord, ccd_side), (x_coord, y_coord, ccd_side), ...)
</code></pre>
<p>Create an empty set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WindowList:
    &#34;&#34;&#34;
    The WindowList contains the window list for the FEE for one CCD.

    A window is defined for a specific CCD, so there are four window lists.

    Each element contains the coordinates for the window and the CCD side.  The size of the windows is identical for all
    windows on a CCD and can be configured between 2x2 and 32x32 [default size is 10x10]. The window does not need to
    be quadratic, i.e. x-size can be different from y-size.

    **Developer information**

    The internal representation of the window list is:

        set((x_coord, y_coord, ccd_side), (x_coord, y_coord, ccd_side), ...)

    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34; Create an empty set&#34;&#34;&#34;

        # A set is used for the internal representation of the window list, that
        # prevents adding duplicate elements to the list.

        self._window_list = set()

        # Default window size in read from the global Settings

        self._window_x_size = win_settings.DEFAULT_WINDOW_SIZE
        self._window_y_size = win_settings.DEFAULT_WINDOW_SIZE

    def __str__(self):

        def _pp(list_):
            &#34;&#34;&#34;Pretty print a large list.&#34;&#34;&#34;
            if len(list_) &gt; 10:
                # FIXME: the representation could be better here...when time allows
                return (
                    f&#34;[{list_[0]}, {list_[1]}, {list_[2]}, {list_[3]}, {list_[4]}&#34;
                    f&#34;, ..., &#34;
                    f&#34;{list_[-2]}, {list_[-1]}]&#34;
                )
            else:
                return str(list_)

        return (
            f&#34;Window size = ({self._window_x_size}, {self._window_y_size})\n&#34;
            f&#34;Window List CCD 1: len={self.get_window_count(1)}, {_pp(self.get_window_list_for_ccd(1))}\n&#34;
            f&#34;Window List CCD 2: len={self.get_window_count(2)}, {_pp(self.get_window_list_for_ccd(2))}\n&#34;
            f&#34;Window List CCD 3: len={self.get_window_count(3)}, {_pp(self.get_window_list_for_ccd(3))}\n&#34;
            f&#34;Window List CCD 4: len={self.get_window_count(4)}, {_pp(self.get_window_list_for_ccd(4))}\n&#34;
        )

    def get_window_list(self):
        &#34;&#34;&#34; Return the window list.

        The list is a set of tuples, where each tuple contains the following information regarding one window:

            (x, y, ccd_side)

        The window list is sorted on y-coordinates first and x_coordinate second.
        &#34;&#34;&#34;

        return sorted(self._window_list, key=itemgetter(1, 0))

    def add_window(self, x: int, y: int, ccd_side):
        &#34;&#34;&#34; Add a window to the window list.

        The window is appended to the list, which renders the list unsorted.  Use the `sort()` method after all windows
        have been added.

        Args:
            - x: Column or x-coordinate of the corner of the window closest to the readout node.
            - y: Row or y-coordinate of the corner of the window closest to the readout node.
            - ccd_side: CCD side.
        &#34;&#34;&#34;

        # The window lists should be sorted first on the Y coordinate (rows), then the X-coordinate (columns).
        #
        # Internally however, the sets are not sorted because it would take too much time to keep the sets
        # sorted when this is only needed when the actual window list is requested by the caller.
        # Remember a list can take up to 100_000 elements.
        #
        # When a window list is requested using the `get_window_list()` method, a properly sorted list
        # will be returned.

        self._window_list.add((x, y, ccd_side))

    def get_window_count(self) -&gt; int:
        &#34;&#34;&#34; Return the number of windows in the list.

        Returns: Number of windows.
        &#34;&#34;&#34;

        return len(self._window_list)

    def set_window_size(self, x_size, y_size):
        &#34;&#34;&#34; Set a new window size.

        All windows have the same size. `x_size` and `y_size` do not have to be equal. The given size for both x and y
        has to be within the range [2-32] inclusive.

        Args:
            - x_side: Window size on the x-axis [pixels].
            - y_side: Window size on the y-axis [pixels].

        Raises a **WindowSizeError** when a given size is out of range.
        &#34;&#34;&#34;

        if win_settings.MIN_WINDOW_SIZE &lt;= x_size &lt;= win_settings.MAX_WINDOW_SIZE:

            self._window_x_size = x_size

        else:

            raise WindowSizeError(f&#34;Window size shall be [2, 32], {x_size} was given for x_size.&#34;)

        if win_settings.MIN_WINDOW_SIZE &lt;= y_size &lt;= win_settings.MAX_WINDOW_SIZE:

            self._window_y_size = y_size

        else:

            raise WindowSizeError(f&#34;Window size shall be [2, 32], {y_size} was given for y_size.&#34;)

    def get_window_size(self):
        &#34;&#34;&#34; Return a tuple (x_size, y_size) containing the window size in pixels.

        Returns: Tuple with the window size (x_size, y_size) [pixels].
        &#34;&#34;&#34;

        return self._window_x_size, self._window_y_size</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="egse.windowing.WindowList.add_window"><code class="name flex">
<span>def <span class="ident">add_window</span></span>(<span>self, x:Â int, y:Â int, ccd_side)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a window to the window list.</p>
<p>The window is appended to the list, which renders the list unsorted.
Use the <code>sort()</code> method after all windows
have been added.</p>
<h2 id="args">Args</h2>
<ul>
<li>x: Column or x-coordinate of the corner of the window closest to the readout node.</li>
<li>y: Row or y-coordinate of the corner of the window closest to the readout node.</li>
<li>ccd_side: CCD side.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_window(self, x: int, y: int, ccd_side):
    &#34;&#34;&#34; Add a window to the window list.

    The window is appended to the list, which renders the list unsorted.  Use the `sort()` method after all windows
    have been added.

    Args:
        - x: Column or x-coordinate of the corner of the window closest to the readout node.
        - y: Row or y-coordinate of the corner of the window closest to the readout node.
        - ccd_side: CCD side.
    &#34;&#34;&#34;

    # The window lists should be sorted first on the Y coordinate (rows), then the X-coordinate (columns).
    #
    # Internally however, the sets are not sorted because it would take too much time to keep the sets
    # sorted when this is only needed when the actual window list is requested by the caller.
    # Remember a list can take up to 100_000 elements.
    #
    # When a window list is requested using the `get_window_list()` method, a properly sorted list
    # will be returned.

    self._window_list.add((x, y, ccd_side))</code></pre>
</details>
</dd>
<dt id="egse.windowing.WindowList.get_window_count"><code class="name flex">
<span>def <span class="ident">get_window_count</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of windows in the list.</p>
<p>Returns: Number of windows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_window_count(self) -&gt; int:
    &#34;&#34;&#34; Return the number of windows in the list.

    Returns: Number of windows.
    &#34;&#34;&#34;

    return len(self._window_list)</code></pre>
</details>
</dd>
<dt id="egse.windowing.WindowList.get_window_list"><code class="name flex">
<span>def <span class="ident">get_window_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the window list.</p>
<p>The list is a set of tuples, where each tuple contains the following information regarding one window:</p>
<pre><code>(x, y, ccd_side)
</code></pre>
<p>The window list is sorted on y-coordinates first and x_coordinate second.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_window_list(self):
    &#34;&#34;&#34; Return the window list.

    The list is a set of tuples, where each tuple contains the following information regarding one window:

        (x, y, ccd_side)

    The window list is sorted on y-coordinates first and x_coordinate second.
    &#34;&#34;&#34;

    return sorted(self._window_list, key=itemgetter(1, 0))</code></pre>
</details>
</dd>
<dt id="egse.windowing.WindowList.get_window_size"><code class="name flex">
<span>def <span class="ident">get_window_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a tuple (x_size, y_size) containing the window size in pixels.</p>
<p>Returns: Tuple with the window size (x_size, y_size) [pixels].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_window_size(self):
    &#34;&#34;&#34; Return a tuple (x_size, y_size) containing the window size in pixels.

    Returns: Tuple with the window size (x_size, y_size) [pixels].
    &#34;&#34;&#34;

    return self._window_x_size, self._window_y_size</code></pre>
</details>
</dd>
<dt id="egse.windowing.WindowList.set_window_size"><code class="name flex">
<span>def <span class="ident">set_window_size</span></span>(<span>self, x_size, y_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a new window size.</p>
<p>All windows have the same size. <code>x_size</code> and <code>y_size</code> do not have to be equal. The given size for both x and y
has to be within the range [2-32] inclusive.</p>
<h2 id="args">Args</h2>
<ul>
<li>x_side: Window size on the x-axis [pixels].</li>
<li>y_side: Window size on the y-axis [pixels].
Raises a <strong>WindowSizeError</strong> when a given size is out of range.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_window_size(self, x_size, y_size):
    &#34;&#34;&#34; Set a new window size.

    All windows have the same size. `x_size` and `y_size` do not have to be equal. The given size for both x and y
    has to be within the range [2-32] inclusive.

    Args:
        - x_side: Window size on the x-axis [pixels].
        - y_side: Window size on the y-axis [pixels].

    Raises a **WindowSizeError** when a given size is out of range.
    &#34;&#34;&#34;

    if win_settings.MIN_WINDOW_SIZE &lt;= x_size &lt;= win_settings.MAX_WINDOW_SIZE:

        self._window_x_size = x_size

    else:

        raise WindowSizeError(f&#34;Window size shall be [2, 32], {x_size} was given for x_size.&#34;)

    if win_settings.MIN_WINDOW_SIZE &lt;= y_size &lt;= win_settings.MAX_WINDOW_SIZE:

        self._window_y_size = y_size

    else:

        raise WindowSizeError(f&#34;Window size shall be [2, 32], {y_size} was given for y_size.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="egse.windowing.WindowSizeError"><code class="flex name class">
<span>class <span class="ident">WindowSizeError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when the requested window sizes are out-of-bounds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WindowSizeError(Exception):
    &#34;&#34;&#34;Raised when the requested window sizes are out-of-bounds.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="egse.windowing.extract_window_data" href="#egse.windowing.extract_window_data">extract_window_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.windowing.CCDIndexError" href="#egse.windowing.CCDIndexError">CCDIndexError</a></code></h4>
</li>
<li>
<h4><code><a title="egse.windowing.WindowList" href="#egse.windowing.WindowList">WindowList</a></code></h4>
<ul class="">
<li><code><a title="egse.windowing.WindowList.add_window" href="#egse.windowing.WindowList.add_window">add_window</a></code></li>
<li><code><a title="egse.windowing.WindowList.get_window_count" href="#egse.windowing.WindowList.get_window_count">get_window_count</a></code></li>
<li><code><a title="egse.windowing.WindowList.get_window_list" href="#egse.windowing.WindowList.get_window_list">get_window_list</a></code></li>
<li><code><a title="egse.windowing.WindowList.get_window_size" href="#egse.windowing.WindowList.get_window_size">get_window_size</a></code></li>
<li><code><a title="egse.windowing.WindowList.set_window_size" href="#egse.windowing.WindowList.set_window_size">set_window_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="egse.windowing.WindowSizeError" href="#egse.windowing.WindowSizeError">WindowSizeError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
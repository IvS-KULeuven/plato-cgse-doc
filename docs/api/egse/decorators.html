<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>egse.decorators API documentation</title>
<meta name="description" content="A collection of useful decorator functions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>egse.decorators</code></h1>
</header>
<section id="section-intro">
<p>A collection of useful decorator functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
A collection of useful decorator functions.
&#34;&#34;&#34;
import cProfile
import functools
import logging
import pstats
import time
import warnings
from typing import Callable
from typing import Optional

from egse.settings import Settings
from egse.system import get_caller_info

MODULE_LOGGER = logging.getLogger(__name__)


def static_vars(**kwargs):
    &#34;&#34;&#34;Define static variables in a function.&#34;&#34;&#34;
    def decorator(func):
        for kw in kwargs:
            setattr(func, kw, kwargs[kw])
        return func
    return decorator


def dynamic_interface(func):
    &#34;&#34;&#34;Adds a static variable `__dynamic_interface` to a method.

    The intended use of this function is as a decorator for functions in an interface class.

    The static variable is currently used by the Proxy class to check if a method
    is meant to be overridden dynamically. The idea behind this is to loosen the contract
    of an abstract base class (ABC) into an interface. For an ABC, the abstract methods
    must be implemented at construction/initialization. This is not possible for the Proxy
    subclasses as they load their commands (i.e. methods) from the control server, and the
    method will be added to the Proxy interface after loading. Nevertheless, we like the
    interface already defined for auto-completion during development or interactive use.

    When a Proxy subclass that implements an interface with methods decorated by
    the `@dynamic_interface` does overwrite one or more of the decorated methods statically,
    these methods will not be dynamically overwritten when loading the interface from the
    control server. A warning will be logged instead.
    &#34;&#34;&#34;
    setattr(func, &#34;__dynamic_interface&#34;, True)
    return func


def query_command(func):
    &#34;&#34;&#34;Adds a static variable `__query_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__query_command&#34;, True)
    return func


def transaction_command(func):
    &#34;&#34;&#34;Adds a static variable `__transaction_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__transaction_command&#34;, True)
    return func


def read_command(func):
    &#34;&#34;&#34;Adds a static variable `__read_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__read_command&#34;, True)
    return func


def write_command(func):
    &#34;&#34;&#34;Adds a static variable `__write_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__write_command&#34;, True)
    return func


def timer(*, level: int = logging.INFO, precision: int = 4):
    &#34;&#34;&#34;
    Print the runtime of the decorated function.

    Args:
        level: the logging level for the time message [default=INFO]
        precision: the number of decimals for the time [default=3 (ms)]
    &#34;&#34;&#34;

    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper_timer(*args, **kwargs):
            start_time = time.perf_counter()
            value = func(*args, **kwargs)
            end_time = time.perf_counter()
            run_time = end_time - start_time
            MODULE_LOGGER.log(level, f&#34;Finished {func.__name__!r} in {run_time:.{precision}f} secs&#34;)
            return value

        return wrapper_timer
    return actual_decorator


def time_it(count: int = 1000):
    &#34;&#34;&#34;Print the runtime of the decorated function.

    This is a simple replacement for the builtin ``timeit`` function. The purpose is to simplify
    calling a function with some parameters.

    The intended way to call this is as a function:

        value = function(args)

        value = time_it(10_000)(function)(args)

    The `time_it` function can be called as a decorator in which case it will always call the
    function `count` times which is probably not what you want.

    Args:
        count (int): the number of executions [default=1000].

    Returns:
        value: the return value of the last function execution.

    See also:
        the ``Timer`` context manager located in ``egse.system``.

    Usage:
        @time_it(count=10000)
        def function(args):
            pass

        time_it(10000)(function)(args)
    &#34;&#34;&#34;

    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper_timer(*args, **kwargs):
            start_time = time.perf_counter()
            for _ in range(count):
                value = func(*args, **kwargs)
            end_time = time.perf_counter()
            run_time = end_time - start_time
            logging.info(f&#34;Finished {func.__name__!r} in {run_time/count:.4f} secs (total time: {run_time:.2f}s, &#34;
                         f&#34;count: {count})&#34;)
            return value

        return wrapper_timer
    return actual_decorator


def debug(func):
    &#34;&#34;&#34;Print the function signature and return value&#34;&#34;&#34;

    @functools.wraps(func)
    def wrapper_debug(*args, **kwargs):
        if __debug__:
            args_repr = [repr(a) for a in args]
            kwargs_repr = [f&#34;{k}={v!r}&#34; for k, v in kwargs.items()]
            signature = &#34;, &#34;.join(args_repr + kwargs_repr)
            MODULE_LOGGER.debug(f&#34;Calling {func.__name__}({signature})&#34;)
            value = func(*args, **kwargs)
            MODULE_LOGGER.debug(f&#34;{func.__name__!r} returned {value!r}&#34;)
        else:
            value = func(*args, **kwargs)
        return value

    return wrapper_debug


def profile_func(output_file=None, sort_by=&#39;cumulative&#39;, lines_to_print=None, strip_dirs=False):
    &#34;&#34;&#34;A time profiler decorator.

    This code was taken from: https://gist.github.com/ekhoda/2de44cf60d29ce24ad29758ce8635b78

    Inspired by and modified the profile decorator of Giampaolo Rodola:
    http://code.activestate.com/recipes/577817-profile-decorator/

    Args:
        output_file: str or None. Default is None
            Path of the output file. If only name of the file is given, it&#39;s
            saved in the current directory.
            If it&#39;s None, the name of the decorated function is used.
        sort_by: str or SortKey enum or tuple/list of str/SortKey enum
            Sorting criteria for the Stats object.
            For a list of valid string and SortKey refer to:
            https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats
        lines_to_print: int or None
            Number of lines to print. Default (None) is for all the lines.
            This is useful in reducing the size of the printout, especially
            that sorting by &#39;cumulative&#39;, the time consuming operations
            are printed toward the top of the file.
        strip_dirs: bool
            Whether to remove the leading path info from file names.
            This is also useful in reducing the size of the printout

    Returns:
        Profile of the decorated function
    &#34;&#34;&#34;

    def inner(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            _output_file = output_file or func.__name__ + &#39;.prof&#39;
            pr = cProfile.Profile()
            pr.enable()
            retval = func(*args, **kwargs)
            pr.disable()
            pr.dump_stats(_output_file)

            with open(_output_file, &#39;w&#39;) as f:
                ps = pstats.Stats(pr, stream=f)
                if strip_dirs:
                    ps.strip_dirs()
                if isinstance(sort_by, (tuple, list)):
                    ps.sort_stats(*sort_by)
                else:
                    ps.sort_stats(sort_by)
                ps.print_stats(lines_to_print)
            return retval

        return wrapper

    return inner


def profile(func):
    &#34;&#34;&#34;Print the function signature and return value&#34;&#34;&#34;
    if not hasattr(profile, &#34;counter&#34;):
        profile.counter = 0

    @functools.wraps(func)
    def wrapper_profile(*args, **kwargs):
        if Settings.profiling():
            profile.counter += 1
            args_repr = [repr(a) for a in args]
            kwargs_repr = [f&#34;{k}={v!r}&#34; for k, v in kwargs.items()]
            signature = &#34;, &#34;.join(args_repr + kwargs_repr)
            caller = get_caller_info()
            prefix = f&#34;PROFILE[{profile.counter}]: &#34;
            MODULE_LOGGER.info(f&#34;{prefix}Calling {func.__name__}({signature})&#34;)
            MODULE_LOGGER.info(f&#34;{&#39; &#39; * len(prefix)}from {caller.filename} at {caller.lineno}.&#34;)
            value = func(*args, **kwargs)
            MODULE_LOGGER.info(f&#34;{prefix}{func.__name__!r} returned {value!r}&#34;)
            profile.counter -= 1
        else:
            value = func(*args, **kwargs)
        return value

    return wrapper_profile


def to_be_implemented(func):
    &#34;&#34;&#34;Print a warning message that this function/method has to be implemented.&#34;&#34;&#34;

    @functools.wraps(func)
    def wrapper_tbi(*args, **kwargs):
        MODULE_LOGGER.warning(f&#34;The function/method {func.__name__} is not yet implemented.&#34;)
        return func(*args, **kwargs)

    return wrapper_tbi


# Taken and adapted from https://github.com/QCoDeS/Qcodes

def deprecate(reason: Optional[str] = None,
              alternative: Optional[str] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Deprecate a function or method. This will print a warning with the function name and where
    it is called from. If the optional parameters `reason` and `alternative` are given, that
    information will be printed with the warning.

    :param reason: provide a short explanation why this function is deprecated. Generates &#39;because {reason}&#39;
    :param alternative: provides an alternative function/parameters to be used. Generates &#39;Use {alternative} as an alternative&#39;
    :return: the decorated function
    &#34;&#34;&#34;

    def actual_decorator(func: Callable) -&gt; Callable:
        @functools.wraps(func)
        def decorated_func(*args, **kwargs):
            caller = get_caller_info(2)
            msg = f&#39;The function \&#34;{func.__name__}\&#34; used at {caller.filename}:{caller.lineno} is deprecated&#39;
            if reason is not None:
                msg += f&#39;, because {reason}&#39;
            if alternative is not None:
                msg += f&#39;. Use {alternative} as an alternative&#39;
            msg += &#39;.&#39;
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)

        decorated_func.__doc__ = (
            f&#34;This function is DEPRECATED, because {reason}, use {alternative} as an alternative.\n&#34;
        )
        return decorated_func

    return actual_decorator


def singleton(cls):
    &#34;&#34;&#34;
    Use class as a singleton.

    from: https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton
    &#34;&#34;&#34;

    cls.__new_original__ = cls.__new__

    @functools.wraps(cls.__new__)
    def singleton_new(cls, *args, **kw):
        it = cls.__dict__.get(&#39;__it__&#39;)
        if it is not None:
            return it

        cls.__it__ = it = cls.__new_original__(cls, *args, **kw)
        it.__init_original__(*args, **kw)
        return it

    cls.__new__ = singleton_new
    cls.__init_original__ = cls.__init__
    cls.__init__ = object.__init__

    return cls


def borg(cls):
    &#34;&#34;&#34;
    Use the Borg pattern to make a class with a shared state between its instances and sub-classes.

    from: http://code.activestate.com/recipes/66531-singleton-we-dont-need-no-stinkin-singleton-the-bo/
    &#34;&#34;&#34;

    cls._shared_state = {}
    orig_init = cls.__init__

    def new_init(self, *args, **kwargs):
        self.__dict__ = cls._shared_state
        orig_init(self, *args, **kwargs)

    cls.__init__ = new_init

    return cls


class classproperty:
    &#34;&#34;&#34;Defines a read-only class property.

    Usage:

        &gt;&gt;&gt; class Message:
        ...     def __init__(self, msg):
        ...         self._msg = msg
        ...
        ...     @classproperty
        ...     def name(cls):
        ...         return cls.__name__

        &gt;&gt;&gt; msg = Message(&#34;a simple doctest&#34;)
        &gt;&gt;&gt; assert &#34;Message&#34; == msg.name

    &#34;&#34;&#34;
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        return self.func(owner)

    def __set__(self, instance, value):
        raise AttributeError(
            f&#34;Cannot change class property &#39;{self.func.__name__}&#39; for class &#39;{instance.__class__.__name__}&#39;.&#34;)


class Nothing:
    &#34;&#34;&#34;Just to get a nice repr for Nothing. It is kind of a Null object...&#34;&#34;&#34;
    def __repr__(self):
        return &#34;&lt;Nothing&gt;&#34;


def spy_on_attr_change(obj: object, obj_name: str = None) -&gt; None:
    &#34;&#34;&#34;
    Tweak an object to show attributes changing. The changes are reported as WARNING log messages
    in the `egse.spy` logger.

    Note this is not a decorator, but a function that changes the class of an object.

    Note that this function is a debugging aid and should not be used in production code!

    Args:
        obj (object): any object that you want to monitor
        obj_name (str): the variable name of the object that was given in the code, if None than
            the class name will be printed.

    Examples:

        &gt;&gt;&gt; class X:
        ...    pass
        &gt;&gt;&gt; x = X()
        &gt;&gt;&gt; spy_on_attr_change(x, obj_name=&#34;x&#34;)
        &gt;&gt;&gt; x.a = 5

    From: https://nedbatchelder.com/blog/202206/adding_a_dunder_to_an_object.html
    &#34;&#34;&#34;
    logger = logging.getLogger(&#34;egse.spy&#34;)

    class Wrapper(obj.__class__):

        def __setattr__(self, name, value):
            old = getattr(self, name, Nothing())
            logger.warning(
                f&#34;Spy: in {obj_name or obj.__class__.__name__} -&gt; {name}: {old!r} -&gt; {value!r}&#34;)
            return super().__setattr__(name, value)

    class_name = obj.__class__.__name__
    obj.__class__ = Wrapper
    obj.__class__.__name__ = class_name</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="egse.decorators.borg"><code class="name flex">
<span>def <span class="ident">borg</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Use the Borg pattern to make a class with a shared state between its instances and sub-classes.</p>
<p>from: <a href="http://code.activestate.com/recipes/66531-singleton-we-dont-need-no-stinkin-singleton-the-bo/">http://code.activestate.com/recipes/66531-singleton-we-dont-need-no-stinkin-singleton-the-bo/</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def borg(cls):
    &#34;&#34;&#34;
    Use the Borg pattern to make a class with a shared state between its instances and sub-classes.

    from: http://code.activestate.com/recipes/66531-singleton-we-dont-need-no-stinkin-singleton-the-bo/
    &#34;&#34;&#34;

    cls._shared_state = {}
    orig_init = cls.__init__

    def new_init(self, *args, **kwargs):
        self.__dict__ = cls._shared_state
        orig_init(self, *args, **kwargs)

    cls.__init__ = new_init

    return cls</code></pre>
</details>
</dd>
<dt id="egse.decorators.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the function signature and return value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(func):
    &#34;&#34;&#34;Print the function signature and return value&#34;&#34;&#34;

    @functools.wraps(func)
    def wrapper_debug(*args, **kwargs):
        if __debug__:
            args_repr = [repr(a) for a in args]
            kwargs_repr = [f&#34;{k}={v!r}&#34; for k, v in kwargs.items()]
            signature = &#34;, &#34;.join(args_repr + kwargs_repr)
            MODULE_LOGGER.debug(f&#34;Calling {func.__name__}({signature})&#34;)
            value = func(*args, **kwargs)
            MODULE_LOGGER.debug(f&#34;{func.__name__!r} returned {value!r}&#34;)
        else:
            value = func(*args, **kwargs)
        return value

    return wrapper_debug</code></pre>
</details>
</dd>
<dt id="egse.decorators.deprecate"><code class="name flex">
<span>def <span class="ident">deprecate</span></span>(<span>reason: Optional[str] = None, alternative: Optional[str] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Deprecate a function or method. This will print a warning with the function name and where
it is called from. If the optional parameters <code>reason</code> and <code>alternative</code> are given, that
information will be printed with the warning.</p>
<p>:param reason: provide a short explanation why this function is deprecated. Generates 'because {reason}'
:param alternative: provides an alternative function/parameters to be used. Generates 'Use {alternative} as an alternative'
:return: the decorated function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deprecate(reason: Optional[str] = None,
              alternative: Optional[str] = None) -&gt; Callable:
    &#34;&#34;&#34;
    Deprecate a function or method. This will print a warning with the function name and where
    it is called from. If the optional parameters `reason` and `alternative` are given, that
    information will be printed with the warning.

    :param reason: provide a short explanation why this function is deprecated. Generates &#39;because {reason}&#39;
    :param alternative: provides an alternative function/parameters to be used. Generates &#39;Use {alternative} as an alternative&#39;
    :return: the decorated function
    &#34;&#34;&#34;

    def actual_decorator(func: Callable) -&gt; Callable:
        @functools.wraps(func)
        def decorated_func(*args, **kwargs):
            caller = get_caller_info(2)
            msg = f&#39;The function \&#34;{func.__name__}\&#34; used at {caller.filename}:{caller.lineno} is deprecated&#39;
            if reason is not None:
                msg += f&#39;, because {reason}&#39;
            if alternative is not None:
                msg += f&#39;. Use {alternative} as an alternative&#39;
            msg += &#39;.&#39;
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)

        decorated_func.__doc__ = (
            f&#34;This function is DEPRECATED, because {reason}, use {alternative} as an alternative.\n&#34;
        )
        return decorated_func

    return actual_decorator</code></pre>
</details>
</dd>
<dt id="egse.decorators.dynamic_interface"><code class="name flex">
<span>def <span class="ident">dynamic_interface</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a static variable <code>__dynamic_interface</code> to a method.</p>
<p>The intended use of this function is as a decorator for functions in an interface class.</p>
<p>The static variable is currently used by the Proxy class to check if a method
is meant to be overridden dynamically. The idea behind this is to loosen the contract
of an abstract base class (ABC) into an interface. For an ABC, the abstract methods
must be implemented at construction/initialization. This is not possible for the Proxy
subclasses as they load their commands (i.e. methods) from the control server, and the
method will be added to the Proxy interface after loading. Nevertheless, we like the
interface already defined for auto-completion during development or interactive use.</p>
<p>When a Proxy subclass that implements an interface with methods decorated by
the <code>@dynamic_interface</code> does overwrite one or more of the decorated methods statically,
these methods will not be dynamically overwritten when loading the interface from the
control server. A warning will be logged instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_interface(func):
    &#34;&#34;&#34;Adds a static variable `__dynamic_interface` to a method.

    The intended use of this function is as a decorator for functions in an interface class.

    The static variable is currently used by the Proxy class to check if a method
    is meant to be overridden dynamically. The idea behind this is to loosen the contract
    of an abstract base class (ABC) into an interface. For an ABC, the abstract methods
    must be implemented at construction/initialization. This is not possible for the Proxy
    subclasses as they load their commands (i.e. methods) from the control server, and the
    method will be added to the Proxy interface after loading. Nevertheless, we like the
    interface already defined for auto-completion during development or interactive use.

    When a Proxy subclass that implements an interface with methods decorated by
    the `@dynamic_interface` does overwrite one or more of the decorated methods statically,
    these methods will not be dynamically overwritten when loading the interface from the
    control server. A warning will be logged instead.
    &#34;&#34;&#34;
    setattr(func, &#34;__dynamic_interface&#34;, True)
    return func</code></pre>
</details>
</dd>
<dt id="egse.decorators.profile"><code class="name flex">
<span>def <span class="ident">profile</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the function signature and return value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def profile(func):
    &#34;&#34;&#34;Print the function signature and return value&#34;&#34;&#34;
    if not hasattr(profile, &#34;counter&#34;):
        profile.counter = 0

    @functools.wraps(func)
    def wrapper_profile(*args, **kwargs):
        if Settings.profiling():
            profile.counter += 1
            args_repr = [repr(a) for a in args]
            kwargs_repr = [f&#34;{k}={v!r}&#34; for k, v in kwargs.items()]
            signature = &#34;, &#34;.join(args_repr + kwargs_repr)
            caller = get_caller_info()
            prefix = f&#34;PROFILE[{profile.counter}]: &#34;
            MODULE_LOGGER.info(f&#34;{prefix}Calling {func.__name__}({signature})&#34;)
            MODULE_LOGGER.info(f&#34;{&#39; &#39; * len(prefix)}from {caller.filename} at {caller.lineno}.&#34;)
            value = func(*args, **kwargs)
            MODULE_LOGGER.info(f&#34;{prefix}{func.__name__!r} returned {value!r}&#34;)
            profile.counter -= 1
        else:
            value = func(*args, **kwargs)
        return value

    return wrapper_profile</code></pre>
</details>
</dd>
<dt id="egse.decorators.profile_func"><code class="name flex">
<span>def <span class="ident">profile_func</span></span>(<span>output_file=None, sort_by='cumulative', lines_to_print=None, strip_dirs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A time profiler decorator.</p>
<p>This code was taken from: <a href="https://gist.github.com/ekhoda/2de44cf60d29ce24ad29758ce8635b78">https://gist.github.com/ekhoda/2de44cf60d29ce24ad29758ce8635b78</a></p>
<p>Inspired by and modified the profile decorator of Giampaolo Rodola:
<a href="http://code.activestate.com/recipes/577817-profile-decorator/">http://code.activestate.com/recipes/577817-profile-decorator/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_file</code></strong></dt>
<dd>str or None. Default is None
Path of the output file. If only name of the file is given, it's
saved in the current directory.
If it's None, the name of the decorated function is used.</dd>
<dt><strong><code>sort_by</code></strong></dt>
<dd>str or SortKey enum or tuple/list of str/SortKey enum
Sorting criteria for the Stats object.
For a list of valid string and SortKey refer to:
<a href="https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats">https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats</a></dd>
<dt><strong><code>lines_to_print</code></strong></dt>
<dd>int or None
Number of lines to print. Default (None) is for all the lines.
This is useful in reducing the size of the printout, especially
that sorting by 'cumulative', the time consuming operations
are printed toward the top of the file.</dd>
<dt><strong><code>strip_dirs</code></strong></dt>
<dd>bool
Whether to remove the leading path info from file names.
This is also useful in reducing the size of the printout</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Profile of the decorated function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def profile_func(output_file=None, sort_by=&#39;cumulative&#39;, lines_to_print=None, strip_dirs=False):
    &#34;&#34;&#34;A time profiler decorator.

    This code was taken from: https://gist.github.com/ekhoda/2de44cf60d29ce24ad29758ce8635b78

    Inspired by and modified the profile decorator of Giampaolo Rodola:
    http://code.activestate.com/recipes/577817-profile-decorator/

    Args:
        output_file: str or None. Default is None
            Path of the output file. If only name of the file is given, it&#39;s
            saved in the current directory.
            If it&#39;s None, the name of the decorated function is used.
        sort_by: str or SortKey enum or tuple/list of str/SortKey enum
            Sorting criteria for the Stats object.
            For a list of valid string and SortKey refer to:
            https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats
        lines_to_print: int or None
            Number of lines to print. Default (None) is for all the lines.
            This is useful in reducing the size of the printout, especially
            that sorting by &#39;cumulative&#39;, the time consuming operations
            are printed toward the top of the file.
        strip_dirs: bool
            Whether to remove the leading path info from file names.
            This is also useful in reducing the size of the printout

    Returns:
        Profile of the decorated function
    &#34;&#34;&#34;

    def inner(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            _output_file = output_file or func.__name__ + &#39;.prof&#39;
            pr = cProfile.Profile()
            pr.enable()
            retval = func(*args, **kwargs)
            pr.disable()
            pr.dump_stats(_output_file)

            with open(_output_file, &#39;w&#39;) as f:
                ps = pstats.Stats(pr, stream=f)
                if strip_dirs:
                    ps.strip_dirs()
                if isinstance(sort_by, (tuple, list)):
                    ps.sort_stats(*sort_by)
                else:
                    ps.sort_stats(sort_by)
                ps.print_stats(lines_to_print)
            return retval

        return wrapper

    return inner</code></pre>
</details>
</dd>
<dt id="egse.decorators.query_command"><code class="name flex">
<span>def <span class="ident">query_command</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a static variable <code>__query_command</code> to a method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_command(func):
    &#34;&#34;&#34;Adds a static variable `__query_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__query_command&#34;, True)
    return func</code></pre>
</details>
</dd>
<dt id="egse.decorators.read_command"><code class="name flex">
<span>def <span class="ident">read_command</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a static variable <code>__read_command</code> to a method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_command(func):
    &#34;&#34;&#34;Adds a static variable `__read_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__read_command&#34;, True)
    return func</code></pre>
</details>
</dd>
<dt id="egse.decorators.singleton"><code class="name flex">
<span>def <span class="ident">singleton</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Use class as a singleton.</p>
<p>from: <a href="https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton">https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleton(cls):
    &#34;&#34;&#34;
    Use class as a singleton.

    from: https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton
    &#34;&#34;&#34;

    cls.__new_original__ = cls.__new__

    @functools.wraps(cls.__new__)
    def singleton_new(cls, *args, **kw):
        it = cls.__dict__.get(&#39;__it__&#39;)
        if it is not None:
            return it

        cls.__it__ = it = cls.__new_original__(cls, *args, **kw)
        it.__init_original__(*args, **kw)
        return it

    cls.__new__ = singleton_new
    cls.__init_original__ = cls.__init__
    cls.__init__ = object.__init__

    return cls</code></pre>
</details>
</dd>
<dt id="egse.decorators.spy_on_attr_change"><code class="name flex">
<span>def <span class="ident">spy_on_attr_change</span></span>(<span>obj: object, obj_name: str = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Tweak an object to show attributes changing. The changes are reported as WARNING log messages
in the <code>egse.spy</code> logger.</p>
<p>Note this is not a decorator, but a function that changes the class of an object.</p>
<p>Note that this function is a debugging aid and should not be used in production code!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>any object that you want to monitor</dd>
<dt><strong><code>obj_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the variable name of the object that was given in the code, if None than
the class name will be printed.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class X:
...    pass
&gt;&gt;&gt; x = X()
&gt;&gt;&gt; spy_on_attr_change(x, obj_name=&quot;x&quot;)
&gt;&gt;&gt; x.a = 5
</code></pre>
<p>From: <a href="https://nedbatchelder.com/blog/202206/adding_a_dunder_to_an_object.html">https://nedbatchelder.com/blog/202206/adding_a_dunder_to_an_object.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spy_on_attr_change(obj: object, obj_name: str = None) -&gt; None:
    &#34;&#34;&#34;
    Tweak an object to show attributes changing. The changes are reported as WARNING log messages
    in the `egse.spy` logger.

    Note this is not a decorator, but a function that changes the class of an object.

    Note that this function is a debugging aid and should not be used in production code!

    Args:
        obj (object): any object that you want to monitor
        obj_name (str): the variable name of the object that was given in the code, if None than
            the class name will be printed.

    Examples:

        &gt;&gt;&gt; class X:
        ...    pass
        &gt;&gt;&gt; x = X()
        &gt;&gt;&gt; spy_on_attr_change(x, obj_name=&#34;x&#34;)
        &gt;&gt;&gt; x.a = 5

    From: https://nedbatchelder.com/blog/202206/adding_a_dunder_to_an_object.html
    &#34;&#34;&#34;
    logger = logging.getLogger(&#34;egse.spy&#34;)

    class Wrapper(obj.__class__):

        def __setattr__(self, name, value):
            old = getattr(self, name, Nothing())
            logger.warning(
                f&#34;Spy: in {obj_name or obj.__class__.__name__} -&gt; {name}: {old!r} -&gt; {value!r}&#34;)
            return super().__setattr__(name, value)

    class_name = obj.__class__.__name__
    obj.__class__ = Wrapper
    obj.__class__.__name__ = class_name</code></pre>
</details>
</dd>
<dt id="egse.decorators.static_vars"><code class="name flex">
<span>def <span class="ident">static_vars</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Define static variables in a function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def static_vars(**kwargs):
    &#34;&#34;&#34;Define static variables in a function.&#34;&#34;&#34;
    def decorator(func):
        for kw in kwargs:
            setattr(func, kw, kwargs[kw])
        return func
    return decorator</code></pre>
</details>
</dd>
<dt id="egse.decorators.time_it"><code class="name flex">
<span>def <span class="ident">time_it</span></span>(<span>count: int = 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the runtime of the decorated function.</p>
<p>This is a simple replacement for the builtin <code>timeit</code> function. The purpose is to simplify
calling a function with some parameters.</p>
<p>The intended way to call this is as a function:</p>
<pre><code>value = function(args)

value = time_it(10_000)(function)(args)
</code></pre>
<p>The <code><a title="egse.decorators.time_it" href="#egse.decorators.time_it">time_it()</a></code> function can be called as a decorator in which case it will always call the
function <code>count</code> times which is probably not what you want.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of executions [default=1000].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>value</code></dt>
<dd>the return value of the last function execution.</dd>
</dl>
<p>See also:
the <code>Timer</code> context manager located in <code><a title="egse.system" href="system.html">egse.system</a></code>.</p>
<h2 id="usage">Usage</h2>
<p>@time_it(count=10000)
def function(args):
pass</p>
<p>time_it(10000)(function)(args)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_it(count: int = 1000):
    &#34;&#34;&#34;Print the runtime of the decorated function.

    This is a simple replacement for the builtin ``timeit`` function. The purpose is to simplify
    calling a function with some parameters.

    The intended way to call this is as a function:

        value = function(args)

        value = time_it(10_000)(function)(args)

    The `time_it` function can be called as a decorator in which case it will always call the
    function `count` times which is probably not what you want.

    Args:
        count (int): the number of executions [default=1000].

    Returns:
        value: the return value of the last function execution.

    See also:
        the ``Timer`` context manager located in ``egse.system``.

    Usage:
        @time_it(count=10000)
        def function(args):
            pass

        time_it(10000)(function)(args)
    &#34;&#34;&#34;

    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper_timer(*args, **kwargs):
            start_time = time.perf_counter()
            for _ in range(count):
                value = func(*args, **kwargs)
            end_time = time.perf_counter()
            run_time = end_time - start_time
            logging.info(f&#34;Finished {func.__name__!r} in {run_time/count:.4f} secs (total time: {run_time:.2f}s, &#34;
                         f&#34;count: {count})&#34;)
            return value

        return wrapper_timer
    return actual_decorator</code></pre>
</details>
</dd>
<dt id="egse.decorators.timer"><code class="name flex">
<span>def <span class="ident">timer</span></span>(<span>*, level: int = 20, precision: int = 4)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the runtime of the decorated function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong></dt>
<dd>the logging level for the time message [default=INFO]</dd>
<dt><strong><code>precision</code></strong></dt>
<dd>the number of decimals for the time [default=3 (ms)]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timer(*, level: int = logging.INFO, precision: int = 4):
    &#34;&#34;&#34;
    Print the runtime of the decorated function.

    Args:
        level: the logging level for the time message [default=INFO]
        precision: the number of decimals for the time [default=3 (ms)]
    &#34;&#34;&#34;

    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper_timer(*args, **kwargs):
            start_time = time.perf_counter()
            value = func(*args, **kwargs)
            end_time = time.perf_counter()
            run_time = end_time - start_time
            MODULE_LOGGER.log(level, f&#34;Finished {func.__name__!r} in {run_time:.{precision}f} secs&#34;)
            return value

        return wrapper_timer
    return actual_decorator</code></pre>
</details>
</dd>
<dt id="egse.decorators.to_be_implemented"><code class="name flex">
<span>def <span class="ident">to_be_implemented</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a warning message that this function/method has to be implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_be_implemented(func):
    &#34;&#34;&#34;Print a warning message that this function/method has to be implemented.&#34;&#34;&#34;

    @functools.wraps(func)
    def wrapper_tbi(*args, **kwargs):
        MODULE_LOGGER.warning(f&#34;The function/method {func.__name__} is not yet implemented.&#34;)
        return func(*args, **kwargs)

    return wrapper_tbi</code></pre>
</details>
</dd>
<dt id="egse.decorators.transaction_command"><code class="name flex">
<span>def <span class="ident">transaction_command</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a static variable <code>__transaction_command</code> to a method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transaction_command(func):
    &#34;&#34;&#34;Adds a static variable `__transaction_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__transaction_command&#34;, True)
    return func</code></pre>
</details>
</dd>
<dt id="egse.decorators.write_command"><code class="name flex">
<span>def <span class="ident">write_command</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a static variable <code>__write_command</code> to a method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_command(func):
    &#34;&#34;&#34;Adds a static variable `__write_command` to a method.
    &#34;&#34;&#34;

    setattr(func, &#34;__write_command&#34;, True)
    return func</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="egse.decorators.Nothing"><code class="flex name class">
<span>class <span class="ident">Nothing</span></span>
</code></dt>
<dd>
<div class="desc"><p>Just to get a nice repr for Nothing. It is kind of a Null object&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Nothing:
    &#34;&#34;&#34;Just to get a nice repr for Nothing. It is kind of a Null object...&#34;&#34;&#34;
    def __repr__(self):
        return &#34;&lt;Nothing&gt;&#34;</code></pre>
</details>
</dd>
<dt id="egse.decorators.classproperty"><code class="flex name class">
<span>class <span class="ident">classproperty</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a read-only class property.</p>
<h2 id="usage">Usage</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Message:
...     def __init__(self, msg):
...         self._msg = msg
...
...     @classproperty
...     def name(cls):
...         return cls.__name__
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; msg = Message(&quot;a simple doctest&quot;)
&gt;&gt;&gt; assert &quot;Message&quot; == msg.name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class classproperty:
    &#34;&#34;&#34;Defines a read-only class property.

    Usage:

        &gt;&gt;&gt; class Message:
        ...     def __init__(self, msg):
        ...         self._msg = msg
        ...
        ...     @classproperty
        ...     def name(cls):
        ...         return cls.__name__

        &gt;&gt;&gt; msg = Message(&#34;a simple doctest&#34;)
        &gt;&gt;&gt; assert &#34;Message&#34; == msg.name

    &#34;&#34;&#34;
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        return self.func(owner)

    def __set__(self, instance, value):
        raise AttributeError(
            f&#34;Cannot change class property &#39;{self.func.__name__}&#39; for class &#39;{instance.__class__.__name__}&#39;.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="egse" href="index.html">egse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="egse.decorators.borg" href="#egse.decorators.borg">borg</a></code></li>
<li><code><a title="egse.decorators.debug" href="#egse.decorators.debug">debug</a></code></li>
<li><code><a title="egse.decorators.deprecate" href="#egse.decorators.deprecate">deprecate</a></code></li>
<li><code><a title="egse.decorators.dynamic_interface" href="#egse.decorators.dynamic_interface">dynamic_interface</a></code></li>
<li><code><a title="egse.decorators.profile" href="#egse.decorators.profile">profile</a></code></li>
<li><code><a title="egse.decorators.profile_func" href="#egse.decorators.profile_func">profile_func</a></code></li>
<li><code><a title="egse.decorators.query_command" href="#egse.decorators.query_command">query_command</a></code></li>
<li><code><a title="egse.decorators.read_command" href="#egse.decorators.read_command">read_command</a></code></li>
<li><code><a title="egse.decorators.singleton" href="#egse.decorators.singleton">singleton</a></code></li>
<li><code><a title="egse.decorators.spy_on_attr_change" href="#egse.decorators.spy_on_attr_change">spy_on_attr_change</a></code></li>
<li><code><a title="egse.decorators.static_vars" href="#egse.decorators.static_vars">static_vars</a></code></li>
<li><code><a title="egse.decorators.time_it" href="#egse.decorators.time_it">time_it</a></code></li>
<li><code><a title="egse.decorators.timer" href="#egse.decorators.timer">timer</a></code></li>
<li><code><a title="egse.decorators.to_be_implemented" href="#egse.decorators.to_be_implemented">to_be_implemented</a></code></li>
<li><code><a title="egse.decorators.transaction_command" href="#egse.decorators.transaction_command">transaction_command</a></code></li>
<li><code><a title="egse.decorators.write_command" href="#egse.decorators.write_command">write_command</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="egse.decorators.Nothing" href="#egse.decorators.Nothing">Nothing</a></code></h4>
</li>
<li>
<h4><code><a title="egse.decorators.classproperty" href="#egse.decorators.classproperty">classproperty</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>